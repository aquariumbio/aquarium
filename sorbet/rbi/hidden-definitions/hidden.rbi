# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

module AWS
  ROOT = ::T.let(nil, ::T.untyped)
  SERVICES = ::T.let(nil, ::T.untyped)
  SRC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::AutoScaling
  include ::AWS::Core::ServiceInterface
  def activities(); end

  def adjustment_types(); end

  def client(); end

  def config(); end

  def groups(); end

  def instances(); end

  def launch_configurations(); end

  def metric_collection_granularities(); end

  def metric_collection_types(); end

  def notification_configurations(); end

  def notification_types(); end

  def scaling_process_types(); end

  def scheduled_actions(); end

  def tags(); end
end

class AWS::AutoScaling::Activity
  def _find_in_describe_scaling_activities_response_0(resp); end

  def _find_in_terminate_instance_in_auto_scaling_group_response_1(resp); end

  def activity_id(); end

  def auto_scaling_group_name(); end

  def cause(); end

  def description(); end

  def details(); end

  def end_time(); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def group(); end

  def id(); end

  def initialize(activity_id, options=T.unsafe(nil)); end

  def progress(); end

  def start_time(); end

  def status_code(); end

  def status_message(); end
end

class AWS::AutoScaling::Activity
end

class AWS::AutoScaling::ActivityCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](activity_id); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def initialize(options=T.unsafe(nil)); end
end

class AWS::AutoScaling::ActivityCollection
end

class AWS::AutoScaling::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::AutoScaling::Client::V20110101
  def attach_instances(*args, &block); end

  def complete_lifecycle_action(*args, &block); end

  def create_auto_scaling_group(*args, &block); end

  def create_launch_configuration(*args, &block); end

  def create_or_update_tags(*args, &block); end

  def delete_auto_scaling_group(*args, &block); end

  def delete_launch_configuration(*args, &block); end

  def delete_lifecycle_hook(*args, &block); end

  def delete_notification_configuration(*args, &block); end

  def delete_policy(*args, &block); end

  def delete_scheduled_action(*args, &block); end

  def delete_tags(*args, &block); end

  def describe_account_limits(*args, &block); end

  def describe_adjustment_types(*args, &block); end

  def describe_auto_scaling_groups(*args, &block); end

  def describe_auto_scaling_instances(*args, &block); end

  def describe_auto_scaling_notification_types(*args, &block); end

  def describe_launch_configurations(*args, &block); end

  def describe_lifecycle_hook_types(*args, &block); end

  def describe_lifecycle_hooks(*args, &block); end

  def describe_metric_collection_types(*args, &block); end

  def describe_notification_configurations(*args, &block); end

  def describe_policies(*args, &block); end

  def describe_scaling_activities(*args, &block); end

  def describe_scaling_process_types(*args, &block); end

  def describe_scheduled_actions(*args, &block); end

  def describe_tags(*args, &block); end

  def describe_termination_policy_types(*args, &block); end

  def detach_instances(*args, &block); end

  def disable_metrics_collection(*args, &block); end

  def enable_metrics_collection(*args, &block); end

  def enter_standby(*args, &block); end

  def execute_policy(*args, &block); end

  def exit_standby(*args, &block); end

  def put_lifecycle_hook(*args, &block); end

  def put_notification_configuration(*args, &block); end

  def put_scaling_policy(*args, &block); end

  def put_scheduled_update_group_action(*args, &block); end

  def record_lifecycle_action_heartbeat(*args, &block); end

  def resume_processes(*args, &block); end

  def set_desired_capacity(*args, &block); end

  def set_instance_health(*args, &block); end

  def suspend_processes(*args, &block); end

  def terminate_instance_in_auto_scaling_group(*args, &block); end

  def update_auto_scaling_group(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::AutoScaling::Client::V20110101
end

class AWS::AutoScaling::Client
end

module AWS::AutoScaling::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::AutoScaling::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::AutoScaling::Group
  include ::AWS::AutoScaling::GroupOptions
  def _find_in_describe_auto_scaling_groups_response_0(resp); end

  def activities(); end

  def arn(); end

  def auto_scaling_group_arn(); end

  def auto_scaling_instances(); end

  def availability_zone_names(); end

  def availability_zones(); end

  def created_time(); end

  def default_cooldown(); end

  def delete(options=T.unsafe(nil)); end

  def delete!(); end

  def delete_all_tags(); end

  def delete_tags(*tags); end

  def desired_capacity(); end

  def disable_all_metrics_collection(); end

  def disable_metrics_collection(*metrics); end

  def ec2_instances(); end

  def enable_all_metrics_collection(); end

  def enable_metrics_collection(*metrics); end

  def enabled_metrics(); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def health_check_grace_period(); end

  def health_check_type(); end

  def initialize(name, options=T.unsafe(nil)); end

  def instances(); end

  def launch_configuration(); end

  def launch_configuration_name(); end

  def load_balancer_names(); end

  def load_balancers(); end

  def max_size(); end

  def min_size(); end

  def name(); end

  def notification_configurations(); end

  def placement_group(); end

  def resume_all_processes(); end

  def resume_processes(*processes); end

  def scaling_policies(); end

  def scheduled_actions(); end

  def set_desired_capacity(capacity, options=T.unsafe(nil)); end

  def subnets(); end

  def suspend_all_processes(); end

  def suspend_processes(*processes); end

  def suspended_processes(); end

  def tag_details(); end

  def tags(); end

  def termination_policies(); end

  def update(options=T.unsafe(nil)); end

  def vpc_zone_identifier(); end
end

class AWS::AutoScaling::Group
end

class AWS::AutoScaling::GroupCollection
  include ::AWS::AutoScaling::GroupOptions
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def create(name, options=T.unsafe(nil)); end
end

class AWS::AutoScaling::GroupCollection
end

module AWS::AutoScaling::GroupOptions
  def az_opt(options); end

  def group_options(options); end

  def health_check_type_opt(options); end

  def launch_config_opt(options); end

  def load_balancers_opt(options); end

  def subnets_opt(options); end

  def tags_opt(options); end
end

module AWS::AutoScaling::GroupOptions
end

class AWS::AutoScaling::Instance
  def _find_in_describe_auto_scaling_groups_response_1(resp); end

  def _find_in_describe_auto_scaling_instances_response_0(resp); end

  def auto_scaling_group(); end

  def auto_scaling_group_name(); end

  def availability_zone(); end

  def availability_zone_name(); end

  def delete(decrement_desired_capacity); end

  def ec2_instance(); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def group(); end

  def health_status(); end

  def id(); end

  def initialize(instance_id, options=T.unsafe(nil)); end

  def instance_id(); end

  def launch_configuration(); end

  def launch_configuration_name(); end

  def lifecycle_state(); end

  def set_health(status, options=T.unsafe(nil)); end

  def terminate(decrement_desired_capacity); end
end

class AWS::AutoScaling::Instance
end

class AWS::AutoScaling::InstanceCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](instance_id); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end
end

class AWS::AutoScaling::InstanceCollection
end

class AWS::AutoScaling::LaunchConfiguration
  def _find_in_describe_launch_configurations_response_0(resp); end

  def arn(); end

  def associate_public_ip_address(); end

  def block_device_mappings(); end

  def classic_link_vpc_id(); end

  def classic_link_vpc_security_group_details(); end

  def classic_link_vpc_security_groups(); end

  def created_at(); end

  def created_time(); end

  def delete(); end

  def detailed_instance_monitoring(); end

  def detailed_instance_monitoring?(); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def get_security_groups(names_or_ids); end

  def iam_instance_profile(); end

  def image(); end

  def image_id(); end

  def initialize(name, options=T.unsafe(nil)); end

  def instance_type(); end

  def kernel_id(); end

  def key_name(); end

  def key_pair(); end

  def name(); end

  def ramdisk_id(); end

  def security_group_details(); end

  def security_groups(); end

  def spot_price(); end

  def user_data(); end
end

class AWS::AutoScaling::LaunchConfiguration
end

class AWS::AutoScaling::LaunchConfigurationCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def create(name, image, instance_type, options=T.unsafe(nil)); end

  def image_id_opt(image); end

  def instance_monitoring_opt(options); end

  def key_name_opt(options); end

  def security_groups_opt(security_groups); end

  def user_data_opt(options); end
end

class AWS::AutoScaling::LaunchConfigurationCollection
end

class AWS::AutoScaling::NotificationConfiguration
  def ==(other); end

  def auto_scaling_group(); end

  def delete(); end

  def eql?(other); end

  def group(); end

  def initialize(auto_scaling_group, topic_arn, notification_types=T.unsafe(nil)); end

  def notification_types(); end

  def notification_types=(*notification_types); end

  def topic(); end

  def topic_arn(); end
end

class AWS::AutoScaling::NotificationConfiguration
end

class AWS::AutoScaling::NotificationConfigurationCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def auto_scaling_group(); end

  def create(options=T.unsafe(nil)); end

  def each(&block); end

  def group(); end

  def initialize(options=T.unsafe(nil)); end

  def put(options=T.unsafe(nil)); end
end

class AWS::AutoScaling::NotificationConfigurationCollection
end

class AWS::AutoScaling::ScalingPolicy
  include ::AWS::AutoScaling::ScalingPolicyOptions
  def _find_in_describe_policies_response_0(resp); end

  def adjustment_type(); end

  def alarms(); end

  def arn(); end

  def auto_scaling_group(); end

  def cooldown(); end

  def delete(); end

  def execute(options=T.unsafe(nil)); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def group(); end

  def initialize(auto_scaling_group, policy_name, options=T.unsafe(nil)); end

  def min_adjustment_step(); end

  def name(); end

  def put(options=T.unsafe(nil)); end

  def scaling_adjustment(); end

  def update(options=T.unsafe(nil)); end
end

class AWS::AutoScaling::ScalingPolicy
end

class AWS::AutoScaling::ScalingPolicyCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  include ::AWS::AutoScaling::ScalingPolicyOptions
  def [](policy_name); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def auto_scaling_group(); end

  def create(name, options=T.unsafe(nil)); end

  def group(); end

  def initialize(auto_scaling_group, options=T.unsafe(nil)); end

  def put(name, options=T.unsafe(nil)); end
end

class AWS::AutoScaling::ScalingPolicyCollection
end

module AWS::AutoScaling::ScalingPolicyOptions
  def scaling_policy_options(auto_scaling_group, policy_name, options); end
end

module AWS::AutoScaling::ScalingPolicyOptions
end

class AWS::AutoScaling::ScheduledAction
  def _find_in_describe_scheduled_actions_response_0(resp); end

  def arn(); end

  def auto_scaling_group_name(); end

  def delete(); end

  def desired_capacity(); end

  def end_time(); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def group(); end

  def initialize(group, name, options=T.unsafe(nil)); end

  def max_size(); end

  def min_size(); end

  def name(); end

  def put(options=T.unsafe(nil)); end

  def recurrence(); end

  def start_time(); end

  def update(options=T.unsafe(nil)); end
end

class AWS::AutoScaling::ScheduledAction
end

class AWS::AutoScaling::ScheduledActionCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def auto_scaling_group(options); end

  def create(name, options=T.unsafe(nil)); end

  def filter(filters=T.unsafe(nil)); end

  def filter_opts(options); end

  def initialize(options=T.unsafe(nil)); end

  def put(name, options=T.unsafe(nil)); end
end

class AWS::AutoScaling::ScheduledActionCollection
end

class AWS::AutoScaling::Tag
  def delete(); end

  def initialize(options=T.unsafe(nil)); end

  def resource(); end
end

class AWS::AutoScaling::Tag
end

class AWS::AutoScaling::TagCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def filter(name, *values); end

  def initialize(options=T.unsafe(nil)); end
end

class AWS::AutoScaling::TagCollection
end

class AWS::AutoScaling
end

class AWS::CloudFormation
  include ::AWS::Core::ServiceInterface
  include ::AWS::CloudFormation::StackOptions
  def client(); end

  def config(); end

  def estimate_template_cost(template, parameters=T.unsafe(nil)); end

  def stack_resource(*args); end

  def stack_summaries(); end

  def stacks(); end

  def validate_template(template); end
end

class AWS::CloudFormation::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFormation::Client::V20100515
  def cancel_update_stack(*args, &block); end

  def create_stack(*args, &block); end

  def delete_stack(*args, &block); end

  def describe_stack_events(*args, &block); end

  def describe_stack_resource(*args, &block); end

  def describe_stack_resources(*args, &block); end

  def describe_stacks(*args, &block); end

  def estimate_template_cost(*args, &block); end

  def get_stack_policy(*args, &block); end

  def get_template(*args, &block); end

  def list_stack_resources(*args, &block); end

  def list_stacks(*args, &block); end

  def set_stack_policy(*args, &block); end

  def update_stack(*args, &block); end

  def validate_template(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFormation::Client::V20100515
end

class AWS::CloudFormation::Client
end

module AWS::CloudFormation::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::CloudFormation::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::CloudFormation::Stack
  include ::AWS::CloudFormation::StackOptions
  def _find_in_describe_stacks_response_0(resp); end

  def _find_in_get_template_response_2(resp); end

  def _find_in_list_stacks_response_1(resp); end

  def capabilities(); end

  def creation_time(); end

  def delete(); end

  def description(); end

  def disable_rollback(); end

  def disable_rollback?(); end

  def estimate_template_cost(); end

  def events(); end

  def exists?(); end

  def get_resource(attribute); end

  def initialize(name, options=T.unsafe(nil)); end

  def last_updated_time(); end

  def name(); end

  def notification_arns(); end

  def output_details(); end

  def outputs(); end

  def parameters(); end

  def resource_summaries(); end

  def resources(); end

  def stack_id(); end

  def status(); end

  def status_reason(); end

  def template(); end

  def template_body(); end

  def timeout(); end

  def timeout_in_minutes(); end

  def update(options=T.unsafe(nil)); end
end

class AWS::CloudFormation::Stack
  def self.describe_attribute(name, options=T.unsafe(nil), &block); end

  def self.describe_attributes(); end

  def self.list_attribute(name, options=T.unsafe(nil), &block); end

  def self.list_attributes(); end

  def self.template_attribute(name, options=T.unsafe(nil), &block); end

  def self.template_attributes(); end
end

class AWS::CloudFormation::StackCollection
  include ::AWS::Core::Collection::WithNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  include ::AWS::CloudFormation::StackOptions
  def [](stack_name); end

  def _each_item(next_token, options=T.unsafe(nil)); end

  def create(stack_name, template, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def with_status(*status_filters); end
end

class AWS::CloudFormation::StackCollection
end

class AWS::CloudFormation::StackEvent
  def event_id(); end

  def initialize(stack, details); end

  def logical_resource_id(); end

  def physical_resource_id(); end

  def resource_properties(); end

  def resource_status(); end

  def resource_status_reason(); end

  def resource_type(); end

  def stack(); end

  def stack_id(); end

  def stack_name(); end

  def timestamp(); end
end

class AWS::CloudFormation::StackEvent
end

class AWS::CloudFormation::StackEventCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(options=T.unsafe(nil)); end

  def initialize(stack, options=T.unsafe(nil)); end

  def stack(); end
end

class AWS::CloudFormation::StackEventCollection
end

module AWS::CloudFormation::StackOptions
  def apply_disable_rollback(options); end

  def apply_notification_arns(options); end

  def apply_parameters(options); end

  def apply_stack_name(stack_name, options); end

  def apply_template(opts); end

  def apply_timeout(options); end
end

module AWS::CloudFormation::StackOptions
end

class AWS::CloudFormation::StackOutput
  def ==(other); end

  def description(); end

  def eql?(other); end

  def initialize(stack, key, value, description); end

  def key(); end

  def stack(); end

  def value(); end
end

class AWS::CloudFormation::StackOutput
end

class AWS::CloudFormation::StackResource
  def _find_in_describe_stack_resource_response_0(resp); end

  def _find_in_describe_stack_resources_response_1(resp); end

  def description(); end

  def get_resource(attribute=T.unsafe(nil)); end

  def initialize(stack, logical_resource_id, options=T.unsafe(nil)); end

  def last_updated_timestamp(); end

  def logical_resource_id(); end

  def metadata(); end

  def physical_resource_id(); end

  def resource_status(); end

  def resource_status_reason(); end

  def resource_type(); end

  def stack(); end

  def stack_id(); end

  def stack_name(); end
end

class AWS::CloudFormation::StackResource
  def self.common_attribute(name, options=T.unsafe(nil), &block); end

  def self.common_attributes(); end

  def self.detail_attribute(name, options=T.unsafe(nil), &block); end

  def self.detail_attributes(); end
end

class AWS::CloudFormation::StackResourceCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  include ::AWS::CloudFormation::StackOptions
  def [](logical_resource_id); end

  def _each_item(options=T.unsafe(nil)); end

  def initialize(stack, options=T.unsafe(nil)); end

  def stack(); end
end

class AWS::CloudFormation::StackResourceCollection
end

class AWS::CloudFormation::StackResourceSummaryCollection
  include ::AWS::Core::Collection::WithNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def initialize(stack, options=T.unsafe(nil)); end

  def stack(); end
end

class AWS::CloudFormation::StackResourceSummaryCollection
end

class AWS::CloudFormation::StackSummaryCollection
  include ::AWS::Core::Collection::WithNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def initialize(options=T.unsafe(nil)); end

  def with_status(*status_filters); end
end

class AWS::CloudFormation::StackSummaryCollection
end

class AWS::CloudFormation
end

class AWS::CloudFront
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::CloudFront::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20130512
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20130512
end

class AWS::CloudFront::Client::V20130826
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20130826
end

class AWS::CloudFront::Client::V20130927
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20130927
end

class AWS::CloudFront::Client::V20131111
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20131111
end

class AWS::CloudFront::Client::V20131122
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20131122
end

class AWS::CloudFront::Client::V20140131
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20140131
end

class AWS::CloudFront::Client::V20140531
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20140531
end

class AWS::CloudFront::Client::V20141021
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20141021
end

class AWS::CloudFront::Client::V20141106
  def create_cloud_front_origin_access_identity(*args, &block); end

  def create_distribution(*args, &block); end

  def create_invalidation(*args, &block); end

  def create_streaming_distribution(*args, &block); end

  def delete_cloud_front_origin_access_identity(*args, &block); end

  def delete_distribution(*args, &block); end

  def delete_streaming_distribution(*args, &block); end

  def get_cloud_front_origin_access_identity(*args, &block); end

  def get_cloud_front_origin_access_identity_config(*args, &block); end

  def get_distribution(*args, &block); end

  def get_distribution_config(*args, &block); end

  def get_invalidation(*args, &block); end

  def get_streaming_distribution(*args, &block); end

  def get_streaming_distribution_config(*args, &block); end

  def list_cloud_front_origin_access_identities(*args, &block); end

  def list_distributions(*args, &block); end

  def list_invalidations(*args, &block); end

  def list_streaming_distributions(*args, &block); end

  def update_cloud_front_origin_access_identity(*args, &block); end

  def update_distribution(*args, &block); end

  def update_streaming_distribution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudFront::Client::V20141106
end

class AWS::CloudFront::Client
end

module AWS::CloudFront::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::CloudFront::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::CloudFront
end

class AWS::CloudSearch
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::CloudSearch::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::CloudSearch::Client::V20110201
  def create_domain(*args, &block); end

  def define_index_field(*args, &block); end

  def define_rank_expression(*args, &block); end

  def delete_domain(*args, &block); end

  def delete_index_field(*args, &block); end

  def delete_rank_expression(*args, &block); end

  def describe_default_search_field(*args, &block); end

  def describe_domains(*args, &block); end

  def describe_index_fields(*args, &block); end

  def describe_rank_expressions(*args, &block); end

  def describe_service_access_policies(*args, &block); end

  def describe_stemming_options(*args, &block); end

  def describe_stopword_options(*args, &block); end

  def describe_synonym_options(*args, &block); end

  def index_documents(*args, &block); end

  def update_default_search_field(*args, &block); end

  def update_service_access_policies(*args, &block); end

  def update_stemming_options(*args, &block); end

  def update_stopword_options(*args, &block); end

  def update_synonym_options(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudSearch::Client::V20110201
end

class AWS::CloudSearch::Client::V20130101
  def build_suggesters(*args, &block); end

  def create_domain(*args, &block); end

  def define_analysis_scheme(*args, &block); end

  def define_expression(*args, &block); end

  def define_index_field(*args, &block); end

  def define_suggester(*args, &block); end

  def delete_analysis_scheme(*args, &block); end

  def delete_domain(*args, &block); end

  def delete_expression(*args, &block); end

  def delete_index_field(*args, &block); end

  def delete_suggester(*args, &block); end

  def describe_analysis_schemes(*args, &block); end

  def describe_availability_options(*args, &block); end

  def describe_domains(*args, &block); end

  def describe_expressions(*args, &block); end

  def describe_index_fields(*args, &block); end

  def describe_scaling_parameters(*args, &block); end

  def describe_service_access_policies(*args, &block); end

  def describe_suggesters(*args, &block); end

  def index_documents(*args, &block); end

  def list_domain_names(*args, &block); end

  def update_availability_options(*args, &block); end

  def update_scaling_parameters(*args, &block); end

  def update_service_access_policies(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudSearch::Client::V20130101
end

class AWS::CloudSearch::Client
end

module AWS::CloudSearch::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::CloudSearch::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::CloudSearch
end

class AWS::CloudTrail
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::CloudTrail::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::CloudTrail::Client::V20131101
  def create_trail(*args, &block); end

  def delete_trail(*args, &block); end

  def describe_trails(*args, &block); end

  def get_trail_status(*args, &block); end

  def start_logging(*args, &block); end

  def stop_logging(*args, &block); end

  def update_trail(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudTrail::Client::V20131101
end

class AWS::CloudTrail::Client
end

module AWS::CloudTrail::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::CloudTrail::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::CloudTrail
end

class AWS::CloudWatch
  include ::AWS::Core::ServiceInterface
  def alarm_history_items(); end

  def alarms(); end

  def client(); end

  def config(); end

  def metrics(options=T.unsafe(nil)); end

  def put_metric_data(options=T.unsafe(nil)); end
end

class AWS::CloudWatch::Alarm
  def _find_in_describe_alarms_for_metric_response_1(resp); end

  def _find_in_describe_alarms_response_0(resp); end

  def actions(); end

  def actions_enabled(); end

  def alarm_actions(); end

  def alarm_arn(); end

  def alarm_configuration_updated_timestamp(); end

  def alarm_description(); end

  def alarm_name(); end

  def arn(); end

  def comparison_operator(); end

  def configuration_updated_timestamp(); end

  def delete(); end

  def description(); end

  def dimensions(); end

  def disable(); end

  def enable(); end

  def enabled(); end

  def enabled?(); end

  def evaluation_periods(); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def histories(options=T.unsafe(nil)); end

  def history(options=T.unsafe(nil)); end

  def history_items(options=T.unsafe(nil)); end

  def initialize(alarm_name, options=T.unsafe(nil)); end

  def insufficient_data_actions(); end

  def metric(); end

  def metric_name(); end

  def name(); end

  def namespace(); end

  def ok_actions(); end

  def period(); end

  def set_state(reason, value, options=T.unsafe(nil)); end

  def state_reason(); end

  def state_reason_data(); end

  def state_updated_timestamp(); end

  def state_value(); end

  def statistic(); end

  def threshold(); end

  def unit(); end

  def update(options=T.unsafe(nil)); end
end

class AWS::CloudWatch::Alarm
end

class AWS::CloudWatch::AlarmCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](alarm_name); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def create(alarm_name, options=T.unsafe(nil)); end

  def delete(*alarm_names); end

  def filter(name, value); end

  def initialize(options=T.unsafe(nil)); end

  def with_action_prefix(prefix); end

  def with_name(*names); end

  def with_name_prefix(prefix); end

  def with_state_value(state); end
end

class AWS::CloudWatch::AlarmCollection
end

class AWS::CloudWatch::AlarmHistoryItem
  def alarm_name(); end

  def data(); end

  def history_data(); end

  def history_item_type(); end

  def history_summary(); end

  def initialize(options); end

  def summary(); end

  def timestamp(); end

  def type(); end
end

class AWS::CloudWatch::AlarmHistoryItem
end

class AWS::CloudWatch::AlarmHistoryItemCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def filter(name, value); end

  def initialize(options=T.unsafe(nil)); end

  def with_alarm_name(name); end

  def with_end_date(date); end

  def with_start_date(date); end

  def with_type(type); end
end

class AWS::CloudWatch::AlarmHistoryItemCollection
end

class AWS::CloudWatch::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::CloudWatch::Client::V20100801
  def delete_alarms(*args, &block); end

  def describe_alarm_history(*args, &block); end

  def describe_alarms(*args, &block); end

  def describe_alarms_for_metric(*args, &block); end

  def disable_alarm_actions(*args, &block); end

  def enable_alarm_actions(*args, &block); end

  def get_metric_statistics(*args, &block); end

  def list_metrics(*args, &block); end

  def put_metric_alarm(*args, &block); end

  def put_metric_data(*args, &block); end

  def set_alarm_state(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::CloudWatch::Client::V20100801
end

class AWS::CloudWatch::Client
end

module AWS::CloudWatch::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::CloudWatch::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::CloudWatch::Metric
  def alarms(); end

  def dimensions(); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def initialize(namespace, metric_name, options=T.unsafe(nil)); end

  def metric_name(); end

  def name(); end

  def namespace(); end

  def put_data(*metric_data); end

  def statistics(options=T.unsafe(nil)); end
end

class AWS::CloudWatch::Metric
end

class AWS::CloudWatch::MetricAlarmCollection
  include ::AWS::Core::Collection::Simple
  def _each_item(options=T.unsafe(nil), &block); end

  def filter(name, value); end

  def initialize(metric, options=T.unsafe(nil)); end

  def metric(); end

  def with_period(period); end

  def with_statistic(statistic); end

  def with_unit(unit); end
end

class AWS::CloudWatch::MetricAlarmCollection
end

class AWS::CloudWatch::MetricCollection
  include ::AWS::Core::Collection::WithNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def filter(name, value); end

  def initialize(options=T.unsafe(nil)); end

  def with_dimension(name, value); end

  def with_dimensions(*dimensions); end

  def with_metric_name(name); end

  def with_namespace(namespace); end
end

class AWS::CloudWatch::MetricCollection
end

class AWS::CloudWatch::MetricStatistics
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(options=T.unsafe(nil)); end

  def datapoints(); end

  def initialize(metric, label, datapoints); end

  def label(); end

  def metric(); end
end

class AWS::CloudWatch::MetricStatistics
end

class AWS::CloudWatch
end

module AWS::Core
end

module AWS::Core::AsyncHandle
  def on_complete(&block); end

  def on_failure(&block); end

  def on_success(&block); end

  def signal_failure(); end

  def signal_success(); end
end

module AWS::Core::AsyncHandle
end

module AWS::Core::Cacheable
  def cache_key(); end

  def local_cache_key(); end

  def retrieve_attribute(attr, &block); end
end

module AWS::Core::Cacheable
  def self.included(base); end
end

class AWS::Core::Client
  def async_request_with_retries(response, http_request, retry_delays=T.unsafe(nil)); end

  def build_request(name, options); end

  def cacheable_request?(name, options); end

  def client_request(name, options, &read_block); end

  def config(); end

  def credential_provider(); end

  def deprecated_http_read_timeout(); end

  def endpoint(); end

  def error_class(error_code); end

  def errors_module(); end

  def expired_credentials?(response); end

  def extract_error_details(response); end

  def http_read_timeout(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def log_client_request(options, &block); end

  def log_response(response); end

  def log_warning(warning); end

  def make_async_request(response); end

  def make_sync_request(response, &read_block); end

  def new_request(); end

  def new_response(*args, &block); end

  def new_stub_for(method_name); end

  def operations(); end

  def populate_error(response); end

  def port(); end

  def rebuild_http_request(response); end

  def redirected?(response); end

  def retry_server_errors(&block); end

  def retryable_error?(response); end

  def return_or_raise(options, &block); end

  def scaling_factor(response); end

  def service_ruby_name(); end

  def should_retry?(response); end

  def sign_request(req); end

  def sleep_durations(response); end

  def stub_for(method_name); end

  def throttled?(response); end

  def to_yaml_properties(); end

  def user_agent_string(); end

  def with_config(config); end

  def with_http_handler(handler=T.unsafe(nil), &blk); end

  def with_options(options); end
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::Core::Client
  extend ::AWS::Core::Deprecations
  extend ::AWS::Core::Naming
  def self.add_client_request_method(method_name, options=T.unsafe(nil), &block); end

  def self.define_client_method(method_name, builder, parser); end

  def self.define_client_methods(api_version); end

  def self.load_api_config(api_version); end

  def self.new(*args, &block); end

  def self.operations(options=T.unsafe(nil)); end

  def self.request_builder_for(api_config, operation); end

  def self.request_builders(); end

  def self.response_parser_for(api_config, operation); end

  def self.response_parsers(); end

  def self.signature_version(version, service_signing_name=T.unsafe(nil)); end
end

module AWS::Core::Collection
  include ::Enumerable
  def _each_batch(options, &block); end

  def _each_item(next_token, options=T.unsafe(nil), &block); end

  def _extract_batch_size(options); end

  def _extract_limit(options); end

  def _extract_next_token(options); end

  def _limit(); end

  def each(options=T.unsafe(nil), &block); end

  def each_batch(options=T.unsafe(nil), &block); end

  def enum(options=T.unsafe(nil)); end

  def enumerator(options=T.unsafe(nil)); end

  def first(options=T.unsafe(nil)); end

  def in_groups_of(size, options=T.unsafe(nil), &block); end

  def page(options=T.unsafe(nil)); end
end

module AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_batch(options=T.unsafe(nil), &block); end
end

module AWS::Core::Collection::Simple
end

module AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_batch(options=T.unsafe(nil), &block); end
end

module AWS::Core::Collection::WithLimitAndNextToken
end

module AWS::Core::Collection::WithNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_batch(options=T.unsafe(nil), &block); end

  def _extract_next_token(options); end
end

module AWS::Core::Collection::WithNextToken
end

module AWS::Core::Collection
end

class AWS::Core::Configuration
  def ==(other); end

  def access_key_id(&default_override); end

  def auto_scaling(&default_override); end

  def auto_scaling_client(); end

  def auto_scaling_endpoint(&default_override); end

  def auto_scaling_port(&default_override); end

  def auto_scaling_region(&default_override); end

  def cloud_formation(&default_override); end

  def cloud_formation_client(); end

  def cloud_formation_endpoint(&default_override); end

  def cloud_formation_port(&default_override); end

  def cloud_formation_region(&default_override); end

  def cloud_front(&default_override); end

  def cloud_front_client(); end

  def cloud_front_endpoint(&default_override); end

  def cloud_front_port(&default_override); end

  def cloud_front_region(&default_override); end

  def cloud_search(&default_override); end

  def cloud_search_client(); end

  def cloud_search_endpoint(&default_override); end

  def cloud_search_port(&default_override); end

  def cloud_search_region(&default_override); end

  def cloud_trail(&default_override); end

  def cloud_trail_client(); end

  def cloud_trail_endpoint(&default_override); end

  def cloud_trail_port(&default_override); end

  def cloud_trail_region(&default_override); end

  def cloud_watch(&default_override); end

  def cloud_watch_client(); end

  def cloud_watch_endpoint(&default_override); end

  def cloud_watch_port(&default_override); end

  def cloud_watch_region(&default_override); end

  def credential_provider(); end

  def credentials(); end

  def data_pipeline(&default_override); end

  def data_pipeline_client(); end

  def data_pipeline_endpoint(&default_override); end

  def data_pipeline_port(&default_override); end

  def data_pipeline_region(&default_override); end

  def direct_connect(&default_override); end

  def direct_connect_client(); end

  def direct_connect_endpoint(&default_override); end

  def direct_connect_port(&default_override); end

  def direct_connect_region(&default_override); end

  def dynamo_db(&default_override); end

  def dynamo_db_big_decimals(&default_override); end

  def dynamo_db_big_decimals?(&default_override); end

  def dynamo_db_client(); end

  def dynamo_db_crc32(&default_override); end

  def dynamo_db_crc32?(&default_override); end

  def dynamo_db_endpoint(&default_override); end

  def dynamo_db_port(&default_override); end

  def dynamo_db_region(&default_override); end

  def dynamo_db_retry_throughput_errors(&default_override); end

  def dynamo_db_retry_throughput_errors?(&default_override); end

  def ec2(&default_override); end

  def ec2_client(); end

  def ec2_endpoint(&default_override); end

  def ec2_port(&default_override); end

  def ec2_region(&default_override); end

  def ec2_signature_version(&default_override); end

  def elastic_beanstalk(&default_override); end

  def elastic_beanstalk_client(); end

  def elastic_beanstalk_endpoint(&default_override); end

  def elastic_beanstalk_port(&default_override); end

  def elastic_beanstalk_region(&default_override); end

  def elastic_transcoder(&default_override); end

  def elastic_transcoder_client(); end

  def elastic_transcoder_endpoint(&default_override); end

  def elastic_transcoder_port(&default_override); end

  def elastic_transcoder_region(&default_override); end

  def elasticache(&default_override); end

  def elasticache_client(); end

  def elasticache_endpoint(&default_override); end

  def elasticache_port(&default_override); end

  def elasticache_region(&default_override); end

  def elb(&default_override); end

  def elb_client(); end

  def elb_endpoint(&default_override); end

  def elb_port(&default_override); end

  def elb_region(&default_override); end

  def emr(&default_override); end

  def emr_client(); end

  def emr_endpoint(&default_override); end

  def emr_port(&default_override); end

  def emr_region(&default_override); end

  def endpoint_region(svc); end

  def eql?(other); end

  def glacier(&default_override); end

  def glacier_client(); end

  def glacier_endpoint(&default_override); end

  def glacier_port(&default_override); end

  def glacier_region(&default_override); end

  def http_continue_threshold(&default_override); end

  def http_continue_timeout(&default_override); end

  def http_handler(); end

  def http_idle_timeout(&default_override); end

  def http_open_timeout(&default_override); end

  def http_read_timeout(&default_override); end

  def http_wire_trace(&default_override); end

  def http_wire_trace?(&default_override); end

  def iam(&default_override); end

  def iam_client(); end

  def iam_endpoint(&default_override); end

  def iam_port(&default_override); end

  def iam_region(&default_override); end

  def import_export(&default_override); end

  def import_export_client(); end

  def import_export_endpoint(&default_override); end

  def import_export_port(&default_override); end

  def import_export_region(&default_override); end

  def initialize(options=T.unsafe(nil)); end

  def kinesis(&default_override); end

  def kinesis_client(); end

  def kinesis_endpoint(&default_override); end

  def kinesis_port(&default_override); end

  def kinesis_region(&default_override); end

  def log_formatter(&default_override); end

  def log_level(&default_override); end

  def logger(&default_override); end

  def max_retries(&default_override); end

  def ops_works(&default_override); end

  def ops_works_client(); end

  def ops_works_endpoint(&default_override); end

  def ops_works_port(&default_override); end

  def ops_works_region(&default_override); end

  def proxy_uri(&default_override); end

  def rds(&default_override); end

  def rds_client(); end

  def rds_endpoint(&default_override); end

  def rds_port(&default_override); end

  def rds_region(&default_override); end

  def redshift(&default_override); end

  def redshift_client(); end

  def redshift_endpoint(&default_override); end

  def redshift_port(&default_override); end

  def redshift_region(&default_override); end

  def region(&default_override); end

  def route_53(&default_override); end

  def route_53_client(); end

  def route_53_endpoint(&default_override); end

  def route_53_port(&default_override); end

  def route_53_region(&default_override); end

  def s3(&default_override); end

  def s3_cache_object_attributes(&default_override); end

  def s3_cache_object_attributes?(&default_override); end

  def s3_client(); end

  def s3_encryption_key(&default_override); end

  def s3_encryption_matdesc(&default_override); end

  def s3_encryption_materials_location(&default_override); end

  def s3_endpoint(&default_override); end

  def s3_force_path_style(&default_override); end

  def s3_force_path_style?(&default_override); end

  def s3_multipart_max_parts(&default_override); end

  def s3_multipart_min_part_size(&default_override); end

  def s3_multipart_threshold(&default_override); end

  def s3_port(&default_override); end

  def s3_region(&default_override); end

  def s3_server_side_encryption(&default_override); end

  def s3_signature_version(&default_override); end

  def s3_storage_class(&default_override); end

  def secret_access_key(&default_override); end

  def ses(&default_override); end

  def session_token(&default_override); end

  def simple_db(&default_override); end

  def simple_db_client(); end

  def simple_db_consistent_reads(&default_override); end

  def simple_db_consistent_reads?(&default_override); end

  def simple_db_endpoint(&default_override); end

  def simple_db_port(&default_override); end

  def simple_db_region(&default_override); end

  def simple_email_service_client(); end

  def simple_email_service_endpoint(&default_override); end

  def simple_email_service_port(&default_override); end

  def simple_email_service_region(&default_override); end

  def simple_workflow_client(); end

  def simple_workflow_endpoint(&default_override); end

  def simple_workflow_port(&default_override); end

  def simple_workflow_region(&default_override); end

  def sns(&default_override); end

  def sns_client(); end

  def sns_endpoint(&default_override); end

  def sns_port(&default_override); end

  def sns_region(&default_override); end

  def sqs(&default_override); end

  def sqs_client(); end

  def sqs_endpoint(&default_override); end

  def sqs_port(&default_override); end

  def sqs_region(&default_override); end

  def sqs_verify_checksums(&default_override); end

  def sqs_verify_checksums?(&default_override); end

  def ssl_ca_file(&default_override); end

  def ssl_ca_path(&default_override); end

  def ssl_cert_store(&default_override); end

  def ssl_verify_peer(&default_override); end

  def ssl_verify_peer?(&default_override); end

  def storage_gateway(&default_override); end

  def storage_gateway_client(); end

  def storage_gateway_endpoint(&default_override); end

  def storage_gateway_port(&default_override); end

  def storage_gateway_region(&default_override); end

  def sts(&default_override); end

  def sts_client(); end

  def sts_endpoint(&default_override); end

  def sts_port(&default_override); end

  def sts_region(&default_override); end

  def stub_requests(&default_override); end

  def stub_requests?(&default_override); end

  def supplied(); end

  def support(&default_override); end

  def support_client(); end

  def support_endpoint(&default_override); end

  def support_port(&default_override); end

  def support_region(&default_override); end

  def swf(&default_override); end

  def to_h(); end

  def to_hash(); end

  def use_ssl(&default_override); end

  def use_ssl?(&default_override); end

  def user_agent_prefix(&default_override); end

  def verify_response_body_content_length(&default_override); end

  def verify_response_body_content_length?(&default_override); end

  def with(options=T.unsafe(nil)); end
end

class AWS::Core::Configuration
  def self.accepted_options(); end

  def self.add_option(name, default_value=T.unsafe(nil), options=T.unsafe(nil), &transform); end

  def self.add_option_with_needs(name, needs, &create_block); end

  def self.add_service(name, ruby_name, endpoint_prefix); end
end

module AWS::Core::CredentialProviders
end

class AWS::Core::CredentialProviders::AssumeRoleProvider
  include ::AWS::Core::CredentialProviders::Provider
  def initialize(options=T.unsafe(nil)); end
end

class AWS::Core::CredentialProviders::AssumeRoleProvider
end

class AWS::Core::CredentialProviders::CredentialFileProvider
  include ::AWS::Core::CredentialProviders::Provider
  def credential_file(); end

  def initialize(credential_file); end
  CREDENTIAL_FILE_KEY_MAP = ::T.let(nil, ::T.untyped)
end

class AWS::Core::CredentialProviders::CredentialFileProvider
end

class AWS::Core::CredentialProviders::DefaultProvider
  include ::AWS::Core::CredentialProviders::Provider
  def initialize(static_credentials=T.unsafe(nil)); end

  def providers(); end
end

class AWS::Core::CredentialProviders::DefaultProvider
end

class AWS::Core::CredentialProviders::EC2Provider
  include ::AWS::Core::CredentialProviders::Provider
  def credentials_expiration(); end

  def credentials_expiration=(credentials_expiration); end

  def get(session, path); end

  def http_debug_output(); end

  def http_debug_output=(http_debug_output); end

  def http_open_timeout(); end

  def http_open_timeout=(http_open_timeout); end

  def http_read_timeout(); end

  def http_read_timeout=(http_read_timeout); end

  def initialize(options=T.unsafe(nil)); end

  def ip_address(); end

  def ip_address=(ip_address); end

  def near_expiration?(); end

  def port(); end

  def port=(port); end

  def retries(); end

  def retries=(retries); end
  FAILURES = ::T.let(nil, ::T.untyped)
end

class AWS::Core::CredentialProviders::EC2Provider::FailedRequestError
end

class AWS::Core::CredentialProviders::EC2Provider::FailedRequestError
end

class AWS::Core::CredentialProviders::EC2Provider
end

class AWS::Core::CredentialProviders::ENVProvider
  include ::AWS::Core::CredentialProviders::Provider
  def initialize(prefix, suffixes=T.unsafe(nil)); end

  def prefix(); end
end

class AWS::Core::CredentialProviders::ENVProvider
end

class AWS::Core::CredentialProviders::FakeProvider
  def fake_access_key_id(); end

  def fake_secret_access_key(); end

  def fake_session_token(); end

  def initialize(options=T.unsafe(nil)); end

  def random_chars(count); end
end

class AWS::Core::CredentialProviders::FakeProvider
end

module AWS::Core::CredentialProviders::Provider
  def access_key_id(); end

  def credentials(); end

  def get_credentials(); end

  def refresh(); end

  def secret_access_key(); end

  def session_token(); end

  def set?(); end
  KEYS = ::T.let(nil, ::T.untyped)
end

module AWS::Core::CredentialProviders::Provider
end

class AWS::Core::CredentialProviders::SessionProvider
  include ::AWS::Core::CredentialProviders::Provider
  def cached_session(); end

  def initialize(long_term_credentials); end

  def orig_refresh(); end

  def refresh_session(); end
end

class AWS::Core::CredentialProviders::SessionProvider
  def self.for(long_term_credentials); end
end

class AWS::Core::CredentialProviders::SharedCredentialFileProvider
  include ::AWS::Core::CredentialProviders::Provider
  def initialize(options=T.unsafe(nil)); end

  def path(); end

  def profile_name(); end

  def shared_credential_file_path(); end
  KEY_MAP = ::T.let(nil, ::T.untyped)
end

class AWS::Core::CredentialProviders::SharedCredentialFileProvider
end

class AWS::Core::CredentialProviders::StaticProvider
  include ::AWS::Core::CredentialProviders::Provider
  def initialize(static_credentials=T.unsafe(nil)); end
end

class AWS::Core::CredentialProviders::StaticProvider
end

module AWS::Core::CredentialProviders
end

class AWS::Core::Data
  include ::AWS::Core::Data::MethodMissingProxy
  def _remove_question_mark(method_name); end

  def initialize(data); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def respond_to?(method_name); end

  def to_a(); end

  def to_ary(); end

  def to_h(); end

  def to_hash(); end
end

class AWS::Core::Data::List
  include ::AWS::Core::Data::MethodMissingProxy
  def empty?(); end

  def initialize(array); end

  def inject(*args, &block); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def to_a(); end

  def to_ary(); end
end

class AWS::Core::Data::List
end

module AWS::Core::Data::MethodMissingProxy
  def ==(other); end

  def [](index_or_key); end

  def _data(); end

  def clone(); end

  def dup(); end

  def eql?(other); end

  def id(); end

  def method_missing(*args, &block); end
end

module AWS::Core::Data::MethodMissingProxy
end

class AWS::Core::Data
  def self.cast(value); end
end

module AWS::Core::Deprecations
  def deprecated(method, options=T.unsafe(nil)); end
end

module AWS::Core::Deprecations
end

module AWS::Core::Endpoints
end

module AWS::Core::Endpoints
  def self.endpoints(); end

  def self.hostname(region, endpoint_prefix); end
end

module AWS::Core::Http
end

class AWS::Core::Http::ConnectionPool
  def clean!(); end

  def empty!(); end

  def http_continue_timeout(); end

  def http_idle_timeout(); end

  def http_open_timeout(); end

  def http_read_timeout(); end

  def http_wire_trace(); end

  def http_wire_trace?(); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def options(); end

  def proxy_uri(); end

  def request(endpoint, request, &block); end

  def session_for(endpoint, &block); end

  def size(); end

  def ssl_ca_file(); end

  def ssl_ca_path(); end

  def ssl_cert_store(); end

  def ssl_verify_peer(); end

  def ssl_verify_peer?(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module AWS::Core::Http::ConnectionPool::SessionExtensions
  def finish(); end

  def last_used(); end

  def request(*args, &block); end
end

module AWS::Core::Http::ConnectionPool::SessionExtensions
end

class AWS::Core::Http::ConnectionPool
  def self.build(options=T.unsafe(nil)); end

  def self.new(options=T.unsafe(nil)); end

  def self.pools(); end
end

class AWS::Core::Http::Handler
  def base(); end

  def handle(request, http_response, &read_block); end

  def handle_async(request, http_response, handle); end

  def initialize(base, &block); end

  def sleep_with_callback(seconds, &block); end
end

class AWS::Core::Http::Handler
end

class AWS::Core::Http::NetHttpHandler
  def build_net_http_request(request); end

  def determine_expected_content_length(response); end

  def handle(request, response, &read_block); end

  def initialize(options=T.unsafe(nil)); end

  def pool(); end
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class AWS::Core::Http::NetHttpHandler::TruncatedBodyError
end

class AWS::Core::Http::NetHttpHandler::TruncatedBodyError
end

class AWS::Core::Http::NetHttpHandler
end

module AWS::Core::Http::Patches
end

module AWS::Core::Http::Patches::Ruby_1_9_3
  def new_transport_request(req); end
end

module AWS::Core::Http::Patches::Ruby_1_9_3
end

module AWS::Core::Http::Patches::Ruby_2
  def new_transport_request(req); end
end

module AWS::Core::Http::Patches::Ruby_2
end

module AWS::Core::Http::Patches
  def self.apply!(); end
end

class AWS::Core::Http::Request
  def access_key_id(); end

  def access_key_id=(access_key_id); end

  def add_param(name_or_param, value=T.unsafe(nil)); end

  def body(); end

  def body=(body); end

  def body_stream(); end

  def body_stream=(stream); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def default_read_timeout(*args, &block); end

  def deprecated_default_read_timeout(); end

  def endpoint(); end

  def headers(); end

  def headers=(headers); end

  def host(); end

  def host=(host); end

  def http_method(); end

  def http_method=(http_method); end

  def params(); end

  def params=(params); end

  def path(); end

  def port(); end

  def port=(port); end

  def querystring(); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def region(); end

  def region=(region); end

  def remove_param(name); end

  def service(); end

  def service=(service); end

  def service_ruby_name(); end

  def service_ruby_name=(service_ruby_name); end

  def uri(); end

  def uri=(uri); end

  def url_encoded_params(); end

  def use_ssl(); end

  def use_ssl=(use_ssl); end

  def use_ssl?(); end
end

class AWS::Core::Http::Request::CaseInsensitiveHash
  def [](key); end

  def []=(key, value); end

  def has_key?(key); end

  def include?(key); end

  def key?(key); end

  def member?(key); end
end

class AWS::Core::Http::Request::CaseInsensitiveHash
end

class AWS::Core::Http::Request::Param
  include ::AWS::Core::UriEscape
  def ==(other); end

  def encoded(); end

  def initialize(name, value=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def value(); end

  def value=(value); end
end

class AWS::Core::Http::Request::Param
end

class AWS::Core::Http::Request
  extend ::AWS::Core::Deprecations
end

class AWS::Core::Http::Response
  def body(); end

  def body=(body); end

  def header(name); end

  def headers(); end

  def headers=(headers); end

  def initialize(options=T.unsafe(nil), &block); end

  def network_error(); end

  def network_error=(network_error); end

  def network_error?(); end

  def status(); end

  def status=(status); end

  def timeout=(timeout); end
end

class AWS::Core::Http::Response
end

module AWS::Core::Http
end

class AWS::Core::IndifferentHash
  def [](key); end

  def []=(key, value); end

  def _getter(_); end

  def _setter(_, _1); end

  def delete(key); end

  def fetch(key, *extras, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(*args); end

  def key?(key); end

  def member?(key); end

  def merge(hash); end

  def merge!(hash); end

  def store(key, value); end

  def update(hash); end
end

class AWS::Core::IndifferentHash
end

module AWS::Core::Inflection
end

module AWS::Core::Inflection
  def self.class_name(name); end

  def self.ruby_name(aws_name); end
end

module AWS::Core::IniParser
end

module AWS::Core::IniParser
  def self.parse(ini); end
end

class AWS::Core::JSONClient
end

class AWS::Core::JSONClient
end

class AWS::Core::JSONParser
  def initialize(rules); end

  def parse(body); end

  def rules(); end

  def translate(values, rules=T.unsafe(nil)); end

  def translate_hash(values, rules); end

  def translate_map(values, rules); end

  def translate_value(value, rule); end
end

class AWS::Core::JSONParser
end

class AWS::Core::JSONRequestBuilder
  def initialize(api, operation); end

  def populate_request(request, options); end
end

class AWS::Core::JSONRequestBuilder
end

class AWS::Core::JSONResponseParser
  def extract_data(response); end

  def initialize(rules); end

  def simulate(); end

  def translate(values, rules=T.unsafe(nil)); end

  def translate_hash(values, rules); end

  def translate_map(values, rules); end

  def translate_value(value, rule); end
end

class AWS::Core::JSONResponseParser
end

module AWS::Core::LazyErrorClasses
  def const_missing(constant); end

  def error_class(code); end
  BASE_ERROR_GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::Core::LazyErrorClasses
  def self.extended(base); end
end

class AWS::Core::LogFormatter
  def ==(other); end

  def _duration(response); end

  def _error_class(response); end

  def _error_message(response); end

  def _http_request_body(response); end

  def _http_request_headers(response); end

  def _http_request_host(response); end

  def _http_request_method(response); end

  def _http_request_port(response); end

  def _http_request_protocol(response); end

  def _http_request_proxy_uri(response); end

  def _http_request_uri(response); end

  def _http_response_body(response); end

  def _http_response_headers(response); end

  def _http_response_status(response); end

  def _operation(response); end

  def _options(response); end

  def _region(response); end

  def _retry_count(response); end

  def _service(response); end

  def eql?(other); end

  def format(response); end

  def initialize(pattern, options=T.unsafe(nil)); end

  def max_string_size(); end

  def method_missing(method_name, *args); end

  def pattern(); end

  def summarize_array(array); end

  def summarize_file(path); end

  def summarize_hash(hash); end

  def summarize_string(str); end

  def summarize_value(value); end
end

class AWS::Core::LogFormatter
  def self.colored(); end

  def self.debug(); end

  def self.default(); end

  def self.short(); end
end

class AWS::Core::ManagedFile
end

class AWS::Core::ManagedFile
  def self.open(path); end
end

module AWS::Core::MetaUtils
end

module AWS::Core::MetaUtils
  def self.class_extend_method(klass, name, &block); end

  def self.extend(object, &block); end

  def self.extend_method(object, name, &block); end
end

module AWS::Core::Model
  def client(); end

  def config(); end

  def config_prefix(); end

  def initialize(*args); end

  def inspect(); end

  def to_yaml_properties(); end
end

module AWS::Core::Model
end

module AWS::Core::Naming
  def service_name(); end

  def service_ruby_name(); end
end

module AWS::Core::Naming
end

class AWS::Core::OptionGrammar
end

class AWS::Core::OptionGrammar::DefaultOption
  include ::AWS::Core::OptionGrammar::Descriptors::String
  def context_description(context); end

  def extend_with_config(*descriptors); end

  def format_error(expected, context=T.unsafe(nil)); end

  def hash_format(value); end

  def initialize(name); end

  def name(); end

  def prefixed_name(prefix); end

  def request_params(value, prefix=T.unsafe(nil)); end

  def required?(); end

  def ruby_name(); end
end

class AWS::Core::OptionGrammar::DefaultOption
end

module AWS::Core::OptionGrammar::Descriptors
end

module AWS::Core::OptionGrammar::Descriptors::Bigdecimal
  def hash_format(value); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::Bigdecimal
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
end

module AWS::Core::OptionGrammar::Descriptors::Blob
  def encode_value(value); end

  def hash_format(value); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::Blob
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
end

module AWS::Core::OptionGrammar::Descriptors::Boolean
  def encode_value(value); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::Boolean
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
end

AWS::Core::OptionGrammar::Descriptors::Double = AWS::Core::OptionGrammar::Descriptors::Float

module AWS::Core::OptionGrammar::Descriptors::Float
  def encode_value(value); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::Float
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
end

module AWS::Core::OptionGrammar::Descriptors::Integer
  def encode_value(value); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::Integer
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
end

module AWS::Core::OptionGrammar::Descriptors::List
  include ::AWS::Core::OptionGrammar::Descriptors::ListMethods::InstanceMethods
end

module AWS::Core::OptionGrammar::Descriptors::List
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
  extend ::AWS::Core::OptionGrammar::Descriptors::ListMethods::ClassMethods
end

class AWS::Core::OptionGrammar::Descriptors::ListMember
  def initialize(options=T.unsafe(nil)); end
end

class AWS::Core::OptionGrammar::Descriptors::ListMember
end

module AWS::Core::OptionGrammar::Descriptors::ListMethods
end

module AWS::Core::OptionGrammar::Descriptors::ListMethods::ClassMethods
  def apply(option, member_descriptors); end
end

module AWS::Core::OptionGrammar::Descriptors::ListMethods::ClassMethods
end

module AWS::Core::OptionGrammar::Descriptors::ListMethods::InstanceMethods
  def hash_format(value); end

  def join(); end

  def request_params(value, prefix=T.unsafe(nil)); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::ListMethods::InstanceMethods
end

module AWS::Core::OptionGrammar::Descriptors::ListMethods
end

AWS::Core::OptionGrammar::Descriptors::Long = AWS::Core::OptionGrammar::Descriptors::Integer

module AWS::Core::OptionGrammar::Descriptors::Map
  def hash_format(value); end

  def key_option(options); end

  def request_params(values, prefix=T.unsafe(nil)); end

  def validate(value, context=T.unsafe(nil)); end

  def value_option(options); end
end

module AWS::Core::OptionGrammar::Descriptors::Map
  def self.apply(option, members=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::MemberedList
  include ::AWS::Core::OptionGrammar::Descriptors::ListMethods::InstanceMethods
  def join(); end
end

module AWS::Core::OptionGrammar::Descriptors::MemberedList
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
  extend ::AWS::Core::OptionGrammar::Descriptors::ListMethods::ClassMethods
end

module AWS::Core::OptionGrammar::Descriptors::NoArgs
  def apply(option); end
end

module AWS::Core::OptionGrammar::Descriptors::NoArgs
end

module AWS::Core::OptionGrammar::Descriptors::Pattern
end

module AWS::Core::OptionGrammar::Descriptors::Pattern
  def self.apply(*args); end
end

module AWS::Core::OptionGrammar::Descriptors::Position
end

module AWS::Core::OptionGrammar::Descriptors::Position
  def self.apply(*args); end
end

module AWS::Core::OptionGrammar::Descriptors::Rename
end

module AWS::Core::OptionGrammar::Descriptors::Rename
  def self.apply(option, new_name); end
end

module AWS::Core::OptionGrammar::Descriptors::Required
  def required?(); end
end

module AWS::Core::OptionGrammar::Descriptors::Required
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
end

module AWS::Core::OptionGrammar::Descriptors::String
  def encode_value(value); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::String
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
end

module AWS::Core::OptionGrammar::Descriptors::Structure
  def hash_format(hash); end

  def request_params(values, prefix=T.unsafe(nil)); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::Structure
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
  def self.apply(option, members); end
end

module AWS::Core::OptionGrammar::Descriptors::Timestamp
  def encode_value(value); end

  def validate(value, context=T.unsafe(nil)); end
end

module AWS::Core::OptionGrammar::Descriptors::Timestamp
  extend ::AWS::Core::OptionGrammar::Descriptors::NoArgs
end

module AWS::Core::OptionGrammar::Descriptors
end

class AWS::Core::OptionGrammar::FormatError
  def context_description(); end

  def context_description=(context_description); end

  def expectation(); end

  def expectation=(expectation); end

  def initialize(expectation, context); end
end

class AWS::Core::OptionGrammar::FormatError
end

class AWS::Core::OptionGrammar::MapOption
  def param_name(); end

  def param_name=(name); end
end

class AWS::Core::OptionGrammar::MapOption
end

module AWS::Core::OptionGrammar::ModuleMethods
  include ::AWS::Core::Inflection
  def apply_integer_descriptor(m, name); end

  def apply_list_descriptor(m, name, arg); end

  def apply_rename_descriptor(m, name, new_name); end

  def apply_required_descriptor(m, name); end

  def apply_string_descriptor(m, name); end

  def customize(config=T.unsafe(nil)); end

  def included(m); end

  def option(name); end

  def parse_option(option); end

  def request_params(options); end

  def supported_options(); end

  def to_h(options); end

  def to_json(options); end

  def validate(options); end
end

module AWS::Core::OptionGrammar::ModuleMethods
end

class AWS::Core::OptionGrammar
  extend ::AWS::Core::OptionGrammar::ModuleMethods
  extend ::AWS::Core::Inflection
end

module AWS::Core::Options
end

class AWS::Core::Options::JSONSerializer
  def initialize(rules, payload_param); end

  def namespace(); end

  def normalize_keys(values, rules); end

  def normalize_value(value, rules); end

  def operation_name(); end

  def rules(); end

  def serialize(request_options); end
end

class AWS::Core::Options::JSONSerializer
end

class AWS::Core::Options::Validator
  def format_error(description, opt_name, context); end

  def initialize(rules); end

  def rules(); end

  def validate!(request_options, rules=T.unsafe(nil)); end

  def validate_array(rules, value, opt_name, context=T.unsafe(nil)); end

  def validate_blob(rules, value, opt_name, context=T.unsafe(nil)); end

  def validate_boolean(rules, value, opt_name, context=T.unsafe(nil)); end

  def validate_hash(rules, value, opt_name, context=T.unsafe(nil)); end

  def validate_integer(rules, value, opt_name, context=T.unsafe(nil)); end

  def validate_map(rules, value, opt_name, context=T.unsafe(nil)); end

  def validate_string(rules, value, opt_name, context=T.unsafe(nil)); end

  def validate_timestamp(rules, value, opt_name, context=T.unsafe(nil)); end

  def validate_value(*args); end
end

class AWS::Core::Options::Validator
end

class AWS::Core::Options::XMLSerializer
  def hash_members_xml(hash, rules, builder); end

  def http(); end

  def initialize(namespace, operation_name, operation); end

  def namespace(); end

  def operation_name(); end

  def rules(); end

  def serialize(request_options); end

  def to_xml(builder, opt_name, rules, value); end

  def validator(); end

  def xml_ordered_members(members); end
end

class AWS::Core::Options::XMLSerializer
end

module AWS::Core::Options
end

class AWS::Core::PageResult
  def collection(); end

  def initialize(collection, items, per_page, next_token); end

  def last_page?(); end

  def more?(); end

  def next_page(); end

  def next_token(); end

  def per_page(); end
end

class AWS::Core::PageResult
end

class AWS::Core::Policy
  def ==(other); end

  def allow(opts=T.unsafe(nil)); end

  def deny(opts=T.unsafe(nil)); end

  def eql?(other); end

  def hash_without_ids(); end

  def id(); end

  def initialize(opts=T.unsafe(nil)); end

  def statements(); end

  def to_h(); end

  def to_json(); end

  def version(); end
end

class AWS::Core::Policy::ConditionBlock
  def [](*args); end

  def add(operator, key, *values); end

  def base_translate(example, base_operator, *modifiers); end

  def convert_value(value); end

  def filter_conditions(conditions=T.unsafe(nil)); end

  def initialize(conditions=T.unsafe(nil)); end

  def keys(); end

  def match_key(filter, key, value=T.unsafe(nil)); end

  def match_operator(filter, op, value); end

  def match_triple(filter, type, op, key, value); end

  def operators(); end

  def strip_modifiers(operator); end

  def to_h(); end

  def translate_greater_than(example, opts); end

  def translate_gt(example, opts); end

  def translate_gte(example, opts); end

  def translate_is(example, opts); end

  def translate_is_arn(example, opts); end

  def translate_is_arn_like(example, opts); end

  def translate_is_ip_address(example, opts); end

  def translate_key(key); end

  def translate_less_than(example, opts); end

  def translate_like(example, opts); end

  def translate_lt(example, opts); end

  def translate_lte(example, opts); end

  def translate_not(example, opts); end

  def translate_not_arn(example, opts); end

  def translate_not_arn_like(example, opts); end

  def translate_not_ip_address(example, opts); end

  def translate_not_like(example, opts); end

  def translate_operator(operator, example_value); end

  def type_notation(example); end

  def valid_operator?(operator); end

  def values(); end
  MODIFIERS = ::T.let(nil, ::T.untyped)
end

class AWS::Core::Policy::ConditionBlock
end

class AWS::Core::Policy::ConditionBuilder
  def conditions(); end

  def initialize(conditions); end

  def where(key, operator=T.unsafe(nil), *values); end
end

class AWS::Core::Policy::ConditionBuilder
end

class AWS::Core::Policy::OperatorBuilder
  def initialize(condition_builder, key); end

  def method_missing(m, *values); end
end

class AWS::Core::Policy::OperatorBuilder
end

class AWS::Core::Policy::Statement
  def actions(); end

  def actions=(actions); end

  def coerce_array_option(attr, value); end

  def conditions(); end

  def conditions=(conditions); end

  def effect(); end

  def effect=(effect); end

  def exclude_action(*actions); end

  def exclude_actions(*actions); end

  def excluded_actions(); end

  def excluded_actions=(excluded_actions); end

  def excluded_resource_arn(excluded_resource); end

  def excluded_resource_arns(); end

  def excluded_resources(); end

  def excluded_resources=(excluded_resources); end

  def include_action(*actions); end

  def include_actions(*actions); end

  def initialize(opts=T.unsafe(nil)); end

  def parse_action_option(value); end

  def parse_condition_option(value); end

  def parse_effect_option(value); end

  def parse_excluded_action_option(value); end

  def parse_excluded_resource_option(value); end

  def parse_not_action_option(value); end

  def parse_not_resource_option(value); end

  def parse_options(options); end

  def parse_principal_option(value); end

  def parse_resource_option(value); end

  def parse_sid_option(value); end

  def principals(); end

  def principals=(principals); end

  def principals_hash(); end

  def resource_arn(resource); end

  def resource_arns(); end

  def resources(); end

  def resources=(resources); end

  def sid(); end

  def sid=(sid); end

  def to_h(); end

  def translate_action(action); end

  def translated_actions(); end

  def translated_excluded_actions(); end
end

class AWS::Core::Policy::Statement
end

class AWS::Core::Policy
  def self.from_json(json); end
end

class AWS::Core::QueryClient
end

class AWS::Core::QueryClient
end

class AWS::Core::QueryRequestBuilder
  def initialize(api_version, operation); end

  def populate_request(request, options); end
end

class AWS::Core::QueryRequestBuilder
end

class AWS::Core::QueryResponseParser
  def extract_data(response); end

  def initialize(parsing_rules); end

  def simulate(); end
end

class AWS::Core::QueryResponseParser
end

AWS::Core::RESTClient = AWS::Core::RESTXMLClient

class AWS::Core::RESTJSONClient
end

class AWS::Core::RESTJSONClient
end

class AWS::Core::RESTRequestBuilder
  def initialize(operation, options=T.unsafe(nil)); end

  def populate_request(request, params); end
end

class AWS::Core::RESTRequestBuilder
end

class AWS::Core::RESTResponseParser
  def extract_data(response); end

  def initialize(operation, options); end

  def simulate(); end
end

class AWS::Core::RESTResponseParser
end

class AWS::Core::RESTXMLClient
end

class AWS::Core::RESTXMLClient
end

class AWS::Core::Region
  def auto_scaling(); end

  def cloud_formation(); end

  def cloud_front(); end

  def cloud_search(); end

  def cloud_trail(); end

  def cloud_watch(); end

  def config(); end

  def data_pipeline(); end

  def direct_connect(); end

  def dynamo_db(); end

  def ec2(); end

  def elastic_beanstalk(); end

  def elastic_transcoder(); end

  def elasticache(); end

  def elb(); end

  def emr(); end

  def glacier(); end

  def iam(); end

  def import_export(); end

  def initialize(name, options=T.unsafe(nil)); end

  def kinesis(); end

  def name(); end

  def ops_works(); end

  def rds(); end

  def redshift(); end

  def route_53(); end

  def s3(); end

  def ses(); end

  def simple_db(); end

  def simple_email_service(); end

  def simple_workflow(); end

  def sns(); end

  def sqs(); end

  def storage_gateway(); end

  def sts(); end

  def support(); end

  def swf(); end
end

class AWS::Core::Region
end

class AWS::Core::RegionCollection
  include ::Enumerable
  def [](name); end

  def config(); end

  def each(&block); end

  def initialize(options=T.unsafe(nil)); end
end

class AWS::Core::RegionCollection
end

class AWS::Core::Resource
  include ::AWS::Core::Model
  include ::AWS::Core::Cacheable
  def ==(other); end

  def attributes_from_response(resp); end

  def cache_static_attributes(request_type, resp_obj); end

  def eql?(other); end

  def get_resource(attr_name); end

  def resource_identifiers(); end

  def resource_options(additional=T.unsafe(nil)); end

  def ruby_name(); end

  def static_attributes(); end

  def update_resource(attr, value); end
end

class AWS::Core::Resource
  extend ::AWS::Core::Naming
  def self.attribute(name, options=T.unsafe(nil), &block); end

  def self.attribute_providers(); end

  def self.attribute_providers_for(request_type); end

  def self.attributes(); end

  def self.define_attribute_getter(attribute); end

  def self.define_attribute_setter(attribute); end

  def self.define_attribute_type(type_name); end

  def self.mutable_attribute(name, options=T.unsafe(nil), &block); end

  def self.new_from(request_type, resp_obj, *args); end

  def self.populates_from(*request_types, &block); end

  def self.provider(*request_types, &block); end
end

class AWS::Core::ResourceCache
  def cached?(key, attribute); end

  def get(key, attribute); end

  def store(key, attributes); end
end

class AWS::Core::ResourceCache
end

class AWS::Core::Response
  include ::AWS::Core::AsyncHandle
  def [](key); end

  def api_version(); end

  def api_version=(api_version); end

  def build_request(); end

  def cache_key(); end

  def cached(); end

  def cached=(cached); end

  def cached?(); end

  def config(); end

  def config=(config); end

  def data(); end

  def data=(data); end

  def duration(); end

  def duration=(duration); end

  def error(); end

  def error=(error); end

  def http_request(); end

  def http_request=(http_request); end

  def http_response(); end

  def http_response=(http_response); end

  def initialize(http_request=T.unsafe(nil), http_response=T.unsafe(nil), &block); end

  def method_missing(*args, &block); end

  def network_error?(); end

  def rebuild_request(); end

  def request_options(); end

  def request_options=(request_options); end

  def request_type(); end

  def request_type=(request_type); end

  def retry_count(); end

  def retry_count=(retry_count); end

  def safe_to_retry?(); end

  def serialize_options_array(array); end

  def serialize_options_hash(hash); end

  def serialize_options_value(value); end

  def serialized_options(); end

  def successful?(); end
end

class AWS::Core::Response
end

class AWS::Core::ResponseCache
  def add(resp); end

  def cached(resp); end

  def cached_responses(); end

  def resource_cache(); end

  def select(*types, &block); end
end

class AWS::Core::ResponseCache
end

module AWS::Core::ServiceInterface
  def initialize(options=T.unsafe(nil)); end

  def inspect(); end
end

module AWS::Core::ServiceInterface
  def self.included(base); end
end

module AWS::Core::Signers
end

module AWS::Core::Signers::Base
end

module AWS::Core::Signers::Base
  def self.hmac(key, value, digest=T.unsafe(nil)); end

  def self.sign(secret, string_to_sign, digest_method=T.unsafe(nil)); end
end

class AWS::Core::Signers::CloudFront
  include ::AWS::Core::Signers::Base
  def credentials(); end

  def initialize(credentials); end

  def sign_request(req); end
end

class AWS::Core::Signers::CloudFront
end

class AWS::Core::Signers::S3
  def credentials(); end

  def initialize(credentials); end

  def sign_request(req); end
  QUERY_PARAMS = ::T.let(nil, ::T.untyped)
  SUB_RESOURCES = ::T.let(nil, ::T.untyped)
end

class AWS::Core::Signers::S3
  def self.canonicalized_headers(req); end

  def self.canonicalized_resource(req); end

  def self.query_parameters_for_signature(req); end

  def self.signing_string_date(req); end

  def self.string_to_sign(req); end

  def self.sub_resource_params(req); end
end

class AWS::Core::Signers::Version2
  include ::AWS::Core::Signers::Base
  def credentials(); end

  def initialize(credentials); end

  def sign_request(req); end
end

class AWS::Core::Signers::Version2
end

class AWS::Core::Signers::Version3
  include ::AWS::Core::Signers::Base
  def credentials(); end

  def initialize(credentials); end

  def sign_request(req); end
end

class AWS::Core::Signers::Version3
end

class AWS::Core::Signers::Version3Https
  include ::AWS::Core::Signers::Base
  def credentials(); end

  def initialize(credentials); end

  def sign_request(req); end
end

class AWS::Core::Signers::Version3Https
end

class AWS::Core::Signers::Version4
  def credential(datetime); end

  def credentials(); end

  def derive_key(datetime); end

  def initialize(credentials, service_name, region); end

  def region(); end

  def service_name(); end

  def sign_request(req, options=T.unsafe(nil)); end

  def signature(request, key, datetime, content_sha256); end
  EMPTY_DIGEST = ::T.let(nil, ::T.untyped)
  STREAMING_CHECKSUM = ::T.let(nil, ::T.untyped)
end

class AWS::Core::Signers::Version4::ChunkSignedStream
  def initialize(stream, stream_size, key, key_path, datetime, signature); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end
  CHUNK_SIGNATURE_HEADER = ::T.let(nil, ::T.untyped)
  CHUNK_STRING_TO_SIGN_PREFIX = ::T.let(nil, ::T.untyped)
  CLRF = ::T.let(nil, ::T.untyped)
  DEFAULT_CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  MAX_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  SIGNATURE_LENGTH = ::T.let(nil, ::T.untyped)
end

class AWS::Core::Signers::Version4::ChunkSignedStream
  def self.signed_size(size); end
end

class AWS::Core::Signers::Version4
end

module AWS::Core::Signers
end

module AWS::Core::UriEscape
end

module AWS::Core::UriEscape
  def self.escape(value); end

  def self.escape_path(value); end
end

module AWS::Core::XML
end

class AWS::Core::XML::Frame
  def add_text(chars); end

  def build_child_frame(element_name); end

  def close(); end

  def consume_child_frame(child_frame); end

  def data(); end

  def data_context_for(child_frame); end

  def datetime_like_value(klass, parts_constructor); end

  def element_name(); end

  def forced?(); end

  def ignored?(); end

  def index_keys_for(index_opts, &block); end

  def initialize(root_frame, parent_frame, element_name, rules); end

  def keys_from_path(data, path, &block); end

  def known_child_frames(); end

  def list?(); end

  def map?(); end

  def map_key(); end

  def map_value(); end

  def parent_frame(); end

  def root_frame(); end

  def ruby_name(); end

  def rules(); end

  def rules_for(child_element_name); end

  def value(); end

  def wrapped?(); end

  def wrapper(); end
  DATE_PUNCTUATION = ::T.let(nil, ::T.untyped)
  EASY_FORMAT = ::T.let(nil, ::T.untyped)
  TRANSLATE_DIGITS = ::T.let(nil, ::T.untyped)
end

class AWS::Core::XML::Frame
end

module AWS::Core::XML::FrameStack
  def attributes(attributes); end

  def end_element(*ignored); end

  def initialize(rules); end

  def parse(xml); end

  def sax_parse(xml); end

  def set_text(text); end

  def start_element(element_name, attributes=T.unsafe(nil)); end
end

module AWS::Core::XML::FrameStack
end

class AWS::Core::XML::Grammar
  def ==(other); end

  def apply_customizations(customizations); end

  def blob(); end

  def blob_value(); end

  def boolean(); end

  def boolean_value(); end

  def collect_values(); end

  def construct_value(&block); end

  def context_for_child(child_element_name); end

  def customize(customizations=T.unsafe(nil), &block); end

  def customize!(customizations=T.unsafe(nil), &block); end

  def datetime(); end

  def datetime_value(); end

  def default_value(name, value); end

  def element(element_name, &block); end

  def enum(*args); end

  def eql?(other); end

  def float(); end

  def float_value(); end

  def force(); end

  def http_header(*args); end

  def http_payload(*args); end

  def http_status(*args); end

  def http_trait(*args); end

  def http_uri_label(*args); end

  def ignore(); end

  def index(index_name, options=T.unsafe(nil)); end

  def inflect(value); end

  def initialize(rules=T.unsafe(nil), options=T.unsafe(nil)); end

  def integer(); end

  def integer_value(); end

  def list(child_element_name=T.unsafe(nil), &block); end

  def long(); end

  def map(map_element_name, key_element_name, value_element_name); end

  def map_entry(key_element_name, value_element_name); end

  def parse(xml); end

  def parse_customization_item(item); end

  def position(*args); end

  def rename(new_name); end

  def rules(); end

  def string(); end

  def string_value(); end

  def symbol(); end

  def symbol_value(); end

  def time(); end

  def time_value(); end

  def timestamp(); end

  def validate_args(identifier, args); end

  def validate_config_method(method); end

  def wrapper(method_name, options=T.unsafe(nil), &block); end
end

class AWS::Core::XML::Grammar
  def self.customize(customizations=T.unsafe(nil), rules=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def self.deep_copy(rules); end

  def self.parse(xml); end
end

class AWS::Core::XML::Parser
  def initialize(rules=T.unsafe(nil)); end

  def parse(xml); end

  def rules(); end

  def sax_handler(); end

  def simulate(); end
end

class AWS::Core::XML::Parser
  def self.parse(xml, rules=T.unsafe(nil)); end
end

class AWS::Core::XML::RootFrame
  def add_to_index(index_name, key, value); end

  def inflect(element_name); end

  def initialize(rules); end

  def setup_indexes(rules); end
end

class AWS::Core::XML::RootFrame
end

module AWS::Core::XML::SaxHandlers
end

class AWS::Core::XML::SaxHandlers::Nokogiri
  include ::AWS::Core::XML::FrameStack
  def characters(chars); end

  def comment(*args); end

  def end_document(); end

  def end_element_namespace(*ignore); end

  def error(*args); end

  def start_document(); end

  def start_element_namespace(element_name, attributes=T.unsafe(nil), *ignore); end

  def xmldecl(*args); end
end

class AWS::Core::XML::SaxHandlers::Nokogiri
end

class AWS::Core::XML::SaxHandlers::REXML
  include ::AWS::Core::XML::FrameStack
  include ::REXML::StreamListener
  def text(chars); end
end

class AWS::Core::XML::SaxHandlers::REXML
end

module AWS::Core::XML::SaxHandlers
end

class AWS::Core::XML::Stub
  def apply_empty_indexes(rules, data); end

  def initialize(rules); end

  def rules(); end

  def simulate(); end

  def stub_data_for(rules, data=T.unsafe(nil)); end
end

class AWS::Core::XML::Stub
  def self.simulate(rules); end
end

module AWS::Core::XML
end

module AWS::Core
end

class AWS::DataPipeline
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::DataPipeline::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::DataPipeline::Client::V20121029
  def activate_pipeline(*args, &block); end

  def create_pipeline(*args, &block); end

  def delete_pipeline(*args, &block); end

  def describe_objects(*args, &block); end

  def describe_pipelines(*args, &block); end

  def evaluate_expression(*args, &block); end

  def get_pipeline_definition(*args, &block); end

  def list_pipelines(*args, &block); end

  def poll_for_task(*args, &block); end

  def put_pipeline_definition(*args, &block); end

  def query_objects(*args, &block); end

  def report_task_progress(*args, &block); end

  def report_task_runner_heartbeat(*args, &block); end

  def set_status(*args, &block); end

  def set_task_status(*args, &block); end

  def validate_pipeline_definition(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::DataPipeline::Client::V20121029
end

class AWS::DataPipeline::Client
end

module AWS::DataPipeline::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::DataPipeline::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::DataPipeline
end

class AWS::DirectConnect
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::DirectConnect::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::DirectConnect::Client::V20121025
  def allocate_connection_on_interconnect(*args, &block); end

  def allocate_private_virtual_interface(*args, &block); end

  def allocate_public_virtual_interface(*args, &block); end

  def confirm_connection(*args, &block); end

  def confirm_private_virtual_interface(*args, &block); end

  def confirm_public_virtual_interface(*args, &block); end

  def create_connection(*args, &block); end

  def create_interconnect(*args, &block); end

  def create_private_virtual_interface(*args, &block); end

  def create_public_virtual_interface(*args, &block); end

  def delete_connection(*args, &block); end

  def delete_interconnect(*args, &block); end

  def delete_virtual_interface(*args, &block); end

  def describe_connections(*args, &block); end

  def describe_connections_on_interconnect(*args, &block); end

  def describe_interconnects(*args, &block); end

  def describe_locations(*args, &block); end

  def describe_virtual_gateways(*args, &block); end

  def describe_virtual_interfaces(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::DirectConnect::Client::V20121025
end

class AWS::DirectConnect::Client
end

module AWS::DirectConnect::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::DirectConnect::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::DirectConnect
end

class AWS::DynamoDB
  include ::AWS::Core::ServiceInterface
  def batch_get(&block); end

  def batch_write(&block); end

  def client(); end

  def config(); end

  def tables(); end
  IGNORING_API_SPECIFIED_MSG = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::AttributeCollection
  include ::AWS::Core::Model
  include ::Enumerable
  include ::AWS::DynamoDB::Keys
  include ::AWS::DynamoDB::Types
  include ::AWS::DynamoDB::Expectations
  def [](attribute); end

  def []=(attribute, value); end

  def add(attributes, options=T.unsafe(nil)); end

  def delete(*args); end

  def each(options=T.unsafe(nil), &block); end

  def each_key(options=T.unsafe(nil)); end

  def each_value(options=T.unsafe(nil)); end

  def initialize(item, opts=T.unsafe(nil)); end

  def item(); end

  def merge!(attributes, options=T.unsafe(nil)); end

  def put(attributes, options=T.unsafe(nil)); end

  def set(attributes, options=T.unsafe(nil)); end

  def to_h(options=T.unsafe(nil)); end

  def to_hash(options=T.unsafe(nil)); end

  def update(options=T.unsafe(nil)); end

  def values_at(*attributes); end
end

class AWS::DynamoDB::AttributeCollection::UpdateBuilder
  include ::AWS::DynamoDB::Types
  def add(attributes); end

  def delete(*args); end

  def merge!(attributes); end

  def put(attributes); end

  def set(attributes); end

  def updates(); end
end

class AWS::DynamoDB::AttributeCollection::UpdateBuilder
end

class AWS::DynamoDB::AttributeCollection
end

class AWS::DynamoDB::BatchGet
  include ::AWS::DynamoDB::Keys
  include ::AWS::DynamoDB::Types
  include ::Enumerable
  include ::AWS::Core::Model
  def convert_unprocessed_keys(response); end

  def each(&block); end

  def each_attributes(); end

  def initialize(options=T.unsafe(nil)); end

  def items(attributes, *items); end

  def table(table, attributes, items, options=T.unsafe(nil)); end
end

class AWS::DynamoDB::BatchGet
end

class AWS::DynamoDB::BatchWrite
  include ::AWS::DynamoDB::Types
  include ::AWS::Core::Model
  def convert_delete_item(item); end

  def convert_put_item(item); end

  def convert_unprocessed_items(items); end

  def delete(table, items); end

  def format_delete(keys); end

  def format_put(attributes); end

  def initialize(options=T.unsafe(nil)); end

  def process!(); end

  def put(table, items); end

  def str2sym(key_desc); end

  def table_items(table); end

  def table_name(table); end

  def write(table, options=T.unsafe(nil)); end
end

class AWS::DynamoDB::BatchWrite
end

class AWS::DynamoDB::Binary
end

class AWS::DynamoDB::Binary
end

class AWS::DynamoDB::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
  REGION_US_E1 = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::Client::V20111205
  def batch_get_item(*args, &block); end

  def batch_write_item(*args, &block); end

  def create_table(*args, &block); end

  def delete_item(*args, &block); end

  def delete_table(*args, &block); end

  def describe_table(*args, &block); end

  def get_item(*args, &block); end

  def list_tables(*args, &block); end

  def put_item(*args, &block); end

  def query(*args, &block); end

  def scan(*args, &block); end

  def update_item(*args, &block); end

  def update_table(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::Client::V20111205
end

class AWS::DynamoDB::Client::V20120810
  def batch_get_item(*args, &block); end

  def batch_write_item(*args, &block); end

  def create_table(*args, &block); end

  def delete_item(*args, &block); end

  def delete_table(*args, &block); end

  def describe_table(*args, &block); end

  def get_item(*args, &block); end

  def list_tables(*args, &block); end

  def put_item(*args, &block); end

  def query(*args, &block); end

  def scan(*args, &block); end

  def update_item(*args, &block); end

  def update_table(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::Client::V20120810
end

class AWS::DynamoDB::Client
end

class AWS::DynamoDB::ClientV2
  DEPRECATION_MSG = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::ClientV2
  def self.deprecated_new(options=T.unsafe(nil)); end

  def self.new(*args, &block); end
end

module AWS::DynamoDB::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::Errors::InternalServerError
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::Errors::InternalServerError
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::DynamoDB::Errors::ProvisionedThroughputExceededException
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::Errors::ProvisionedThroughputExceededException
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::DynamoDB::Errors::ResourceInUseException
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::Errors::ResourceInUseException
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::DynamoDB::Errors::ResourceNotFoundException
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::Errors::ResourceNotFoundException
  extend ::AWS::Core::LazyErrorClasses
end

module AWS::DynamoDB::Errors
  extend ::AWS::Core::LazyErrorClasses
end

module AWS::DynamoDB::Expectations
end

module AWS::DynamoDB::Expectations
end

class AWS::DynamoDB::Item
  include ::AWS::DynamoDB::Keys
  include ::AWS::DynamoDB::Types
  include ::AWS::DynamoDB::Expectations
  def attributes(); end

  def delete(options=T.unsafe(nil)); end

  def exists?(options=T.unsafe(nil)); end

  def hash_value(); end

  def initialize(table, *args); end

  def range_value(); end

  def table(); end
end

class AWS::DynamoDB::Item
  extend ::AWS::DynamoDB::Types
  def self.new_from(op, response_object, table, *args); end
end

class AWS::DynamoDB::ItemCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  include ::AWS::DynamoDB::Types
  include ::AWS::DynamoDB::Expectations
  def [](hash_value, range_value=T.unsafe(nil)); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def _yield_items(mode, response, &block); end

  def and(filter); end

  def at(hash_value, range_value=T.unsafe(nil)); end

  def count(options=T.unsafe(nil)); end

  def create(attributes, options=T.unsafe(nil)); end

  def initialize(table, opts=T.unsafe(nil)); end

  def put(attributes, options=T.unsafe(nil)); end

  def query(options=T.unsafe(nil), &block); end

  def refine(opts); end

  def request_includes_key?(options); end

  def scan_filters(); end

  def select(*attributes, &block); end

  def table(); end

  def where(filter); end

  def with_filter(attribute, op, *values); end
  RANGE_KEY_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::ItemCollection::FilterBuilder
  include ::AWS::DynamoDB::Types
  def attribute(); end

  def begins_with(value); end

  def between(min, max); end

  def contains(value); end

  def does_not_contain(value); end

  def equals(value); end

  def greater_than(value); end

  def gte(value); end

  def in(*values); end

  def initialize(items, attribute); end

  def is_null(); end

  def items(); end

  def less_than(value); end

  def lte(value); end

  def not_equal_to(value); end

  def not_null(); end
end

class AWS::DynamoDB::ItemCollection::FilterBuilder
end

class AWS::DynamoDB::ItemCollection
end

class AWS::DynamoDB::ItemData
  def attributes(); end

  def initialize(opts=T.unsafe(nil)); end

  def item(); end
end

class AWS::DynamoDB::ItemData
end

module AWS::DynamoDB::Keys
  include ::AWS::DynamoDB::Types
  def item_key_hash(item); end

  def item_key_options(item, extra=T.unsafe(nil)); end
end

module AWS::DynamoDB::Keys
end

class AWS::DynamoDB::PrimaryKeyElement
  def initialize(hash); end

  def name(); end

  def type(); end
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
end

class AWS::DynamoDB::PrimaryKeyElement
  def self.from_description(description); end
end

class AWS::DynamoDB::Resource
end

class AWS::DynamoDB::Resource
  def self.attribute(name, options=T.unsafe(nil)); end
end

class AWS::DynamoDB::Table
  def _find_in_create_table_or_delete_table_response_1(resp); end

  def _find_in_describe_table_response_0(resp); end

  def assert_schema!(); end

  def batch_delete(items); end

  def batch_get(attributes, items, options=T.unsafe(nil), &block); end

  def batch_put(items); end

  def batch_write(options=T.unsafe(nil)); end

  def composite_key?(); end

  def created_at(); end

  def creation_date_time(); end

  def delete(); end

  def exists?(); end

  def get_resource(attribute_name=T.unsafe(nil)); end

  def has_range_key?(); end

  def hash_key(); end

  def hash_key=(description); end

  def initialize(name, options=T.unsafe(nil)); end

  def item_count(); end

  def items(); end

  def load_schema(); end

  def name(); end

  def provision_throughput(options=T.unsafe(nil)); end

  def range_key(); end

  def range_key=(description); end

  def range_key_without_schema_override(); end

  def read_capacity_units(); end

  def read_capacity_units=(read_capacity_units); end

  def schema_loaded?(); end

  def simple_key?(); end

  def size_bytes(); end

  def status(); end

  def throughput_last_decreased_at(); end

  def throughput_last_increased_at(); end

  def write_capacity_units(); end

  def write_capacity_units=(write_capacity_units); end
end

class AWS::DynamoDB::Table
end

class AWS::DynamoDB::TableCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def create(name, read_capacity_units, write_capacity_units, options=T.unsafe(nil)); end
end

class AWS::DynamoDB::TableCollection
end

module AWS::DynamoDB::Types
  def cast_binary(data); end

  def cast_number(number, options=T.unsafe(nil)); end

  def format_attribute_value(value, context=T.unsafe(nil)); end

  def raise_error(msg, context); end

  def type_indicator(value, context); end

  def value_from_response(hash, options=T.unsafe(nil)); end

  def values_from_response_hash(hash, options=T.unsafe(nil)); end
end

module AWS::DynamoDB::Types
end

class AWS::DynamoDB
end

class AWS::EC2
  include ::AWS::Core::ServiceInterface
  def availability_zones(); end

  def client(); end

  def config(); end

  def customer_gateways(); end

  def dhcp_options(); end

  def elastic_ips(); end

  def export_tasks(); end

  def images(); end

  def instances(); end

  def internet_gateways(); end

  def key_pairs(); end

  def network_acls(); end

  def network_interfaces(); end

  def regions(); end

  def reserved_instances(); end

  def reserved_instances_offerings(); end

  def route_tables(); end

  def security_groups(); end

  def snapshots(); end

  def subnets(); end

  def tags(); end

  def volumes(); end

  def vpcs(); end

  def vpn_connections(); end

  def vpn_gateways(); end
end

class AWS::EC2::Attachment
  def _find_in_attach_volume_or_detach_volume_response_1(resp); end

  def _find_in_describe_volumes_response_0(resp); end

  def attach_time(); end

  def delete(options=T.unsafe(nil)); end

  def delete_on_termination(); end

  def device(); end

  def exists?(); end

  def initialize(volume, instance, device, options=T.unsafe(nil)); end

  def instance(); end

  def status(); end

  def volume(); end
end

class AWS::EC2::Attachment
end

class AWS::EC2::AttachmentCollection
  include ::AWS::Core::Model
  include ::Enumerable
  def each(&block); end

  def initialize(volume, options=T.unsafe(nil)); end

  def volume(); end
end

class AWS::EC2::AttachmentCollection
end

class AWS::EC2::AvailabilityZone
  def _find_in_describe_availability_zones_response_0(resp); end

  def initialize(name, options=T.unsafe(nil)); end

  def messages(); end

  def name(); end

  def region(); end

  def region_name(); end

  def state(); end

  def to_str(); end
end

class AWS::EC2::AvailabilityZone
end

class AWS::EC2::AvailabilityZoneCollection
  def each(&block); end
end

class AWS::EC2::AvailabilityZoneCollection
end

module AWS::EC2::BlockDeviceMappings
end

module AWS::EC2::BlockDeviceMappings
end

class AWS::EC2::Client
  def v2_signer(); end

  def v4_signer(); end
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Client::V20130815
  def activate_license(*args, &block); end

  def allocate_address(*args, &block); end

  def assign_private_ip_addresses(*args, &block); end

  def associate_address(*args, &block); end

  def associate_dhcp_options(*args, &block); end

  def associate_route_table(*args, &block); end

  def attach_internet_gateway(*args, &block); end

  def attach_network_interface(*args, &block); end

  def attach_volume(*args, &block); end

  def attach_vpn_gateway(*args, &block); end

  def authorize_security_group_egress(*args, &block); end

  def authorize_security_group_ingress(*args, &block); end

  def bundle_instance(*args, &block); end

  def cancel_bundle_task(*args, &block); end

  def cancel_conversion_task(*args, &block); end

  def cancel_export_task(*args, &block); end

  def cancel_reserved_instances_listing(*args, &block); end

  def cancel_spot_instance_requests(*args, &block); end

  def confirm_product_instance(*args, &block); end

  def copy_image(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_customer_gateway(*args, &block); end

  def create_dhcp_options(*args, &block); end

  def create_image(*args, &block); end

  def create_instance_export_task(*args, &block); end

  def create_internet_gateway(*args, &block); end

  def create_key_pair(*args, &block); end

  def create_network_acl(*args, &block); end

  def create_network_acl_entry(*args, &block); end

  def create_network_interface(*args, &block); end

  def create_placement_group(*args, &block); end

  def create_reserved_instances_listing(*args, &block); end

  def create_route(*args, &block); end

  def create_route_table(*args, &block); end

  def create_security_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_spot_datafeed_subscription(*args, &block); end

  def create_subnet(*args, &block); end

  def create_tags(*args, &block); end

  def create_volume(*args, &block); end

  def create_vpc(*args, &block); end

  def create_vpn_connection(*args, &block); end

  def create_vpn_connection_route(*args, &block); end

  def create_vpn_gateway(*args, &block); end

  def deactivate_license(*args, &block); end

  def delete_customer_gateway(*args, &block); end

  def delete_dhcp_options(*args, &block); end

  def delete_internet_gateway(*args, &block); end

  def delete_key_pair(*args, &block); end

  def delete_network_acl(*args, &block); end

  def delete_network_acl_entry(*args, &block); end

  def delete_network_interface(*args, &block); end

  def delete_placement_group(*args, &block); end

  def delete_route(*args, &block); end

  def delete_route_table(*args, &block); end

  def delete_security_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def delete_spot_datafeed_subscription(*args, &block); end

  def delete_subnet(*args, &block); end

  def delete_tags(*args, &block); end

  def delete_volume(*args, &block); end

  def delete_vpc(*args, &block); end

  def delete_vpn_connection(*args, &block); end

  def delete_vpn_connection_route(*args, &block); end

  def delete_vpn_gateway(*args, &block); end

  def deregister_image(*args, &block); end

  def describe_account_attributes(*args, &block); end

  def describe_addresses(*args, &block); end

  def describe_availability_zones(*args, &block); end

  def describe_bundle_tasks(*args, &block); end

  def describe_conversion_tasks(*args, &block); end

  def describe_customer_gateways(*args, &block); end

  def describe_dhcp_options(*args, &block); end

  def describe_export_tasks(*args, &block); end

  def describe_image_attribute(*args, &block); end

  def describe_images(*args, &block); end

  def describe_instance_attribute(*args, &block); end

  def describe_instance_status(*args, &block); end

  def describe_instances(*args, &block); end

  def describe_internet_gateways(*args, &block); end

  def describe_key_pairs(*args, &block); end

  def describe_licenses(*args, &block); end

  def describe_network_acls(*args, &block); end

  def describe_network_interface_attribute(*args, &block); end

  def describe_network_interfaces(*args, &block); end

  def describe_placement_groups(*args, &block); end

  def describe_regions(*args, &block); end

  def describe_reserved_instances(*args, &block); end

  def describe_reserved_instances_listings(*args, &block); end

  def describe_reserved_instances_modifications(*args, &block); end

  def describe_reserved_instances_offerings(*args, &block); end

  def describe_route_tables(*args, &block); end

  def describe_security_groups(*args, &block); end

  def describe_snapshot_attribute(*args, &block); end

  def describe_snapshots(*args, &block); end

  def describe_spot_datafeed_subscription(*args, &block); end

  def describe_spot_instance_requests(*args, &block); end

  def describe_spot_price_history(*args, &block); end

  def describe_subnets(*args, &block); end

  def describe_tags(*args, &block); end

  def describe_volume_attribute(*args, &block); end

  def describe_volume_status(*args, &block); end

  def describe_volumes(*args, &block); end

  def describe_vpc_attribute(*args, &block); end

  def describe_vpcs(*args, &block); end

  def describe_vpn_connections(*args, &block); end

  def describe_vpn_gateways(*args, &block); end

  def detach_internet_gateway(*args, &block); end

  def detach_network_interface(*args, &block); end

  def detach_volume(*args, &block); end

  def detach_vpn_gateway(*args, &block); end

  def disable_vgw_route_propagation(*args, &block); end

  def disassociate_address(*args, &block); end

  def disassociate_route_table(*args, &block); end

  def enable_vgw_route_propagation(*args, &block); end

  def enable_volume_io(*args, &block); end

  def get_console_output(*args, &block); end

  def get_password_data(*args, &block); end

  def import_instance(*args, &block); end

  def import_key_pair(*args, &block); end

  def import_volume(*args, &block); end

  def modify_image_attribute(*args, &block); end

  def modify_instance_attribute(*args, &block); end

  def modify_network_interface_attribute(*args, &block); end

  def modify_reserved_instances(*args, &block); end

  def modify_snapshot_attribute(*args, &block); end

  def modify_volume_attribute(*args, &block); end

  def modify_vpc_attribute(*args, &block); end

  def monitor_instances(*args, &block); end

  def purchase_reserved_instances_offering(*args, &block); end

  def reboot_instances(*args, &block); end

  def register_image(*args, &block); end

  def release_address(*args, &block); end

  def replace_network_acl_association(*args, &block); end

  def replace_network_acl_entry(*args, &block); end

  def replace_route(*args, &block); end

  def replace_route_table_association(*args, &block); end

  def report_instance_status(*args, &block); end

  def request_spot_instances(*args, &block); end

  def reset_image_attribute(*args, &block); end

  def reset_instance_attribute(*args, &block); end

  def reset_network_interface_attribute(*args, &block); end

  def reset_snapshot_attribute(*args, &block); end

  def revoke_security_group_egress(*args, &block); end

  def revoke_security_group_ingress(*args, &block); end

  def run_instances(*args, &block); end

  def start_instances(*args, &block); end

  def stop_instances(*args, &block); end

  def terminate_instances(*args, &block); end

  def unassign_private_ip_addresses(*args, &block); end

  def unmonitor_instances(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Client::V20130815
end

class AWS::EC2::Client::V20131001
  def activate_license(*args, &block); end

  def allocate_address(*args, &block); end

  def assign_private_ip_addresses(*args, &block); end

  def associate_address(*args, &block); end

  def associate_dhcp_options(*args, &block); end

  def associate_route_table(*args, &block); end

  def attach_internet_gateway(*args, &block); end

  def attach_network_interface(*args, &block); end

  def attach_volume(*args, &block); end

  def attach_vpn_gateway(*args, &block); end

  def authorize_security_group_egress(*args, &block); end

  def authorize_security_group_ingress(*args, &block); end

  def bundle_instance(*args, &block); end

  def cancel_bundle_task(*args, &block); end

  def cancel_conversion_task(*args, &block); end

  def cancel_export_task(*args, &block); end

  def cancel_reserved_instances_listing(*args, &block); end

  def cancel_spot_instance_requests(*args, &block); end

  def confirm_product_instance(*args, &block); end

  def copy_image(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_customer_gateway(*args, &block); end

  def create_dhcp_options(*args, &block); end

  def create_image(*args, &block); end

  def create_instance_export_task(*args, &block); end

  def create_internet_gateway(*args, &block); end

  def create_key_pair(*args, &block); end

  def create_network_acl(*args, &block); end

  def create_network_acl_entry(*args, &block); end

  def create_network_interface(*args, &block); end

  def create_placement_group(*args, &block); end

  def create_reserved_instances_listing(*args, &block); end

  def create_route(*args, &block); end

  def create_route_table(*args, &block); end

  def create_security_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_spot_datafeed_subscription(*args, &block); end

  def create_subnet(*args, &block); end

  def create_tags(*args, &block); end

  def create_volume(*args, &block); end

  def create_vpc(*args, &block); end

  def create_vpn_connection(*args, &block); end

  def create_vpn_connection_route(*args, &block); end

  def create_vpn_gateway(*args, &block); end

  def deactivate_license(*args, &block); end

  def delete_customer_gateway(*args, &block); end

  def delete_dhcp_options(*args, &block); end

  def delete_internet_gateway(*args, &block); end

  def delete_key_pair(*args, &block); end

  def delete_network_acl(*args, &block); end

  def delete_network_acl_entry(*args, &block); end

  def delete_network_interface(*args, &block); end

  def delete_placement_group(*args, &block); end

  def delete_route(*args, &block); end

  def delete_route_table(*args, &block); end

  def delete_security_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def delete_spot_datafeed_subscription(*args, &block); end

  def delete_subnet(*args, &block); end

  def delete_tags(*args, &block); end

  def delete_volume(*args, &block); end

  def delete_vpc(*args, &block); end

  def delete_vpn_connection(*args, &block); end

  def delete_vpn_connection_route(*args, &block); end

  def delete_vpn_gateway(*args, &block); end

  def deregister_image(*args, &block); end

  def describe_account_attributes(*args, &block); end

  def describe_addresses(*args, &block); end

  def describe_availability_zones(*args, &block); end

  def describe_bundle_tasks(*args, &block); end

  def describe_conversion_tasks(*args, &block); end

  def describe_customer_gateways(*args, &block); end

  def describe_dhcp_options(*args, &block); end

  def describe_export_tasks(*args, &block); end

  def describe_image_attribute(*args, &block); end

  def describe_images(*args, &block); end

  def describe_instance_attribute(*args, &block); end

  def describe_instance_status(*args, &block); end

  def describe_instances(*args, &block); end

  def describe_internet_gateways(*args, &block); end

  def describe_key_pairs(*args, &block); end

  def describe_licenses(*args, &block); end

  def describe_network_acls(*args, &block); end

  def describe_network_interface_attribute(*args, &block); end

  def describe_network_interfaces(*args, &block); end

  def describe_placement_groups(*args, &block); end

  def describe_regions(*args, &block); end

  def describe_reserved_instances(*args, &block); end

  def describe_reserved_instances_listings(*args, &block); end

  def describe_reserved_instances_modifications(*args, &block); end

  def describe_reserved_instances_offerings(*args, &block); end

  def describe_route_tables(*args, &block); end

  def describe_security_groups(*args, &block); end

  def describe_snapshot_attribute(*args, &block); end

  def describe_snapshots(*args, &block); end

  def describe_spot_datafeed_subscription(*args, &block); end

  def describe_spot_instance_requests(*args, &block); end

  def describe_spot_price_history(*args, &block); end

  def describe_subnets(*args, &block); end

  def describe_tags(*args, &block); end

  def describe_volume_attribute(*args, &block); end

  def describe_volume_status(*args, &block); end

  def describe_volumes(*args, &block); end

  def describe_vpc_attribute(*args, &block); end

  def describe_vpcs(*args, &block); end

  def describe_vpn_connections(*args, &block); end

  def describe_vpn_gateways(*args, &block); end

  def detach_internet_gateway(*args, &block); end

  def detach_network_interface(*args, &block); end

  def detach_volume(*args, &block); end

  def detach_vpn_gateway(*args, &block); end

  def disable_vgw_route_propagation(*args, &block); end

  def disassociate_address(*args, &block); end

  def disassociate_route_table(*args, &block); end

  def enable_vgw_route_propagation(*args, &block); end

  def enable_volume_io(*args, &block); end

  def get_console_output(*args, &block); end

  def get_password_data(*args, &block); end

  def import_instance(*args, &block); end

  def import_key_pair(*args, &block); end

  def import_volume(*args, &block); end

  def modify_image_attribute(*args, &block); end

  def modify_instance_attribute(*args, &block); end

  def modify_network_interface_attribute(*args, &block); end

  def modify_reserved_instances(*args, &block); end

  def modify_snapshot_attribute(*args, &block); end

  def modify_volume_attribute(*args, &block); end

  def modify_vpc_attribute(*args, &block); end

  def monitor_instances(*args, &block); end

  def purchase_reserved_instances_offering(*args, &block); end

  def reboot_instances(*args, &block); end

  def register_image(*args, &block); end

  def release_address(*args, &block); end

  def replace_network_acl_association(*args, &block); end

  def replace_network_acl_entry(*args, &block); end

  def replace_route(*args, &block); end

  def replace_route_table_association(*args, &block); end

  def report_instance_status(*args, &block); end

  def request_spot_instances(*args, &block); end

  def reset_image_attribute(*args, &block); end

  def reset_instance_attribute(*args, &block); end

  def reset_network_interface_attribute(*args, &block); end

  def reset_snapshot_attribute(*args, &block); end

  def revoke_security_group_egress(*args, &block); end

  def revoke_security_group_ingress(*args, &block); end

  def run_instances(*args, &block); end

  def start_instances(*args, &block); end

  def stop_instances(*args, &block); end

  def terminate_instances(*args, &block); end

  def unassign_private_ip_addresses(*args, &block); end

  def unmonitor_instances(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Client::V20131001
end

class AWS::EC2::Client::V20131015
  def allocate_address(*args, &block); end

  def assign_private_ip_addresses(*args, &block); end

  def associate_address(*args, &block); end

  def associate_dhcp_options(*args, &block); end

  def associate_route_table(*args, &block); end

  def attach_internet_gateway(*args, &block); end

  def attach_network_interface(*args, &block); end

  def attach_volume(*args, &block); end

  def attach_vpn_gateway(*args, &block); end

  def authorize_security_group_egress(*args, &block); end

  def authorize_security_group_ingress(*args, &block); end

  def bundle_instance(*args, &block); end

  def cancel_bundle_task(*args, &block); end

  def cancel_conversion_task(*args, &block); end

  def cancel_export_task(*args, &block); end

  def cancel_reserved_instances_listing(*args, &block); end

  def cancel_spot_instance_requests(*args, &block); end

  def confirm_product_instance(*args, &block); end

  def copy_image(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_customer_gateway(*args, &block); end

  def create_dhcp_options(*args, &block); end

  def create_image(*args, &block); end

  def create_instance_export_task(*args, &block); end

  def create_internet_gateway(*args, &block); end

  def create_key_pair(*args, &block); end

  def create_network_acl(*args, &block); end

  def create_network_acl_entry(*args, &block); end

  def create_network_interface(*args, &block); end

  def create_placement_group(*args, &block); end

  def create_reserved_instances_listing(*args, &block); end

  def create_route(*args, &block); end

  def create_route_table(*args, &block); end

  def create_security_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_spot_datafeed_subscription(*args, &block); end

  def create_subnet(*args, &block); end

  def create_tags(*args, &block); end

  def create_volume(*args, &block); end

  def create_vpc(*args, &block); end

  def create_vpn_connection(*args, &block); end

  def create_vpn_connection_route(*args, &block); end

  def create_vpn_gateway(*args, &block); end

  def delete_customer_gateway(*args, &block); end

  def delete_dhcp_options(*args, &block); end

  def delete_internet_gateway(*args, &block); end

  def delete_key_pair(*args, &block); end

  def delete_network_acl(*args, &block); end

  def delete_network_acl_entry(*args, &block); end

  def delete_network_interface(*args, &block); end

  def delete_placement_group(*args, &block); end

  def delete_route(*args, &block); end

  def delete_route_table(*args, &block); end

  def delete_security_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def delete_spot_datafeed_subscription(*args, &block); end

  def delete_subnet(*args, &block); end

  def delete_tags(*args, &block); end

  def delete_volume(*args, &block); end

  def delete_vpc(*args, &block); end

  def delete_vpn_connection(*args, &block); end

  def delete_vpn_connection_route(*args, &block); end

  def delete_vpn_gateway(*args, &block); end

  def deregister_image(*args, &block); end

  def describe_account_attributes(*args, &block); end

  def describe_addresses(*args, &block); end

  def describe_availability_zones(*args, &block); end

  def describe_bundle_tasks(*args, &block); end

  def describe_conversion_tasks(*args, &block); end

  def describe_customer_gateways(*args, &block); end

  def describe_dhcp_options(*args, &block); end

  def describe_export_tasks(*args, &block); end

  def describe_image_attribute(*args, &block); end

  def describe_images(*args, &block); end

  def describe_instance_attribute(*args, &block); end

  def describe_instance_status(*args, &block); end

  def describe_instances(*args, &block); end

  def describe_internet_gateways(*args, &block); end

  def describe_key_pairs(*args, &block); end

  def describe_network_acls(*args, &block); end

  def describe_network_interface_attribute(*args, &block); end

  def describe_network_interfaces(*args, &block); end

  def describe_placement_groups(*args, &block); end

  def describe_regions(*args, &block); end

  def describe_reserved_instances(*args, &block); end

  def describe_reserved_instances_listings(*args, &block); end

  def describe_reserved_instances_modifications(*args, &block); end

  def describe_reserved_instances_offerings(*args, &block); end

  def describe_route_tables(*args, &block); end

  def describe_security_groups(*args, &block); end

  def describe_snapshot_attribute(*args, &block); end

  def describe_snapshots(*args, &block); end

  def describe_spot_datafeed_subscription(*args, &block); end

  def describe_spot_instance_requests(*args, &block); end

  def describe_spot_price_history(*args, &block); end

  def describe_subnets(*args, &block); end

  def describe_tags(*args, &block); end

  def describe_volume_attribute(*args, &block); end

  def describe_volume_status(*args, &block); end

  def describe_volumes(*args, &block); end

  def describe_vpc_attribute(*args, &block); end

  def describe_vpcs(*args, &block); end

  def describe_vpn_connections(*args, &block); end

  def describe_vpn_gateways(*args, &block); end

  def detach_internet_gateway(*args, &block); end

  def detach_network_interface(*args, &block); end

  def detach_volume(*args, &block); end

  def detach_vpn_gateway(*args, &block); end

  def disable_vgw_route_propagation(*args, &block); end

  def disassociate_address(*args, &block); end

  def disassociate_route_table(*args, &block); end

  def enable_vgw_route_propagation(*args, &block); end

  def enable_volume_io(*args, &block); end

  def get_console_output(*args, &block); end

  def get_password_data(*args, &block); end

  def import_instance(*args, &block); end

  def import_key_pair(*args, &block); end

  def import_volume(*args, &block); end

  def modify_image_attribute(*args, &block); end

  def modify_instance_attribute(*args, &block); end

  def modify_network_interface_attribute(*args, &block); end

  def modify_reserved_instances(*args, &block); end

  def modify_snapshot_attribute(*args, &block); end

  def modify_volume_attribute(*args, &block); end

  def modify_vpc_attribute(*args, &block); end

  def monitor_instances(*args, &block); end

  def purchase_reserved_instances_offering(*args, &block); end

  def reboot_instances(*args, &block); end

  def register_image(*args, &block); end

  def release_address(*args, &block); end

  def replace_network_acl_association(*args, &block); end

  def replace_network_acl_entry(*args, &block); end

  def replace_route(*args, &block); end

  def replace_route_table_association(*args, &block); end

  def report_instance_status(*args, &block); end

  def request_spot_instances(*args, &block); end

  def reset_image_attribute(*args, &block); end

  def reset_instance_attribute(*args, &block); end

  def reset_network_interface_attribute(*args, &block); end

  def reset_snapshot_attribute(*args, &block); end

  def revoke_security_group_egress(*args, &block); end

  def revoke_security_group_ingress(*args, &block); end

  def run_instances(*args, &block); end

  def start_instances(*args, &block); end

  def stop_instances(*args, &block); end

  def terminate_instances(*args, &block); end

  def unassign_private_ip_addresses(*args, &block); end

  def unmonitor_instances(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Client::V20131015
end

class AWS::EC2::Client::V20140201
  def accept_vpc_peering_connection(*args, &block); end

  def allocate_address(*args, &block); end

  def assign_private_ip_addresses(*args, &block); end

  def associate_address(*args, &block); end

  def associate_dhcp_options(*args, &block); end

  def associate_route_table(*args, &block); end

  def attach_internet_gateway(*args, &block); end

  def attach_network_interface(*args, &block); end

  def attach_volume(*args, &block); end

  def attach_vpn_gateway(*args, &block); end

  def authorize_security_group_egress(*args, &block); end

  def authorize_security_group_ingress(*args, &block); end

  def bundle_instance(*args, &block); end

  def cancel_bundle_task(*args, &block); end

  def cancel_conversion_task(*args, &block); end

  def cancel_export_task(*args, &block); end

  def cancel_reserved_instances_listing(*args, &block); end

  def cancel_spot_instance_requests(*args, &block); end

  def confirm_product_instance(*args, &block); end

  def copy_image(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_customer_gateway(*args, &block); end

  def create_dhcp_options(*args, &block); end

  def create_image(*args, &block); end

  def create_instance_export_task(*args, &block); end

  def create_internet_gateway(*args, &block); end

  def create_key_pair(*args, &block); end

  def create_network_acl(*args, &block); end

  def create_network_acl_entry(*args, &block); end

  def create_network_interface(*args, &block); end

  def create_placement_group(*args, &block); end

  def create_reserved_instances_listing(*args, &block); end

  def create_route(*args, &block); end

  def create_route_table(*args, &block); end

  def create_security_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_spot_datafeed_subscription(*args, &block); end

  def create_subnet(*args, &block); end

  def create_tags(*args, &block); end

  def create_volume(*args, &block); end

  def create_vpc(*args, &block); end

  def create_vpc_peering_connection(*args, &block); end

  def create_vpn_connection(*args, &block); end

  def create_vpn_connection_route(*args, &block); end

  def create_vpn_gateway(*args, &block); end

  def delete_customer_gateway(*args, &block); end

  def delete_dhcp_options(*args, &block); end

  def delete_internet_gateway(*args, &block); end

  def delete_key_pair(*args, &block); end

  def delete_network_acl(*args, &block); end

  def delete_network_acl_entry(*args, &block); end

  def delete_network_interface(*args, &block); end

  def delete_placement_group(*args, &block); end

  def delete_route(*args, &block); end

  def delete_route_table(*args, &block); end

  def delete_security_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def delete_spot_datafeed_subscription(*args, &block); end

  def delete_subnet(*args, &block); end

  def delete_tags(*args, &block); end

  def delete_volume(*args, &block); end

  def delete_vpc(*args, &block); end

  def delete_vpc_peering_connection(*args, &block); end

  def delete_vpn_connection(*args, &block); end

  def delete_vpn_connection_route(*args, &block); end

  def delete_vpn_gateway(*args, &block); end

  def deregister_image(*args, &block); end

  def describe_account_attributes(*args, &block); end

  def describe_addresses(*args, &block); end

  def describe_availability_zones(*args, &block); end

  def describe_bundle_tasks(*args, &block); end

  def describe_conversion_tasks(*args, &block); end

  def describe_customer_gateways(*args, &block); end

  def describe_dhcp_options(*args, &block); end

  def describe_export_tasks(*args, &block); end

  def describe_image_attribute(*args, &block); end

  def describe_images(*args, &block); end

  def describe_instance_attribute(*args, &block); end

  def describe_instance_status(*args, &block); end

  def describe_instances(*args, &block); end

  def describe_internet_gateways(*args, &block); end

  def describe_key_pairs(*args, &block); end

  def describe_network_acls(*args, &block); end

  def describe_network_interface_attribute(*args, &block); end

  def describe_network_interfaces(*args, &block); end

  def describe_placement_groups(*args, &block); end

  def describe_regions(*args, &block); end

  def describe_reserved_instances(*args, &block); end

  def describe_reserved_instances_listings(*args, &block); end

  def describe_reserved_instances_modifications(*args, &block); end

  def describe_reserved_instances_offerings(*args, &block); end

  def describe_route_tables(*args, &block); end

  def describe_security_groups(*args, &block); end

  def describe_snapshot_attribute(*args, &block); end

  def describe_snapshots(*args, &block); end

  def describe_spot_datafeed_subscription(*args, &block); end

  def describe_spot_instance_requests(*args, &block); end

  def describe_spot_price_history(*args, &block); end

  def describe_subnets(*args, &block); end

  def describe_tags(*args, &block); end

  def describe_volume_attribute(*args, &block); end

  def describe_volume_status(*args, &block); end

  def describe_volumes(*args, &block); end

  def describe_vpc_attribute(*args, &block); end

  def describe_vpc_peering_connections(*args, &block); end

  def describe_vpcs(*args, &block); end

  def describe_vpn_connections(*args, &block); end

  def describe_vpn_gateways(*args, &block); end

  def detach_internet_gateway(*args, &block); end

  def detach_network_interface(*args, &block); end

  def detach_volume(*args, &block); end

  def detach_vpn_gateway(*args, &block); end

  def disable_vgw_route_propagation(*args, &block); end

  def disassociate_address(*args, &block); end

  def disassociate_route_table(*args, &block); end

  def enable_vgw_route_propagation(*args, &block); end

  def enable_volume_io(*args, &block); end

  def get_console_output(*args, &block); end

  def get_password_data(*args, &block); end

  def import_instance(*args, &block); end

  def import_key_pair(*args, &block); end

  def import_volume(*args, &block); end

  def modify_image_attribute(*args, &block); end

  def modify_instance_attribute(*args, &block); end

  def modify_network_interface_attribute(*args, &block); end

  def modify_reserved_instances(*args, &block); end

  def modify_snapshot_attribute(*args, &block); end

  def modify_volume_attribute(*args, &block); end

  def modify_vpc_attribute(*args, &block); end

  def monitor_instances(*args, &block); end

  def purchase_reserved_instances_offering(*args, &block); end

  def reboot_instances(*args, &block); end

  def register_image(*args, &block); end

  def reject_vpc_peering_connection(*args, &block); end

  def release_address(*args, &block); end

  def replace_network_acl_association(*args, &block); end

  def replace_network_acl_entry(*args, &block); end

  def replace_route(*args, &block); end

  def replace_route_table_association(*args, &block); end

  def report_instance_status(*args, &block); end

  def request_spot_instances(*args, &block); end

  def reset_image_attribute(*args, &block); end

  def reset_instance_attribute(*args, &block); end

  def reset_network_interface_attribute(*args, &block); end

  def reset_snapshot_attribute(*args, &block); end

  def revoke_security_group_egress(*args, &block); end

  def revoke_security_group_ingress(*args, &block); end

  def run_instances(*args, &block); end

  def start_instances(*args, &block); end

  def stop_instances(*args, &block); end

  def terminate_instances(*args, &block); end

  def unassign_private_ip_addresses(*args, &block); end

  def unmonitor_instances(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Client::V20140201
end

class AWS::EC2::Client::V20140501
  def accept_vpc_peering_connection(*args, &block); end

  def allocate_address(*args, &block); end

  def assign_private_ip_addresses(*args, &block); end

  def associate_address(*args, &block); end

  def associate_dhcp_options(*args, &block); end

  def associate_route_table(*args, &block); end

  def attach_internet_gateway(*args, &block); end

  def attach_network_interface(*args, &block); end

  def attach_volume(*args, &block); end

  def attach_vpn_gateway(*args, &block); end

  def authorize_security_group_egress(*args, &block); end

  def authorize_security_group_ingress(*args, &block); end

  def bundle_instance(*args, &block); end

  def cancel_bundle_task(*args, &block); end

  def cancel_conversion_task(*args, &block); end

  def cancel_export_task(*args, &block); end

  def cancel_reserved_instances_listing(*args, &block); end

  def cancel_spot_instance_requests(*args, &block); end

  def confirm_product_instance(*args, &block); end

  def copy_image(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_customer_gateway(*args, &block); end

  def create_dhcp_options(*args, &block); end

  def create_image(*args, &block); end

  def create_instance_export_task(*args, &block); end

  def create_internet_gateway(*args, &block); end

  def create_key_pair(*args, &block); end

  def create_network_acl(*args, &block); end

  def create_network_acl_entry(*args, &block); end

  def create_network_interface(*args, &block); end

  def create_placement_group(*args, &block); end

  def create_reserved_instances_listing(*args, &block); end

  def create_route(*args, &block); end

  def create_route_table(*args, &block); end

  def create_security_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_spot_datafeed_subscription(*args, &block); end

  def create_subnet(*args, &block); end

  def create_tags(*args, &block); end

  def create_volume(*args, &block); end

  def create_vpc(*args, &block); end

  def create_vpc_peering_connection(*args, &block); end

  def create_vpn_connection(*args, &block); end

  def create_vpn_connection_route(*args, &block); end

  def create_vpn_gateway(*args, &block); end

  def delete_customer_gateway(*args, &block); end

  def delete_dhcp_options(*args, &block); end

  def delete_internet_gateway(*args, &block); end

  def delete_key_pair(*args, &block); end

  def delete_network_acl(*args, &block); end

  def delete_network_acl_entry(*args, &block); end

  def delete_network_interface(*args, &block); end

  def delete_placement_group(*args, &block); end

  def delete_route(*args, &block); end

  def delete_route_table(*args, &block); end

  def delete_security_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def delete_spot_datafeed_subscription(*args, &block); end

  def delete_subnet(*args, &block); end

  def delete_tags(*args, &block); end

  def delete_volume(*args, &block); end

  def delete_vpc(*args, &block); end

  def delete_vpc_peering_connection(*args, &block); end

  def delete_vpn_connection(*args, &block); end

  def delete_vpn_connection_route(*args, &block); end

  def delete_vpn_gateway(*args, &block); end

  def deregister_image(*args, &block); end

  def describe_account_attributes(*args, &block); end

  def describe_addresses(*args, &block); end

  def describe_availability_zones(*args, &block); end

  def describe_bundle_tasks(*args, &block); end

  def describe_conversion_tasks(*args, &block); end

  def describe_customer_gateways(*args, &block); end

  def describe_dhcp_options(*args, &block); end

  def describe_export_tasks(*args, &block); end

  def describe_image_attribute(*args, &block); end

  def describe_images(*args, &block); end

  def describe_instance_attribute(*args, &block); end

  def describe_instance_status(*args, &block); end

  def describe_instances(*args, &block); end

  def describe_internet_gateways(*args, &block); end

  def describe_key_pairs(*args, &block); end

  def describe_network_acls(*args, &block); end

  def describe_network_interface_attribute(*args, &block); end

  def describe_network_interfaces(*args, &block); end

  def describe_placement_groups(*args, &block); end

  def describe_regions(*args, &block); end

  def describe_reserved_instances(*args, &block); end

  def describe_reserved_instances_listings(*args, &block); end

  def describe_reserved_instances_modifications(*args, &block); end

  def describe_reserved_instances_offerings(*args, &block); end

  def describe_route_tables(*args, &block); end

  def describe_security_groups(*args, &block); end

  def describe_snapshot_attribute(*args, &block); end

  def describe_snapshots(*args, &block); end

  def describe_spot_datafeed_subscription(*args, &block); end

  def describe_spot_instance_requests(*args, &block); end

  def describe_spot_price_history(*args, &block); end

  def describe_subnets(*args, &block); end

  def describe_tags(*args, &block); end

  def describe_volume_attribute(*args, &block); end

  def describe_volume_status(*args, &block); end

  def describe_volumes(*args, &block); end

  def describe_vpc_attribute(*args, &block); end

  def describe_vpc_peering_connections(*args, &block); end

  def describe_vpcs(*args, &block); end

  def describe_vpn_connections(*args, &block); end

  def describe_vpn_gateways(*args, &block); end

  def detach_internet_gateway(*args, &block); end

  def detach_network_interface(*args, &block); end

  def detach_volume(*args, &block); end

  def detach_vpn_gateway(*args, &block); end

  def disable_vgw_route_propagation(*args, &block); end

  def disassociate_address(*args, &block); end

  def disassociate_route_table(*args, &block); end

  def enable_vgw_route_propagation(*args, &block); end

  def enable_volume_io(*args, &block); end

  def get_console_output(*args, &block); end

  def get_password_data(*args, &block); end

  def import_instance(*args, &block); end

  def import_key_pair(*args, &block); end

  def import_volume(*args, &block); end

  def modify_image_attribute(*args, &block); end

  def modify_instance_attribute(*args, &block); end

  def modify_network_interface_attribute(*args, &block); end

  def modify_reserved_instances(*args, &block); end

  def modify_snapshot_attribute(*args, &block); end

  def modify_subnet_attribute(*args, &block); end

  def modify_volume_attribute(*args, &block); end

  def modify_vpc_attribute(*args, &block); end

  def monitor_instances(*args, &block); end

  def purchase_reserved_instances_offering(*args, &block); end

  def reboot_instances(*args, &block); end

  def register_image(*args, &block); end

  def reject_vpc_peering_connection(*args, &block); end

  def release_address(*args, &block); end

  def replace_network_acl_association(*args, &block); end

  def replace_network_acl_entry(*args, &block); end

  def replace_route(*args, &block); end

  def replace_route_table_association(*args, &block); end

  def report_instance_status(*args, &block); end

  def request_spot_instances(*args, &block); end

  def reset_image_attribute(*args, &block); end

  def reset_instance_attribute(*args, &block); end

  def reset_network_interface_attribute(*args, &block); end

  def reset_snapshot_attribute(*args, &block); end

  def revoke_security_group_egress(*args, &block); end

  def revoke_security_group_ingress(*args, &block); end

  def run_instances(*args, &block); end

  def start_instances(*args, &block); end

  def stop_instances(*args, &block); end

  def terminate_instances(*args, &block); end

  def unassign_private_ip_addresses(*args, &block); end

  def unmonitor_instances(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Client::V20140501
end

class AWS::EC2::Client::V20140901
  def accept_vpc_peering_connection(*args, &block); end

  def allocate_address(*args, &block); end

  def assign_private_ip_addresses(*args, &block); end

  def associate_address(*args, &block); end

  def associate_dhcp_options(*args, &block); end

  def associate_route_table(*args, &block); end

  def attach_internet_gateway(*args, &block); end

  def attach_network_interface(*args, &block); end

  def attach_volume(*args, &block); end

  def attach_vpn_gateway(*args, &block); end

  def authorize_security_group_egress(*args, &block); end

  def authorize_security_group_ingress(*args, &block); end

  def bundle_instance(*args, &block); end

  def cancel_bundle_task(*args, &block); end

  def cancel_conversion_task(*args, &block); end

  def cancel_export_task(*args, &block); end

  def cancel_reserved_instances_listing(*args, &block); end

  def cancel_spot_instance_requests(*args, &block); end

  def confirm_product_instance(*args, &block); end

  def copy_image(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_customer_gateway(*args, &block); end

  def create_dhcp_options(*args, &block); end

  def create_image(*args, &block); end

  def create_instance_export_task(*args, &block); end

  def create_internet_gateway(*args, &block); end

  def create_key_pair(*args, &block); end

  def create_network_acl(*args, &block); end

  def create_network_acl_entry(*args, &block); end

  def create_network_interface(*args, &block); end

  def create_placement_group(*args, &block); end

  def create_reserved_instances_listing(*args, &block); end

  def create_route(*args, &block); end

  def create_route_table(*args, &block); end

  def create_security_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_spot_datafeed_subscription(*args, &block); end

  def create_subnet(*args, &block); end

  def create_tags(*args, &block); end

  def create_volume(*args, &block); end

  def create_vpc(*args, &block); end

  def create_vpc_peering_connection(*args, &block); end

  def create_vpn_connection(*args, &block); end

  def create_vpn_connection_route(*args, &block); end

  def create_vpn_gateway(*args, &block); end

  def delete_customer_gateway(*args, &block); end

  def delete_dhcp_options(*args, &block); end

  def delete_internet_gateway(*args, &block); end

  def delete_key_pair(*args, &block); end

  def delete_network_acl(*args, &block); end

  def delete_network_acl_entry(*args, &block); end

  def delete_network_interface(*args, &block); end

  def delete_placement_group(*args, &block); end

  def delete_route(*args, &block); end

  def delete_route_table(*args, &block); end

  def delete_security_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def delete_spot_datafeed_subscription(*args, &block); end

  def delete_subnet(*args, &block); end

  def delete_tags(*args, &block); end

  def delete_volume(*args, &block); end

  def delete_vpc(*args, &block); end

  def delete_vpc_peering_connection(*args, &block); end

  def delete_vpn_connection(*args, &block); end

  def delete_vpn_connection_route(*args, &block); end

  def delete_vpn_gateway(*args, &block); end

  def deregister_image(*args, &block); end

  def describe_account_attributes(*args, &block); end

  def describe_addresses(*args, &block); end

  def describe_availability_zones(*args, &block); end

  def describe_bundle_tasks(*args, &block); end

  def describe_conversion_tasks(*args, &block); end

  def describe_customer_gateways(*args, &block); end

  def describe_dhcp_options(*args, &block); end

  def describe_export_tasks(*args, &block); end

  def describe_image_attribute(*args, &block); end

  def describe_images(*args, &block); end

  def describe_instance_attribute(*args, &block); end

  def describe_instance_status(*args, &block); end

  def describe_instances(*args, &block); end

  def describe_internet_gateways(*args, &block); end

  def describe_key_pairs(*args, &block); end

  def describe_network_acls(*args, &block); end

  def describe_network_interface_attribute(*args, &block); end

  def describe_network_interfaces(*args, &block); end

  def describe_placement_groups(*args, &block); end

  def describe_regions(*args, &block); end

  def describe_reserved_instances(*args, &block); end

  def describe_reserved_instances_listings(*args, &block); end

  def describe_reserved_instances_modifications(*args, &block); end

  def describe_reserved_instances_offerings(*args, &block); end

  def describe_route_tables(*args, &block); end

  def describe_security_groups(*args, &block); end

  def describe_snapshot_attribute(*args, &block); end

  def describe_snapshots(*args, &block); end

  def describe_spot_datafeed_subscription(*args, &block); end

  def describe_spot_instance_requests(*args, &block); end

  def describe_spot_price_history(*args, &block); end

  def describe_subnets(*args, &block); end

  def describe_tags(*args, &block); end

  def describe_volume_attribute(*args, &block); end

  def describe_volume_status(*args, &block); end

  def describe_volumes(*args, &block); end

  def describe_vpc_attribute(*args, &block); end

  def describe_vpc_peering_connections(*args, &block); end

  def describe_vpcs(*args, &block); end

  def describe_vpn_connections(*args, &block); end

  def describe_vpn_gateways(*args, &block); end

  def detach_internet_gateway(*args, &block); end

  def detach_network_interface(*args, &block); end

  def detach_volume(*args, &block); end

  def detach_vpn_gateway(*args, &block); end

  def disable_vgw_route_propagation(*args, &block); end

  def disassociate_address(*args, &block); end

  def disassociate_route_table(*args, &block); end

  def enable_vgw_route_propagation(*args, &block); end

  def enable_volume_io(*args, &block); end

  def get_console_output(*args, &block); end

  def get_password_data(*args, &block); end

  def import_instance(*args, &block); end

  def import_key_pair(*args, &block); end

  def import_volume(*args, &block); end

  def modify_image_attribute(*args, &block); end

  def modify_instance_attribute(*args, &block); end

  def modify_network_interface_attribute(*args, &block); end

  def modify_reserved_instances(*args, &block); end

  def modify_snapshot_attribute(*args, &block); end

  def modify_subnet_attribute(*args, &block); end

  def modify_volume_attribute(*args, &block); end

  def modify_vpc_attribute(*args, &block); end

  def monitor_instances(*args, &block); end

  def purchase_reserved_instances_offering(*args, &block); end

  def reboot_instances(*args, &block); end

  def register_image(*args, &block); end

  def reject_vpc_peering_connection(*args, &block); end

  def release_address(*args, &block); end

  def replace_network_acl_association(*args, &block); end

  def replace_network_acl_entry(*args, &block); end

  def replace_route(*args, &block); end

  def replace_route_table_association(*args, &block); end

  def report_instance_status(*args, &block); end

  def request_spot_instances(*args, &block); end

  def reset_image_attribute(*args, &block); end

  def reset_instance_attribute(*args, &block); end

  def reset_network_interface_attribute(*args, &block); end

  def reset_snapshot_attribute(*args, &block); end

  def revoke_security_group_egress(*args, &block); end

  def revoke_security_group_ingress(*args, &block); end

  def run_instances(*args, &block); end

  def start_instances(*args, &block); end

  def stop_instances(*args, &block); end

  def terminate_instances(*args, &block); end

  def unassign_private_ip_addresses(*args, &block); end

  def unmonitor_instances(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Client::V20140901
end

class AWS::EC2::Client::V20141001
  def accept_vpc_peering_connection(*args, &block); end

  def allocate_address(*args, &block); end

  def assign_private_ip_addresses(*args, &block); end

  def associate_address(*args, &block); end

  def associate_dhcp_options(*args, &block); end

  def associate_route_table(*args, &block); end

  def attach_classic_link_vpc(*args, &block); end

  def attach_internet_gateway(*args, &block); end

  def attach_network_interface(*args, &block); end

  def attach_volume(*args, &block); end

  def attach_vpn_gateway(*args, &block); end

  def authorize_security_group_egress(*args, &block); end

  def authorize_security_group_ingress(*args, &block); end

  def basic_copy_snapshot(*args, &block); end

  def bundle_instance(*args, &block); end

  def cancel_bundle_task(*args, &block); end

  def cancel_conversion_task(*args, &block); end

  def cancel_export_task(*args, &block); end

  def cancel_reserved_instances_listing(*args, &block); end

  def cancel_spot_instance_requests(*args, &block); end

  def confirm_product_instance(*args, &block); end

  def copy_image(*args, &block); end

  def copy_snapshot(params=T.unsafe(nil)); end

  def create_customer_gateway(*args, &block); end

  def create_dhcp_options(*args, &block); end

  def create_image(*args, &block); end

  def create_instance_export_task(*args, &block); end

  def create_internet_gateway(*args, &block); end

  def create_key_pair(*args, &block); end

  def create_network_acl(*args, &block); end

  def create_network_acl_entry(*args, &block); end

  def create_network_interface(*args, &block); end

  def create_placement_group(*args, &block); end

  def create_reserved_instances_listing(*args, &block); end

  def create_route(*args, &block); end

  def create_route_table(*args, &block); end

  def create_security_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_spot_datafeed_subscription(*args, &block); end

  def create_subnet(*args, &block); end

  def create_tags(*args, &block); end

  def create_volume(*args, &block); end

  def create_vpc(*args, &block); end

  def create_vpc_peering_connection(*args, &block); end

  def create_vpn_connection(*args, &block); end

  def create_vpn_connection_route(*args, &block); end

  def create_vpn_gateway(*args, &block); end

  def delete_customer_gateway(*args, &block); end

  def delete_dhcp_options(*args, &block); end

  def delete_internet_gateway(*args, &block); end

  def delete_key_pair(*args, &block); end

  def delete_network_acl(*args, &block); end

  def delete_network_acl_entry(*args, &block); end

  def delete_network_interface(*args, &block); end

  def delete_placement_group(*args, &block); end

  def delete_route(*args, &block); end

  def delete_route_table(*args, &block); end

  def delete_security_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def delete_spot_datafeed_subscription(*args, &block); end

  def delete_subnet(*args, &block); end

  def delete_tags(*args, &block); end

  def delete_volume(*args, &block); end

  def delete_vpc(*args, &block); end

  def delete_vpc_peering_connection(*args, &block); end

  def delete_vpn_connection(*args, &block); end

  def delete_vpn_connection_route(*args, &block); end

  def delete_vpn_gateway(*args, &block); end

  def deregister_image(*args, &block); end

  def describe_account_attributes(*args, &block); end

  def describe_addresses(*args, &block); end

  def describe_availability_zones(*args, &block); end

  def describe_bundle_tasks(*args, &block); end

  def describe_classic_link_instances(*args, &block); end

  def describe_conversion_tasks(*args, &block); end

  def describe_customer_gateways(*args, &block); end

  def describe_dhcp_options(*args, &block); end

  def describe_export_tasks(*args, &block); end

  def describe_image_attribute(*args, &block); end

  def describe_images(*args, &block); end

  def describe_instance_attribute(*args, &block); end

  def describe_instance_status(*args, &block); end

  def describe_instances(*args, &block); end

  def describe_internet_gateways(*args, &block); end

  def describe_key_pairs(*args, &block); end

  def describe_network_acls(*args, &block); end

  def describe_network_interface_attribute(*args, &block); end

  def describe_network_interfaces(*args, &block); end

  def describe_placement_groups(*args, &block); end

  def describe_regions(*args, &block); end

  def describe_reserved_instances(*args, &block); end

  def describe_reserved_instances_listings(*args, &block); end

  def describe_reserved_instances_modifications(*args, &block); end

  def describe_reserved_instances_offerings(*args, &block); end

  def describe_route_tables(*args, &block); end

  def describe_security_groups(*args, &block); end

  def describe_snapshot_attribute(*args, &block); end

  def describe_snapshots(*args, &block); end

  def describe_spot_datafeed_subscription(*args, &block); end

  def describe_spot_instance_requests(*args, &block); end

  def describe_spot_price_history(*args, &block); end

  def describe_subnets(*args, &block); end

  def describe_tags(*args, &block); end

  def describe_volume_attribute(*args, &block); end

  def describe_volume_status(*args, &block); end

  def describe_volumes(*args, &block); end

  def describe_vpc_attribute(*args, &block); end

  def describe_vpc_classic_link(*args, &block); end

  def describe_vpc_peering_connections(*args, &block); end

  def describe_vpcs(*args, &block); end

  def describe_vpn_connections(*args, &block); end

  def describe_vpn_gateways(*args, &block); end

  def detach_classic_link_vpc(*args, &block); end

  def detach_internet_gateway(*args, &block); end

  def detach_network_interface(*args, &block); end

  def detach_volume(*args, &block); end

  def detach_vpn_gateway(*args, &block); end

  def disable_vgw_route_propagation(*args, &block); end

  def disable_vpc_classic_link(*args, &block); end

  def disassociate_address(*args, &block); end

  def disassociate_route_table(*args, &block); end

  def enable_vgw_route_propagation(*args, &block); end

  def enable_volume_io(*args, &block); end

  def enable_vpc_classic_link(*args, &block); end

  def get_console_output(*args, &block); end

  def get_password_data(*args, &block); end

  def import_instance(*args, &block); end

  def import_key_pair(*args, &block); end

  def import_volume(*args, &block); end

  def modify_image_attribute(*args, &block); end

  def modify_instance_attribute(*args, &block); end

  def modify_network_interface_attribute(*args, &block); end

  def modify_reserved_instances(*args, &block); end

  def modify_snapshot_attribute(*args, &block); end

  def modify_subnet_attribute(*args, &block); end

  def modify_volume_attribute(*args, &block); end

  def modify_vpc_attribute(*args, &block); end

  def monitor_instances(*args, &block); end

  def purchase_reserved_instances_offering(*args, &block); end

  def reboot_instances(*args, &block); end

  def register_image(*args, &block); end

  def reject_vpc_peering_connection(*args, &block); end

  def release_address(*args, &block); end

  def replace_network_acl_association(*args, &block); end

  def replace_network_acl_entry(*args, &block); end

  def replace_route(*args, &block); end

  def replace_route_table_association(*args, &block); end

  def report_instance_status(*args, &block); end

  def request_spot_instances(*args, &block); end

  def reset_image_attribute(*args, &block); end

  def reset_instance_attribute(*args, &block); end

  def reset_network_interface_attribute(*args, &block); end

  def reset_snapshot_attribute(*args, &block); end

  def revoke_security_group_egress(*args, &block); end

  def revoke_security_group_ingress(*args, &block); end

  def run_instances(*args, &block); end

  def start_instances(*args, &block); end

  def stop_instances(*args, &block); end

  def terminate_instances(*args, &block); end

  def unassign_private_ip_addresses(*args, &block); end

  def unmonitor_instances(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Client::V20141001
end

class AWS::EC2::Client
end

class AWS::EC2::Collection
  include ::AWS::Core::Model
  include ::Enumerable
  include ::AWS::EC2::FilteredCollection
  def [](id); end

  def member_class(); end
end

class AWS::EC2::Collection
end

class AWS::EC2::CustomerGateway
  include ::AWS::EC2::TaggedItem
  def _find_in_create_customer_gateway_response_0(resp); end

  def _find_in_describe_customer_gateways_response_1(resp); end

  def bgp_asn(); end

  def customer_gateway_id(); end

  def delete(); end

  def exists?(); end

  def id(); end

  def initialize(customer_gateway_id, options=T.unsafe(nil)); end

  def ip_address(); end

  def state(); end

  def vpn_connections(); end

  def vpn_type(); end
end

class AWS::EC2::CustomerGateway
end

class AWS::EC2::CustomerGatewayCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](customer_gateway_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(bgp_asn, ip_address, options=T.unsafe(nil)); end
end

class AWS::EC2::CustomerGatewayCollection
end

class AWS::EC2::DHCPOptions
  include ::AWS::EC2::TaggedItem
  def _find_in_create_dhcp_options_response_0(resp); end

  def _find_in_describe_dhcp_options_response_1(resp); end

  def associate(vpc); end

  def configuration(); end

  def delete(); end

  def dhcp_configuration_set(); end

  def dhcp_options_id(); end

  def exists?(); end

  def id(); end

  def initialize(dhcp_options_id, options=T.unsafe(nil)); end

  def vpc_id_option(vpc); end

  def vpcs(); end
end

class AWS::EC2::DHCPOptions
end

class AWS::EC2::DHCPOptionsCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](dhcp_options_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(options=T.unsafe(nil)); end
end

class AWS::EC2::DHCPOptionsCollection
end

class AWS::EC2::ElasticIp
  def _find_in_describe_addresses_response_0(resp); end

  def allocation_id(); end

  def associate(options); end

  def associated?(); end

  def association_id(); end

  def attached?(); end

  def delete(); end

  def disassociate(); end

  def domain(); end

  def exists?(); end

  def initialize(public_ip, options=T.unsafe(nil)); end

  def instance(); end

  def instance_id(); end

  def ip_address(); end

  def network_interface(); end

  def network_interface_id(); end

  def network_interface_owner_id(); end

  def public_ip(); end

  def release(); end

  def vpc?(); end
end

class AWS::EC2::ElasticIp
end

class AWS::EC2::ElasticIpCollection
  def [](public_ip); end

  def allocate(options=T.unsafe(nil)); end

  def create(options=T.unsafe(nil)); end

  def each(&block); end
end

class AWS::EC2::ElasticIpCollection
end

module AWS::EC2::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Errors::RequestLimitExceeded
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Errors::RequestLimitExceeded
  extend ::AWS::Core::LazyErrorClasses
end

module AWS::EC2::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::EC2::ExportTask
  def _find_in_create_instance_export_task_response_0(resp); end

  def _find_in_describe_export_tasks_response_1(resp); end

  def cancel(); end

  def container_format(); end

  def description(); end

  def disk_image_format(); end

  def export_task_id(); end

  def id(); end

  def initialize(export_task_id, options=T.unsafe(nil)); end

  def instance(); end

  def instance_id(); end

  def s3_bucket(); end

  def s3_bucket_name(); end

  def s3_key(); end

  def s3_object(); end

  def state(); end

  def status_message(); end

  def target_environment(); end
end

class AWS::EC2::ExportTask
end

class AWS::EC2::ExportTaskCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](export_task_id); end

  def _each_item(options=T.unsafe(nil), &block); end
end

class AWS::EC2::ExportTaskCollection
end

module AWS::EC2::FilteredCollection
  def collection_with(options=T.unsafe(nil)); end

  def filter(filter_name, *values); end

  def filter_value_for(filter_name); end

  def filtered_request(client_method, options=T.unsafe(nil), &block); end

  def initialize(options=T.unsafe(nil)); end

  def preserved_options(); end

  def subnet_id_option(options); end

  def vpc_id_option(options); end
end

module AWS::EC2::FilteredCollection
end

module AWS::EC2::HasPermissions
  def permissions(); end

  def private?(); end

  def public=(value); end

  def public?(); end
end

module AWS::EC2::HasPermissions
end

class AWS::EC2::Image
  include ::AWS::EC2::TaggedItem
  include ::AWS::EC2::HasPermissions
  def __permissions_attribute__(); end

  def _find_in_describe_images_response_0(resp); end

  def add_product_codes(*product_codes); end

  def architecture(); end

  def block_device_mapping(); end

  def block_device_mappings(); end

  def block_devices(); end

  def creation_date(); end

  def delete(); end

  def deregister(); end

  def description(); end

  def description=(value); end

  def exists?(); end

  def hypervisor(); end

  def id(); end

  def image_id(); end

  def initialize(image_id, options=T.unsafe(nil)); end

  def kernel(); end

  def kernel_id(); end

  def launch_permissions(); end

  def location(); end

  def name(); end

  def owner_alias(); end

  def owner_id(); end

  def platform(); end

  def product_codes(); end

  def ramdisk(); end

  def ramdisk_id(); end

  def root_device_name(); end

  def root_device_type(); end

  def run_instance(options=T.unsafe(nil)); end

  def run_instances(count, options=T.unsafe(nil)); end

  def state(); end

  def state_reason(); end

  def type(); end

  def virtualization_type(); end
end

class AWS::EC2::Image
end

class AWS::EC2::ImageCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::EC2::BlockDeviceMappings
  def [](image_id); end

  def create(options=T.unsafe(nil)); end

  def each(opts=T.unsafe(nil), &block); end

  def executable_by(*users); end

  def with_owner(*owners); end
end

class AWS::EC2::ImageCollection
end

class AWS::EC2::Instance
  include ::AWS::EC2::TaggedItem
  def _find_in_describe_instance_attribute_response_4(resp); end

  def _find_in_describe_instance_attribute_response_5(resp); end

  def _find_in_describe_instance_attribute_response_6(resp); end

  def _find_in_describe_instance_attribute_response_7(resp); end

  def _find_in_describe_instances_response_0(resp); end

  def _find_in_describe_instances_response_1(resp); end

  def _find_in_monitor_instances_or_unmonitor_instances_response_9(resp); end

  def _find_in_run_instances_response_2(resp); end

  def _find_in_run_instances_response_3(resp); end

  def _find_in_terminate_instances_or_start_instances_or_stop_instances_response_8(resp); end

  def ami_launch_index(); end

  def api_termination_disabled=(value); end

  def api_termination_disabled?(); end

  def architecture(); end

  def associate_elastic_ip(elastic_ip); end

  def attach_network_interface(network_interface, options=T.unsafe(nil)); end

  def attachments(); end

  def attributes_from_response_object(obj); end

  def availability_zone(); end

  def block_device_mapping(); end

  def block_device_mappings(); end

  def block_devices(); end

  def client_token(); end

  def console_output(); end

  def create_image(name, options=T.unsafe(nil)); end

  def dedicated_tenancy?(); end

  def delete(); end

  def disable_monitoring(); end

  def disassociate_elastic_ip(); end

  def dns_name(); end

  def ebs_optimized(); end

  def ebs_optimized=(value); end

  def elastic_ip(); end

  def enable_monitoring(); end

  def exists?(); end

  def export_to_s3(bucket, options=T.unsafe(nil)); end

  def find_in_response(resp); end

  def get_resource(attribute); end

  def group_set(); end

  def group_set=(value); end

  def groups(); end

  def has_elastic_ip?(); end

  def hypervisor(); end

  def iam_instance_profile_arn(); end

  def iam_instance_profile_id(); end

  def id(); end

  def image(); end

  def image_id(); end

  def initialize(instance_id, opts=T.unsafe(nil)); end

  def instance_action(name); end

  def instance_id(); end

  def instance_initiated_shutdown_behavior(); end

  def instance_initiated_shutdown_behavior=(value); end

  def instance_lifecycle(); end

  def instance_type(); end

  def instance_type=(value); end

  def ip_address(); end

  def ip_address=(elastic_ip); end

  def kernel_id(); end

  def kernel_id=(value); end

  def key_name(); end

  def key_pair(); end

  def launch_time(); end

  def monitoring(); end

  def monitoring_enabled=(state); end

  def monitoring_enabled?(); end

  def network_interface_set(); end

  def network_interfaces(); end

  def owner_id(); end

  def placement(); end

  def platform(); end

  def private_dns_name(); end

  def private_ip_address(); end

  def product_codes(); end

  def public_dns_name(); end

  def public_ip_address(); end

  def ramdisk_id(); end

  def ramdisk_id=(value); end

  def reboot(); end

  def requester_id(); end

  def reservation_id(); end

  def reset_kernel_id(); end

  def reset_ramdisk_id(); end

  def root_device_name(); end

  def root_device_type(); end

  def security_groups(); end

  def source_dest_check(); end

  def source_dest_check=(value); end

  def source_dest_check?(); end

  def spot_instance?(); end

  def start(); end

  def state_transition_reason(); end

  def status(); end

  def status_code(); end

  def stop(); end

  def subnet(); end

  def subnet_id(); end

  def terminate(); end

  def user_data(); end

  def user_data=(value); end

  def virtualization_type(); end

  def vpc(); end

  def vpc?(); end

  def vpc_id(); end
end

class AWS::EC2::Instance
  def self.describe_call_attribute(name, options=T.unsafe(nil), &block); end

  def self.describe_call_attributes(); end

  def self.mutable_describe_attribute(name, options=T.unsafe(nil), &block); end

  def self.mutable_describe_attributes(); end

  def self.mutable_describe_call_attribute(name, options=T.unsafe(nil), &block); end

  def self.reservation_attribute(name, options=T.unsafe(nil), &block); end

  def self.reservation_attributes(); end
end

class AWS::EC2::InstanceCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::EC2::BlockDeviceMappings
  def create(options=T.unsafe(nil)); end

  def each(&block); end

  def run(options=T.unsafe(nil)); end
end

class AWS::EC2::InstanceCollection
end

class AWS::EC2::InternetGateway
  include ::AWS::EC2::TaggedItem
  def _find_in_describe_internet_gateways_response_0(resp); end

  def attach(vpc); end

  def attachment_set(); end

  def attachments(); end

  def delete(); end

  def detach(vpc); end

  def exists?(); end

  def id(); end

  def initialize(internet_gateway_id, options=T.unsafe(nil)); end

  def internet_gateway_id(); end

  def vpc(); end

  def vpc=(vpc); end

  def vpc_id(); end

  def vpc_id_option(vpc); end
end

class AWS::EC2::InternetGateway::Attachment
  def delete(); end

  def detach(); end

  def initialize(internet_gateway, details); end

  def internet_gateway(); end

  def state(); end

  def vpc(); end
end

class AWS::EC2::InternetGateway::Attachment
end

class AWS::EC2::InternetGateway
end

class AWS::EC2::InternetGatewayCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](internet_gateway_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(); end
end

class AWS::EC2::InternetGatewayCollection
end

class AWS::EC2::KeyPair
  def _find_in_create_key_pair_or_import_key_pair_response_0(resp); end

  def _find_in_describe_key_pairs_response_1(resp); end

  def delete(); end

  def exists?(); end

  def find_in_response(resp); end

  def fingerprint(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def private_key(); end
end

class AWS::EC2::KeyPair
end

class AWS::EC2::KeyPairCollection
  def [](key_name); end

  def create(key_name); end

  def each(&block); end

  def import(key_name, public_key); end
end

class AWS::EC2::KeyPairCollection
end

class AWS::EC2::NetworkACL
  include ::AWS::EC2::TaggedItem
  def _find_in_create_network_acl_response_0(resp); end

  def _find_in_describe_network_acls_response_1(resp); end

  def association_set(); end

  def associations(); end

  def create_entry(options=T.unsafe(nil)); end

  def default(); end

  def default?(); end

  def delete(); end

  def delete_entry(egress_or_ingress, rule_number); end

  def entries(); end

  def entry_options(options); end

  def entry_set(); end

  def id(); end

  def initialize(network_acl_id, options=T.unsafe(nil)); end

  def network_acl_id(); end

  def replace_entry(options=T.unsafe(nil)); end

  def subnets(); end

  def vpc(); end

  def vpc_id(); end
end

class AWS::EC2::NetworkACL::Association
  def association_id(); end

  def initialize(association_id, network_acl, subnet); end

  def network_acl(); end

  def replace_network_acl(network_acl); end

  def subnet(); end
end

class AWS::EC2::NetworkACL::Association
end

class AWS::EC2::NetworkACL::Entry
  def action(); end

  def allow?(); end

  def cidr_block(); end

  def delete(); end

  def deny?(); end

  def egress(); end

  def egress?(); end

  def icmp_code(); end

  def icmp_type(); end

  def ingress(); end

  def ingress?(); end

  def initialize(network_acl, details); end

  def network_acl(); end

  def port_range(); end

  def protocol(); end

  def replace(options=T.unsafe(nil)); end

  def rule_number(); end
end

class AWS::EC2::NetworkACL::Entry
end

class AWS::EC2::NetworkACL
end

class AWS::EC2::NetworkACLCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](network_acl_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(options=T.unsafe(nil)); end
end

class AWS::EC2::NetworkACLCollection
end

class AWS::EC2::NetworkInterface
  include ::AWS::EC2::TaggedItem
  def _find_in_create_network_interface_response_0(resp); end

  def _find_in_describe_network_interfaces_response_1(resp); end

  def association(); end

  def attach(instance, options=T.unsafe(nil)); end

  def attachment(); end

  def attachment_details(); end

  def availability_zone(); end

  def availability_zone_name(); end

  def delete(); end

  def description(); end

  def description=(value); end

  def detach(options=T.unsafe(nil)); end

  def elastic_ip(); end

  def exists?(); end

  def groups(); end

  def groups=(value); end

  def id(); end

  def initialize(network_interface_id, options=T.unsafe(nil)); end

  def instance(); end

  def mac_address(); end

  def network_interface_id(); end

  def owner_id(); end

  def private_dns_name(); end

  def private_ip_address(); end

  def private_ip_addresses(); end

  def requester_managed(); end

  def requester_managed?(); end

  def security_groups(); end

  def security_groups=(*groups); end

  def set_security_groups(*groups); end

  def source_dest_check(); end

  def source_dest_check=(value); end

  def source_dest_check?(); end

  def status(); end

  def subnet(); end

  def subnet_id(); end

  def vpc(); end

  def vpc_id(); end
end

class AWS::EC2::NetworkInterface::Attachment
  def attach_time(); end

  def attachment_id(); end

  def delete(options=T.unsafe(nil)); end

  def delete_on_termination(); end

  def delete_on_termination=(state); end

  def delete_on_termination?(); end

  def detach(options=T.unsafe(nil)); end

  def device_index(); end

  def id(); end

  def initialize(network_interface, details); end

  def instance(); end

  def instance_owner_id(); end

  def network_interface(); end

  def status(); end
end

class AWS::EC2::NetworkInterface::Attachment
end

class AWS::EC2::NetworkInterface
end

class AWS::EC2::NetworkInterfaceCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](network_interface_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(options=T.unsafe(nil)); end

  def groups_options(options); end
end

class AWS::EC2::NetworkInterfaceCollection
end

class AWS::EC2::PermissionCollection
  include ::AWS::Core::Model
  include ::Enumerable
  def add(*users); end

  def each(&block); end

  def empty?(); end

  def initialize(resource, opts=T.unsafe(nil)); end

  def private?(); end

  def public=(value); end

  def public?(); end

  def remove(*users); end

  def reset(); end

  def size(); end
end

class AWS::EC2::PermissionCollection
end

class AWS::EC2::Region
  def ==(other); end

  def availability_zones(); end

  def client(); end

  def config(); end

  def customer_gateways(); end

  def dhcp_options(); end

  def elastic_ips(); end

  def endpoint(); end

  def eql?(other); end

  def exists?(); end

  def export_tasks(); end

  def images(); end

  def initialize(name, options=T.unsafe(nil)); end

  def instances(); end

  def internet_gateways(); end

  def key_pairs(); end

  def name(); end

  def network_acls(); end

  def network_interfaces(); end

  def reserved_instances(); end

  def reserved_instances_offerings(); end

  def route_tables(); end

  def security_groups(); end

  def snapshots(); end

  def subnets(); end

  def tags(); end

  def volumes(); end

  def vpcs(); end

  def vpn_connections(); end

  def vpn_gateways(); end
  PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::Region
end

class AWS::EC2::RegionCollection
  def [](name); end

  def each(&blk); end
end

class AWS::EC2::RegionCollection
end

class AWS::EC2::ReservedInstances
  include ::AWS::EC2::TaggedItem
  def _find_in_describe_reserved_instances_response_0(resp); end

  def availability_zone(); end

  def currency_code(); end

  def duration(); end

  def end(); end

  def fixed_price(); end

  def id(); end

  def initialize(id, options=T.unsafe(nil)); end

  def instance_count(); end

  def instance_tenancy(); end

  def instance_type(); end

  def offering_type(); end

  def product_description(); end

  def recurring_charges(); end

  def start(); end

  def state(); end

  def usage_price(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::ReservedInstances
end

class AWS::EC2::ReservedInstancesCollection
  include ::AWS::EC2::TaggedCollection
  def each(&block); end
end

class AWS::EC2::ReservedInstancesCollection
end

class AWS::EC2::ReservedInstancesOffering
  include ::AWS::EC2::TaggedItem
  def _find_in_describe_reserved_instances_offerings_response_0(resp); end

  def availability_zone(); end

  def currency_code(); end

  def duration(); end

  def fixed_price(); end

  def id(); end

  def initialize(id, options=T.unsafe(nil)); end

  def instance_tenancy(); end

  def instance_type(); end

  def offering_type(); end

  def product_description(); end

  def purchase(options=T.unsafe(nil)); end

  def recurring_charges(); end

  def usage_price(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class AWS::EC2::ReservedInstancesOffering
end

class AWS::EC2::ReservedInstancesOfferingCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Collection
  def _each_item(next_token, max_results, options=T.unsafe(nil), &block); end
end

class AWS::EC2::ReservedInstancesOfferingCollection
end

class AWS::EC2::Resource
  include ::AWS::EC2::Resource::InflectionMethods
  def __resource_id__(); end

  def describe_attribute_call(attribute); end

  def describe_call(); end

  def find_in_response(response); end

  def get_resource(attribute=T.unsafe(nil)); end

  def resource_id_method(); end

  def response_id_method(); end

  def retrieve_attribute(attribute_or_attribute_name, &block); end

  def update_resource(attribute, value); end
end

module AWS::EC2::Resource::InflectionMethods
  def class_name(); end

  def describe_attribute_call_name(); end

  def describe_call_name(); end

  def inflected_name(); end

  def output_translator(name, type); end

  def plural_name(); end
end

module AWS::EC2::Resource::InflectionMethods
end

class AWS::EC2::Resource
  extend ::AWS::EC2::Resource::InflectionMethods
  def self.describe_call_attribute(name, opts=T.unsafe(nil), &blk); end
end

class AWS::EC2::ResourceObject
  include ::AWS::EC2::TaggedItem
  def id(); end

  def initialize(id, options=T.unsafe(nil)); end
end

class AWS::EC2::ResourceObject
end

class AWS::EC2::ResourceTagCollection
  include ::AWS::Core::Model
  include ::Enumerable
  def <<(key); end

  def [](key); end

  def []=(key, value); end

  def add(key); end

  def clear(); end

  def delete(*keys); end

  def each(&blk); end

  def each_pair(&blk); end

  def empty?(); end

  def has_key?(key); end

  def has_value?(value); end

  def include?(key); end

  def initialize(resource, opts=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def method_missing(m, *args); end

  def set(tags); end

  def store(key, value); end

  def to_h(); end

  def update(tags); end

  def value?(value); end

  def values_at(*keys); end
end

class AWS::EC2::ResourceTagCollection
end

class AWS::EC2::RouteTable
  include ::AWS::EC2::TaggedItem
  def _find_in_create_route_table_response_0(resp); end

  def _find_in_describe_route_tables_response_1(resp); end

  def association_set(); end

  def associations(); end

  def create_route(destination_cidr_block, options=T.unsafe(nil)); end

  def delete(); end

  def delete_route(destination_cidr_block); end

  def id(); end

  def initialize(route_table_id, options=T.unsafe(nil)); end

  def main?(); end

  def replace_route(destination_cidr_block, options=T.unsafe(nil)); end

  def route_options(destination_cidr_block, options=T.unsafe(nil)); end

  def route_set(); end

  def route_table_id(); end

  def routes(); end

  def subnets(); end

  def vpc(); end

  def vpc_id(); end
end

class AWS::EC2::RouteTable::Association
  def association_id(); end

  def delete(); end

  def disassociate(); end

  def id(); end

  def initialize(route_table, association_id, subnet_id); end

  def main(); end

  def main?(); end

  def route_table(); end

  def subnet(); end
end

class AWS::EC2::RouteTable::Association
end

class AWS::EC2::RouteTable::Route
  def cidr_block(); end

  def delete(); end

  def destination_cidr_block(); end

  def initialize(route_table, details); end

  def instance(); end

  def internet_gateway(); end

  def network_interface(); end

  def origin(); end

  def replace(options=T.unsafe(nil)); end

  def route_table(); end

  def state(); end

  def target(); end
end

class AWS::EC2::RouteTable::Route
end

class AWS::EC2::RouteTable
end

class AWS::EC2::RouteTableCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](route_table_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(options=T.unsafe(nil)); end

  def main_route_table(); end
end

class AWS::EC2::RouteTableCollection
end

class AWS::EC2::SecurityGroup
  include ::AWS::EC2::TaggedItem
  def _find_in_describe_security_groups_response_0(resp); end

  def allow_ping(*sources); end

  def authorize_egress(*sources); end

  def authorize_ingress(protocol, ports, *sources); end

  def delete(); end

  def description(); end

  def disallow_ping(*sources); end

  def egress_ip_permissions(); end

  def egress_opts(args); end

  def ensure_vpc(&block); end

  def exists?(); end

  def find_in_response(resp); end

  def group_id(); end

  def id(); end

  def ingress_ip_permissions(); end

  def ingress_opts(protocol, ports, sources); end

  def initialize(security_group_id, options=T.unsafe(nil)); end

  def instances(); end

  def ip_permissions(); end

  def ip_permissions_list(); end

  def ip_permissions_list_egress(); end

  def name(); end

  def owner_id(); end

  def parse_sources(sources); end

  def resource_type(); end

  def revoke_egress(*sources); end

  def revoke_ingress(protocol, ports, *sources); end

  def security_group_id(); end

  def vpc(); end

  def vpc?(); end

  def vpc_id(); end
end

class AWS::EC2::SecurityGroup::EgressIpPermissionCollection
end

class AWS::EC2::SecurityGroup::EgressIpPermissionCollection
end

class AWS::EC2::SecurityGroup::IngressIpPermissionCollection
end

class AWS::EC2::SecurityGroup::IngressIpPermissionCollection
end

class AWS::EC2::SecurityGroup::IpPermission
  include ::AWS::Core::Model
  def ==(other); end

  def authorize(); end

  def egress(); end

  def egress?(); end

  def eql?(other); end

  def groups(); end

  def initialize(security_group, protocol, ports, options=T.unsafe(nil)); end

  def ip_ranges(); end

  def port_range(); end

  def protocol(); end

  def revoke(); end

  def security_group(); end

  def update_sg(method); end
end

class AWS::EC2::SecurityGroup::IpPermission
end

class AWS::EC2::SecurityGroup::IpPermissionCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def egress(); end

  def egress?(); end

  def initialize(security_group, options=T.unsafe(nil)); end

  def security_group(); end
end

class AWS::EC2::SecurityGroup::IpPermissionCollection
end

class AWS::EC2::SecurityGroup
end

class AWS::EC2::SecurityGroupCollection
  include ::AWS::EC2::TaggedCollection
  def [](group_id); end

  def create(name, options=T.unsafe(nil)); end

  def each(&block); end
end

class AWS::EC2::SecurityGroupCollection
end

class AWS::EC2::Snapshot
  include ::AWS::EC2::TaggedItem
  include ::AWS::EC2::HasPermissions
  def __permissions_attribute__(); end

  def _find_in_create_snapshot_response_0(resp); end

  def _find_in_describe_snapshots_response_1(resp); end

  def create_volume(availability_zone, options=T.unsafe(nil)); end

  def create_volume_permissions(); end

  def delete(); end

  def description(); end

  def exists?(); end

  def id(); end

  def initialize(id, options=T.unsafe(nil)); end

  def owner_alias(); end

  def owner_id(); end

  def progress(); end

  def start_time(); end

  def status(); end

  def volume(); end

  def volume_id(); end

  def volume_size(); end
end

class AWS::EC2::Snapshot
end

class AWS::EC2::SnapshotCollection
  include ::AWS::EC2::TaggedCollection
  def create(opts=T.unsafe(nil)); end

  def each(&block); end

  def restorable_by(*users); end

  def with_owner(*owners); end
end

class AWS::EC2::SnapshotCollection
end

class AWS::EC2::Subnet
  include ::AWS::EC2::TaggedItem
  def _find_in_create_subnet_response_0(resp); end

  def _find_in_describe_subnets_response_1(resp); end

  def availability_zone(); end

  def availability_zone_name(); end

  def available_ip_address_count(); end

  def cidr_block(); end

  def delete(); end

  def id(); end

  def initialize(subnet_id, options=T.unsafe(nil)); end

  def instances(); end

  def network_acl(); end

  def network_acl=(network_acl); end

  def network_acl_association(); end

  def network_interfaces(); end

  def route_table(); end

  def route_table=(route_table); end

  def route_table_association(); end

  def set_route_table(route_table); end

  def state(); end

  def subnet_id(); end

  def vpc(); end

  def vpc_id(); end
end

class AWS::EC2::Subnet
end

class AWS::EC2::SubnetCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](subnet_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def az_option(options); end

  def create(cidr_block, options=T.unsafe(nil)); end
end

class AWS::EC2::SubnetCollection
end

class AWS::EC2::Tag
  def _find_in_describe_tags_response_0(resp); end

  def delete(value=T.unsafe(nil)); end

  def get_resource(attr); end

  def initialize(resource, key, options=T.unsafe(nil)); end

  def key(); end

  def name(); end

  def resource(); end

  def value(); end
end

class AWS::EC2::Tag
end

class AWS::EC2::TagCollection
  def [](tag_name); end

  def create(resource, key, options=T.unsafe(nil)); end

  def each(&block); end
end

class AWS::EC2::TagCollection
end

module AWS::EC2::TaggedCollection
  def tagged(*keys); end

  def tagged_values(*values); end

  def with_tag(tag_key, *values); end
end

module AWS::EC2::TaggedCollection
end

module AWS::EC2::TaggedItem
  def add_tag(key, options=T.unsafe(nil)); end

  def cached_tags(); end

  def clear_tags(); end

  def tag(key, options=T.unsafe(nil)); end

  def tagging_resource_type(); end

  def tags(); end
end

module AWS::EC2::TaggedItem
end

class AWS::EC2::VPC
  include ::AWS::EC2::TaggedItem
  def _find_in_create_vpc_response_0(resp); end

  def _find_in_describe_vpcs_response_1(resp); end

  def cidr_block(); end

  def delete(); end

  def dhcp_options(); end

  def dhcp_options=(dhcp_options); end

  def dhcp_options_id(); end

  def dns_hostnames(); end

  def dns_hostnames=(enable_dns_hostnames); end

  def dns_support(); end

  def dns_support=(enable_dns_support); end

  def exists?(); end

  def id(); end

  def initialize(vpc_id, options=T.unsafe(nil)); end

  def instance_tenancy(); end

  def instances(); end

  def internet_gateway(); end

  def internet_gateway=(internet_gateway); end

  def is_default(); end

  def is_default?(); end

  def network_acls(); end

  def network_interfaces(); end

  def peer_to(vpc); end

  def peering_connections(); end

  def route_tables(); end

  def security_groups(); end

  def state(); end

  def subnets(); end

  def vpc_id(); end

  def vpn_gateway(); end
end

class AWS::EC2::VPC
end

class AWS::EC2::VPCCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](vpc_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(cidr_block, options=T.unsafe(nil)); end
end

class AWS::EC2::VPCCollection
end

class AWS::EC2::VPNConnection
  include ::AWS::EC2::TaggedItem
  def _find_in_create_vpn_connection_response_0(resp); end

  def _find_in_describe_vpn_connections_response_1(resp); end

  def customer_gateway(); end

  def customer_gateway_configuration(); end

  def customer_gateway_id(); end

  def delete(); end

  def id(); end

  def initialize(vpn_connection_id, options=T.unsafe(nil)); end

  def state(); end

  def vgw_telemetry(); end

  def vgw_telemetry_details(); end

  def vpn_connection_id(); end

  def vpn_gateway(); end

  def vpn_gateway_id(); end

  def vpn_type(); end
end

class AWS::EC2::VPNConnection::Telemetry
  def accepted_route_count(); end

  def initialize(vpn_connection, details); end

  def last_status_change(); end

  def outside_ip_address(); end

  def status(); end

  def status_message(); end

  def vpn_connection(); end
end

class AWS::EC2::VPNConnection::Telemetry
end

class AWS::EC2::VPNConnection
end

class AWS::EC2::VPNConnectionCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](vpn_connection_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(options=T.unsafe(nil)); end

  def customer_gateway_id(options); end

  def vpn_gateway_id(options); end
end

class AWS::EC2::VPNConnectionCollection
end

class AWS::EC2::VPNGateway
  include ::AWS::EC2::TaggedItem
  def _find_in_create_vpn_gateway_response_0(resp); end

  def _find_in_describe_vpn_gateways_response_1(resp); end

  def attach(vpc); end

  def attachment_set(); end

  def attachments(); end

  def delete(); end

  def detach(vpc); end

  def exists?(); end

  def id(); end

  def initialize(vpn_gateway_id, options=T.unsafe(nil)); end

  def state(); end

  def vpc(); end

  def vpc_id(vpc); end

  def vpn_connections(); end

  def vpn_gateway_id(); end

  def vpn_type(); end
end

class AWS::EC2::VPNGateway::Attachment
  def delete(); end

  def detach(); end

  def initialize(vpn_gateway, details); end

  def state(); end

  def vpc(); end

  def vpn_gateway(); end
end

class AWS::EC2::VPNGateway::Attachment
end

class AWS::EC2::VPNGateway
end

class AWS::EC2::VPNGatewayCollection
  include ::AWS::EC2::TaggedCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Collection
  def [](vpn_gateway_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(options=T.unsafe(nil)); end
end

class AWS::EC2::VPNGatewayCollection
end

class AWS::EC2::Volume
  include ::AWS::EC2::TaggedItem
  def _find_in_create_volume_response_0(resp); end

  def _find_in_describe_volumes_response_1(resp); end

  def attach(instance, device); end

  def attach_to(instance, device); end

  def attachment_set(); end

  def attachments(); end

  def availability_zone(); end

  def availability_zone_name(); end

  def create_snapshot(description=T.unsafe(nil)); end

  def create_time(); end

  def delete(); end

  def detach_from(instance, device, options=T.unsafe(nil)); end

  def encrypted(); end

  def encrypted?(); end

  def exists?(); end

  def id(); end

  def initialize(id, opts=T.unsafe(nil)); end

  def iops(); end

  def size(); end

  def snapshot(); end

  def snapshot_id(); end

  def state(); end

  def status(); end

  def type(); end
end

class AWS::EC2::Volume
end

class AWS::EC2::VolumeCollection
  include ::AWS::EC2::TaggedCollection
  def create(options=T.unsafe(nil)); end

  def each(&block); end
end

class AWS::EC2::VolumeCollection
end

class AWS::EC2
end

class AWS::ELB
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def load_balancers(); end
end

class AWS::ELB::AvailabilityZoneCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(options=T.unsafe(nil), &block); end

  def disable(*availability_zones); end

  def enable(*availability_zones); end

  def initialize(load_balancer, options=T.unsafe(nil)); end

  def load_balancer(); end
end

class AWS::ELB::AvailabilityZoneCollection
end

class AWS::ELB::BackendServerPolicyCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](instance_port); end

  def []=(instance_port, policy); end

  def _each_item(options=T.unsafe(nil)); end

  def initialize(load_balancer, options=T.unsafe(nil)); end

  def load_balancer(); end

  def policy_name(policy); end
end

class AWS::ELB::BackendServerPolicyCollection
end

class AWS::ELB::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::ELB::Client::V20120601
  def add_tags(*args, &block); end

  def apply_security_groups_to_load_balancer(*args, &block); end

  def attach_load_balancer_to_subnets(*args, &block); end

  def configure_health_check(*args, &block); end

  def create_app_cookie_stickiness_policy(*args, &block); end

  def create_lb_cookie_stickiness_policy(*args, &block); end

  def create_load_balancer(*args, &block); end

  def create_load_balancer_listeners(*args, &block); end

  def create_load_balancer_policy(*args, &block); end

  def delete_load_balancer(*args, &block); end

  def delete_load_balancer_listeners(*args, &block); end

  def delete_load_balancer_policy(*args, &block); end

  def deregister_instances_from_load_balancer(*args, &block); end

  def describe_instance_health(*args, &block); end

  def describe_load_balancer_attributes(*args, &block); end

  def describe_load_balancer_policies(*args, &block); end

  def describe_load_balancer_policy_types(*args, &block); end

  def describe_load_balancers(*args, &block); end

  def describe_tags(*args, &block); end

  def detach_load_balancer_from_subnets(*args, &block); end

  def disable_availability_zones_for_load_balancer(*args, &block); end

  def enable_availability_zones_for_load_balancer(*args, &block); end

  def modify_load_balancer_attributes(*args, &block); end

  def register_instances_with_load_balancer(*args, &block); end

  def remove_tags(*args, &block); end

  def set_load_balancer_listener_ssl_certificate(*args, &block); end

  def set_load_balancer_policies_for_backend_server(*args, &block); end

  def set_load_balancer_policies_of_listener(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::ELB::Client::V20120601
end

class AWS::ELB::Client
end

module AWS::ELB::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::ELB::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::ELB::InstanceCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](instance_id); end

  def _each_item(options=T.unsafe(nil)); end

  def add(*instances); end

  def deregister(*instances); end

  def health(*instances); end

  def initialize(load_balancer, options=T.unsafe(nil)); end

  def instance_ids(instances); end

  def load_balancer(); end

  def register(*instances); end

  def remove(*instances); end
end

class AWS::ELB::InstanceCollection
end

class AWS::ELB::Listener
  include ::AWS::Core::Model
  def ==(other); end

  def _description(); end

  def delete(); end

  def eql?(other); end

  def exists?(); end

  def initialize(load_balancer, port, options=T.unsafe(nil)); end

  def instance_port(); end

  def instance_protocol(); end

  def load_balancer(); end

  def policy(); end

  def policy=(policy_or_policy_name); end

  def port(); end

  def protocol(); end

  def remove_policy(); end

  def server_certificate(); end

  def server_certificate=(server_certificate); end
end

class AWS::ELB::Listener
end

class AWS::ELB::ListenerCollection
  include ::AWS::ELB::ListenerOpts
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](port); end

  def _each_item(options=T.unsafe(nil)); end

  def create(options=T.unsafe(nil)); end

  def initialize(load_balancer, options=T.unsafe(nil)); end

  def load_balancer(); end
end

class AWS::ELB::ListenerCollection
end

module AWS::ELB::ListenerOpts
  def format_listener_opts(options); end
end

module AWS::ELB::ListenerOpts
end

class AWS::ELB::LoadBalancer
  def _find_in_describe_load_balancers_response_0(resp); end

  def availability_zone_names(); end

  def availability_zones(); end

  def backend_server_descriptions(); end

  def backend_server_policies(); end

  def canonical_hosted_zone_name(); end

  def canonical_hosted_zone_name_id(); end

  def configure_health_check(options=T.unsafe(nil)); end

  def created_time(); end

  def delete(); end

  def dns_name(); end

  def exists?(); end

  def health_check(); end

  def health_check_configuration(); end

  def initialize(name, options=T.unsafe(nil)); end

  def instance_descriptions(); end

  def instances(); end

  def listener_descriptions(); end

  def listeners(); end

  def name(); end

  def policies(); end

  def policy_descriptions(); end

  def scheme(); end

  def security_group_ids(); end

  def security_groups(); end

  def source_security_group(); end

  def source_security_group_name(); end

  def source_security_group_owner_alias(); end

  def subnet_ids(); end

  def subnets(); end
end

class AWS::ELB::LoadBalancer
end

class AWS::ELB::LoadBalancerCollection
  include ::AWS::ELB::ListenerOpts
  include ::AWS::Core::Collection::WithNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def _each_item(marker, options=T.unsafe(nil), &block); end

  def create(name, options=T.unsafe(nil)); end
end

class AWS::ELB::LoadBalancerCollection
end

class AWS::ELB::LoadBalancerPolicy
  def _find_in_describe_load_balancer_policies_response_0(resp); end

  def attributes(); end

  def delete(); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def initialize(load_balancer, name, options=T.unsafe(nil)); end

  def load_balancer(); end

  def name(); end

  def policy_attribute_descriptions(); end

  def type(); end
end

class AWS::ELB::LoadBalancerPolicy
end

class AWS::ELB::LoadBalancerPolicyCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](policy_name); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(name, type, attributes=T.unsafe(nil)); end

  def initialize(load_balancer, options=T.unsafe(nil)); end

  def load_balancer(); end
end

class AWS::ELB::LoadBalancerPolicyCollection
end

class AWS::ELB
end

class AWS::EMR
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def job_flows(); end

  def jobs(); end
end

class AWS::EMR::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::EMR::Client::V20090331
  def add_instance_groups(*args, &block); end

  def add_job_flow_steps(*args, &block); end

  def add_tags(*args, &block); end

  def describe_cluster(*args, &block); end

  def describe_job_flows(*args, &block); end

  def describe_step(*args, &block); end

  def list_bootstrap_actions(*args, &block); end

  def list_clusters(*args, &block); end

  def list_instance_groups(*args, &block); end

  def list_instances(*args, &block); end

  def list_steps(*args, &block); end

  def modify_instance_groups(*args, &block); end

  def remove_tags(*args, &block); end

  def run_job_flow(*args, &block); end

  def set_termination_protection(*args, &block); end

  def set_visible_to_all_users(*args, &block); end

  def terminate_job_flows(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::EMR::Client::V20090331
end

class AWS::EMR::Client
end

module AWS::EMR::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::EMR::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::EMR::InstanceGroup
  def _find_in_describe_job_flows_response_0(resp); end

  def bid_price(); end

  def created_at(); end

  def creation_date_time(); end

  def end_date_time(); end

  def ended_at(); end

  def exists?(); end

  def find_in_response(resp); end

  def get_resource(attr=T.unsafe(nil)); end

  def id(); end

  def initialize(job_flow, instance_group_id, options=T.unsafe(nil)); end

  def instance_group_id(); end

  def instance_request_count(); end

  def instance_role(); end

  def instance_running_count(); end

  def instance_type(); end

  def job_flow(); end

  def last_state_change_reason(); end

  def market(); end

  def modify(options=T.unsafe(nil)); end

  def name(); end

  def ready_at(); end

  def ready_date_time(); end

  def set_instance_count(count); end

  def start_date_time(); end

  def started_at(); end

  def state(); end
end

class AWS::EMR::InstanceGroup
end

class AWS::EMR::InstanceGroupCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](instance_group_id); end

  def _each_item(options=T.unsafe(nil)); end

  def add(role, instance_type, instance_count, options=T.unsafe(nil)); end

  def create(role, instance_type, instance_count, options=T.unsafe(nil)); end

  def initialize(job_flow, options=T.unsafe(nil)); end

  def job_flow(); end
end

class AWS::EMR::InstanceGroupCollection
end

class AWS::EMR::JobFlow
  def _find_in_describe_job_flows_response_0(resp); end

  def add_steps(*steps); end

  def ami_version(); end

  def availability_zone(); end

  def availability_zone_name(); end

  def bootstrap_actions(); end

  def created_at(); end

  def creation_date_time(); end

  def delete(); end

  def disable_termination_protection(); end

  def ec2_key_name(); end

  def ec2_subnet_id(); end

  def enable_termination_protection(); end

  def end_date_time(); end

  def ended_at(); end

  def exists?(); end

  def get_resource(attr=T.unsafe(nil)); end

  def hadoop_version(); end

  def id(); end

  def initialize(job_flow_id, options=T.unsafe(nil)); end

  def instance_count(); end

  def instance_group_details(); end

  def instance_groups(); end

  def job_flow_id(); end

  def keep_job_flow_alive_when_no_steps(); end

  def keep_job_flow_alive_when_no_steps?(); end

  def last_state_change_reason(); end

  def log_uri(); end

  def master_instance(); end

  def master_instance_id(); end

  def master_instance_type(); end

  def master_public_dns_name(); end

  def name(); end

  def normalized_instance_hours(); end

  def ready_at(); end

  def ready_date_time(); end

  def set_termination_protection(state); end

  def set_visible_to_all_users(state); end

  def slave_instance(); end

  def slave_instance_type(); end

  def start_date_time(); end

  def started_at(); end

  def state(); end

  def step_details(); end

  def supported_products(); end

  def terminate(); end

  def termination_protected(); end

  def termination_protected?(); end
end

class AWS::EMR::JobFlow
end

class AWS::EMR::JobFlowCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](job_flow_id); end

  def _each_item(options=T.unsafe(nil), &block); end

  def create(name, options=T.unsafe(nil)); end

  def created_after(time); end

  def created_before(time); end

  def filter(name, value); end

  def initialize(options=T.unsafe(nil)); end

  def run(name, options=T.unsafe(nil)); end

  def with_id(*ids); end

  def with_state(*states); end
end

class AWS::EMR::JobFlowCollection
end

class AWS::EMR
end

class AWS::ElastiCache
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::ElastiCache::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::ElastiCache::Client::V20130615
  def authorize_cache_security_group_ingress(*args, &block); end

  def create_cache_cluster(*args, &block); end

  def create_cache_parameter_group(*args, &block); end

  def create_cache_security_group(*args, &block); end

  def create_cache_subnet_group(*args, &block); end

  def create_replication_group(*args, &block); end

  def delete_cache_cluster(*args, &block); end

  def delete_cache_parameter_group(*args, &block); end

  def delete_cache_security_group(*args, &block); end

  def delete_cache_subnet_group(*args, &block); end

  def delete_replication_group(*args, &block); end

  def describe_cache_clusters(*args, &block); end

  def describe_cache_engine_versions(*args, &block); end

  def describe_cache_parameter_groups(*args, &block); end

  def describe_cache_parameters(*args, &block); end

  def describe_cache_security_groups(*args, &block); end

  def describe_cache_subnet_groups(*args, &block); end

  def describe_engine_default_parameters(*args, &block); end

  def describe_events(*args, &block); end

  def describe_replication_groups(*args, &block); end

  def describe_reserved_cache_nodes(*args, &block); end

  def describe_reserved_cache_nodes_offerings(*args, &block); end

  def modify_cache_cluster(*args, &block); end

  def modify_cache_parameter_group(*args, &block); end

  def modify_cache_subnet_group(*args, &block); end

  def modify_replication_group(*args, &block); end

  def purchase_reserved_cache_nodes_offering(*args, &block); end

  def reboot_cache_cluster(*args, &block); end

  def reset_cache_parameter_group(*args, &block); end

  def revoke_cache_security_group_ingress(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::ElastiCache::Client::V20130615
end

class AWS::ElastiCache::Client::V20140324
  def authorize_cache_security_group_ingress(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_cache_cluster(*args, &block); end

  def create_cache_parameter_group(*args, &block); end

  def create_cache_security_group(*args, &block); end

  def create_cache_subnet_group(*args, &block); end

  def create_replication_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def delete_cache_cluster(*args, &block); end

  def delete_cache_parameter_group(*args, &block); end

  def delete_cache_security_group(*args, &block); end

  def delete_cache_subnet_group(*args, &block); end

  def delete_replication_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def describe_cache_clusters(*args, &block); end

  def describe_cache_engine_versions(*args, &block); end

  def describe_cache_parameter_groups(*args, &block); end

  def describe_cache_parameters(*args, &block); end

  def describe_cache_security_groups(*args, &block); end

  def describe_cache_subnet_groups(*args, &block); end

  def describe_engine_default_parameters(*args, &block); end

  def describe_events(*args, &block); end

  def describe_replication_groups(*args, &block); end

  def describe_reserved_cache_nodes(*args, &block); end

  def describe_reserved_cache_nodes_offerings(*args, &block); end

  def describe_snapshots(*args, &block); end

  def modify_cache_cluster(*args, &block); end

  def modify_cache_parameter_group(*args, &block); end

  def modify_cache_subnet_group(*args, &block); end

  def modify_replication_group(*args, &block); end

  def purchase_reserved_cache_nodes_offering(*args, &block); end

  def reboot_cache_cluster(*args, &block); end

  def reset_cache_parameter_group(*args, &block); end

  def revoke_cache_security_group_ingress(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::ElastiCache::Client::V20140324
end

class AWS::ElastiCache::Client::V20140715
  def authorize_cache_security_group_ingress(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_cache_cluster(*args, &block); end

  def create_cache_parameter_group(*args, &block); end

  def create_cache_security_group(*args, &block); end

  def create_cache_subnet_group(*args, &block); end

  def create_replication_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def delete_cache_cluster(*args, &block); end

  def delete_cache_parameter_group(*args, &block); end

  def delete_cache_security_group(*args, &block); end

  def delete_cache_subnet_group(*args, &block); end

  def delete_replication_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def describe_cache_clusters(*args, &block); end

  def describe_cache_engine_versions(*args, &block); end

  def describe_cache_parameter_groups(*args, &block); end

  def describe_cache_parameters(*args, &block); end

  def describe_cache_security_groups(*args, &block); end

  def describe_cache_subnet_groups(*args, &block); end

  def describe_engine_default_parameters(*args, &block); end

  def describe_events(*args, &block); end

  def describe_replication_groups(*args, &block); end

  def describe_reserved_cache_nodes(*args, &block); end

  def describe_reserved_cache_nodes_offerings(*args, &block); end

  def describe_snapshots(*args, &block); end

  def modify_cache_cluster(*args, &block); end

  def modify_cache_parameter_group(*args, &block); end

  def modify_cache_subnet_group(*args, &block); end

  def modify_replication_group(*args, &block); end

  def purchase_reserved_cache_nodes_offering(*args, &block); end

  def reboot_cache_cluster(*args, &block); end

  def reset_cache_parameter_group(*args, &block); end

  def revoke_cache_security_group_ingress(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::ElastiCache::Client::V20140715
end

class AWS::ElastiCache::Client::V20140930
  def authorize_cache_security_group_ingress(*args, &block); end

  def copy_snapshot(*args, &block); end

  def create_cache_cluster(*args, &block); end

  def create_cache_parameter_group(*args, &block); end

  def create_cache_security_group(*args, &block); end

  def create_cache_subnet_group(*args, &block); end

  def create_replication_group(*args, &block); end

  def create_snapshot(*args, &block); end

  def delete_cache_cluster(*args, &block); end

  def delete_cache_parameter_group(*args, &block); end

  def delete_cache_security_group(*args, &block); end

  def delete_cache_subnet_group(*args, &block); end

  def delete_replication_group(*args, &block); end

  def delete_snapshot(*args, &block); end

  def describe_cache_clusters(*args, &block); end

  def describe_cache_engine_versions(*args, &block); end

  def describe_cache_parameter_groups(*args, &block); end

  def describe_cache_parameters(*args, &block); end

  def describe_cache_security_groups(*args, &block); end

  def describe_cache_subnet_groups(*args, &block); end

  def describe_engine_default_parameters(*args, &block); end

  def describe_events(*args, &block); end

  def describe_replication_groups(*args, &block); end

  def describe_reserved_cache_nodes(*args, &block); end

  def describe_reserved_cache_nodes_offerings(*args, &block); end

  def describe_snapshots(*args, &block); end

  def modify_cache_cluster(*args, &block); end

  def modify_cache_parameter_group(*args, &block); end

  def modify_cache_subnet_group(*args, &block); end

  def modify_replication_group(*args, &block); end

  def purchase_reserved_cache_nodes_offering(*args, &block); end

  def reboot_cache_cluster(*args, &block); end

  def reset_cache_parameter_group(*args, &block); end

  def revoke_cache_security_group_ingress(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::ElastiCache::Client::V20140930
end

class AWS::ElastiCache::Client
end

module AWS::ElastiCache::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::ElastiCache::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::ElastiCache
end

class AWS::ElasticBeanstalk
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::ElasticBeanstalk::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::ElasticBeanstalk::Client::V20101201
  def check_dns_availability(*args, &block); end

  def create_application(*args, &block); end

  def create_application_version(*args, &block); end

  def create_configuration_template(*args, &block); end

  def create_environment(*args, &block); end

  def create_storage_location(*args, &block); end

  def delete_application(*args, &block); end

  def delete_application_version(*args, &block); end

  def delete_configuration_template(*args, &block); end

  def delete_environment_configuration(*args, &block); end

  def describe_application_versions(*args, &block); end

  def describe_applications(*args, &block); end

  def describe_configuration_options(*args, &block); end

  def describe_configuration_settings(*args, &block); end

  def describe_environment_resources(*args, &block); end

  def describe_environments(*args, &block); end

  def describe_events(*args, &block); end

  def list_available_solution_stacks(*args, &block); end

  def rebuild_environment(*args, &block); end

  def request_environment_info(*args, &block); end

  def restart_app_server(*args, &block); end

  def retrieve_environment_info(*args, &block); end

  def swap_environment_cnam_es(*args, &block); end

  def terminate_environment(*args, &block); end

  def update_application(*args, &block); end

  def update_application_version(*args, &block); end

  def update_configuration_template(*args, &block); end

  def update_environment(*args, &block); end

  def validate_configuration_settings(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::ElasticBeanstalk::Client::V20101201
end

class AWS::ElasticBeanstalk::Client
end

module AWS::ElasticBeanstalk::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::ElasticBeanstalk::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::ElasticBeanstalk
end

class AWS::ElasticTranscoder
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::ElasticTranscoder::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::ElasticTranscoder::Client::V20120925
  def cancel_job(*args, &block); end

  def create_job(*args, &block); end

  def create_pipeline(*args, &block); end

  def create_preset(*args, &block); end

  def delete_pipeline(*args, &block); end

  def delete_preset(*args, &block); end

  def list_jobs_by_pipeline(*args, &block); end

  def list_jobs_by_status(*args, &block); end

  def list_pipelines(*args, &block); end

  def list_presets(*args, &block); end

  def read_job(*args, &block); end

  def read_pipeline(*args, &block); end

  def read_preset(*args, &block); end

  def test_role(*args, &block); end

  def update_pipeline(*args, &block); end

  def update_pipeline_notifications(*args, &block); end

  def update_pipeline_status(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::ElasticTranscoder::Client::V20120925
end

class AWS::ElasticTranscoder::Client
end

module AWS::ElasticTranscoder::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::ElasticTranscoder::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::ElasticTranscoder
end

module AWS::Errors
end

class AWS::Errors::Base
  def code(); end

  def http_request(); end

  def http_response(); end

  def include_error_type(); end

  def initialize(req=T.unsafe(nil), resp=T.unsafe(nil), code=T.unsafe(nil), message=T.unsafe(nil)); end
end

class AWS::Errors::Base
end

module AWS::Errors::ClientError
end

module AWS::Errors::ClientError
  extend ::AWS::Errors::ExceptionMixinClassMethods
end

module AWS::Errors::ExceptionMixinClassMethods
  def new(*args); end
end

module AWS::Errors::ExceptionMixinClassMethods
end

class AWS::Errors::MissingCredentialsError
  def initialize(msg=T.unsafe(nil)); end
end

class AWS::Errors::MissingCredentialsError
end

module AWS::Errors::ServerError
end

module AWS::Errors::ServerError
  extend ::AWS::Errors::ExceptionMixinClassMethods
end

module AWS::Errors
end

class AWS::Glacier
  include ::AWS::Core::ServiceInterface
  def account_id(); end

  def account_id=(account_id); end

  def client(); end

  def config(); end

  def vaults(); end
end

class AWS::Glacier::Archive
  def archive_id(); end

  def delete(); end

  def id(); end

  def initialize(vault, archive_id, options=T.unsafe(nil)); end

  def vault(); end
end

class AWS::Glacier::Archive
end

class AWS::Glacier::ArchiveCollection
  include ::AWS::Core::Model
  def [](archive_id); end

  def account_id(); end

  def compute_checksums(data); end

  def compute_tree_hash(hashes); end

  def convert_to_io(data); end

  def create(data, options=T.unsafe(nil)); end

  def initialize(vault, options=T.unsafe(nil)); end

  def io_like?(data); end

  def vault(); end
end

class AWS::Glacier::ArchiveCollection
end

class AWS::Glacier::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::Glacier::Client::V20120601
  def abort_multipart_upload(*args, &block); end

  def complete_multipart_upload(*args, &block); end

  def create_vault(*args, &block); end

  def delete_archive(*args, &block); end

  def delete_vault(*args, &block); end

  def delete_vault_notifications(*args, &block); end

  def describe_job(*args, &block); end

  def describe_vault(*args, &block); end

  def get_job_output(*args, &block); end

  def get_vault_notifications(*args, &block); end

  def initiate_job(*args, &block); end

  def initiate_multipart_upload(*args, &block); end

  def list_jobs(*args, &block); end

  def list_multipart_uploads(*args, &block); end

  def list_parts(*args, &block); end

  def list_vaults(*args, &block); end

  def set_vault_notifications(*args, &block); end

  def upload_archive(*args, &block); end

  def upload_multipart_part(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::Glacier::Client::V20120601
end

class AWS::Glacier::Client
end

module AWS::Glacier::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::Glacier::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::Glacier::Resource
  def account_id(); end
end

class AWS::Glacier::Resource
end

class AWS::Glacier::Vault
  def _find_in_describe_vault_response_1(resp); end

  def _find_in_list_vaults_response_0(resp); end

  def archives(); end

  def arn(); end

  def configure_notifications(topic, events); end

  def creation_date(); end

  def delete(); end

  def exists?(); end

  def get_resource(attr=T.unsafe(nil)); end

  def initialize(name, options=T.unsafe(nil)); end

  def last_inventory_date(); end

  def name(); end

  def notification_configuration(); end

  def notification_configuration=(cfg); end

  def number_of_archives(); end

  def size_in_bytes(); end
end

class AWS::Glacier::Vault
end

class AWS::Glacier::VaultCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def _each_item(next_token, limit, options, &block); end

  def account_id(); end

  def create(name); end

  def initialize(options=T.unsafe(nil)); end
end

class AWS::Glacier::VaultCollection
end

class AWS::Glacier::VaultNotificationConfiguration
  def events(); end

  def events=(events); end

  def sns_topic(); end

  def sns_topic=(sns_topic); end

  def topic(); end
end

class AWS::Glacier::VaultNotificationConfiguration
end

class AWS::Glacier
end

class AWS::IAM
  include ::AWS::Core::ServiceInterface
  def access_keys(); end

  def account_alias(); end

  def account_alias=(account_alias); end

  def account_aliases(); end

  def account_password_policy(); end

  def account_summary(); end

  def change_password(old_password, new_password); end

  def client(); end

  def config(); end

  def delete_account_password_policy(); end

  def groups(); end

  def remove_account_alias(); end

  def server_certificates(); end

  def signing_certificates(); end

  def update_account_password_policy(options=T.unsafe(nil)); end

  def users(); end

  def virtual_mfa_devices(); end
end

class AWS::IAM::AccessKey
  def _find_in_create_access_key_response_0(resp); end

  def _find_in_list_access_keys_response_1(resp); end

  def access_key_id(); end

  def activate!(); end

  def active?(); end

  def create_date(); end

  def credentials(); end

  def deactivate!(); end

  def delete(); end

  def get_resource(attribute); end

  def id(); end

  def inactive?(); end

  def initialize(access_key_id, options=T.unsafe(nil)); end

  def matches_response_object?(obj); end

  def secret(); end

  def secret_access_key(); end

  def secret_value(); end

  def status(); end

  def status=(value); end

  def user(); end

  def user_name(); end
end

class AWS::IAM::AccessKey
end

class AWS::IAM::AccessKeyCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](access_key_id); end

  def clear(); end

  def create(); end

  def each_item(response, &block); end

  def initialize(options=T.unsafe(nil)); end

  def new_options(); end

  def user(); end
end

class AWS::IAM::AccessKeyCollection
end

class AWS::IAM::AccountAliasCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def create(account_alias); end

  def delete(account_alias); end

  def each_item(response, &block); end
end

class AWS::IAM::AccountAliasCollection
end

class AWS::IAM::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::IAM::Client::V20100508
  def add_client_id_to_open_id_connect_provider(*args, &block); end

  def add_role_to_instance_profile(*args, &block); end

  def add_user_to_group(*args, &block); end

  def attach_group_policy(*args, &block); end

  def attach_role_policy(*args, &block); end

  def attach_user_policy(*args, &block); end

  def change_password(*args, &block); end

  def create_access_key(*args, &block); end

  def create_account_alias(*args, &block); end

  def create_group(*args, &block); end

  def create_instance_profile(*args, &block); end

  def create_login_profile(*args, &block); end

  def create_open_id_connect_provider(*args, &block); end

  def create_policy(*args, &block); end

  def create_policy_version(*args, &block); end

  def create_role(*args, &block); end

  def create_saml_provider(*args, &block); end

  def create_user(*args, &block); end

  def create_virtual_mfa_device(*args, &block); end

  def deactivate_mfa_device(*args, &block); end

  def delete_access_key(*args, &block); end

  def delete_account_alias(*args, &block); end

  def delete_account_password_policy(*args, &block); end

  def delete_group(*args, &block); end

  def delete_group_policy(*args, &block); end

  def delete_instance_profile(*args, &block); end

  def delete_login_profile(*args, &block); end

  def delete_open_id_connect_provider(*args, &block); end

  def delete_policy(*args, &block); end

  def delete_policy_version(*args, &block); end

  def delete_role(*args, &block); end

  def delete_role_policy(*args, &block); end

  def delete_saml_provider(*args, &block); end

  def delete_server_certificate(*args, &block); end

  def delete_signing_certificate(*args, &block); end

  def delete_user(*args, &block); end

  def delete_user_policy(*args, &block); end

  def delete_virtual_mfa_device(*args, &block); end

  def detach_group_policy(*args, &block); end

  def detach_role_policy(*args, &block); end

  def detach_user_policy(*args, &block); end

  def enable_mfa_device(*args, &block); end

  def generate_credential_report(*args, &block); end

  def get_account_authorization_details(*args, &block); end

  def get_account_password_policy(*args, &block); end

  def get_account_summary(*args, &block); end

  def get_credential_report(*args, &block); end

  def get_group(*args, &block); end

  def get_group_policy(*args, &block); end

  def get_instance_profile(*args, &block); end

  def get_login_profile(*args, &block); end

  def get_open_id_connect_provider(*args, &block); end

  def get_policy(*args, &block); end

  def get_policy_version(*args, &block); end

  def get_role(*args, &block); end

  def get_role_policy(*args, &block); end

  def get_saml_provider(*args, &block); end

  def get_server_certificate(*args, &block); end

  def get_user(*args, &block); end

  def get_user_policy(*args, &block); end

  def list_access_keys(*args, &block); end

  def list_account_aliases(*args, &block); end

  def list_attached_group_policies(*args, &block); end

  def list_attached_role_policies(*args, &block); end

  def list_attached_user_policies(*args, &block); end

  def list_entities_for_policy(*args, &block); end

  def list_group_policies(*args, &block); end

  def list_groups(*args, &block); end

  def list_groups_for_user(*args, &block); end

  def list_instance_profiles(*args, &block); end

  def list_instance_profiles_for_role(*args, &block); end

  def list_mfa_devices(*args, &block); end

  def list_open_id_connect_providers(*args, &block); end

  def list_policies(*args, &block); end

  def list_policy_versions(*args, &block); end

  def list_role_policies(*args, &block); end

  def list_roles(*args, &block); end

  def list_saml_providers(*args, &block); end

  def list_server_certificates(*args, &block); end

  def list_signing_certificates(*args, &block); end

  def list_user_policies(*args, &block); end

  def list_users(*args, &block); end

  def list_virtual_mfa_devices(*args, &block); end

  def put_group_policy(*args, &block); end

  def put_role_policy(*args, &block); end

  def put_user_policy(*args, &block); end

  def remove_client_id_from_open_id_connect_provider(*args, &block); end

  def remove_role_from_instance_profile(*args, &block); end

  def remove_user_from_group(*args, &block); end

  def resync_mfa_device(*args, &block); end

  def set_default_policy_version(*args, &block); end

  def update_access_key(*args, &block); end

  def update_account_password_policy(*args, &block); end

  def update_assume_role_policy(*args, &block); end

  def update_group(*args, &block); end

  def update_login_profile(*args, &block); end

  def update_open_id_connect_provider_thumbprint(*args, &block); end

  def update_saml_provider(*args, &block); end

  def update_server_certificate(*args, &block); end

  def update_signing_certificate(*args, &block); end

  def update_user(*args, &block); end

  def upload_server_certificate(*args, &block); end

  def upload_signing_certificate(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::IAM::Client::V20100508
end

class AWS::IAM::Client
end

module AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(marker, max_items, options=T.unsafe(nil), &block); end

  def request_method(); end
end

module AWS::IAM::Collection::WithPrefix
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(marker, max_items, options=T.unsafe(nil), &block); end

  def initialize(options=T.unsafe(nil)); end

  def prefix(); end

  def with_prefix(prefix); end
end

module AWS::IAM::Collection::WithPrefix
end

module AWS::IAM::Collection
end

module AWS::IAM::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::IAM::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::IAM::Group
  def _find_in_get_group_or_create_group_response_0(resp); end

  def _find_in_list_groups_or_list_groups_for_user_response_1(resp); end

  def arn(); end

  def create_date(); end

  def delete(); end

  def id(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def name=(value); end

  def path(); end

  def path=(value); end

  def policies(); end

  def users(); end
end

class AWS::IAM::Group
end

class AWS::IAM::GroupCollection
  include ::AWS::IAM::Collection::WithPrefix
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def create(name, options=T.unsafe(nil)); end

  def each_item(response, &block); end
end

class AWS::IAM::GroupCollection
end

class AWS::IAM::GroupPolicyCollection
  include ::AWS::IAM::PolicyCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def group(); end

  def initialize(group, opts=T.unsafe(nil)); end
end

class AWS::IAM::GroupPolicyCollection
end

class AWS::IAM::GroupUserCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(options=T.unsafe(nil), &block); end

  def add(user); end

  def clear(); end

  def group(); end

  def initialize(group, options=T.unsafe(nil)); end

  def remove(user); end
end

class AWS::IAM::GroupUserCollection
end

class AWS::IAM::LoginProfile
  def _find_in_get_login_profile_or_create_login_profile_response_0(resp); end

  def create_date(); end

  def delete(); end

  def initialize(user, opts=T.unsafe(nil)); end

  def password=(password); end

  def password_reset_required=(bool); end

  def user(); end
end

class AWS::IAM::LoginProfile
end

class AWS::IAM::MFADevice
  include ::AWS::Core::Model
  def deactivate(); end

  def delete(); end

  def initialize(user, serial_number, options=T.unsafe(nil)); end

  def serial_number(); end

  def user(); end
end

class AWS::IAM::MFADevice
end

class AWS::IAM::MFADeviceCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](serial_number); end

  def clear(); end

  def create(serial_number, authentication_code_1, authentication_code_2); end

  def disable(serial_number); end

  def each_item(response, &block); end

  def enable(serial_number, authentication_code_1, authentication_code_2); end

  def initialize(user, options=T.unsafe(nil)); end

  def user(); end
end

class AWS::IAM::MFADeviceCollection
end

class AWS::IAM::Policy
end

class AWS::IAM::Policy::Statement
  ACTION_MAPPING = ::T.let(nil, ::T.untyped)
end

class AWS::IAM::Policy::Statement
end

class AWS::IAM::Policy
end

module AWS::IAM::PolicyCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def []=(name, document); end

  def clear(); end

  def client_opts(opts=T.unsafe(nil)); end

  def delete(name); end

  def delete_policy(opts=T.unsafe(nil)); end

  def each(opts=T.unsafe(nil), &block); end

  def each_item(response, &block); end

  def get_policy(opts=T.unsafe(nil)); end

  def has_key?(name); end

  def include?(name); end

  def key?(name); end

  def keys(); end

  def member?(name); end

  def names(); end

  def put_policy(opts=T.unsafe(nil)); end

  def request_method(); end

  def resource_name(); end

  def to_h(); end

  def values(); end

  def values_at(*names); end
end

module AWS::IAM::PolicyCollection
end

class AWS::IAM::Resource
  def exists?(); end
end

class AWS::IAM::Resource
  def self.prefix_update_attributes(prefix=T.unsafe(nil)); end

  def self.update_prefix(); end
end

class AWS::IAM::ServerCertificate
  def _find_in_get_server_certificate_response_0(resp); end

  def _find_in_get_server_certificate_response_1(resp); end

  def _find_in_list_server_certificates_response_3(resp); end

  def _find_in_upload_server_certificate_response_2(resp); end

  def arn(); end

  def certificate_body(); end

  def certificate_chain(); end

  def delete(); end

  def id(); end

  def initialize(name, opts=T.unsafe(nil)); end

  def name(); end

  def name=(value); end

  def path(); end

  def path=(value); end

  def upload_date(); end
end

class AWS::IAM::ServerCertificate
end

class AWS::IAM::ServerCertificateCollection
  include ::AWS::IAM::Collection::WithPrefix
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def create(options=T.unsafe(nil)); end

  def each_item(response, &block); end

  def upload(options=T.unsafe(nil)); end
end

class AWS::IAM::ServerCertificateCollection
end

class AWS::IAM::SigningCertificate
  def _find_in_list_signing_certificates_response_1(resp); end

  def _find_in_upload_signing_certificate_or_update_signing_certificate_response_0(resp); end

  def activate!(); end

  def active?(); end

  def contents(); end

  def deactivate!(); end

  def delete(); end

  def id(); end

  def inactive?(); end

  def initialize(certificate_id, options=T.unsafe(nil)); end

  def matches_response_object?(obj); end

  def status(); end

  def status=(value); end

  def upload_date(); end

  def user(); end

  def user_name(); end
end

class AWS::IAM::SigningCertificate
end

class AWS::IAM::SigningCertificateCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](certificate_id); end

  def clear(); end

  def create(certificate_body); end

  def each_item(response, &block); end

  def initialize(options=T.unsafe(nil)); end

  def new_options(); end

  def upload(certificate_body); end

  def user(); end
end

class AWS::IAM::SigningCertificateCollection
end

class AWS::IAM::User
  def _find_in_create_user_or_get_user_response_0(resp); end

  def _find_in_list_users_or_get_group_response_1(resp); end

  def access_keys(); end

  def arn(); end

  def create_date(); end

  def delete(); end

  def delete!(); end

  def groups(); end

  def id(); end

  def initialize(name, options=T.unsafe(nil)); end

  def login_profile(); end

  def mfa_devices(); end

  def name(); end

  def name=(value); end

  def path(); end

  def path=(value); end

  def policies(); end

  def signing_certificates(); end
end

class AWS::IAM::User
end

class AWS::IAM::UserCollection
  include ::AWS::IAM::Collection::WithPrefix
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def create(name, options=T.unsafe(nil)); end

  def each_item(response, &block); end
end

class AWS::IAM::UserCollection
end

class AWS::IAM::UserGroupCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def add(group); end

  def clear(); end

  def each_item(response); end

  def initialize(user, opts=T.unsafe(nil)); end

  def remove(group); end

  def user(); end
end

class AWS::IAM::UserGroupCollection
end

class AWS::IAM::UserPolicy
  def delete(); end

  def initialize(user, name, options=T.unsafe(nil)); end

  def name(); end

  def policy(); end

  def policy=(policy); end

  def user(); end
end

module AWS::IAM::UserPolicy::PolicyProxy
  def change(); end

  def user_policy(); end

  def user_policy=(user_policy); end
end

module AWS::IAM::UserPolicy::PolicyProxy
end

class AWS::IAM::UserPolicy
end

class AWS::IAM::UserPolicyCollection
  include ::AWS::IAM::PolicyCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def initialize(user, options=T.unsafe(nil)); end

  def user(); end
end

class AWS::IAM::UserPolicyCollection
end

class AWS::IAM::VirtualMfaDevice
  def _find_in_create_virtual_mfa_device_response_0(resp); end

  def _find_in_list_virtual_mfa_devices_response_1(resp); end

  def arn(); end

  def base_32_string_seed(); end

  def deactivate(); end

  def delete(); end

  def disable(); end

  def enable(user, code1, code2); end

  def enable_date(); end

  def enabled?(); end

  def format_auth_code(code); end

  def get_resource(attr_name); end

  def initialize(serial_number, options=T.unsafe(nil)); end

  def qr_code_png(); end

  def serial_number(); end

  def user(); end

  def user_details(); end
end

class AWS::IAM::VirtualMfaDevice
end

class AWS::IAM::VirtualMfaDeviceCollection
  include ::AWS::IAM::Collection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](serial_number); end

  def create(name, options=T.unsafe(nil)); end

  def each_item(response); end

  def limit_key(); end

  def next_token_key(); end
end

class AWS::IAM::VirtualMfaDeviceCollection
end

class AWS::IAM
end

class AWS::ImportExport
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::ImportExport::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::ImportExport::Client::V20100601
  def cancel_job(*args, &block); end

  def create_job(*args, &block); end

  def get_status(*args, &block); end

  def list_jobs(*args, &block); end

  def update_job(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::ImportExport::Client::V20100601
end

class AWS::ImportExport::Client
end

module AWS::ImportExport::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::ImportExport::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::ImportExport
end

class AWS::Kinesis
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::Kinesis::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::Kinesis::Client::V20131202
  def add_tags_to_stream(*args, &block); end

  def create_stream(*args, &block); end

  def delete_stream(*args, &block); end

  def describe_stream(*args, &block); end

  def get_records(*args, &block); end

  def get_shard_iterator(*args, &block); end

  def list_streams(*args, &block); end

  def list_tags_for_stream(*args, &block); end

  def merge_shards(*args, &block); end

  def put_record(*args, &block); end

  def put_records(*args, &block); end

  def remove_tags_from_stream(*args, &block); end

  def split_shard(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::Kinesis::Client::V20131202
end

class AWS::Kinesis::Client
end

module AWS::Kinesis::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::Kinesis::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::Kinesis
end

class AWS::OpsWorks
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::OpsWorks::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::OpsWorks::Client::V20130218
  def assign_instance(*args, &block); end

  def assign_volume(*args, &block); end

  def associate_elastic_ip(*args, &block); end

  def attach_elastic_load_balancer(*args, &block); end

  def clone_stack(*args, &block); end

  def create_app(*args, &block); end

  def create_deployment(*args, &block); end

  def create_instance(*args, &block); end

  def create_layer(*args, &block); end

  def create_stack(*args, &block); end

  def create_user_profile(*args, &block); end

  def delete_app(*args, &block); end

  def delete_instance(*args, &block); end

  def delete_layer(*args, &block); end

  def delete_stack(*args, &block); end

  def delete_user_profile(*args, &block); end

  def deregister_elastic_ip(*args, &block); end

  def deregister_instance(*args, &block); end

  def deregister_rds_db_instance(*args, &block); end

  def deregister_volume(*args, &block); end

  def describe_agent_versions(*args, &block); end

  def describe_apps(*args, &block); end

  def describe_commands(*args, &block); end

  def describe_deployments(*args, &block); end

  def describe_elastic_ips(*args, &block); end

  def describe_elastic_load_balancers(*args, &block); end

  def describe_instances(*args, &block); end

  def describe_layers(*args, &block); end

  def describe_load_based_auto_scaling(*args, &block); end

  def describe_my_user_profile(*args, &block); end

  def describe_permissions(*args, &block); end

  def describe_raid_arrays(*args, &block); end

  def describe_rds_db_instances(*args, &block); end

  def describe_service_errors(*args, &block); end

  def describe_stack_provisioning_parameters(*args, &block); end

  def describe_stack_summary(*args, &block); end

  def describe_stacks(*args, &block); end

  def describe_time_based_auto_scaling(*args, &block); end

  def describe_user_profiles(*args, &block); end

  def describe_volumes(*args, &block); end

  def detach_elastic_load_balancer(*args, &block); end

  def disassociate_elastic_ip(*args, &block); end

  def get_hostname_suggestion(*args, &block); end

  def grant_access(*args, &block); end

  def reboot_instance(*args, &block); end

  def register_elastic_ip(*args, &block); end

  def register_instance(*args, &block); end

  def register_rds_db_instance(*args, &block); end

  def register_volume(*args, &block); end

  def set_load_based_auto_scaling(*args, &block); end

  def set_permission(*args, &block); end

  def set_time_based_auto_scaling(*args, &block); end

  def start_instance(*args, &block); end

  def start_stack(*args, &block); end

  def stop_instance(*args, &block); end

  def stop_stack(*args, &block); end

  def unassign_instance(*args, &block); end

  def unassign_volume(*args, &block); end

  def update_app(*args, &block); end

  def update_elastic_ip(*args, &block); end

  def update_instance(*args, &block); end

  def update_layer(*args, &block); end

  def update_my_user_profile(*args, &block); end

  def update_rds_db_instance(*args, &block); end

  def update_stack(*args, &block); end

  def update_user_profile(*args, &block); end

  def update_volume(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::OpsWorks::Client::V20130218
end

class AWS::OpsWorks::Client
end

module AWS::OpsWorks::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::OpsWorks::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::OpsWorks
end

class AWS::RDS
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def db_instances(); end

  def db_snapshots(); end

  def instances(); end

  def snapshots(); end
end

class AWS::RDS::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::RDS::Client::V20130515
  def add_source_identifier_to_subscription(*args, &block); end

  def add_tags_to_resource(*args, &block); end

  def authorize_db_security_group_ingress(*args, &block); end

  def copy_db_snapshot(*args, &block); end

  def create_db_instance(*args, &block); end

  def create_db_instance_read_replica(*args, &block); end

  def create_db_parameter_group(*args, &block); end

  def create_db_security_group(*args, &block); end

  def create_db_snapshot(*args, &block); end

  def create_db_subnet_group(*args, &block); end

  def create_event_subscription(*args, &block); end

  def create_option_group(*args, &block); end

  def delete_db_instance(*args, &block); end

  def delete_db_parameter_group(*args, &block); end

  def delete_db_security_group(*args, &block); end

  def delete_db_snapshot(*args, &block); end

  def delete_db_subnet_group(*args, &block); end

  def delete_event_subscription(*args, &block); end

  def delete_option_group(*args, &block); end

  def describe_db_engine_versions(*args, &block); end

  def describe_db_instances(*args, &block); end

  def describe_db_log_files(*args, &block); end

  def describe_db_parameter_groups(*args, &block); end

  def describe_db_parameters(*args, &block); end

  def describe_db_security_groups(*args, &block); end

  def describe_db_snapshots(*args, &block); end

  def describe_db_subnet_groups(*args, &block); end

  def describe_engine_default_parameters(*args, &block); end

  def describe_event_categories(*args, &block); end

  def describe_event_subscriptions(*args, &block); end

  def describe_events(*args, &block); end

  def describe_option_group_options(*args, &block); end

  def describe_option_groups(*args, &block); end

  def describe_orderable_db_instance_options(*args, &block); end

  def describe_reserved_db_instances(*args, &block); end

  def describe_reserved_db_instances_offerings(*args, &block); end

  def download_db_log_file_portion(*args, &block); end

  def list_tags_for_resource(*args, &block); end

  def modify_db_instance(*args, &block); end

  def modify_db_parameter_group(*args, &block); end

  def modify_db_subnet_group(*args, &block); end

  def modify_event_subscription(*args, &block); end

  def modify_option_group(*args, &block); end

  def promote_read_replica(*args, &block); end

  def purchase_reserved_db_instances_offering(*args, &block); end

  def reboot_db_instance(*args, &block); end

  def remove_source_identifier_from_subscription(*args, &block); end

  def remove_tags_from_resource(*args, &block); end

  def reset_db_parameter_group(*args, &block); end

  def restore_db_instance_from_db_snapshot(*args, &block); end

  def restore_db_instance_to_point_in_time(*args, &block); end

  def revoke_db_security_group_ingress(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::RDS::Client::V20130515
end

class AWS::RDS::Client::V20130909
  def add_source_identifier_to_subscription(*args, &block); end

  def add_tags_to_resource(*args, &block); end

  def authorize_db_security_group_ingress(*args, &block); end

  def copy_db_snapshot(*args, &block); end

  def create_db_instance(*args, &block); end

  def create_db_instance_read_replica(*args, &block); end

  def create_db_parameter_group(*args, &block); end

  def create_db_security_group(*args, &block); end

  def create_db_snapshot(*args, &block); end

  def create_db_subnet_group(*args, &block); end

  def create_event_subscription(*args, &block); end

  def create_option_group(*args, &block); end

  def delete_db_instance(*args, &block); end

  def delete_db_parameter_group(*args, &block); end

  def delete_db_security_group(*args, &block); end

  def delete_db_snapshot(*args, &block); end

  def delete_db_subnet_group(*args, &block); end

  def delete_event_subscription(*args, &block); end

  def delete_option_group(*args, &block); end

  def describe_db_engine_versions(*args, &block); end

  def describe_db_instances(*args, &block); end

  def describe_db_log_files(*args, &block); end

  def describe_db_parameter_groups(*args, &block); end

  def describe_db_parameters(*args, &block); end

  def describe_db_security_groups(*args, &block); end

  def describe_db_snapshots(*args, &block); end

  def describe_db_subnet_groups(*args, &block); end

  def describe_engine_default_parameters(*args, &block); end

  def describe_event_categories(*args, &block); end

  def describe_event_subscriptions(*args, &block); end

  def describe_events(*args, &block); end

  def describe_option_group_options(*args, &block); end

  def describe_option_groups(*args, &block); end

  def describe_orderable_db_instance_options(*args, &block); end

  def describe_reserved_db_instances(*args, &block); end

  def describe_reserved_db_instances_offerings(*args, &block); end

  def download_db_log_file_portion(*args, &block); end

  def list_tags_for_resource(*args, &block); end

  def modify_db_instance(*args, &block); end

  def modify_db_parameter_group(*args, &block); end

  def modify_db_subnet_group(*args, &block); end

  def modify_event_subscription(*args, &block); end

  def modify_option_group(*args, &block); end

  def promote_read_replica(*args, &block); end

  def purchase_reserved_db_instances_offering(*args, &block); end

  def reboot_db_instance(*args, &block); end

  def remove_source_identifier_from_subscription(*args, &block); end

  def remove_tags_from_resource(*args, &block); end

  def reset_db_parameter_group(*args, &block); end

  def restore_db_instance_from_db_snapshot(*args, &block); end

  def restore_db_instance_to_point_in_time(*args, &block); end

  def revoke_db_security_group_ingress(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::RDS::Client::V20130909
end

class AWS::RDS::Client::V20140901
  def add_source_identifier_to_subscription(*args, &block); end

  def add_tags_to_resource(*args, &block); end

  def authorize_db_security_group_ingress(*args, &block); end

  def copy_db_parameter_group(*args, &block); end

  def copy_db_snapshot(*args, &block); end

  def copy_option_group(*args, &block); end

  def create_db_instance(*args, &block); end

  def create_db_instance_read_replica(*args, &block); end

  def create_db_parameter_group(*args, &block); end

  def create_db_security_group(*args, &block); end

  def create_db_snapshot(*args, &block); end

  def create_db_subnet_group(*args, &block); end

  def create_event_subscription(*args, &block); end

  def create_option_group(*args, &block); end

  def delete_db_instance(*args, &block); end

  def delete_db_parameter_group(*args, &block); end

  def delete_db_security_group(*args, &block); end

  def delete_db_snapshot(*args, &block); end

  def delete_db_subnet_group(*args, &block); end

  def delete_event_subscription(*args, &block); end

  def delete_option_group(*args, &block); end

  def describe_db_engine_versions(*args, &block); end

  def describe_db_instances(*args, &block); end

  def describe_db_log_files(*args, &block); end

  def describe_db_parameter_groups(*args, &block); end

  def describe_db_parameters(*args, &block); end

  def describe_db_security_groups(*args, &block); end

  def describe_db_snapshots(*args, &block); end

  def describe_db_subnet_groups(*args, &block); end

  def describe_engine_default_parameters(*args, &block); end

  def describe_event_categories(*args, &block); end

  def describe_event_subscriptions(*args, &block); end

  def describe_events(*args, &block); end

  def describe_option_group_options(*args, &block); end

  def describe_option_groups(*args, &block); end

  def describe_orderable_db_instance_options(*args, &block); end

  def describe_reserved_db_instances(*args, &block); end

  def describe_reserved_db_instances_offerings(*args, &block); end

  def download_db_log_file_portion(*args, &block); end

  def list_tags_for_resource(*args, &block); end

  def modify_db_instance(*args, &block); end

  def modify_db_parameter_group(*args, &block); end

  def modify_db_subnet_group(*args, &block); end

  def modify_event_subscription(*args, &block); end

  def modify_option_group(*args, &block); end

  def promote_read_replica(*args, &block); end

  def purchase_reserved_db_instances_offering(*args, &block); end

  def reboot_db_instance(*args, &block); end

  def remove_source_identifier_from_subscription(*args, &block); end

  def remove_tags_from_resource(*args, &block); end

  def reset_db_parameter_group(*args, &block); end

  def restore_db_instance_from_db_snapshot(*args, &block); end

  def restore_db_instance_to_point_in_time(*args, &block); end

  def revoke_db_security_group_ingress(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::RDS::Client::V20140901
end

class AWS::RDS::Client
end

class AWS::RDS::DBInstance
  def _find_in_create_db_instance_response_0(resp); end

  def _find_in_describe_db_instances_response_1(resp); end

  def allocated_storage(); end

  def auto_minor_version_upgrade(); end

  def availability_zone_name(); end

  def backup_retention_period(); end

  def character_set_name(); end

  def create_snapshot(db_snapshot_id); end

  def created_at(); end

  def creation_date_time(); end

  def db_instance_class(); end

  def db_instance_id(); end

  def db_instance_identifier(); end

  def db_instance_status(); end

  def db_name(); end

  def delete(options=T.unsafe(nil)); end

  def endpoint_address(); end

  def endpoint_port(); end

  def engine(); end

  def engine_version(); end

  def exists?(); end

  def get_resource(attr=T.unsafe(nil)); end

  def id(); end

  def initialize(db_instance_id, options=T.unsafe(nil)); end

  def iops(); end

  def latest_restorable_time(); end

  def license_model(); end

  def master_username(); end

  def modify(options=T.unsafe(nil)); end

  def multi_az(); end

  def multi_az?(); end

  def name(); end

  def preferred_backup_window(); end

  def preferred_maintenance_window(); end

  def read_replica_db_instance_identifiers(); end

  def read_replica_source_db_instance_identifier(); end

  def reboot(options=T.unsafe(nil)); end

  def size(); end

  def snapshots(); end

  def status(); end

  def vpc(); end

  def vpc_id(); end
end

class AWS::RDS::DBInstance
end

class AWS::RDS::DBInstanceCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](db_instance_id); end

  def _each_item(marker, max_records, options=T.unsafe(nil), &block); end

  def create(db_instance_id, options=T.unsafe(nil)); end
end

class AWS::RDS::DBInstanceCollection
end

class AWS::RDS::DBSnapshot
  def _find_in_create_db_snapshot_or_copy_db_snapshot_response_0(resp); end

  def _find_in_describe_db_snapshots_response_1(resp); end

  def allocated_storage(); end

  def availability_zone_name(); end

  def copy(new_snapshot_id); end

  def created_at(); end

  def db_instance(); end

  def db_instance_id(); end

  def db_instance_identifier(); end

  def db_snapshot_id(); end

  def db_snapshot_identifier(); end

  def db_snapshot_status(); end

  def delete(); end

  def engine(); end

  def engine_version(); end

  def exists?(); end

  def get_resource(attr=T.unsafe(nil)); end

  def id(); end

  def initialize(db_snapshot_id, options=T.unsafe(nil)); end

  def instance_create_time(); end

  def license_model(); end

  def master_username(); end

  def port(); end

  def restore_instance(options=T.unsafe(nil)); end

  def size(); end

  def snapshot_type(); end

  def status(); end

  def type(); end

  def vpc_id(); end
end

class AWS::RDS::DBSnapshot
end

class AWS::RDS::DBSnapshotCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](db_snapshot_id); end

  def _each_item(marker, max_records, options=T.unsafe(nil), &block); end

  def db_instance(db_instance); end

  def filter(name, value); end

  def initialize(options=T.unsafe(nil)); end

  def type(snapshot_type); end

  def with_type(snapshot_type); end
end

class AWS::RDS::DBSnapshotCollection
end

module AWS::RDS::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::RDS::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::RDS
end

module AWS::Rails
end

module AWS::Rails
  def self.add_action_mailer_delivery_method(name=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.load_yaml_config(); end

  def self.log_to_rails_logger(); end

  def self.rails_env(); end

  def self.rails_logger(); end

  def self.rails_root(); end

  def self.setup(); end
end

class AWS::Railtie
end

class AWS::Railtie
end

module AWS::Record
end

module AWS::Record::AbstractBase
end

module AWS::Record::AbstractBase::ClassMethods
  def add_attribute(attribute); end

  def attribute_for(attribute_name, &block); end

  def attributes(); end

  def create(attributes=T.unsafe(nil)); end

  def create!(attributes=T.unsafe(nil)); end

  def domain_name(name=T.unsafe(nil)); end

  def new_scope(); end

  def optimistic_locking(attribute_name=T.unsafe(nil)); end

  def optimistic_locking?(); end

  def optimistic_locking_attr(); end

  def remove_attribute(attribute); end

  def scope(name, scope=T.unsafe(nil), &block); end

  def set_domain_name(name); end

  def set_shard_name(name); end

  def shard_name(name=T.unsafe(nil)); end

  def shard_name=(name); end
end

module AWS::Record::AbstractBase::ClassMethods
end

module AWS::Record::AbstractBase::InstanceMethods
  def [](attribute_name); end

  def []=(attribute_name, new_value); end

  def attributes(); end

  def attributes=(attributes); end

  def create(); end

  def create_storage(); end

  def delete(); end

  def delete_storage(); end

  def deleted?(); end

  def destroy(); end

  def domain(); end

  def errors(); end

  def hydrate(id, data); end

  def if_locks_optimistically(&block); end

  def increment_optimistic_lock_value(); end

  def initialize(attributes=T.unsafe(nil)); end

  def new_record?(); end

  def opt_lock_conditions(); end

  def persisted?(); end

  def save(opts=T.unsafe(nil)); end

  def save!(); end

  def shard(); end

  def touch_timestamps(*attributes); end

  def update_attributes(attribute_hash); end

  def update_attributes!(attribute_hash); end

  def update_storage(); end

  def valid?(opts=T.unsafe(nil)); end
end

module AWS::Record::AbstractBase::InstanceMethods
end

module AWS::Record::AbstractBase
  def self.extended(base); end
end

class AWS::Record::AcceptanceValidator
  def message(); end

  def setup(record_class); end

  def validate_attribute(record, attribute_name, value); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::AcceptanceValidator
end

module AWS::Record::Attributes
end

class AWS::Record::Attributes::BaseAttr
  def default_value(); end

  def deserialize(serialized_value); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def options(); end

  def persist_as(); end

  def serialize(type_casted_value); end

  def set?(); end

  def type_cast(raw_value); end
end

class AWS::Record::Attributes::BaseAttr
  def self.allow_set?(); end

  def self.deserialize(serialized_value, options=T.unsafe(nil)); end

  def self.expect(klass, value, &block); end
end

class AWS::Record::Attributes::BooleanAttr
end

class AWS::Record::Attributes::BooleanAttr
  def self.serialize(boolean, options=T.unsafe(nil)); end

  def self.type_cast(raw_value, options=T.unsafe(nil)); end
end

class AWS::Record::Attributes::DateAttr
end

class AWS::Record::Attributes::DateAttr
  def self.serialize(date, options=T.unsafe(nil)); end

  def self.type_cast(raw_value, options=T.unsafe(nil)); end
end

class AWS::Record::Attributes::DateTimeAttr
end

class AWS::Record::Attributes::DateTimeAttr
  def self.serialize(datetime, options=T.unsafe(nil)); end

  def self.type_cast(raw_value, options=T.unsafe(nil)); end
end

class AWS::Record::Attributes::FloatAttr
end

class AWS::Record::Attributes::FloatAttr
  def self.serialize(float, options=T.unsafe(nil)); end

  def self.type_cast(raw_value, options=T.unsafe(nil)); end
end

class AWS::Record::Attributes::IntegerAttr
end

class AWS::Record::Attributes::IntegerAttr
  def self.serialize(integer, options=T.unsafe(nil)); end

  def self.type_cast(raw_value, options=T.unsafe(nil)); end
end

class AWS::Record::Attributes::StringAttr
end

class AWS::Record::Attributes::StringAttr
  def self.serialize(string, options=T.unsafe(nil)); end

  def self.type_cast(raw_value, options=T.unsafe(nil)); end
end

module AWS::Record::Attributes
end

AWS::Record::Base = AWS::Record::Model

class AWS::Record::BlockValidator
  def block(); end

  def initialize(*args, &block); end

  def validate_attribute(record, attribute_name, value); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::BlockValidator
end

class AWS::Record::ConfirmationValidator
  def message(); end

  def setup(record_class); end

  def validate_attribute(record, attribute_name, value); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::ConfirmationValidator
end

module AWS::Record::Conversion
  def to_key(); end

  def to_model(); end

  def to_param(); end
end

module AWS::Record::Conversion
end

class AWS::Record::CountValidator
  def interpolate(message_with_placeholders, values); end

  def setup(record_class); end

  def too_few(min, got); end

  def too_many(max, got); end

  def validate_attribute(record, attribute_name, value); end

  def wrong_number(exactly, got); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::CountValidator
end

module AWS::Record::DirtyTracking
  def changed(); end

  def changed?(); end

  def changes(); end
end

module AWS::Record::DirtyTracking
end

class AWS::Record::EmptyRecordError
  def initialize(record); end

  def record(); end
end

class AWS::Record::EmptyRecordError
end

class AWS::Record::Errors
  def [](attribute_name); end

  def []=(attribute_name, message=T.unsafe(nil)); end

  def add(attribute_name, message=T.unsafe(nil)); end

  def add_to_base(message); end

  def clear!(); end

  def count(); end

  def each(&block); end

  def full_messages(); end

  def on(attribute_name); end
end

class AWS::Record::Errors
end

class AWS::Record::ExclusionValidator
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::ExclusionValidator
end

class AWS::Record::FormatValidator
  def message(); end

  def setup(record_class); end

  def validate_attribute(record, attribute_name, value_or_values); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::FormatValidator
end

class AWS::Record::HashModel
  include ::AWS::Record::AbstractBase::InstanceMethods
  include ::AWS::Record::DirtyTracking
  include ::AWS::Record::Naming
  include ::AWS::Record::Conversion
  def hash_key(); end
end

class AWS::Record::HashModel::Scope
end

class AWS::Record::HashModel::Scope
end

class AWS::Record::HashModel
  extend ::AWS::Record::AbstractBase
  extend ::AWS::Record::AbstractBase::ClassMethods
  extend ::AWS::Record::Validations
  extend ::AWS::Record::Naming
  def self.[](id, options=T.unsafe(nil)); end

  def self.all(options=T.unsafe(nil)); end

  def self.binary_attr(name, options=T.unsafe(nil)); end

  def self.boolean_attr(name, options=T.unsafe(nil)); end

  def self.count(options=T.unsafe(nil)); end

  def self.create_table(read_capacity_units, write_capacity_units, options=T.unsafe(nil)); end

  def self.date_attr(name, options=T.unsafe(nil)); end

  def self.datetime_attr(name, options=T.unsafe(nil)); end

  def self.domain(shard_name); end

  def self.dynamo_db_table(shard_name=T.unsafe(nil)); end

  def self.each(&block); end

  def self.find(*args); end

  def self.find_by_id(id, options=T.unsafe(nil)); end

  def self.first(options=T.unsafe(nil)); end

  def self.float_attr(name, options=T.unsafe(nil)); end

  def self.hash_key(); end

  def self.hash_key_attribute(); end

  def self.inherited(sub_class); end

  def self.integer_attr(name, options=T.unsafe(nil)); end

  def self.limit(limit); end

  def self.shard(shard_name); end

  def self.size(options=T.unsafe(nil)); end

  def self.string_attr(name, options=T.unsafe(nil)); end

  def self.timestamps(); end
end

class AWS::Record::InclusionValidator
  def message(); end

  def setup(record_class); end

  def validate_attribute(record, attribute_name, value_or_values); end

  def value_included?(value); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::InclusionValidator
end

class AWS::Record::InvalidRecordError
  def initialize(record); end

  def record(); end
end

class AWS::Record::InvalidRecordError
end

class AWS::Record::LengthValidator
  def interpolate(message_with_placeholders, values); end

  def setup(record_class); end

  def too_long(max, got); end

  def too_short(min, got); end

  def validate_attribute(record, attribute_name, value_or_values); end

  def wrong_length(exactly, got); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::LengthValidator
end

class AWS::Record::MethodValidator
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::MethodValidator
end

class AWS::Record::Model
  include ::AWS::Record::AbstractBase::InstanceMethods
  include ::AWS::Record::DirtyTracking
  include ::AWS::Record::Naming
  include ::AWS::Record::Conversion
  def id(); end
end

module AWS::Record::Model::Attributes
end

class AWS::Record::Model::Attributes::BooleanAttr
end

class AWS::Record::Model::Attributes::BooleanAttr
end

class AWS::Record::Model::Attributes::FloatAttr
end

class AWS::Record::Model::Attributes::FloatAttr
end

class AWS::Record::Model::Attributes::IntegerAttr
end

class AWS::Record::Model::Attributes::IntegerAttr
end

class AWS::Record::Model::Attributes::SortableFloatAttr
end

class AWS::Record::Model::Attributes::SortableFloatAttr
  def self.deserialize(string_value, options=T.unsafe(nil)); end
end

class AWS::Record::Model::Attributes::SortableIntegerAttr
end

class AWS::Record::Model::Attributes::SortableIntegerAttr
  def self.check_range(number, options); end

  def self.deserialize(string_value, options=T.unsafe(nil)); end

  def self.offset_and_precision(options, &block); end
end

module AWS::Record::Model::Attributes
end

class AWS::Record::Model::Scope
  def order(attribute_name, order=T.unsafe(nil)); end

  def where(*conditions); end
end

class AWS::Record::Model::Scope
end

class AWS::Record::Model
  extend ::AWS::Record::AbstractBase
  extend ::AWS::Record::AbstractBase::ClassMethods
  extend ::AWS::Record::Validations
  extend ::AWS::Record::Naming
  def self.[](id, options=T.unsafe(nil)); end

  def self.all(options=T.unsafe(nil)); end

  def self.boolean_attr(name, options=T.unsafe(nil)); end

  def self.count(options=T.unsafe(nil)); end

  def self.create_domain(shard_name=T.unsafe(nil)); end

  def self.date_attr(name, options=T.unsafe(nil)); end

  def self.datetime_attr(name, options=T.unsafe(nil)); end

  def self.domain(shard_name); end

  def self.each(&block); end

  def self.find(*args); end

  def self.find_by_id(id, options=T.unsafe(nil)); end

  def self.first(options=T.unsafe(nil)); end

  def self.float_attr(name, options=T.unsafe(nil)); end

  def self.integer_attr(name, options=T.unsafe(nil)); end

  def self.limit(limit); end

  def self.order(*args); end

  def self.sdb(); end

  def self.sdb_domain(shard_name=T.unsafe(nil)); end

  def self.sdb_domain_name(shard_name=T.unsafe(nil)); end

  def self.shard(shard_name); end

  def self.size(options=T.unsafe(nil)); end

  def self.sortable_float_attr(name, options=T.unsafe(nil)); end

  def self.sortable_integer_attr(name, options=T.unsafe(nil)); end

  def self.string_attr(name, options=T.unsafe(nil)); end

  def self.timestamps(); end

  def self.where(*args); end
end

module AWS::Record::Naming
  def model_name(); end
end

module AWS::Record::Naming
end

class AWS::Record::NumericalityValidator
  def as_integer(value); end

  def as_number(value); end

  def message_for(error_type, requirement=T.unsafe(nil)); end

  def setup(record_class); end

  def validate_attribute(record, attribute_name, raw); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
  COMPARISONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::NumericalityValidator
end

class AWS::Record::PresenceValidator
  def message(); end

  def validate_attribute(record, attribute_name, value); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::PresenceValidator
end

class AWS::Record::RecordNotFound
end

class AWS::Record::RecordNotFound
end

class AWS::Record::Scope
  include ::Enumerable
  def _shard(); end

  def base_class(); end

  def build(attributes=T.unsafe(nil)); end

  def count(options=T.unsafe(nil)); end

  def domain(shard_name); end

  def each(&block); end

  def find(id_or_mode, options=T.unsafe(nil)); end

  def first(options=T.unsafe(nil)); end

  def initialize(base_class, options=T.unsafe(nil)); end

  def limit(limit); end

  def new(attributes=T.unsafe(nil)); end

  def shard(shard_name); end

  def size(options=T.unsafe(nil)); end
end

class AWS::Record::Scope
end

class AWS::Record::UndefinedAttributeError
  def initalize(attribute_name); end
end

class AWS::Record::UndefinedAttributeError
end

module AWS::Record::Validations
  def validate(*args); end

  def validates_acceptance_of(*args); end

  def validates_confirmation_of(*args); end

  def validates_count_of(*args); end

  def validates_each(*attributes, &block); end

  def validates_exclusion_of(*args); end

  def validates_format_of(*args); end

  def validates_inclusion_of(*attributes); end

  def validates_length_of(*args); end

  def validates_numericality_of(*args); end

  def validates_presence_of(*args); end
end

module AWS::Record::Validations
  def self.extended(base); end
end

class AWS::Record::Validator
  def add_accessors(klass, *accessors); end

  def attribute_names(); end

  def blank?(value); end

  def each_value(value, &block); end

  def ensure_at_least_one(*keys); end

  def ensure_exclusive(*key_groups); end

  def ensure_is(value_or_values, *keys); end

  def ensure_present(*keys); end

  def ensure_type(type_or_types, *keys); end

  def initialize(record_class, *attribute_names, &block); end

  def options(); end

  def read_attribute_for_validation(record, attribute_name); end

  def reject_unknown_options(); end

  def set_default(key, value); end

  def setup(klass); end

  def validate(record); end

  def validate_attributes(record); end
  ACCEPTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class AWS::Record::Validator
end

module AWS::Record
  def self.as_array(value); end

  def self.as_set(value); end

  def self.domain_prefix(); end

  def self.domain_prefix=(prefix); end

  def self.table_prefix(); end

  def self.table_prefix=(prefix); end
end

class AWS::Redshift
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::Redshift::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::Redshift::Client::V20121201
  def authorize_cluster_security_group_ingress(*args, &block); end

  def authorize_snapshot_access(*args, &block); end

  def copy_cluster_snapshot(*args, &block); end

  def create_cluster(*args, &block); end

  def create_cluster_parameter_group(*args, &block); end

  def create_cluster_security_group(*args, &block); end

  def create_cluster_snapshot(*args, &block); end

  def create_cluster_subnet_group(*args, &block); end

  def create_event_subscription(*args, &block); end

  def create_hsm_client_certificate(*args, &block); end

  def create_hsm_configuration(*args, &block); end

  def create_tags(*args, &block); end

  def delete_cluster(*args, &block); end

  def delete_cluster_parameter_group(*args, &block); end

  def delete_cluster_security_group(*args, &block); end

  def delete_cluster_snapshot(*args, &block); end

  def delete_cluster_subnet_group(*args, &block); end

  def delete_event_subscription(*args, &block); end

  def delete_hsm_client_certificate(*args, &block); end

  def delete_hsm_configuration(*args, &block); end

  def delete_tags(*args, &block); end

  def describe_cluster_parameter_groups(*args, &block); end

  def describe_cluster_parameters(*args, &block); end

  def describe_cluster_security_groups(*args, &block); end

  def describe_cluster_snapshots(*args, &block); end

  def describe_cluster_subnet_groups(*args, &block); end

  def describe_cluster_versions(*args, &block); end

  def describe_clusters(*args, &block); end

  def describe_default_cluster_parameters(*args, &block); end

  def describe_event_categories(*args, &block); end

  def describe_event_subscriptions(*args, &block); end

  def describe_events(*args, &block); end

  def describe_hsm_client_certificates(*args, &block); end

  def describe_hsm_configurations(*args, &block); end

  def describe_logging_status(*args, &block); end

  def describe_orderable_cluster_options(*args, &block); end

  def describe_reserved_node_offerings(*args, &block); end

  def describe_reserved_nodes(*args, &block); end

  def describe_resize(*args, &block); end

  def describe_tags(*args, &block); end

  def disable_logging(*args, &block); end

  def disable_snapshot_copy(*args, &block); end

  def enable_logging(*args, &block); end

  def enable_snapshot_copy(*args, &block); end

  def modify_cluster(*args, &block); end

  def modify_cluster_parameter_group(*args, &block); end

  def modify_cluster_subnet_group(*args, &block); end

  def modify_event_subscription(*args, &block); end

  def modify_snapshot_copy_retention_period(*args, &block); end

  def purchase_reserved_node_offering(*args, &block); end

  def reboot_cluster(*args, &block); end

  def reset_cluster_parameter_group(*args, &block); end

  def restore_from_cluster_snapshot(*args, &block); end

  def revoke_cluster_security_group_ingress(*args, &block); end

  def revoke_snapshot_access(*args, &block); end

  def rotate_encryption_key(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::Redshift::Client::V20121201
end

class AWS::Redshift::Client
end

module AWS::Redshift::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::Redshift::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::Redshift
end

class AWS::Route53
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def hosted_zones(); end
end

class AWS::Route53::ChangeBatch
  include ::Enumerable
  include ::AWS::Core::Model
  def <<(change); end

  def call(options=T.unsafe(nil)); end

  def changes(); end

  def comment(); end

  def each(&block); end

  def hosted_zone_id(); end

  def initialize(hosted_zone_id, options=T.unsafe(nil)); end

  def length(); end

  def push(change); end

  def size(); end

  def to_hash(); end
end

class AWS::Route53::ChangeBatch
end

class AWS::Route53::ChangeInfo
  def _find_in_change_resource_record_sets_response_0(resp); end

  def _find_in_create_hosted_zone_response_1(resp); end

  def _find_in_delete_hosted_zone_response_2(resp); end

  def _find_in_get_change_response_3(resp); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def id(); end

  def initialize(id, options=T.unsafe(nil)); end

  def status(); end

  def submitted_at(); end
end

class AWS::Route53::ChangeInfo
end

class AWS::Route53::ChangeRequest
  def action(); end

  def initialize(action, name, type, options=T.unsafe(nil)); end

  def name(); end

  def to_hash(); end

  def type(); end
end

class AWS::Route53::ChangeRequest
end

class AWS::Route53::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::Route53::Client::V20121212
  def change_resource_record_sets(*args, &block); end

  def create_health_check(*args, &block); end

  def create_hosted_zone(*args, &block); end

  def delete_health_check(*args, &block); end

  def delete_hosted_zone(*args, &block); end

  def get_change(*args, &block); end

  def get_health_check(*args, &block); end

  def get_hosted_zone(*args, &block); end

  def list_health_checks(*args, &block); end

  def list_hosted_zones(*args, &block); end

  def list_resource_record_sets(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::Route53::Client::V20121212
end

class AWS::Route53::Client::V20130401
  def associate_vpc_with_hosted_zone(*args, &block); end

  def change_resource_record_sets(*args, &block); end

  def change_tags_for_resource(*args, &block); end

  def create_health_check(*args, &block); end

  def create_hosted_zone(*args, &block); end

  def create_reusable_delegation_set(*args, &block); end

  def delete_health_check(*args, &block); end

  def delete_hosted_zone(*args, &block); end

  def delete_reusable_delegation_set(*args, &block); end

  def disassociate_vpc_from_hosted_zone(*args, &block); end

  def get_change(*args, &block); end

  def get_checker_ip_ranges(*args, &block); end

  def get_geo_location(*args, &block); end

  def get_health_check(*args, &block); end

  def get_health_check_count(*args, &block); end

  def get_health_check_last_failure_reason(*args, &block); end

  def get_health_check_status(*args, &block); end

  def get_hosted_zone(*args, &block); end

  def get_reusable_delegation_set(*args, &block); end

  def list_geo_locations(*args, &block); end

  def list_health_checks(*args, &block); end

  def list_hosted_zones(*args, &block); end

  def list_resource_record_sets(*args, &block); end

  def list_reusable_delegation_sets(*args, &block); end

  def list_tags_for_resource(*args, &block); end

  def list_tags_for_resources(*args, &block); end

  def update_health_check(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::Route53::Client::V20130401
end

class AWS::Route53::Client
end

class AWS::Route53::CreateRequest
  def initialize(name, type, options=T.unsafe(nil)); end
end

class AWS::Route53::CreateRequest
end

class AWS::Route53::DeleteRequest
  def initialize(name, type, options=T.unsafe(nil)); end
end

class AWS::Route53::DeleteRequest
end

module AWS::Route53::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::Route53::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::Route53::HostedZone
  def _find_in_create_hosted_zone_or_get_hosted_zone_response_1(resp); end

  def _find_in_list_hosted_zones_response_0(resp); end

  def associate_vpc(vpc); end

  def change_info(); end

  def configuration(); end

  def delegation_set(); end

  def delete(); end

  def disassociate_vpc(vpc); end

  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def id(); end

  def initialize(id, options=T.unsafe(nil)); end

  def name(); end

  def path(); end

  def resource_record_set_count(); end

  def resource_record_sets(); end

  def rrsets(); end

  def vpcs(); end
  S3_HOSTED_ZONE_IDS = ::T.let(nil, ::T.untyped)
end

class AWS::Route53::HostedZone
  def self.get_attribute(name, options=T.unsafe(nil), &block); end

  def self.get_attributes(); end

  def self.list_attribute(name, options=T.unsafe(nil), &block); end

  def self.list_attributes(); end
end

class AWS::Route53::HostedZoneCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](hosted_zone_id); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def create(name, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class AWS::Route53::HostedZoneCollection
end

class AWS::Route53::ResourceRecordSet
  def _find_in_list_resource_record_sets_response_0(resp); end

  def alias_target(); end

  def alias_target=(new_target); end

  def change_info(); end

  def delete(options=T.unsafe(nil)); end

  def exists?(); end

  def failover(); end

  def failover=(new_failover); end

  def geo_location(); end

  def geo_location=(new_geo_location); end

  def get_resource(attr_name=T.unsafe(nil)); end

  def health_check_id(); end

  def health_check_id=(new_health_check_id); end

  def hosted_zone_id(); end

  def identifier(); end

  def identifier=(new_identifier); end

  def initialize(name, type, options=T.unsafe(nil)); end

  def name(); end

  def name=(new_name); end

  def new_change_batch(options=T.unsafe(nil)); end

  def new_create_request(); end

  def new_delete_request(); end

  def region(); end

  def region=(new_region); end

  def resource_records(); end

  def resource_records=(new_rrs); end

  def set_identifier(); end

  def set_identifier=(new_identifier); end

  def ttl(); end

  def ttl=(new_ttl); end

  def type(); end

  def type=(new_type); end

  def update(options=T.unsafe(nil)); end

  def weight(); end

  def weight=(new_weight); end
end

class AWS::Route53::ResourceRecordSet
end

class AWS::Route53::ResourceRecordSetCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name, type, set_identifier=T.unsafe(nil)); end

  def create(name, type, options=T.unsafe(nil)); end

  def hosted_zone_id(); end

  def initialize(hosted_zone_id, options=T.unsafe(nil)); end
end

class AWS::Route53::ResourceRecordSetCollection
end

class AWS::Route53
end

class AWS::S3
  include ::AWS::Core::ServiceInterface
  def buckets(); end

  def client(); end

  def config(); end
  BUCKET_REGIONS = ::T.let(nil, ::T.untyped)
end

module AWS::S3::ACLObject
  def body_xml(); end

  def element_name(); end

  def initialize(opts=T.unsafe(nil)); end

  def stag(); end

  def to_s(); end

  def to_xml(); end

  def valid?(); end

  def validate!(); end

  def validate_input(name, value, context=T.unsafe(nil)); end
end

module AWS::S3::ACLObject::ClassMethods
  def add_xml_child(method_name); end

  def body_xml_content(method_name); end

  def body_xml_list_content(list_element, method_name); end

  def body_xml_string_content(element_name, method_name); end

  def input_validator(method_name, &blk); end

  def object_attr(klass, options=T.unsafe(nil)); end

  def object_input_validator(klass, base_name, method_name, cast); end

  def object_list_attr(list_element, klass, options=T.unsafe(nil)); end

  def object_list_input_validator(klass, base_name, method_name); end

  def object_list_setter(klass, method_name); end

  def object_setter(klass, method_name, cast); end

  def setter_option(method_name); end

  def string_attr(element_name, options=T.unsafe(nil)); end

  def string_input_validator(method_name); end

  def validate_list(method_name); end

  def validate_object(method_name); end

  def validate_string(method_name); end
end

module AWS::S3::ACLObject::ClassMethods
end

module AWS::S3::ACLObject
  def self.included(m); end
end

module AWS::S3::ACLOptions
  def acl_options(acl); end

  def format_grantee(grantee); end

  def format_grants(acl_hash); end

  def grant_hash?(acl_hash); end

  def ucfirst(str); end

  def xml?(acl_string); end
end

module AWS::S3::ACLOptions
end

class AWS::S3::AccessControlList
  include ::AWS::S3::ACLObject
  def grant(permission); end

  def grants(); end

  def grants=(value); end

  def owner(); end

  def owner=(value); end
end

class AWS::S3::AccessControlList::Grant
  include ::AWS::S3::ACLObject
  def grantee(); end

  def grantee=(value); end

  def permission(); end

  def permission=(value); end
end

class AWS::S3::AccessControlList::Grant
  extend ::AWS::S3::ACLObject::ClassMethods
end

class AWS::S3::AccessControlList::GrantBuilder
  def initialize(acl, grant); end

  def to(grantee); end
end

class AWS::S3::AccessControlList::GrantBuilder
end

class AWS::S3::AccessControlList::Grantee
  include ::AWS::S3::ACLObject
  def amazon_customer_email(); end

  def amazon_customer_email=(amazon_customer_email); end

  def canonical_user_id(); end

  def canonical_user_id=(canonical_user_id); end

  def display_name(); end

  def display_name=(display_name); end

  def group_uri(); end

  def group_uri=(group_uri); end

  def signal_attribute(); end

  def type_for_attr(attr); end

  def uri(); end

  def uri=(uri); end
  SIGNAL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class AWS::S3::AccessControlList::Grantee
  extend ::AWS::S3::ACLObject::ClassMethods
end

class AWS::S3::AccessControlList::Owner
  include ::AWS::S3::ACLObject
  def display_name(); end

  def display_name=(display_name); end

  def id(); end

  def id=(id); end
end

class AWS::S3::AccessControlList::Owner
  extend ::AWS::S3::ACLObject::ClassMethods
end

class AWS::S3::AccessControlList::Permission
  include ::AWS::S3::ACLObject
  def initialize(name); end

  def name(); end
end

class AWS::S3::AccessControlList::Permission
  extend ::AWS::S3::ACLObject::ClassMethods
end

class AWS::S3::AccessControlList
  extend ::AWS::S3::ACLObject::ClassMethods
end

class AWS::S3::Bucket
  include ::AWS::Core::Model
  include ::AWS::S3::ACLOptions
  def ==(other); end

  def acl(); end

  def acl=(acl); end

  def as_tree(options=T.unsafe(nil)); end

  def clear!(); end

  def configure_website(&block); end

  def cors(); end

  def cors=(*rules); end

  def delete(); end

  def delete!(); end

  def empty?(); end

  def enable_versioning(opts=T.unsafe(nil)); end

  def eql?(other_bucket); end

  def exists?(); end

  def initialize(name, options=T.unsafe(nil)); end

  def lifecycle_configuration(); end

  def lifecycle_configuration=(config); end

  def location_constraint(); end

  def multipart_uploads(); end

  def name(); end

  def objects(); end

  def owner(); end

  def policy(); end

  def policy=(policy); end

  def presigned_post(options=T.unsafe(nil)); end

  def remove_website_configuration(); end

  def suspend_versioning(opts=T.unsafe(nil)); end

  def tags(); end

  def tags=(tags); end

  def url(options=T.unsafe(nil)); end

  def versioned?(); end

  def versioning_enabled?(); end

  def versioning_state(); end

  def versions(); end

  def website?(); end

  def website_configuration(); end

  def website_configuration=(website_configuration); end
end

module AWS::S3::Bucket::ACLProxy
  def bucket(); end

  def bucket=(bucket); end

  def change(); end
end

module AWS::S3::Bucket::ACLProxy
end

module AWS::S3::Bucket::PolicyProxy
  def bucket(); end

  def bucket=(bucket); end

  def change(); end

  def delete(); end
end

module AWS::S3::Bucket::PolicyProxy
end

class AWS::S3::Bucket
end

class AWS::S3::BucketCollection
  include ::AWS::Core::Model
  include ::Enumerable
  def [](bucket_name); end

  def create(bucket_name, options=T.unsafe(nil)); end

  def each(&block); end
end

class AWS::S3::BucketCollection
end

class AWS::S3::BucketLifecycleConfiguration
  def add_rule(prefix, expiration_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def bucket(); end

  def clear(); end

  def initialize(bucket, options=T.unsafe(nil)); end

  def parse_xml(xml); end

  def persist(force=T.unsafe(nil)); end

  def remove(); end

  def remove_rule(rule_or_rule_id); end

  def replace(&block); end

  def rules(); end

  def to_xml(); end

  def update(arg=T.unsafe(nil), &block); end
end

class AWS::S3::BucketLifecycleConfiguration::Rule
  def ==(other); end

  def configuration(); end

  def disabled!(); end

  def disabled?(); end

  def enable!(); end

  def enabled?(); end

  def eql?(other); end

  def expiration_days(); end

  def expiration_days=(value); end

  def expiration_time(); end

  def expiration_time=(value); end

  def glacier_transition_time(); end

  def glacier_transition_time=(value); end

  def id(); end

  def initialize(configuration, id, prefix, expiration_time=T.unsafe(nil), status=T.unsafe(nil)); end

  def noncurrent_version_expiration_days(); end

  def noncurrent_version_expiration_days=(noncurrent_version_expiration_days); end

  def noncurrent_version_transition_days(); end

  def noncurrent_version_transition_days=(noncurrent_version_transition_days); end

  def prefix(); end

  def prefix=(prefix); end

  def status(); end

  def status=(status); end
end

class AWS::S3::BucketLifecycleConfiguration::Rule
end

class AWS::S3::BucketLifecycleConfiguration
end

class AWS::S3::BucketRegionCache
  def [](bucket_name); end

  def []=(bucket_name, region_name); end

  def clear(); end

  def delete(bucket_name); end

  def to_h(); end

  def to_hash(); end

  def update!(bucket_regions); end
end

class AWS::S3::BucketRegionCache
end

class AWS::S3::BucketTagCollection
  include ::AWS::Core::Model
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def bucket(); end

  def clear(); end

  def eql?(other); end

  def initialize(bucket, options=T.unsafe(nil)); end

  def set(tags); end

  def to_h(); end

  def to_hash(); end
end

class AWS::S3::BucketTagCollection
end

class AWS::S3::BucketVersionCollection
  include ::AWS::S3::PrefixAndDelimiterCollection
  include ::AWS::S3::PrefixedCollection
  include ::AWS::S3::PaginatedCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def bucket(); end

  def initialize(bucket, options=T.unsafe(nil)); end

  def latest(); end
end

class AWS::S3::BucketVersionCollection
end

class AWS::S3::CORSRule
  def allowed_headers(); end

  def allowed_methods(); end

  def allowed_origins(); end

  def expose_headers(); end

  def id(); end

  def initialize(options=T.unsafe(nil)); end

  def max_age_seconds(); end

  def to_h(); end
end

class AWS::S3::CORSRule
end

class AWS::S3::CORSRuleCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(options); end

  def add(*rules); end

  def bucket(); end

  def clear(); end

  def create(*rules); end

  def delete_if(&block); end

  def initialize(bucket, options=T.unsafe(nil)); end

  def rule_hashes(rule); end

  def set(*rules); end
end

class AWS::S3::CORSRuleCollection
end

class AWS::S3::CipherIO
  def eof?(); end

  def initialize(cipher, stream, stream_size=T.unsafe(nil)); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end
end

class AWS::S3::CipherIO
end

class AWS::S3::Client
  include ::AWS::S3::RegionDetection
  include ::AWS::S3::DataOptions
  include ::AWS::Core::UriEscape
  include ::AWS::S3::Client::Validators
  def chunk_sign?(req); end

  def empty_response_body?(response_body); end

  def extract_object_headers(resp); end

  def http_200_error?(response); end

  def is_xml?(possible_xml); end

  def md5(str); end

  def move_access_control_policy(options); end

  def parse_copy_part_response(resp); end

  def populate_error(resp); end

  def set_metadata(request, options); end

  def set_server_side_encryption(request, options); end

  def set_storage_class(request, options); end

  def sign_request(request); end

  def v3_signer(); end

  def v4_signer(); end
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
  EMPTY_BODY_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_200_ERROR_OPERATIONS = ::T.let(nil, ::T.untyped)
  XMLNS = ::T.let(nil, ::T.untyped)
end

class AWS::S3::Client::V20060301
  def abort_multipart_upload(*args, &block); end

  def complete_multipart_upload(*args, &block); end

  def copy_object(*args, &block); end

  def copy_part(*args, &block); end

  def create_bucket(*args, &block); end

  def delete_bucket(*args, &block); end

  def delete_bucket_cors(*args, &block); end

  def delete_bucket_lifecycle_configuration(*args, &block); end

  def delete_bucket_policy(*args, &block); end

  def delete_bucket_tagging(*args, &block); end

  def delete_bucket_website(*args, &block); end

  def delete_object(*args, &block); end

  def delete_objects(*args, &block); end

  def get_bucket(*args, &block); end

  def get_bucket_acl(*args, &block); end

  def get_bucket_cors(*args, &block); end

  def get_bucket_lifecycle_configuration(*args, &block); end

  def get_bucket_location(*args, &block); end

  def get_bucket_logging(*args, &block); end

  def get_bucket_policy(*args, &block); end

  def get_bucket_tagging(*args, &block); end

  def get_bucket_versioning(*args, &block); end

  def get_bucket_website(*args, &block); end

  def get_object(*args, &block); end

  def get_object_acl(*args, &block); end

  def get_object_torrent(*args, &block); end

  def head_object(*args, &block); end

  def initiate_multipart_upload(*args, &block); end

  def list_buckets(*args, &block); end

  def list_multipart_uploads(*args, &block); end

  def list_object_versions(*args, &block); end

  def list_objects(*args, &block); end

  def list_parts(*args, &block); end

  def put_bucket(*args, &block); end

  def put_bucket_acl(*args, &block); end

  def put_bucket_cors(*args, &block); end

  def put_bucket_logging(*args, &block); end

  def put_bucket_tagging(*args, &block); end

  def put_bucket_website(*args, &block); end

  def put_object(*args, &block); end

  def put_object_acl(*args, &block); end

  def restore_object(*args, &block); end

  def set_bucket_acl(*args, &block); end

  def set_bucket_lifecycle_configuration(*args, &block); end

  def set_bucket_policy(*args, &block); end

  def set_bucket_versioning(*args, &block); end

  def set_object_acl(*args, &block); end

  def upload_part(*args, &block); end
end

class AWS::S3::Client::V20060301
  def self.object_method(method_name, verb, *args, &block); end
end

module AWS::S3::Client::Validators
  def dns_compatible_bucket_name?(bucket_name); end

  def json_validation_message(obj); end

  def path_style_bucket_name?(bucket_name); end

  def require_acl!(options); end

  def require_allowed_methods!(allowed_methods); end

  def require_allowed_origins!(allowed_origins); end

  def require_bucket_name!(bucket_name); end

  def require_part_number!(part_number); end

  def require_policy!(policy); end

  def require_upload_id!(upload_id); end

  def set_body_stream_and_content_length(request, options); end

  def valid_bucket_name?(bucket_name); end

  def validate!(name, value, &block); end

  def validate_bucket_name!(bucket_name); end

  def validate_key!(key); end

  def validate_parts!(parts); end
end

module AWS::S3::Client::Validators
end

module AWS::S3::Client::XML
  BaseGrammar = ::T.let(nil, ::T.untyped)
  CompleteMultipartUpload = ::T.let(nil, ::T.untyped)
  CopyPart = ::T.let(nil, ::T.untyped)
  DeleteObjects = ::T.let(nil, ::T.untyped)
  GetBucketAcl = ::T.let(nil, ::T.untyped)
  GetBucketCors = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleConfiguration = ::T.let(nil, ::T.untyped)
  GetBucketLogging = ::T.let(nil, ::T.untyped)
  GetBucketTagging = ::T.let(nil, ::T.untyped)
  GetBucketVersioning = ::T.let(nil, ::T.untyped)
  GetBucketWebsite = ::T.let(nil, ::T.untyped)
  GetObjectAcl = ::T.let(nil, ::T.untyped)
  InitiateMultipartUpload = ::T.let(nil, ::T.untyped)
  ListBuckets = ::T.let(nil, ::T.untyped)
  ListMultipartUploads = ::T.let(nil, ::T.untyped)
  ListObjectVersions = ::T.let(nil, ::T.untyped)
  ListObjects = ::T.let(nil, ::T.untyped)
  ListParts = ::T.let(nil, ::T.untyped)
end

module AWS::S3::Client::XML
end

class AWS::S3::Client
  extend ::AWS::S3::Client::Validators
  def self.bucket_method(method_name, verb, *args, &block); end
end

module AWS::S3::DataOptions
  def compute_write_options(*args, &block); end

  def convert_args_to_options_hash(*args); end

  def convert_data_to_io_obj(options, &block); end

  def io_like?(io); end

  def open_file(path); end

  def rename_file_to_data(options); end

  def try_to_determine_content_length(options); end

  def validate_data!(options, &block); end
end

class AWS::S3::DataOptions::IOProxy
  def eof?(); end

  def initialize(write_block); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def read_all(); end

  def read_chunk(bytes); end
end

class AWS::S3::DataOptions::IOProxy
end

module AWS::S3::DataOptions
end

module AWS::S3::EncryptionUtils
  def check_encryption_materials(mode, key); end

  def decrypt(data, key); end

  def encrypt(data, key); end

  def generate_aes_key(cipher, &block); end

  def get_aes_cipher(mode, block_mode, key=T.unsafe(nil), iv=T.unsafe(nil)); end
  UNSAFE_MSG = ::T.let(nil, ::T.untyped)
end

module AWS::S3::EncryptionUtils
  def self.get_encrypted_size(size); end
end

module AWS::S3::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::S3::Errors::AccessDenied
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::S3::Errors::AccessDenied
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::S3::Errors::BadRequest
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::S3::Errors::BadRequest
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::S3::Errors::BatchDeleteError
  def error_counts(); end

  def initialize(error_counts); end
end

class AWS::S3::Errors::BatchDeleteError
end

class AWS::S3::Errors::Forbidden
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::S3::Errors::Forbidden
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::S3::Errors::IncorrectClientSideEncryptionKey
  include ::AWS::Errors::ClientError
  def initialize(msg); end
end

class AWS::S3::Errors::IncorrectClientSideEncryptionKey
end

class AWS::S3::Errors::NoSuchBucket
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::S3::Errors::NoSuchBucket
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::S3::Errors::NoSuchKey
  include ::AWS::Errors::ClientError
  def initialize(req, resp, code=T.unsafe(nil), message=T.unsafe(nil)); end
end

class AWS::S3::Errors::NoSuchKey
end

class AWS::S3::Errors::NotFound
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::S3::Errors::NotFound
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::S3::Errors::NotModified
  include ::AWS::Errors::ClientError
  def initialize(req, resp); end
end

class AWS::S3::Errors::NotModified
end

module AWS::S3::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::S3::MultipartUpload
  include ::AWS::Core::Model
  def ==(other); end

  def abort(); end

  def aborted?(); end

  def add_part(data_or_options, options=T.unsafe(nil)); end

  def bucket(); end

  def cancel(); end

  def close(); end

  def complete(*parts); end

  def completed_parts(); end

  def copy_part(copy_source, options=T.unsafe(nil)); end

  def delete(); end

  def eql?(other); end

  def exists?(); end

  def id(); end

  def initialize(object, id, options=T.unsafe(nil)); end

  def initiator(); end

  def object(); end

  def owner(); end

  def parts(); end

  def reduced_redundancy?(); end

  def storage_class(); end

  def upload_id(); end
end

class AWS::S3::MultipartUpload::EmptyUploadError
end

class AWS::S3::MultipartUpload::EmptyUploadError
end

class AWS::S3::MultipartUpload
end

class AWS::S3::MultipartUploadCollection
  include ::AWS::S3::PrefixAndDelimiterCollection
  include ::AWS::S3::PrefixedCollection
  include ::AWS::S3::PaginatedCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def bucket(); end

  def initialize(bucket, opts=T.unsafe(nil)); end
end

class AWS::S3::MultipartUploadCollection
end

class AWS::S3::ObjectCollection
  include ::AWS::S3::PrefixAndDelimiterCollection
  include ::AWS::S3::PrefixedCollection
  include ::AWS::S3::PaginatedCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](key); end

  def bucket(); end

  def create(key, *args, &block); end

  def delete(*objects); end

  def delete_all(); end

  def delete_if(&block); end

  def initialize(bucket, options=T.unsafe(nil)); end
end

class AWS::S3::ObjectCollection::BatchHelper
  def add(item); end

  def after_batch(&block); end

  def complete!(); end

  def initialize(batch_size, &block); end
end

class AWS::S3::ObjectCollection::BatchHelper
end

class AWS::S3::ObjectCollection
end

class AWS::S3::ObjectMetadata
  include ::AWS::Core::Model
  def [](name); end

  def []=(name, value); end

  def initialize(object, options=T.unsafe(nil)); end

  def method_missing(name, *args, &blk); end

  def object(); end

  def to_h(); end
end

class AWS::S3::ObjectMetadata
end

class AWS::S3::ObjectUploadCollection
  include ::Enumerable
  include ::AWS::Core::Model
  def [](id); end

  def create(options=T.unsafe(nil)); end

  def each(options=T.unsafe(nil), &block); end

  def initialize(object, opts=T.unsafe(nil)); end

  def object(); end
end

class AWS::S3::ObjectUploadCollection
end

class AWS::S3::ObjectVersion
  include ::AWS::Core::Model
  def ==(other); end

  def bucket(); end

  def content_length(); end

  def content_type(); end

  def delete(options=T.unsafe(nil)); end

  def delete_marker?(); end

  def eql?(other); end

  def etag(); end

  def head(); end

  def initialize(object, version_id, options=T.unsafe(nil)); end

  def key(); end

  def last_modified(); end

  def latest?(); end

  def metadata(); end

  def object(); end

  def read(options=T.unsafe(nil), &block); end

  def url_for(method, options=T.unsafe(nil)); end

  def version_id(); end
end

class AWS::S3::ObjectVersion
end

class AWS::S3::ObjectVersionCollection
  include ::AWS::Core::Model
  include ::Enumerable
  def [](version_id); end

  def each(&block); end

  def initialize(object, options=T.unsafe(nil)); end

  def latest(); end

  def object(); end
end

class AWS::S3::ObjectVersionCollection
end

module AWS::S3::PaginatedCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(markers, limit, options=T.unsafe(nil), &block); end

  def each_member_in_page(page, &block); end

  def limit_param(); end

  def list_options(options); end

  def list_request(options); end

  def next_markers(page); end

  def pagination_markers(); end
end

module AWS::S3::PaginatedCollection
end

class AWS::S3::Policy
end

class AWS::S3::Policy::Statement
  ACTION_MAPPING = ::T.let(nil, ::T.untyped)
end

class AWS::S3::Policy::Statement
end

class AWS::S3::Policy
end

module AWS::S3::PrefixAndDelimiterCollection
  include ::AWS::S3::PrefixedCollection
  include ::AWS::S3::PaginatedCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def as_tree(options=T.unsafe(nil)); end

  def each_member_in_page(page, &block); end

  def list_options(options); end
end

module AWS::S3::PrefixAndDelimiterCollection
end

module AWS::S3::PrefixedCollection
  include ::AWS::S3::PaginatedCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def initialize(*args); end

  def list_options(options); end

  def prefix(); end

  def with_prefix(prefix, mode=T.unsafe(nil)); end
end

module AWS::S3::PrefixedCollection
end

class AWS::S3::PresignV4
  def client(); end

  def initialize(object); end

  def object(); end

  def presign(method, options=T.unsafe(nil)); end

  def signer(); end
end

class AWS::S3::PresignV4
end

class AWS::S3::PresignedPost
  include ::AWS::Core::Model
  def bucket(); end

  def conditions(); end

  def content_length(); end

  def expires(); end

  def fields(); end

  def ignored_fields(); end

  def initialize(bucket, opts=T.unsafe(nil)); end

  def key(); end

  def metadata(); end

  def policy(); end

  def refine(opts); end

  def secure?(); end

  def url(); end

  def where(field); end

  def where_metadata(field); end

  def with_equality_condition(option_name, value); end

  def with_prefix_condition(option_name, prefix); end
  SPECIAL_FIELDS = ::T.let(nil, ::T.untyped)
end

class AWS::S3::PresignedPost::ConditionBuilder
  def in(range); end

  def initialize(post, field); end

  def is(value); end

  def starts_with(prefix); end
end

class AWS::S3::PresignedPost::ConditionBuilder
end

class AWS::S3::PresignedPost
end

module AWS::S3::RegionDetection
end

module AWS::S3::RegionDetection
end

class AWS::S3::Request
  include ::AWS::Core::UriEscape
  def bucket(); end

  def bucket=(bucket); end

  def force_path_style(); end

  def force_path_style=(force_path_style); end

  def key(); end

  def key=(key); end

  def path_style?(); end
end

class AWS::S3::Request
end

class AWS::S3::S3Object
  include ::AWS::Core::Model
  include ::AWS::S3::DataOptions
  include ::AWS::S3::ACLOptions
  include ::AWS::S3::EncryptionUtils
  def ==(other); end

  def acl(); end

  def acl=(acl); end

  def bucket(); end

  def content_length(); end

  def content_type(); end

  def copy_from(source, options=T.unsafe(nil)); end

  def copy_to(target, options=T.unsafe(nil)); end

  def delete(options=T.unsafe(nil)); end

  def eql?(other); end

  def etag(); end

  def exists?(); end

  def expiration_date(); end

  def expiration_rule_id(); end

  def head(options=T.unsafe(nil)); end

  def initialize(bucket, key, opts=T.unsafe(nil)); end

  def key(); end

  def last_modified(); end

  def metadata(options=T.unsafe(nil)); end

  def move_to(target, options=T.unsafe(nil)); end

  def multipart_upload(options=T.unsafe(nil)); end

  def multipart_uploads(); end

  def presigned_post(options=T.unsafe(nil)); end

  def public_url(options=T.unsafe(nil)); end

  def read(options=T.unsafe(nil), &read_block); end

  def reduced_redundancy=(value); end

  def rename_to(target, options=T.unsafe(nil)); end

  def restore(options=T.unsafe(nil)); end

  def restore_expiration_date(); end

  def restore_in_progress?(); end

  def restored_object?(); end

  def server_side_encryption(); end

  def server_side_encryption?(); end

  def url_for(method, options=T.unsafe(nil)); end

  def versions(); end

  def write(*args, &block); end
  REQUEST_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module AWS::S3::S3Object::ACLProxy
  def change(); end

  def object(); end

  def object=(object); end
end

module AWS::S3::S3Object::ACLProxy
end

class AWS::S3::S3Object
end

class AWS::S3::Tree
  include ::AWS::S3::Tree::Parent
  include ::AWS::Core::Model
  def parent(); end
end

class AWS::S3::Tree::BranchNode
  include ::AWS::S3::Tree::Parent
  include ::AWS::Core::Model
  def as_tree(); end

  def branch?(); end

  def initialize(parent, collection, options=T.unsafe(nil)); end

  def leaf?(); end

  def parent(); end
end

class AWS::S3::Tree::BranchNode
end

class AWS::S3::Tree::ChildCollection
  include ::AWS::Core::Model
  include ::Enumerable
  def append?(); end

  def collection(); end

  def delimiter(); end

  def each(&block); end

  def initialize(parent, collection, options=T.unsafe(nil)); end

  def parent(); end

  def prefix(); end

  def prefix_with_delim(); end
end

class AWS::S3::Tree::ChildCollection
end

class AWS::S3::Tree::LeafNode
  def branch?(); end

  def initialize(parent, member); end

  def key(); end

  def leaf?(); end

  def member(); end

  def object(); end

  def parent(); end

  def upload(); end

  def version(); end
end

class AWS::S3::Tree::LeafNode
end

class AWS::S3::Tree::Node
end

class AWS::S3::Tree::Node
end

module AWS::S3::Tree::Parent
  include ::AWS::Core::Model
  def append?(); end

  def children(); end

  def collection(); end

  def delimiter(); end

  def initialize(collection, options=T.unsafe(nil)); end

  def inspect(); end

  def prefix(); end
end

module AWS::S3::Tree::Parent
end

class AWS::S3::Tree
end

class AWS::S3::UploadedPart
  include ::AWS::Core::Model
  def ==(other); end

  def eql?(other); end

  def etag(); end

  def initialize(upload, part_number, opts=T.unsafe(nil)); end

  def last_modified(); end

  def part_number(); end

  def size(); end

  def upload(); end
end

class AWS::S3::UploadedPart
end

class AWS::S3::UploadedPartCollection
  include ::AWS::S3::PaginatedCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](number); end

  def initialize(upload, opts=T.unsafe(nil)); end

  def upload(); end
end

class AWS::S3::UploadedPartCollection
end

class AWS::S3::WebsiteConfiguration
  def error_document_key(); end

  def error_document_key=(key); end

  def index_document_suffix(); end

  def index_document_suffix=(suffix); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def to_hash(); end
end

class AWS::S3::WebsiteConfiguration
end

class AWS::S3
end

class AWS::SNS
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def subscriptions(); end

  def topics(); end
end

class AWS::SNS::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::SNS::Client::V20100331
  def add_permission(*args, &block); end

  def confirm_subscription(*args, &block); end

  def create_platform_application(*args, &block); end

  def create_platform_endpoint(*args, &block); end

  def create_topic(*args, &block); end

  def delete_endpoint(*args, &block); end

  def delete_platform_application(*args, &block); end

  def delete_topic(*args, &block); end

  def get_endpoint_attributes(*args, &block); end

  def get_platform_application_attributes(*args, &block); end

  def get_subscription_attributes(*args, &block); end

  def get_topic_attributes(*args, &block); end

  def list_endpoints_by_platform_application(*args, &block); end

  def list_platform_applications(*args, &block); end

  def list_subscriptions(*args, &block); end

  def list_subscriptions_by_topic(*args, &block); end

  def list_topics(*args, &block); end

  def publish(*args, &block); end

  def remove_permission(*args, &block); end

  def set_endpoint_attributes(*args, &block); end

  def set_platform_application_attributes(*args, &block); end

  def set_subscription_attributes(*args, &block); end

  def set_topic_attributes(*args, &block); end

  def subscribe(*args, &block); end

  def unsubscribe(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::SNS::Client::V20100331
end

class AWS::SNS::Client
end

module AWS::SNS::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::SNS::Errors
  extend ::AWS::Core::LazyErrorClasses
end

module AWS::SNS::FromAutoScaling
  def body(); end

  def event(); end

  def group_name(); end

  def instance_id(); end

  def status_code(); end
end

module AWS::SNS::FromAutoScaling
  def self.applicable?(sns); end

  def self.extended(base); end
end

module AWS::SNS::HasDeliveryPolicy
  def delivery_policy(); end

  def delivery_policy=(policy); end

  def delivery_policy_json(); end

  def effective_delivery_policy(); end

  def effective_delivery_policy_json(); end

  def parse_delivery_policy(policy_json); end

  def update_delivery_policy(policy_json); end
end

module AWS::SNS::HasDeliveryPolicy
end

class AWS::SNS::Message
  def [](key); end

  def authentic?(); end

  def canonical_string(); end

  def decode(raw); end

  def download(url); end

  def get_public_key_from(x509_pem_url); end

  def https_get(url); end

  def initialize(sns); end

  def message(); end

  def message_id(); end

  def origin(); end

  def origin=(origin); end

  def parse_from(json); end

  def raw(); end

  def signature(); end

  def signature_version(); end

  def signing_cert_url(); end

  def subject(); end

  def subscribe_url(); end

  def timestamp(); end

  def token(); end

  def topic_arn(); end

  def type(); end

  def unsubscribe_url(); end
  SIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

class AWS::SNS::Message
end

class AWS::SNS::MessageWasNotAuthenticError
end

class AWS::SNS::MessageWasNotAuthenticError
end

class AWS::SNS::Policy
end

class AWS::SNS::Policy::Statement
  ACTION_MAPPING = ::T.let(nil, ::T.untyped)
end

class AWS::SNS::Policy::Statement
end

class AWS::SNS::Policy
end

class AWS::SNS::Subscription
  include ::AWS::Core::Model
  include ::AWS::SNS::HasDeliveryPolicy
  def ==(other); end

  def arn(); end

  def confirmation_authenticated?(); end

  def endpoint(); end

  def eql?(other); end

  def exists?(); end

  def get_attributes(); end

  def initialize(arn, opts=T.unsafe(nil)); end

  def owner_id(); end

  def protocol(); end

  def raw_message_delivery(); end

  def raw_message_delivery=(raw_delivery); end

  def topic(); end

  def topic_arn(); end

  def unsubscribe(); end

  def update_subscription_attribute(name, value); end
end

class AWS::SNS::Subscription
end

class AWS::SNS::SubscriptionCollection
  include ::AWS::Core::Collection::WithNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](arn); end

  def _each_item(next_token, options, &block); end

  def client_method(); end

  def request_options(); end
end

class AWS::SNS::SubscriptionCollection
end

class AWS::SNS::Topic
  include ::AWS::Core::Model
  include ::AWS::SNS::HasDeliveryPolicy
  def ==(other); end

  def arn(); end

  def confirm_subscription(token, options=T.unsafe(nil)); end

  def delete(); end

  def display_name(); end

  def display_name=(display_name); end

  def endpoint_opts(endpoint, opts=T.unsafe(nil)); end

  def eql?(other); end

  def initialize(arn, options=T.unsafe(nil)); end

  def name(); end

  def num_subscriptions_confirmed(); end

  def num_subscriptions_deleted(); end

  def num_subscriptions_pending(); end

  def owner(); end

  def parse_policy(policy_json); end

  def policy(); end

  def policy=(policy); end

  def publish(default_message, options=T.unsafe(nil)); end

  def set_attribute(name, value); end

  def subscribe(endpoint, options=T.unsafe(nil)); end

  def subscriptions(); end

  def to_h(); end
end

module AWS::SNS::Topic::PolicyProxy
  def change(); end

  def topic(); end

  def topic=(topic); end
end

module AWS::SNS::Topic::PolicyProxy
end

class AWS::SNS::Topic
end

class AWS::SNS::TopicCollection
  include ::AWS::Core::Collection::WithNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](topic_arn); end

  def _each_item(next_token, options, &block); end

  def create(name); end
end

class AWS::SNS::TopicCollection
end

class AWS::SNS::TopicSubscriptionCollection
  def initialize(topic, opts=T.unsafe(nil)); end

  def topic(); end
end

class AWS::SNS::TopicSubscriptionCollection
end

class AWS::SNS
end

class AWS::SQS
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def queues(); end
end

class AWS::SQS::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::SQS::Client::V20121105
  def add_permission(*args, &block); end

  def change_message_visibility(*args, &block); end

  def change_message_visibility_batch(*args, &block); end

  def create_queue(*args, &block); end

  def delete_message(*args, &block); end

  def delete_message_batch(*args, &block); end

  def delete_queue(*args, &block); end

  def get_queue_attributes(*args, &block); end

  def get_queue_url(*args, &block); end

  def list_dead_letter_source_queues(*args, &block); end

  def list_queues(*args, &block); end

  def receive_message(*args, &block); end

  def remove_permission(*args, &block); end

  def send_message(*args, &block); end

  def send_message_batch(*args, &block); end

  def set_queue_attributes(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::SQS::Client::V20121105
end

class AWS::SQS::Client
end

module AWS::SQS::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

class AWS::SQS::Errors::BatchChangeVisibilityError
  def failures(); end

  def initialize(failures); end
end

class AWS::SQS::Errors::BatchChangeVisibilityError
end

class AWS::SQS::Errors::BatchDeleteError
  def failures(); end

  def initialize(failures); end
end

class AWS::SQS::Errors::BatchDeleteError
end

class AWS::SQS::Errors::BatchSendError
  def failures(); end

  def initialize(sent, failures); end

  def sent(); end
end

class AWS::SQS::Errors::BatchSendError
end

class AWS::SQS::Errors::BatchSendMultiError
  def errors(); end

  def initialize(*error_set); end
end

class AWS::SQS::Errors::BatchSendMultiError
end

class AWS::SQS::Errors::ChecksumError
  def failures(); end

  def initialize(failures); end
end

class AWS::SQS::Errors::ChecksumError
end

module AWS::SQS::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::SQS::Policy
end

class AWS::SQS::Policy::Statement
  ACTION_MAPPING = ::T.let(nil, ::T.untyped)
end

class AWS::SQS::Policy::Statement
end

class AWS::SQS::Policy
end

class AWS::SQS::Queue
  include ::AWS::Core::Model
  def ==(other); end

  def approximate_number_of_messages(); end

  def approximate_number_of_messages_delayed(); end

  def approximate_number_of_messages_not_visible(); end

  def arn(); end

  def batch_change_visibility(*args); end

  def batch_delete(*messages); end

  def batch_failures(entries, response, include_batch_index=T.unsafe(nil)); end

  def batch_send(*messages); end

  def calculate_checksum(data); end

  def call_message_block(messages, block); end

  def created_timestamp(); end

  def delay_seconds(); end

  def delay_seconds=(seconds); end

  def delete(); end

  def eql?(other); end

  def exists?(); end

  def get_attribute(name); end

  def hit_timeout?(got_first, last_message_at, opts); end

  def initialize(url, opts=T.unsafe(nil)); end

  def invisible_messages(); end

  def is_checksum_valid(checksum, data); end

  def last_modified_timestamp(); end

  def maximum_message_size(); end

  def maximum_message_size=(size); end

  def message_retention_period(); end

  def message_retention_period=(period); end

  def policy(); end

  def policy=(policy); end

  def poll(opts=T.unsafe(nil), &block); end

  def receive_message(opts=T.unsafe(nil), &block); end

  def receive_messages(opts=T.unsafe(nil), &block); end

  def receive_opts(opts); end

  def send_message(body, options=T.unsafe(nil)); end

  def set_attribute(name, value); end

  def url(); end

  def verify_receive_message_checksum(response); end

  def verify_send_message_batch_checksum(entries, response); end

  def verify_send_message_checksum(body, md5); end

  def visibility_timeout(); end

  def visibility_timeout=(timeout); end

  def visible_messages(); end

  def wait_time_seconds(); end

  def wait_time_seconds=(seconds); end
  DEFAULT_POLL_INTERVAL = ::T.let(nil, ::T.untyped)
  DEFAULT_WAIT_TIME_SECONDS = ::T.let(nil, ::T.untyped)
end

module AWS::SQS::Queue::PolicyProxy
  def change(); end

  def delete(); end

  def queue(); end

  def queue=(queue); end
end

module AWS::SQS::Queue::PolicyProxy
end

class AWS::SQS::Queue::SentMessage
  def id(); end

  def md5(); end

  def md5=(md5); end

  def message_id(); end

  def message_id=(message_id); end

  def request_id(); end

  def request_id=(request_id); end
end

class AWS::SQS::Queue::SentMessage
end

class AWS::SQS::Queue
end

class AWS::SQS::QueueCollection
  include ::AWS::Core::Collection::Simple
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](url); end

  def _each_item(options, &block); end

  def create(name, options=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def named(queue_name, options=T.unsafe(nil)); end

  def prefix(); end

  def url_for(queue_name, options=T.unsafe(nil)); end

  def with_prefix(prefix); end
end

class AWS::SQS::QueueCollection
end

class AWS::SQS::ReceivedMessage
  include ::AWS::Core::Model
  def approximate_first_receive_timestamp(); end

  def approximate_receive_count(); end

  def as_sns_message(); end

  def attributes(); end

  def body(); end

  def delete(); end

  def first_received_at(); end

  def handle(); end

  def id(); end

  def initialize(queue, id, handle, opts=T.unsafe(nil)); end

  def md5(); end

  def message_attributes(); end

  def queue(); end

  def receive_count(); end

  def request_id(); end

  def sender_id(); end

  def sent_at(); end

  def sent_timestamp(); end

  def visibility_timeout=(timeout); end
  ATTRIBUTE_ALIASES = ::T.let(nil, ::T.untyped)
end

class AWS::SQS::ReceivedMessage
end

class AWS::SQS::ReceivedSNSMessage
  include ::AWS::Core::Model
  def body(); end

  def body_message_as_h(); end

  def initialize(body, options=T.unsafe(nil)); end

  def message_id(); end

  def message_type(); end

  def published_at(); end

  def raw_message(); end

  def signature(); end

  def signature_version(); end

  def signing_cert_url(); end

  def to_h(); end

  def topic(); end

  def topic_arn(); end

  def unsubscribe_url(); end
end

class AWS::SQS::ReceivedSNSMessage
end

class AWS::SQS
end

class AWS::STS
  include ::AWS::Core::ServiceInterface
  def assume_role(options=T.unsafe(nil)); end

  def client(); end

  def config(); end

  def get_session(method, opts=T.unsafe(nil)); end

  def new_federated_session(name, opts=T.unsafe(nil)); end

  def new_session(opts=T.unsafe(nil)); end
end

class AWS::STS::Client
  def do_sign_request(req); end

  def initialize(*args); end
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
  REGION_US_E1 = ::T.let(nil, ::T.untyped)
end

class AWS::STS::Client::V20110615
  def assume_role(*args, &block); end

  def assume_role_with_saml(*args, &block); end

  def assume_role_with_web_identity(*args, &block); end

  def decode_authorization_message(*args, &block); end

  def get_federation_token(*args, &block); end

  def get_session_token(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::STS::Client::V20110615
end

class AWS::STS::Client
end

module AWS::STS::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::STS::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::STS::FederatedSession
  def packed_policy_size(); end

  def user_arn(); end

  def user_id(); end
end

class AWS::STS::FederatedSession
end

class AWS::STS::Policy
end

class AWS::STS::Policy
end

class AWS::STS::Session
  def credentials(); end

  def expires_at(); end

  def initialize(opts=T.unsafe(nil)); end
end

class AWS::STS::Session
end

class AWS::STS
end

class AWS::SimpleDB
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def domains(); end
end

class AWS::SimpleDB::Attribute
  include ::AWS::Core::Model
  include ::Enumerable
  include ::AWS::SimpleDB::ConsistentReadOption
  include ::AWS::SimpleDB::PutAttributes
  include ::AWS::SimpleDB::DeleteAttributes
  include ::AWS::SimpleDB::ExpectConditionOption
  def <<(*values); end

  def add(*values); end

  def delete(*values); end

  def each(options=T.unsafe(nil), &block); end

  def initialize(item, name, options=T.unsafe(nil)); end

  def item(); end

  def name(); end

  def put(values, replace); end

  def set(*values); end

  def values(options=T.unsafe(nil)); end
end

class AWS::SimpleDB::Attribute
end

class AWS::SimpleDB::AttributeCollection
  include ::AWS::Core::Model
  include ::Enumerable
  include ::AWS::SimpleDB::ConsistentReadOption
  include ::AWS::SimpleDB::PutAttributes
  include ::AWS::SimpleDB::DeleteAttributes
  include ::AWS::SimpleDB::ExpectConditionOption
  def [](attribute_name); end

  def []=(attribute_name, *values); end

  def add(attributes); end

  def delete(*args); end

  def each(options=T.unsafe(nil), &block); end

  def each_value(options=T.unsafe(nil), &block); end

  def initialize(item, options=T.unsafe(nil)); end

  def item(); end

  def put(options=T.unsafe(nil)); end

  def replace(attributes); end

  def set(attributes); end

  def to_h(options=T.unsafe(nil)); end
end

class AWS::SimpleDB::AttributeCollection
end

class AWS::SimpleDB::Client
  def valid_domain_name?(name); end
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
  REGION_APAC_SE1 = ::T.let(nil, ::T.untyped)
  REGION_EU_W1 = ::T.let(nil, ::T.untyped)
  REGION_US_E1 = ::T.let(nil, ::T.untyped)
  REGION_US_W1 = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleDB::Client::V20090415
  def batch_delete_attributes(*args, &block); end

  def batch_put_attributes(*args, &block); end

  def create_domain(*args, &block); end

  def delete_attributes(*args, &block); end

  def delete_domain(*args, &block); end

  def domain_metadata(*args, &block); end

  def get_attributes(*args, &block); end

  def list_domains(*args, &block); end

  def put_attributes(*args, &block); end

  def select(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleDB::Client::V20090415
end

class AWS::SimpleDB::Client
  def self.valid_domain_name?(name); end
end

module AWS::SimpleDB::ConsistentReadOption
  def consistent_read(options); end
end

module AWS::SimpleDB::ConsistentReadOption
end

module AWS::SimpleDB::DeleteAttributes
  include ::AWS::SimpleDB::ExpectConditionOption
  def delete_attribute_values(attributes); end

  def delete_named_attributes(*attribute_names); end
end

module AWS::SimpleDB::DeleteAttributes
end

class AWS::SimpleDB::Domain
  include ::AWS::Core::Model
  def ==(other); end

  def delete(); end

  def delete!(); end

  def empty?(); end

  def eql?(other); end

  def exists?(); end

  def initialize(name, options=T.unsafe(nil)); end

  def items(); end

  def metadata(); end

  def name(); end
end

class AWS::SimpleDB::Domain::NonEmptyDeleteError
end

class AWS::SimpleDB::Domain::NonEmptyDeleteError
end

class AWS::SimpleDB::Domain
end

class AWS::SimpleDB::DomainCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](domain_name); end

  def _each_item(next_token, limit, options=T.unsafe(nil)); end

  def create(domain_name); end
end

class AWS::SimpleDB::DomainCollection
end

class AWS::SimpleDB::DomainMetadata
  include ::AWS::Core::Model
  def attribute_name_count(); end

  def attribute_names_size_bytes(); end

  def attribute_value_count(); end

  def attribute_values_size_bytes(); end

  def domain(); end

  def initialize(domain, options=T.unsafe(nil)); end

  def item_count(); end

  def item_names_size_bytes(); end

  def timestamp(); end

  def to_h(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleDB::DomainMetadata
end

module AWS::SimpleDB::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::SimpleDB::Errors
  extend ::AWS::Core::LazyErrorClasses
end

module AWS::SimpleDB::ExpectConditionOption
  def expect_condition_opts(opts); end
end

module AWS::SimpleDB::ExpectConditionOption
end

class AWS::SimpleDB::Item
  include ::AWS::Core::Model
  include ::AWS::SimpleDB::ExpectConditionOption
  include ::AWS::SimpleDB::ConsistentReadOption
  def ==(other); end

  def attributes(); end

  def data(options=T.unsafe(nil)); end

  def delete(options=T.unsafe(nil)); end

  def domain(); end

  def eql?(other); end

  def initialize(domain, name, options=T.unsafe(nil)); end

  def name(); end
end

class AWS::SimpleDB::Item
end

class AWS::SimpleDB::ItemCollection
  include ::AWS::SimpleDB::ConsistentReadOption
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](item_name); end

  def _each_item(next_token, max, options=T.unsafe(nil), &block); end

  def _limit(*args); end

  def coerce_attribute(name); end

  def coerce_substitution(subst); end

  def collection_with(options); end

  def conditions(); end

  def count(options=T.unsafe(nil), &block); end

  def create(item_name, *args); end

  def domain(); end

  def handle_query_options(*args); end

  def initialize(domain, options=T.unsafe(nil)); end

  def limit(*args); end

  def limit_clause(); end

  def order(attribute, order=T.unsafe(nil)); end

  def order_by_clause(); end

  def output_list(); end

  def replace_named_placeholders(orig_str, str, named); end

  def replace_placeholders(str, *substitutions); end

  def replace_placeholders_outside_quotes(str, count, substitutions, named=T.unsafe(nil)); end

  def replace_positional_placeders(str, count, substitutions); end

  def select(*attributes, &block); end

  def select_expression(options=T.unsafe(nil)); end

  def select_request(options, next_token=T.unsafe(nil), limit=T.unsafe(nil)); end

  def size(options=T.unsafe(nil), &block); end

  def sort_instructions(); end

  def where(conditions, *substitutions); end

  def where_clause(); end
  OUTSIDE_QUOTES_REGEX = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleDB::ItemCollection
end

class AWS::SimpleDB::ItemData
  def attributes(); end

  def domain(); end

  def initialize(opts=T.unsafe(nil)); end

  def item(); end

  def name(); end
end

class AWS::SimpleDB::ItemData
end

module AWS::SimpleDB::PutAttributes
  include ::AWS::SimpleDB::ExpectConditionOption
  def attribute_hashes(attributes, replace); end

  def do_put(attribute_hashes, expect_opts=T.unsafe(nil)); end
end

module AWS::SimpleDB::PutAttributes
end

class AWS::SimpleDB
  def self.consistent_reads(state=T.unsafe(nil), &block); end

  def self.consistent_reads_state(); end

  def self.in_consistent_reads_block?(); end
end

class AWS::SimpleEmailService
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def deliver(raw_message, options=T.unsafe(nil)); end

  def deliver!(raw_message, options=T.unsafe(nil)); end

  def email_addresses(); end

  def identities(); end

  def nest_options(options, accepted_options); end

  def quotas(); end

  def require_each(options, *keys); end

  def require_one_of(options, *keys); end

  def send_email(options=T.unsafe(nil)); end

  def send_raw_email(raw_message, options=T.unsafe(nil)); end

  def settings(); end

  def statistics(); end
end

class AWS::SimpleEmailService::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
  REGION_US_E1 = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleEmailService::Client::V20101201
  def delete_identity(*args, &block); end

  def delete_verified_email_address(*args, &block); end

  def get_identity_dkim_attributes(*args, &block); end

  def get_identity_notification_attributes(*args, &block); end

  def get_identity_verification_attributes(*args, &block); end

  def get_send_quota(*args, &block); end

  def get_send_statistics(*args, &block); end

  def list_identities(*args, &block); end

  def list_verified_email_addresses(*args, &block); end

  def send_email(*args, &block); end

  def send_raw_email(*args, &block); end

  def set_identity_dkim_enabled(*args, &block); end

  def set_identity_feedback_forwarding_enabled(*args, &block); end

  def set_identity_notification_topic(*args, &block); end

  def verify_domain_dkim(*args, &block); end

  def verify_domain_identity(*args, &block); end

  def verify_email_address(*args, &block); end

  def verify_email_identity(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleEmailService::Client::V20101201
end

class AWS::SimpleEmailService::Client
end

class AWS::SimpleEmailService::EmailAddressCollection
  include ::AWS::Core::Model
  include ::Enumerable
  def create(email_address); end

  def delete(email_address); end

  def each(&block); end

  def include?(); end

  def verified?(); end

  def verify(email_address); end
end

class AWS::SimpleEmailService::EmailAddressCollection
end

module AWS::SimpleEmailService::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::SimpleEmailService::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::SimpleEmailService::Identity
  def _find_in_get_identity_dkim_attributes_response_2(resp); end

  def _find_in_get_identity_notification_attributes_response_1(resp); end

  def _find_in_get_identity_verification_attributes_response_0(resp); end

  def bounce_topic(); end

  def bounce_topic=(topic); end

  def bounce_topic_arn(); end

  def bounce_topic_arn=(value); end

  def complaint_topic(); end

  def complaint_topic=(topic); end

  def complaint_topic_arn(); end

  def complaint_topic_arn=(value); end

  def delete(); end

  def delivery_topic(); end

  def delivery_topic=(topic); end

  def delivery_topic_arn(); end

  def delivery_topic_arn=(value); end

  def dkim_enabled(); end

  def dkim_enabled=(value); end

  def dkim_enabled?(); end

  def dkim_tokens(); end

  def dkim_verification_status(); end

  def domain?(); end

  def email_address?(); end

  def exists?(); end

  def forwarding_enabled(); end

  def forwarding_enabled=(value); end

  def forwarding_enabled?(); end

  def get_resource(attr); end

  def identity(); end

  def initialize(email_address_or_domain, options=T.unsafe(nil)); end

  def pending?(); end

  def verification_status(); end

  def verification_token(); end

  def verified?(); end

  def verify_dkim(); end
end

class AWS::SimpleEmailService::Identity
end

class AWS::SimpleEmailService::IdentityCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](email_or_domain); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def create(email_or_domain); end

  def domains(); end

  def email_addresses(); end

  def initialize(options=T.unsafe(nil)); end

  def verify(email_or_domain); end
end

class AWS::SimpleEmailService::IdentityCollection
end

class AWS::SimpleEmailService::Quotas
  include ::AWS::Core::Model
  def max_24_hour_send(); end

  def max_send_rate(); end

  def sent_last_24_hours(); end

  def to_h(); end

  def to_hash(); end
end

class AWS::SimpleEmailService::Quotas
end

class AWS::SimpleEmailService
end

class AWS::SimpleWorkflow
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end

  def domains(); end
end

class AWS::SimpleWorkflow::ActivityTask
  include ::AWS::Core::Model
  def activity_id(); end

  def activity_type(); end

  def cancel!(options=T.unsafe(nil)); end

  def complete!(options=T.unsafe(nil)); end

  def domain(); end

  def fail!(options=T.unsafe(nil)); end

  def initialize(domain, data, options=T.unsafe(nil)); end

  def input(); end

  def record_heartbeat!(options=T.unsafe(nil)); end

  def respond(status, options); end

  def responded?(); end

  def started_event_id(); end

  def task_token(); end

  def workflow_execution(); end
end

class AWS::SimpleWorkflow::ActivityTask::CancelRequestedError
end

class AWS::SimpleWorkflow::ActivityTask::CancelRequestedError
end

class AWS::SimpleWorkflow::ActivityTask
end

class AWS::SimpleWorkflow::ActivityTaskCollection
  include ::AWS::Core::Model
  include ::AWS::SimpleWorkflow::OptionFormatters
  def count(task_list); end

  def domain(); end

  def initialize(domain, options=T.unsafe(nil)); end

  def poll(task_list, options=T.unsafe(nil), &block); end

  def poll_for_single_task(task_list, options=T.unsafe(nil), &block); end
end

class AWS::SimpleWorkflow::ActivityTaskCollection
end

class AWS::SimpleWorkflow::ActivityType
  def _find_in_describe_activity_type_response_1(resp); end

  def _find_in_list_activity_types_response_0(resp); end

  def creation_date(); end

  def default_task_heartbeat_timeout(); end

  def default_task_list(); end

  def default_task_priority(); end

  def default_task_schedule_to_close_timeout(); end

  def default_task_schedule_to_start_timeout(); end

  def default_task_start_to_close_timeout(); end

  def deprecation_date(); end

  def description(); end

  def status(); end
end

class AWS::SimpleWorkflow::ActivityType
end

class AWS::SimpleWorkflow::ActivityTypeCollection
  def create(name, version, options=T.unsafe(nil)); end

  def register(name, version, options=T.unsafe(nil)); end
end

class AWS::SimpleWorkflow::ActivityTypeCollection
end

class AWS::SimpleWorkflow::Client
  def build_request(*args); end
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleWorkflow::Client::V20120125
  def count_closed_workflow_executions(*args, &block); end

  def count_open_workflow_executions(*args, &block); end

  def count_pending_activity_tasks(*args, &block); end

  def count_pending_decision_tasks(*args, &block); end

  def deprecate_activity_type(*args, &block); end

  def deprecate_domain(*args, &block); end

  def deprecate_workflow_type(*args, &block); end

  def describe_activity_type(*args, &block); end

  def describe_domain(*args, &block); end

  def describe_workflow_execution(*args, &block); end

  def describe_workflow_type(*args, &block); end

  def get_workflow_execution_history(*args, &block); end

  def list_activity_types(*args, &block); end

  def list_closed_workflow_executions(*args, &block); end

  def list_domains(*args, &block); end

  def list_open_workflow_executions(*args, &block); end

  def list_workflow_types(*args, &block); end

  def poll_for_activity_task(*args, &block); end

  def poll_for_decision_task(*args, &block); end

  def record_activity_task_heartbeat(*args, &block); end

  def register_activity_type(*args, &block); end

  def register_domain(*args, &block); end

  def register_workflow_type(*args, &block); end

  def request_cancel_workflow_execution(*args, &block); end

  def respond_activity_task_canceled(*args, &block); end

  def respond_activity_task_completed(*args, &block); end

  def respond_activity_task_failed(*args, &block); end

  def respond_decision_task_completed(*args, &block); end

  def signal_workflow_execution(*args, &block); end

  def start_workflow_execution(*args, &block); end

  def terminate_workflow_execution(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleWorkflow::Client::V20120125
end

class AWS::SimpleWorkflow::Client
end

class AWS::SimpleWorkflow::Count
  def ==(other); end

  def count(); end

  def eql?(other); end

  def initialize(count, truncated); end

  def to_i(); end

  def truncated?(); end
end

class AWS::SimpleWorkflow::Count
end

class AWS::SimpleWorkflow::DecisionTask
  include ::AWS::Core::Model
  include ::AWS::SimpleWorkflow::OptionFormatters
  def _each_event(events, &block); end

  def _events(&block); end

  def _new_events(&block); end

  def add_decision(decision_type, attributes); end

  def cancel_timer(timer_id); end

  def cancel_workflow_execution(options=T.unsafe(nil)); end

  def complete!(options=T.unsafe(nil)); end

  def complete_workflow_execution(options=T.unsafe(nil)); end

  def continue_as_new_workflow_execution(options=T.unsafe(nil)); end

  def domain(); end

  def events(); end

  def fail_workflow_execution(options=T.unsafe(nil)); end

  def initialize(domain, request_options, data); end

  def new_events(); end

  def next_token(); end

  def previous_started_event_id(); end

  def record_marker(marker_name, options=T.unsafe(nil)); end

  def request_cancel_activity_task(activity_or_activity_id); end

  def request_cancel_external_workflow_execution(workflow_execution, options=T.unsafe(nil)); end

  def responded?(); end

  def schedule_activity_task(activity_type, options=T.unsafe(nil)); end

  def signal_external_workflow_execution(workflow_execution, signal_name, options=T.unsafe(nil)); end

  def start_child_workflow_execution(workflow_type, options=T.unsafe(nil)); end

  def start_timer(start_to_fire_timeout, options=T.unsafe(nil)); end

  def started_event_id(); end

  def task_token(); end

  def workflow_execution(); end

  def workflow_execution_opts(options, workflow_execution); end

  def workflow_type(); end
end

class AWS::SimpleWorkflow::DecisionTask
end

class AWS::SimpleWorkflow::DecisionTaskCollection
  include ::AWS::Core::Model
  include ::AWS::SimpleWorkflow::OptionFormatters
  def count(task_list); end

  def domain(); end

  def initialize(domain, options=T.unsafe(nil)); end

  def poll(task_list, options=T.unsafe(nil), &block); end

  def poll_for_single_task(task_list, options=T.unsafe(nil), &block); end
end

class AWS::SimpleWorkflow::DecisionTaskCollection
end

class AWS::SimpleWorkflow::Domain
  include ::AWS::SimpleWorkflow::OptionFormatters
  def _find_in_describe_domain_response_0(resp); end

  def _find_in_list_domains_response_1(resp); end

  def activity_tasks(); end

  def activity_types(); end

  def decision_tasks(); end

  def delete(); end

  def deprecate(); end

  def deprecated?(); end

  def description(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def retention_period(); end

  def status(); end

  def workflow_executions(); end

  def workflow_types(); end
end

class AWS::SimpleWorkflow::Domain
end

class AWS::SimpleWorkflow::DomainCollection
  include ::AWS::SimpleWorkflow::OptionFormatters
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def collection_with(options=T.unsafe(nil)); end

  def create(name, retention_period, options=T.unsafe(nil)); end

  def deprecated(); end

  def initialize(options=T.unsafe(nil)); end

  def register(name, retention_period, options=T.unsafe(nil)); end

  def registered(); end

  def reverse_order(); end
end

class AWS::SimpleWorkflow::DomainCollection
end

module AWS::SimpleWorkflow::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::SimpleWorkflow::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::SimpleWorkflow::HistoryEvent
  include ::AWS::Core::Model
  def attributes(); end

  def created_at(); end

  def event_id(); end

  def event_type(); end

  def id(); end

  def initialize(workflow_execution, details); end

  def to_h(); end

  def to_json(); end

  def workflow_execution(); end
end

class AWS::SimpleWorkflow::HistoryEvent::Attributes
  def [](key); end

  def _camel_case(key); end

  def _cast(key, value); end

  def _key_string(); end

  def _snake_case(key); end

  def has_key?(key); end

  def include?(key); end

  def initialize(workflow_execution, data); end

  def key?(key); end

  def keys(); end

  def member?(key); end

  def method_missing(method); end

  def to_h(); end
end

class AWS::SimpleWorkflow::HistoryEvent::Attributes
end

class AWS::SimpleWorkflow::HistoryEvent
end

class AWS::SimpleWorkflow::HistoryEventCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def initialize(workflow_execution, options=T.unsafe(nil)); end

  def reverse_order(); end

  def workflow_execution(); end
end

class AWS::SimpleWorkflow::HistoryEventCollection
end

module AWS::SimpleWorkflow::OptionFormatters
  def duration_opts(options, *opt_names); end

  def identity_opt(options); end

  def start_execution_opts(options, workflow_type=T.unsafe(nil)); end

  def upcase_opts(options, *opt_names); end
end

module AWS::SimpleWorkflow::OptionFormatters
end

class AWS::SimpleWorkflow::Resource
  def exists?(); end

  def get_resource(attr_name=T.unsafe(nil)); end
end

class AWS::SimpleWorkflow::Resource
  def self.config_attribute(name, options=T.unsafe(nil), &block); end

  def self.config_attributes(); end

  def self.info_attribute(name, options=T.unsafe(nil)); end

  def self.info_attributes(); end

  def self.type_attribute(name, options=T.unsafe(nil), &block); end

  def self.type_attributes(); end
end

class AWS::SimpleWorkflow::Type
  def delete(); end

  def deprecate(); end

  def deprecated?(); end

  def domain(); end

  def initialize(domain, name, version, options=T.unsafe(nil)); end

  def name(); end

  def resource_options(); end

  def version(); end
end

class AWS::SimpleWorkflow::Type
  def self.ruby_name(); end

  def self.type_key(); end
end

class AWS::SimpleWorkflow::TypeCollection
  include ::AWS::SimpleWorkflow::OptionFormatters
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  def [](name, version); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def at(name, version); end

  def collection_with(options=T.unsafe(nil)); end

  def create(); end

  def deprecated(); end

  def domain(); end

  def initialize(domain, options=T.unsafe(nil)); end

  def member_class(); end

  def named(name); end

  def register(); end

  def reverse_order(); end
end

class AWS::SimpleWorkflow::TypeCollection
end

class AWS::SimpleWorkflow::WorkflowExecution
  def _find_in_describe_workflow_execution_response_1(resp); end

  def _find_in_list_open_workflow_executions_or_list_closed_workflow_executions_response_0(resp); end

  def cancel_requested(); end

  def cancel_requested?(); end

  def child_policy(); end

  def close_status(); end

  def closed?(); end

  def closed_at(); end

  def count_executions(options=T.unsafe(nil)); end

  def domain(); end

  def events(); end

  def execution_start_to_close_timeout(); end

  def execution_status(); end

  def history_events(); end

  def initialize(domain, workflow_id, run_id, options=T.unsafe(nil)); end

  def latest_activity_task_scheduled_at(); end

  def latest_execution_context(); end

  def open?(); end

  def open_activity_task_count(); end

  def open_child_workflow_execution_count(); end

  def open_counts(); end

  def open_decision_task_count(); end

  def open_timer_count(); end

  def parent(); end

  def parent_details(); end

  def request_cancel(); end

  def resource_options(); end

  def run_id(); end

  def signal(signal_name, options=T.unsafe(nil)); end

  def started_at(); end

  def status(); end

  def tag_list(); end

  def tags(); end

  def task_list(); end

  def task_priority(); end

  def task_start_to_close_timeout(); end

  def terminate(options=T.unsafe(nil)); end

  def type_details(); end

  def workflow_id(); end

  def workflow_type(); end
end

class AWS::SimpleWorkflow::WorkflowExecution
end

class AWS::SimpleWorkflow::WorkflowExecutionCollection
  include ::AWS::Core::Collection::WithLimitAndNextToken
  include ::AWS::Core::Model
  include ::AWS::Core::Collection
  include ::Enumerable
  include ::AWS::SimpleWorkflow::OptionFormatters
  def [](workflow_id, run_id); end

  def _each_item(next_token, limit, options=T.unsafe(nil), &block); end

  def at(workflow_id, run_id); end

  def closed_after(time); end

  def closed_before(time); end

  def closed_between(oldest_time, latest_time); end

  def collection_with(options=T.unsafe(nil)); end

  def count(options=T.unsafe(nil)); end

  def domain(); end

  def each(options=T.unsafe(nil), &blk); end

  def handle_options(options); end

  def initialize(domain, options=T.unsafe(nil)); end

  def request_cancel(workflow_id, options=T.unsafe(nil)); end

  def reverse_order(); end

  def signal(workflow_id, signal_name, options=T.unsafe(nil)); end

  def started_after(time); end

  def started_before(time); end

  def started_between(oldest_time, latest_time); end

  def tagged(tag); end

  def terminate(workflow_id, options=T.unsafe(nil)); end

  def time_filter(open_or_closed, options); end

  def to_timestamp(time); end

  def with_status(status); end

  def with_workflow_id(workflow_id); end

  def with_workflow_type(workflow_type); end
  FILTERS = ::T.let(nil, ::T.untyped)
end

class AWS::SimpleWorkflow::WorkflowExecutionCollection
end

class AWS::SimpleWorkflow::WorkflowType
  include ::AWS::SimpleWorkflow::OptionFormatters
  def _find_in_describe_workflow_type_response_1(resp); end

  def _find_in_list_workflow_types_response_0(resp); end

  def count_executions(options=T.unsafe(nil)); end

  def creation_date(); end

  def default_child_policy(); end

  def default_execution_start_to_close_timeout(); end

  def default_task_list(); end

  def default_task_priority(); end

  def default_task_start_to_close_timeout(); end

  def deprecation_date(); end

  def description(); end

  def start_execution(options=T.unsafe(nil)); end

  def status(); end

  def workflow_executions(); end
end

class AWS::SimpleWorkflow::WorkflowType
end

class AWS::SimpleWorkflow::WorkflowTypeCollection
  def create(name, version, options=T.unsafe(nil)); end

  def register(name, version, options=T.unsafe(nil)); end
end

class AWS::SimpleWorkflow::WorkflowTypeCollection
end

class AWS::SimpleWorkflow
end

class AWS::StorageGateway
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::StorageGateway::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::StorageGateway::Client::V20120630
  def activate_gateway(*args, &block); end

  def add_cache(*args, &block); end

  def add_upload_buffer(*args, &block); end

  def add_working_storage(*args, &block); end

  def create_cachedi_scsi_volume(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_snapshot_from_volume_recovery_point(*args, &block); end

  def create_storedi_scsi_volume(*args, &block); end

  def delete_bandwidth_rate_limit(*args, &block); end

  def delete_chap_credentials(*args, &block); end

  def delete_gateway(*args, &block); end

  def delete_snapshot_schedule(*args, &block); end

  def delete_volume(*args, &block); end

  def describe_bandwidth_rate_limit(*args, &block); end

  def describe_cache(*args, &block); end

  def describe_cachedi_scsi_volumes(*args, &block); end

  def describe_chap_credentials(*args, &block); end

  def describe_gateway_information(*args, &block); end

  def describe_maintenance_start_time(*args, &block); end

  def describe_snapshot_schedule(*args, &block); end

  def describe_storedi_scsi_volumes(*args, &block); end

  def describe_upload_buffer(*args, &block); end

  def describe_working_storage(*args, &block); end

  def list_gateways(*args, &block); end

  def list_local_disks(*args, &block); end

  def list_volume_recovery_points(*args, &block); end

  def list_volumes(*args, &block); end

  def shutdown_gateway(*args, &block); end

  def start_gateway(*args, &block); end

  def update_bandwidth_rate_limit(*args, &block); end

  def update_chap_credentials(*args, &block); end

  def update_gateway_information(*args, &block); end

  def update_gateway_software_now(*args, &block); end

  def update_maintenance_start_time(*args, &block); end

  def update_snapshot_schedule(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::StorageGateway::Client::V20120630
end

class AWS::StorageGateway::Client::V20130630
  def activate_gateway(*args, &block); end

  def add_cache(*args, &block); end

  def add_upload_buffer(*args, &block); end

  def add_working_storage(*args, &block); end

  def cancel_archival(*args, &block); end

  def cancel_retrieval(*args, &block); end

  def create_cachedi_scsi_volume(*args, &block); end

  def create_snapshot(*args, &block); end

  def create_snapshot_from_volume_recovery_point(*args, &block); end

  def create_storedi_scsi_volume(*args, &block); end

  def create_tapes(*args, &block); end

  def delete_bandwidth_rate_limit(*args, &block); end

  def delete_chap_credentials(*args, &block); end

  def delete_gateway(*args, &block); end

  def delete_snapshot_schedule(*args, &block); end

  def delete_tape(*args, &block); end

  def delete_tape_archive(*args, &block); end

  def delete_volume(*args, &block); end

  def describe_bandwidth_rate_limit(*args, &block); end

  def describe_cache(*args, &block); end

  def describe_cachedi_scsi_volumes(*args, &block); end

  def describe_chap_credentials(*args, &block); end

  def describe_gateway_information(*args, &block); end

  def describe_maintenance_start_time(*args, &block); end

  def describe_snapshot_schedule(*args, &block); end

  def describe_storedi_scsi_volumes(*args, &block); end

  def describe_tape_archives(*args, &block); end

  def describe_tape_recovery_points(*args, &block); end

  def describe_tapes(*args, &block); end

  def describe_upload_buffer(*args, &block); end

  def describe_vtl_devices(*args, &block); end

  def describe_working_storage(*args, &block); end

  def disable_gateway(*args, &block); end

  def list_gateways(*args, &block); end

  def list_local_disks(*args, &block); end

  def list_volume_recovery_points(*args, &block); end

  def list_volumes(*args, &block); end

  def retrieve_tape_archive(*args, &block); end

  def retrieve_tape_recovery_point(*args, &block); end

  def shutdown_gateway(*args, &block); end

  def start_gateway(*args, &block); end

  def update_bandwidth_rate_limit(*args, &block); end

  def update_chap_credentials(*args, &block); end

  def update_gateway_information(*args, &block); end

  def update_gateway_software_now(*args, &block); end

  def update_maintenance_start_time(*args, &block); end

  def update_snapshot_schedule(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::StorageGateway::Client::V20130630
end

class AWS::StorageGateway::Client
end

module AWS::StorageGateway::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::StorageGateway::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::StorageGateway
end

class AWS::Support
  include ::AWS::Core::ServiceInterface
  def client(); end

  def config(); end
end

class AWS::Support::Client
  API_VERSION = ::T.let(nil, ::T.untyped)
  CACHEABLE_REQUESTS = ::T.let(nil, ::T.untyped)
end

class AWS::Support::Client::V20130415
  def add_attachments_to_set(*args, &block); end

  def add_communication_to_case(*args, &block); end

  def create_case(*args, &block); end

  def describe_attachment(*args, &block); end

  def describe_cases(*args, &block); end

  def describe_communications(*args, &block); end

  def describe_services(*args, &block); end

  def describe_severity_levels(*args, &block); end

  def describe_trusted_advisor_check_refresh_statuses(*args, &block); end

  def describe_trusted_advisor_check_result(*args, &block); end

  def describe_trusted_advisor_check_summaries(*args, &block); end

  def describe_trusted_advisor_checks(*args, &block); end

  def refresh_trusted_advisor_check(*args, &block); end

  def resolve_case(*args, &block); end
  API_VERSION = ::T.let(nil, ::T.untyped)
end

class AWS::Support::Client::V20130415
end

class AWS::Support::Client
end

module AWS::Support::Errors
  include ::AWS::Errors
  GRAMMAR = ::T.let(nil, ::T.untyped)
end

module AWS::Support::Errors
  extend ::AWS::Core::LazyErrorClasses
end

class AWS::Support
end

class AWS::SvcDetails
  def class_name(); end

  def full_name(); end

  def initialize(class_name, options); end

  def method_alias(); end

  def method_name(); end

  def old_name(); end
end

class AWS::SvcDetails
end

module AWS
  def self.api_versions(); end

  def self.auto_scaling(*args); end

  def self.cloud_formation(*args); end

  def self.cloud_front(*args); end

  def self.cloud_search(*args); end

  def self.cloud_trail(*args); end

  def self.cloud_watch(*args); end

  def self.config(options=T.unsafe(nil)); end

  def self.data_pipeline(*args); end

  def self.direct_connect(*args); end

  def self.dynamo_db(*args); end

  def self.eager_autoload!(klass_or_module=T.unsafe(nil), visited=T.unsafe(nil)); end

  def self.ec2(*args); end

  def self.elastic_beanstalk(*args); end

  def self.elastic_transcoder(*args); end

  def self.elasticache(*args); end

  def self.elb(*args); end

  def self.emr(*args); end

  def self.glacier(*args); end

  def self.iam(*args); end

  def self.import_export(*args); end

  def self.kinesis(*args); end

  def self.memoize(); end

  def self.memoizing?(); end

  def self.ops_works(*args); end

  def self.patch_net_http_100_continue!(); end

  def self.rds(*args); end

  def self.redshift(*args); end

  def self.regions(); end

  def self.reset_memoization(); end

  def self.resource_cache(); end

  def self.response_cache(); end

  def self.route_53(*args); end

  def self.s3(*args); end

  def self.ses(*args); end

  def self.simple_db(*args); end

  def self.simple_email_service(*args); end

  def self.simple_workflow(*args); end

  def self.sns(*args); end

  def self.sqs(*args); end

  def self.start_memoizing(); end

  def self.stop_memoizing(); end

  def self.storage_gateway(*args); end

  def self.sts(*args); end

  def self.stub!(); end

  def self.support(*args); end

  def self.swf(*args); end
end

class AbstractController::ActionNotFound
end

class AbstractController::ActionNotFound
end

module AbstractController::AssetPaths
end

module AbstractController::AssetPaths
  extend ::ActiveSupport::Concern
end

class AbstractController::Base
  include ::ActiveSupport::Configurable
  def action_methods(); end

  def action_name(); end

  def action_name=(action_name); end

  def available_action?(action_name); end

  def controller_path(); end

  def formats(); end

  def formats=(formats); end

  def process(action, *args); end

  def response_body(); end

  def response_body=(response_body); end

  def send_action(*_); end
end

class AbstractController::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.abstract(); end

  def self.abstract!(); end

  def self.abstract?(); end

  def self.action_methods(); end

  def self.clear_action_methods!(); end

  def self.controller_path(); end

  def self.hidden_actions(); end

  def self.inherited(klass); end

  def self.internal_methods(); end

  def self.method_added(name); end

  def self.supports_path?(); end
end

module AbstractController::Callbacks
  def process_action(*args); end
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block=T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  def _normalize_callback_options(options); end

  def after_filter(*names, &blk); end

  def append_after_filter(*names, &blk); end

  def append_around_filter(*names, &blk); end

  def append_before_filter(*names, &blk); end

  def around_filter(*names, &blk); end

  def before_filter(*names, &blk); end

  def prepend_after_filter(*names, &blk); end

  def prepend_around_filter(*names, &blk); end

  def prepend_before_filter(*names, &blk); end

  def skip_action_callback(*names); end

  def skip_after_filter(*names); end

  def skip_around_filter(*names); end

  def skip_before_filter(*names); end

  def skip_filter(*names); end
end

module AbstractController::Callbacks
  extend ::ActiveSupport::Concern
end

module AbstractController::Collector
  def atom(*args, &block); end

  def bmp(*args, &block); end

  def css(*args, &block); end

  def csv(*args, &block); end

  def gif(*args, &block); end

  def html(*args, &block); end

  def ics(*args, &block); end

  def jpeg(*args, &block); end

  def js(*args, &block); end

  def json(*args, &block); end

  def method_missing(symbol, &block); end

  def mpeg(*args, &block); end

  def multipart_form(*args, &block); end

  def pdf(*args, &block); end

  def png(*args, &block); end

  def rss(*args, &block); end

  def text(*args, &block); end

  def tiff(*args, &block); end

  def url_encoded_form(*args, &block); end

  def vcf(*args, &block); end

  def web_console_v2(*args, &block); end

  def xml(*args, &block); end

  def yaml(*args, &block); end

  def zip(*args, &block); end
end

module AbstractController::Collector
  def self.generate_method_for_mime(mime); end
end

class AbstractController::DoubleRenderError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class AbstractController::DoubleRenderError
end

class AbstractController::Error
end

class AbstractController::Error
end

module AbstractController::Helpers
end

module AbstractController::Helpers::ClassMethods
  def clear_helpers(); end

  def helper(*args, &block); end

  def helper_method(*meths); end

  def inherited(klass); end

  def modules_for_helpers(args); end
end

module AbstractController::Helpers::ClassMethods
end

class AbstractController::Helpers::MissingHelperError
  def initialize(error, path); end
end

class AbstractController::Helpers::MissingHelperError
end

module AbstractController::Helpers
  extend ::ActiveSupport::Concern
end

module AbstractController::Logger
end

module AbstractController::Logger
  extend ::ActiveSupport::Concern
end

module AbstractController::Railties
end

module AbstractController::Railties::RoutesHelpers
end

module AbstractController::Railties::RoutesHelpers
  def self.with(routes, include_path_helpers=T.unsafe(nil)); end
end

module AbstractController::Railties
end

module AbstractController::Rendering
  def _normalize_args(action=T.unsafe(nil), options=T.unsafe(nil)); end

  def _normalize_options(options); end

  def _normalize_render(*args, &block); end

  def _process_format(format, options=T.unsafe(nil)); end

  def _process_options(options); end

  def _protected_ivars(); end

  def render(*args, &block); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*args, &block); end

  def rendered_format(); end

  def view_assigns(); end
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  extend ::ActiveSupport::Concern
end

module AbstractController::Translation
  def l(*args); end

  def localize(*args); end

  def t(*args); end

  def translate(*args); end
end

module AbstractController::Translation
end

module AbstractController::UrlFor
  def _routes(); end
end

module AbstractController::UrlFor::ClassMethods
  def _routes(); end

  def action_methods(); end
end

module AbstractController::UrlFor::ClassMethods
end

module AbstractController::UrlFor
  extend ::ActiveSupport::Concern
end

module AbstractController
  extend ::ActiveSupport::Autoload
end

class Account
  def after_add_for_first_row_logs(); end

  def after_add_for_first_row_logs=(after_add_for_first_row_logs); end

  def after_add_for_first_row_logs?(); end

  def after_add_for_second_row_logs(); end

  def after_add_for_second_row_logs=(after_add_for_second_row_logs); end

  def after_add_for_second_row_logs?(); end

  def after_remove_for_first_row_logs(); end

  def after_remove_for_first_row_logs=(after_remove_for_first_row_logs); end

  def after_remove_for_first_row_logs?(); end

  def after_remove_for_second_row_logs(); end

  def after_remove_for_second_row_logs=(after_remove_for_second_row_logs); end

  def after_remove_for_second_row_logs?(); end

  def autosave_associated_records_for_budget(*args); end

  def autosave_associated_records_for_first_row_logs(*args); end

  def autosave_associated_records_for_job(*args); end

  def autosave_associated_records_for_operation(*args); end

  def autosave_associated_records_for_second_row_logs(*args); end

  def autosave_associated_records_for_user(*args); end

  def before_add_for_first_row_logs(); end

  def before_add_for_first_row_logs=(before_add_for_first_row_logs); end

  def before_add_for_first_row_logs?(); end

  def before_add_for_second_row_logs(); end

  def before_add_for_second_row_logs=(before_add_for_second_row_logs); end

  def before_add_for_second_row_logs?(); end

  def before_remove_for_first_row_logs(); end

  def before_remove_for_first_row_logs=(before_remove_for_first_row_logs); end

  def before_remove_for_first_row_logs?(); end

  def before_remove_for_second_row_logs(); end

  def before_remove_for_second_row_logs=(before_remove_for_second_row_logs); end

  def before_remove_for_second_row_logs?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_first_row_logs(*args); end

  def validate_associated_records_for_second_row_logs(*args); end
end

class Account::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Account::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Account::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Account::GeneratedAssociationMethods
  def build_budget(*args, &block); end

  def build_job(*args, &block); end

  def build_operation(*args, &block); end

  def build_user(*args, &block); end

  def create_budget(*args, &block); end

  def create_budget!(*args, &block); end

  def create_job(*args, &block); end

  def create_job!(*args, &block); end

  def create_operation(*args, &block); end

  def create_operation!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def first_row_log_ids(); end

  def first_row_log_ids=(ids); end

  def second_row_log_ids(); end

  def second_row_log_ids=(ids); end
end

class Account
  def self.after_add_for_first_row_logs(); end

  def self.after_add_for_first_row_logs=(val); end

  def self.after_add_for_first_row_logs?(); end

  def self.after_add_for_second_row_logs(); end

  def self.after_add_for_second_row_logs=(val); end

  def self.after_add_for_second_row_logs?(); end

  def self.after_remove_for_first_row_logs(); end

  def self.after_remove_for_first_row_logs=(val); end

  def self.after_remove_for_first_row_logs?(); end

  def self.after_remove_for_second_row_logs(); end

  def self.after_remove_for_second_row_logs=(val); end

  def self.after_remove_for_second_row_logs?(); end

  def self.before_add_for_first_row_logs(); end

  def self.before_add_for_first_row_logs=(val); end

  def self.before_add_for_first_row_logs?(); end

  def self.before_add_for_second_row_logs(); end

  def self.before_add_for_second_row_logs=(val); end

  def self.before_add_for_second_row_logs?(); end

  def self.before_remove_for_first_row_logs(); end

  def self.before_remove_for_first_row_logs=(val); end

  def self.before_remove_for_first_row_logs?(); end

  def self.before_remove_for_second_row_logs(); end

  def self.before_remove_for_second_row_logs=(val); end

  def self.before_remove_for_second_row_logs?(); end
end

class AccountLog
  def autosave_associated_records_for_first_row(*args); end

  def autosave_associated_records_for_second_row(*args); end

  def autosave_associated_records_for_user(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class AccountLog::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class AccountLog::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class AccountLog::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module AccountLog::GeneratedAssociationMethods
  def build_first_row(*args, &block); end

  def build_second_row(*args, &block); end

  def build_user(*args, &block); end

  def create_first_row(*args, &block); end

  def create_first_row!(*args, &block); end

  def create_second_row(*args, &block); end

  def create_second_row!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end
end

class ActionController::ActionControllerError
end

class ActionController::ActionControllerError
end

class ActionController::BadRequest
  def initialize(type=T.unsafe(nil), e=T.unsafe(nil)); end

  def original_exception(); end
end

class ActionController::BadRequest
end

class ActionController::Base
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionController::HideActions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::RackDelegation
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::EtagWithTemplateDigest
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::Caching
  include ::ActionController::Caching::ConfigMethods
  include ::ActionController::Caching::Fragments
  include ::ActionController::MimeResponds
  include ::ActionController::ImplicitRender
  include ::ActiveSupport::Rescuable
  include ::ActionController::StrongParameters
  include ::ActionController::Cookies
  include ::ActionController::Flash
  include ::ActionController::RequestForgeryProtection
  include ::ActionController::ForceSSL
  include ::ActionController::Streaming
  include ::ActionController::DataStreaming
  include ::ActionController::HttpAuthentication::Basic::ControllerMethods
  include ::ActionController::HttpAuthentication::Digest::ControllerMethods
  include ::ActionController::HttpAuthentication::Token::ControllerMethods
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::AngularRailsCsrf::Concern
  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(_helpers); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _process_action_callbacks?(); end

  def _renderers(); end

  def _renderers=(_renderers); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(_view_cache_dependencies); end

  def _view_cache_dependencies?(); end

  def _view_paths(); end

  def _view_paths=(_view_paths); end

  def _view_paths?(); end

  def _wrapper_options(); end

  def _wrapper_options=(_wrapper_options); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(etag_with_template_digest); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(etaggers); end

  def etaggers?(); end

  def flash(*args, &block); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def helpers_path(); end

  def helpers_path=(helpers_path); end

  def helpers_path?(); end

  def hidden_actions(); end

  def hidden_actions=(hidden_actions); end

  def hidden_actions?(); end

  def include_all_helpers(); end

  def include_all_helpers=(include_all_helpers); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def notice(); end

  def perform_caching(); end

  def perform_caching=(value); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionController::Base
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::Caching::ConfigMethods
  extend ::ActionController::Railties::Helpers
  extend ::WillPaginate::Railtie::ControllerRescuePatch
  def self._flash_types(); end

  def self._flash_types=(val); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(val); end

  def self._process_action_callbacks?(); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self._view_paths(); end

  def self._view_paths=(val); end

  def self._view_paths?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(val); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.helpers_path(); end

  def self.helpers_path=(val); end

  def self.helpers_path?(); end

  def self.hidden_actions=(val); end

  def self.hidden_actions?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(val); end

  def self.include_all_helpers?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.protected_instance_variables(); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.without_modules(*modules); end
end

module ActionController::Caching
  include ::ActionController::Caching::ConfigMethods
  include ::ActionController::Caching::Fragments
  def cache(key, options=T.unsafe(nil), &block); end

  def view_cache_dependencies(); end
end

module ActionController::Caching::ConfigMethods
  def cache_store(); end

  def cache_store=(store); end
end

module ActionController::Caching::ConfigMethods
end

module ActionController::Caching::Fragments
  def expire_fragment(key, options=T.unsafe(nil)); end

  def fragment_cache_key(key); end

  def fragment_exist?(key, options=T.unsafe(nil)); end

  def instrument_fragment_cache(name, key); end

  def read_fragment(key, options=T.unsafe(nil)); end

  def write_fragment(key, content, options=T.unsafe(nil)); end
end

module ActionController::Caching::Fragments
end

module ActionController::Caching
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActionController::ConditionalGet
  include ::ActionController::Head
  def expires_in(seconds, options=T.unsafe(nil)); end

  def expires_now(); end

  def fresh_when(record_or_options, additional_options=T.unsafe(nil)); end

  def stale?(record_or_options, additional_options=T.unsafe(nil)); end
end

module ActionController::ConditionalGet
  extend ::ActiveSupport::Concern
end

module ActionController::Cookies
end

module ActionController::Cookies
  extend ::ActiveSupport::Concern
end

module ActionController::DataStreaming
  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithTemplateDigest
end

module ActionController::EtagWithTemplateDigest
  extend ::ActiveSupport::Concern
end

module ActionController::Flash
  def redirect_to(options=T.unsafe(nil), response_status_and_flash=T.unsafe(nil)); end
end

module ActionController::Flash
  extend ::ActiveSupport::Concern
end

module ActionController::ForceSSL
  def force_ssl_redirect(host_or_options=T.unsafe(nil)); end
  ACTION_OPTIONS = ::T.let(nil, ::T.untyped)
  REDIRECT_OPTIONS = ::T.let(nil, ::T.untyped)
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::ForceSSL
  extend ::ActiveSupport::Concern
end

module ActionController::Head
  def head(status, options=T.unsafe(nil)); end
end

module ActionController::Head
end

module ActionController::Helpers
end

module ActionController::Helpers
  extend ::ActiveSupport::Concern
  def self.helpers_path(); end

  def self.helpers_path=(helpers_path); end
end

module ActionController::HideActions
end

module ActionController::HideActions
  extend ::ActiveSupport::Concern
end

module ActionController::HttpAuthentication
end

module ActionController::HttpAuthentication::Basic
  def auth_param(request); end

  def auth_scheme(request); end

  def authenticate(request, &login_procedure); end

  def authentication_request(controller, realm); end

  def decode_credentials(request); end

  def encode_credentials(user_name, password); end

  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  def authenticate_or_request_with_http_basic(realm=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_basic(&login_procedure); end

  def request_http_basic_authentication(realm=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend ::ActiveSupport::Concern
end

module ActionController::HttpAuthentication::Basic
  extend ::ActionController::HttpAuthentication::Basic
end

module ActionController::HttpAuthentication::Digest
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def decode_credentials(header); end

  def decode_credentials_header(request); end

  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  def expected_response(http_method, uri, credentials, password, password_is_ha1=T.unsafe(nil)); end

  def ha1(credentials, password); end

  def nonce(secret_key, time=T.unsafe(nil)); end

  def opaque(secret_key); end

  def secret_token(request); end

  def validate_digest_response(request, realm, &password_procedure); end

  def validate_nonce(secret_key, request, value, seconds_to_timeout=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def authenticate_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def request_http_digest_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
end

module ActionController::HttpAuthentication::Digest
  extend ::ActionController::HttpAuthentication::Digest
end

module ActionController::HttpAuthentication::Token
  def authenticate(controller, &login_procedure); end

  def authentication_request(controller, realm); end

  def encode_credentials(token, options=T.unsafe(nil)); end

  def params_array_from(raw_params); end

  def raw_params(auth); end

  def rewrite_param_values(array_params); end

  def token_and_options(request); end

  def token_params_from(auth); end
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_token(&login_procedure); end

  def request_http_token_authentication(realm=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token::ControllerMethods
end

module ActionController::HttpAuthentication::Token
  extend ::ActionController::HttpAuthentication::Token
end

module ActionController::HttpAuthentication
end

module ActionController::ImplicitRender
  def default_render(*args); end

  def method_for_action(action_name); end

  def send_action(method, *args); end
end

module ActionController::ImplicitRender
end

module ActionController::Instrumentation
  def process_action(*args); end

  def redirect_to(*args); end

  def render(*args); end

  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end

  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

module ActionController::Instrumentation
  extend ::ActiveSupport::Concern
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidCrossOriginRequest
end

class ActionController::InvalidCrossOriginRequest
end

module ActionController::Live
  def log_error(exception); end

  def process(name); end

  def response_body=(body); end

  def set_response!(request); end
end

class ActionController::Live::Buffer
  include ::MonitorMixin
  def await_close(); end

  def call_on_error(); end

  def connected?(); end

  def each(&blk); end

  def ignore_disconnect(); end

  def ignore_disconnect=(ignore_disconnect); end

  def initialize(response); end

  def on_error(&block); end
end

class ActionController::Live::Buffer
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::Response
end

class ActionController::Live::Response::Header
  def []=(k, v); end

  def initialize(response, header); end

  def merge(other); end

  def to_hash(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::Response::Header
end

class ActionController::Live::Response
end

class ActionController::Live::SSE
  def close(); end

  def initialize(stream, options=T.unsafe(nil)); end

  def write(object, options=T.unsafe(nil)); end
  WHITELISTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::SSE
end

module ActionController::Live
end

class ActionController::LiveTestResponse
  def error?(); end

  def missing?(); end

  def recycle!(); end

  def success?(); end
end

class ActionController::LiveTestResponse
end

class ActionController::LogSubscriber
  def deep_munge(event); end

  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end

  def write_page(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::LogSubscriber
end

class ActionController::Metal
  def content_type(); end

  def content_type=(type); end

  def controller_name(); end

  def dispatch(name, request); end

  def env(); end

  def env=(env); end

  def headers(); end

  def headers=(headers); end

  def location(); end

  def location=(url); end

  def middleware_stack(); end

  def middleware_stack=(middleware_stack); end

  def middleware_stack?(); end

  def params=(val); end

  def performed?(); end

  def request=(request); end

  def response=(response); end

  def response_body=(body); end

  def response_code(); end

  def session(*args, &block); end

  def status(); end

  def status=(status); end

  def to_a(); end

  def url_for(string); end
end

class ActionController::Metal
  def self.action(name, klass=T.unsafe(nil)); end

  def self.call(env); end

  def self.controller_name(); end

  def self.inherited(base); end

  def self.middleware(); end

  def self.middleware_stack(); end

  def self.middleware_stack=(val); end

  def self.middleware_stack?(); end

  def self.use(*args, &block); end
end

class ActionController::MethodNotAllowed
  def initialize(*allowed_methods); end
end

class ActionController::MethodNotAllowed
end

class ActionController::Middleware
  def app(); end

  def app=(app); end

  def index(); end

  def initialize(app); end

  def process(action); end
end

class ActionController::Middleware::ActionMiddleware
  def call(env); end

  def initialize(controller, app); end
end

class ActionController::Middleware::ActionMiddleware
end

class ActionController::Middleware
  def self.build(*_); end

  def self.new(app); end
end

class ActionController::MiddlewareStack
  def build(action, app=T.unsafe(nil)); end
end

class ActionController::MiddlewareStack::Middleware
  def initialize(klass, *args, &block); end

  def valid?(action); end
end

class ActionController::MiddlewareStack::Middleware
end

class ActionController::MiddlewareStack
end

module ActionController::MimeResponds
  def respond_with(*_); end
end

module ActionController::MimeResponds
  extend ::ActiveSupport::Concern
end

class ActionController::MissingFile
end

class ActionController::MissingFile
end

class ActionController::MissingRenderer
  def initialize(format); end
end

class ActionController::MissingRenderer
end

module ActionController::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

module ActionController::ModelNaming
end

class ActionController::NotImplemented
end

class ActionController::NotImplemented
end

class ActionController::ParameterMissing
  def initialize(param); end

  def param(); end
end

class ActionController::ParameterMissing
end

class ActionController::Parameters
  include ::SorbetRails::CustomParamsMethods
  def converted_arrays(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper
  def process_action(*args); end
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper
  extend ::ActiveSupport::Concern
end

module ActionController::RackDelegation
  def content_type(*args, &block); end

  def content_type=(arg); end

  def dispatch(action, request); end

  def headers(*args, &block); end

  def location(*args, &block); end

  def location=(arg); end

  def reset_session(); end

  def response_body=(body); end

  def response_code(*args, &block); end

  def status(*args, &block); end

  def status=(arg); end
end

module ActionController::RackDelegation
  extend ::ActiveSupport::Concern
end

class ActionController::Railtie
end

class ActionController::Railtie
end

module ActionController::Railties
end

module ActionController::Railties::Helpers
  def inherited(klass); end
end

module ActionController::Railties::Helpers
end

module ActionController::Railties
end

class ActionController::RedirectBackError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RedirectBackError
end

module ActionController::Redirecting
  def _compute_redirect_to_location(request, options); end

  def redirect_to(options=T.unsafe(nil), response_status=T.unsafe(nil)); end
end

module ActionController::Redirecting
  extend ::ActiveSupport::Concern
  def self._compute_redirect_to_location(request, options); end
end

class ActionController::RenderError
end

class ActionController::RenderError
end

module ActionController::Renderers
  def _render_to_body_with_renderer(options); end

  def _render_with_renderer_js(js, options); end

  def _render_with_renderer_json(json, options); end

  def _render_with_renderer_xml(xml, options); end

  def render_to_body(options); end
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers::All
end

module ActionController::Renderers::All
  extend ::ActiveSupport::Concern
end

module ActionController::Renderers
  extend ::ActiveSupport::Concern
  def self._render_with_renderer_method_name(key); end

  def self.add(key, &block); end

  def self.remove(key); end
end

module ActionController::Rendering
  def process_action(*_); end

  def render(*args); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*_); end
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering
  extend ::ActiveSupport::Concern
end

module ActionController::RequestForgeryProtection
  def compare_with_real_token(token, session); end

  def form_authenticity_param(); end

  def form_authenticity_token(); end

  def handle_unverified_request(); end

  def mark_for_same_origin_verification!(); end

  def marked_for_same_origin_verification?(); end

  def masked_authenticity_token(session); end

  def non_xhr_javascript_response?(); end

  def protect_against_forgery?(); end

  def real_csrf_token(session); end

  def valid_authenticity_token?(session, encoded_masked_token); end

  def verified_request?(); end

  def verify_authenticity_token(); end

  def verify_same_origin_request(); end

  def xor_byte_strings(s1, s2); end
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection
  extend ::ActiveSupport::Concern
end

module ActionController::Rescue
  def rescue_with_handler(exception); end

  def show_detailed_exceptions?(); end
end

module ActionController::Rescue
  extend ::ActiveSupport::Concern
end

class ActionController::RoutingError
  def failures(); end

  def initialize(message, failures=T.unsafe(nil)); end
end

class ActionController::RoutingError
end

class ActionController::SessionOverflowError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::SessionOverflowError
end

module ActionController::Streaming
  def _process_options(options); end

  def _render_template(options); end
end

module ActionController::Streaming
  extend ::ActiveSupport::Concern
end

module ActionController::StrongParameters
  def params=(value); end
end

module ActionController::StrongParameters
  extend ::ActiveSupport::Concern
end

module ActionController::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def process(*args); end

  def reset_template_assertion(); end

  def setup_subscriptions(); end

  def teardown_subscriptions(); end
  RENDER_TEMPLATE_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module ActionController::TemplateAssertions
  extend ::ActiveSupport::Concern
end

class ActionController::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::TagAssertions
  include ::ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def _controller_class(); end

  def _controller_class=(_controller_class); end

  def _controller_class?(); end
end

module ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  def build_request(); end

  def build_response(klass); end

  def delete(action, *args); end

  def get(action, *args); end

  def head(action, *args); end

  def paramify_values(hash_or_array_or_value); end

  def patch(action, *args); end

  def post(action, *args); end

  def process(action, http_method=T.unsafe(nil), *args); end

  def put(action, *args); end

  def request(); end

  def response(); end

  def setup_controller_request_and_response(); end

  def xhr(request_method, action, parameters=T.unsafe(nil), session=T.unsafe(nil), flash=T.unsafe(nil)); end

  def xml_http_request(request_method, action, parameters=T.unsafe(nil), session=T.unsafe(nil), flash=T.unsafe(nil)); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class(); end

  def controller_class=(new_class); end

  def determine_default_controller_class(name); end

  def tests(controller_class); end
end

module ActionController::TestCase::Behavior::ClassMethods
end

module ActionController::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionController::TestCase
  extend ::ActionController::TestCase::Behavior::ClassMethods
  def self._controller_class(); end

  def self._controller_class=(val); end

  def self._controller_class?(); end
end

class ActionController::TestRequest
  def assign_parameters(routes, controller_path, action, parameters=T.unsafe(nil)); end

  def recycle!(); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
end

class ActionController::TestResponse
end

class ActionController::TestSession
  def fetch(key, *args, &block); end

  def initialize(session=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::TestSession
end

module ActionController::Testing
  def headers=(new_headers); end
end

module ActionController::Testing::ClassMethods
  def before_filters(); end
end

module ActionController::Testing::ClassMethods
end

module ActionController::Testing::Functional
  def recycle!(); end

  def set_response!(request); end
end

module ActionController::Testing::Functional
end

module ActionController::Testing
  extend ::ActiveSupport::Concern
end

class ActionController::UnknownController
end

class ActionController::UnknownController
end

class ActionController::UnknownFormat
end

class ActionController::UnknownFormat
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnpermittedParameters
  def initialize(params); end

  def params(); end
end

class ActionController::UnpermittedParameters
end

module ActionController::UrlFor
  def url_options(); end
end

module ActionController::UrlFor
  extend ::ActiveSupport::Concern
end

class ActionController::UrlGenerationError
end

class ActionController::UrlGenerationError
end

module ActionController
  extend ::ActiveSupport::Autoload
  def self.add_renderer(key, &block); end

  def self.remove_renderer(key); end
end

module ActionDispatch
  def test_app(); end

  def test_app=(obj); end
end

module ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
end

module ActionDispatch::Assertions::ResponseAssertions
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, &block); end

  def with_routing(); end
end

module ActionDispatch::Assertions::RoutingAssertions
end

module ActionDispatch::Assertions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Callbacks
  include ::ActiveSupport::Callbacks
  def _call_callbacks(); end

  def _call_callbacks?(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  def self._call_callbacks(); end

  def self._call_callbacks=(val); end

  def self._call_callbacks?(); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end

  def self.to_cleanup(*args, &block); end

  def self.to_prepare(*args, &block); end
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SECRET_TOKEN = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::Enumerable
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(obj); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def handle_options(options); end

  def has_key?(name); end

  def initialize(key_generator, host=T.unsafe(nil), secure=T.unsafe(nil), options=T.unsafe(nil)); end

  def key?(name); end

  def recycle!(); end

  def update(other_hash); end

  def write(headers); end
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(obj); end

  def self.build(request); end

  def self.options_for_env(env); end
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::EncryptedCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::ActionDispatch::Cookies::SerializedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar, key_generator, options=T.unsafe(nil)); end
end

class ActionDispatch::Cookies::EncryptedCookieJar
end

class ActionDispatch::Cookies::JsonSerializer
end

class ActionDispatch::Cookies::JsonSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::PermanentCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar, key_generator, options=T.unsafe(nil)); end
end

class ActionDispatch::Cookies::PermanentCookieJar
end

module ActionDispatch::Cookies::SerializedCookieJars
  def deserialize(name, value); end

  def digest(); end

  def needs_migration?(value); end

  def serialize(name, value); end

  def serializer(); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::ActionDispatch::Cookies::SerializedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar, key_generator, options=T.unsafe(nil)); end
end

class ActionDispatch::Cookies::SignedCookieJar
end

class ActionDispatch::Cookies::UpgradeLegacyEncryptedCookieJar
  include ::ActionDispatch::Cookies::VerifyAndUpgradeLegacySignedMessage
end

class ActionDispatch::Cookies::UpgradeLegacyEncryptedCookieJar
end

class ActionDispatch::Cookies::UpgradeLegacySignedCookieJar
  include ::ActionDispatch::Cookies::VerifyAndUpgradeLegacySignedMessage
end

class ActionDispatch::Cookies::UpgradeLegacySignedCookieJar
end

module ActionDispatch::Cookies::VerifyAndUpgradeLegacySignedMessage
  def initialize(*args); end

  def verify_and_upgrade_legacy_signed_message(name, signed_message); end
end

module ActionDispatch::Cookies::VerifyAndUpgradeLegacySignedMessage
end

class ActionDispatch::Cookies
end

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil)); end

  def render_exception(request, exception); end

  def render_exception_with_web_console(request, exception); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugExceptions
end

class ActionDispatch::ExceptionWrapper
  include ::WillPaginate::Railtie::ShowExceptionsPatch
  def application_trace(); end

  def env(); end

  def exception(); end

  def file(); end

  def framework_trace(); end

  def full_trace(); end

  def initialize(env, exception); end

  def line_number(); end

  def rescue_responses(); end

  def rescue_responses=(obj); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(obj); end

  def source_extracts(); end

  def status_code(exception=T.unsafe(nil)); end

  def status_code_without_paginate(); end

  def traces(); end
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(obj); end

  def self.rescue_templates(); end

  def self.rescue_templates=(obj); end

  def self.status_code_for_exception(class_name); end
end

class ActionDispatch::FileHandler
  def call(env); end

  def initialize(root, cache_control); end

  def match?(path); end
end

class ActionDispatch::FileHandler
end

class ActionDispatch::Flash
  def call(env); end

  def initialize(app); end
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  include ::Enumerable
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def stringify_array(array); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

class ActionDispatch::Flash::FlashNow
end

class ActionDispatch::Flash
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end

  def fresh?(response); end

  def if_modified_since(); end

  def if_none_match(); end

  def if_none_match_etags(); end

  def not_modified?(modified_at); end
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Request
end

module ActionDispatch::Http::Cache::Response
  def cache_control(); end

  def date(); end

  def date=(utc_time); end

  def date?(); end

  def etag(); end

  def etag=(etag); end

  def etag?(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::FilterParameters
  def env_filter(); end

  def filtered_env(); end

  def filtered_parameters(); end

  def filtered_path(); end

  def filtered_query_string(); end

  def initialize(env); end

  def parameter_filter(); end

  def parameter_filter_for(filters); end
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
end

class ActionDispatch::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def each(&block); end

  def env(); end

  def fetch(key, *args, &block); end

  def include?(key); end

  def initialize(env=T.unsafe(nil)); end

  def key?(key); end

  def merge(headers_or_env); end

  def merge!(headers_or_env); end
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def negotiate_mime(order); end

  def use_accept_header(); end

  def valid_accept_header(); end

  def variant(); end

  def variant=(variant); end
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Http::ParameterFilter
  def filter(params); end

  def initialize(filters=T.unsafe(nil)); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ParameterFilter::CompiledFilter
  def blocks(); end

  def call(original_params); end

  def initialize(regexps, blocks); end

  def regexps(); end
end

class ActionDispatch::Http::ParameterFilter::CompiledFilter
  def self.compile(filters); end
end

class ActionDispatch::Http::ParameterFilter
end

module ActionDispatch::Http::Parameters
  def path_parameters(); end

  def path_parameters=(parameters); end

  def symbolized_path_parameters(); end
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  def domain(tld_length=T.unsafe(nil)); end

  def host(); end

  def host_with_port(); end

  def initialize(env); end

  def optional_port(); end

  def port(); end

  def port_string(); end

  def protocol(); end

  def raw_host_with_port(); end

  def server_port(); end

  def standard_port(); end

  def standard_port?(); end

  def subdomain(tld_length=T.unsafe(nil)); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def tld_length(); end

  def tld_length=(obj); end

  def url(); end
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  def self.extract_domain(host, tld_length); end

  def self.extract_subdomain(host, tld_length); end

  def self.extract_subdomains(host, tld_length); end

  def self.full_url_for(options); end

  def self.path_for(options); end

  def self.tld_length(); end

  def self.tld_length=(obj); end

  def self.url_for(options); end
end

class ActionDispatch::Http::UploadedFile
  def close(unlink_now=T.unsafe(nil)); end

  def content_type(); end

  def content_type=(content_type); end

  def eof?(); end

  def headers(); end

  def headers=(headers); end

  def initialize(hash); end

  def open(); end

  def original_filename(); end

  def original_filename=(original_filename); end

  def path(); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def tempfile(); end

  def tempfile=(tempfile); end

  def to_io(); end
end

class ActionDispatch::Http::UploadedFile
end

module ActionDispatch::Http
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::IllegalStateError
end

class ActionDispatch::IllegalStateError
end

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def delete_via_redirect(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def follow_redirect!(); end

  def get(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def get_via_redirect(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def head(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def patch(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def patch_via_redirect(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def post(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def post_via_redirect(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def put(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def put_via_redirect(path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def request_via_redirect(http_method, path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def xhr(request_method, path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end

  def xml_http_request(request_method, path, parameters=T.unsafe(nil), headers_or_env=T.unsafe(nil)); end
end

module ActionDispatch::Integration::RequestHelpers
end

module ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::TagAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def app(); end

  def assigns(*args); end

  def cookies(*args); end

  def copy_session_variables!(); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*args); end

  def get(*args); end

  def get_via_redirect(*args); end

  def head(*args); end

  def method_missing(sym, *args, &block); end

  def open_session(); end

  def patch(*args); end

  def post(*args); end

  def post_via_redirect(*args); end

  def put(*args); end

  def remove!(); end

  def reset!(); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def xhr(*args); end

  def xml_http_request(*args); end
end

module ActionDispatch::Integration::Runner
end

class ActionDispatch::Integration::Session
  include ::Minitest::Assertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::TagAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Integration::RequestHelpers
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  def accept(); end

  def accept=(accept); end

  def body(*args, &block); end

  def controller(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def headers(*args, &block); end

  def host(); end

  def host!(_); end

  def host=(host); end

  def https!(flag=T.unsafe(nil)); end

  def https?(); end

  def initialize(app); end

  def path(*args, &block); end

  def redirect?(*args, &block); end

  def remote_addr(); end

  def remote_addr=(remote_addr); end

  def request(); end

  def request_count(); end

  def request_count=(request_count); end

  def reset!(); end

  def response(); end

  def status(*args, &block); end

  def status_message(*args, &block); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Integration
end

class ActionDispatch::IntegrationTest
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::TagAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
end

class ActionDispatch::IntegrationTest
  def self.app(); end

  def self.app=(app); end
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Format
  def evaluate(hash); end

  def initialize(parts); end
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format::Parameter
  def escape(value); end
end

class ActionDispatch::Journey::Format::Parameter
end

class ActionDispatch::Journey::Format
  def self.required_path(symbol); end

  def self.required_segment(symbol); end
end

class ActionDispatch::Journey::Formatter
  def clear(); end

  def generate(name, options, path_parameters, parameterize=T.unsafe(nil)); end

  def initialize(routes); end

  def routes(); end
end

class ActionDispatch::Journey::Formatter
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def ast(); end

  def endpoints(); end

  def firstpos(node); end

  def followpos(node); end

  def initialize(root); end

  def lastpos(node); end

  def nullable?(node); end

  def root(); end

  def transition_table(); end
  DUMMY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
end

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::GTG::MatchData
end

class ActionDispatch::Journey::GTG::Simulator
  def =~(string); end

  def initialize(transition_table); end

  def match(string); end

  def memos(string); end

  def simulate(string); end

  def tt(); end
end

class ActionDispatch::Journey::GTG::Simulator
end

class ActionDispatch::Journey::GTG::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(from, to, sym); end

  def accepting?(state); end

  def accepting_states(); end

  def add_accepting(state); end

  def add_memo(idx, memo); end

  def eclosure(t); end

  def memo(idx); end

  def memos(); end

  def move(t, a); end

  def states(); end

  def to_svg(); end

  def transitions(); end

  def visualizer(paths, title=T.unsafe(nil)); end
end

class ActionDispatch::Journey::GTG::TransitionTable
end

module ActionDispatch::Journey::GTG
end

module ActionDispatch::Journey::NFA
end

class ActionDispatch::Journey::NFA::Builder
  def initialize(ast); end

  def transition_table(); end
end

class ActionDispatch::Journey::NFA::Builder
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot(); end
end

module ActionDispatch::Journey::NFA::Dot
end

class ActionDispatch::Journey::NFA::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::NFA::MatchData
end

class ActionDispatch::Journey::NFA::Simulator
  def =~(string); end

  def initialize(transition_table); end

  def match(string); end

  def simulate(string); end

  def tt(); end
end

class ActionDispatch::Journey::NFA::Simulator
end

class ActionDispatch::Journey::NFA::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(i, f, s); end

  def accepting(); end

  def accepting=(accepting); end

  def accepting?(state); end

  def accepting_states(); end

  def add_memo(idx, memo); end

  def alphabet(); end

  def eclosure(t); end

  def following_states(t, a); end

  def generalized_table(); end

  def memo(idx); end

  def memos(); end

  def merge(left, right); end

  def move(t, a); end

  def states(); end

  def transitions(); end
end

class ActionDispatch::Journey::NFA::TransitionTable
end

class ActionDispatch::Journey::NFA::Visitor
  def initialize(tt); end

  def visit_CAT(node); end

  def visit_GROUP(node); end

  def visit_OR(node); end
end

class ActionDispatch::Journey::NFA::Visitor
end

module ActionDispatch::Journey::NFA
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary
  def children(); end

  def initialize(left, right); end

  def right(); end

  def right=(right); end
end

class ActionDispatch::Journey::Nodes::Binary
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dummy
  def initialize(x=T.unsafe(nil)); end
end

class ActionDispatch::Journey::Nodes::Dummy
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Node
  include ::Enumerable
  def each(&block); end

  def initialize(left); end

  def left(); end

  def left=(left); end

  def literal?(); end

  def memo(); end

  def memo=(memo); end

  def name(); end

  def symbol?(); end

  def to_dot(); end

  def to_sym(); end

  def type(); end
end

class ActionDispatch::Journey::Nodes::Node
end

class ActionDispatch::Journey::Nodes::Or
  def children(); end

  def initialize(children); end
end

class ActionDispatch::Journey::Nodes::Or
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Symbol
  def default_regexp?(); end

  def regexp(); end

  def regexp=(regexp); end
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
end

class ActionDispatch::Journey::Nodes::Terminal
  def symbol(); end
end

class ActionDispatch::Journey::Nodes::Terminal
end

class ActionDispatch::Journey::Nodes::Unary
  def children(); end
end

class ActionDispatch::Journey::Nodes::Unary
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Parser
  include ::ActionDispatch::Journey::Nodes
  def _reduce_1(val, _values); end

  def _reduce_10(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def parse(string); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def =~(other); end

  def anchored(); end

  def ast(); end

  def build_formatter(); end

  def initialize(strexp); end

  def match(other); end

  def names(); end

  def optional_names(); end

  def required_names(); end

  def requirements(); end

  def source(); end

  def spec(); end

  def to_regexp(); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def initialize(separator, matchers); end

  def visit_CAT(node); end

  def visit_DOT(node); end

  def visit_GROUP(node); end

  def visit_LITERAL(node); end

  def visit_SLASH(node); end

  def visit_STAR(node); end

  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def [](x); end

  def captures(); end

  def initialize(names, offsets, match); end

  def length(); end

  def names(); end

  def post_match(); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
end

class ActionDispatch::Journey::Path::Pattern::RegexpOffsets
  def initialize(matchers); end

  def offsets(); end

  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::RegexpOffsets
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern
  def self.from_string(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Route
  def app(); end

  def ast(); end

  def conditions(); end

  def constraints(); end

  def defaults(); end

  def dispatcher?(); end

  def format(path_options); end

  def glob?(); end

  def initialize(name, app, path, constraints, defaults=T.unsafe(nil)); end

  def ip(); end

  def matches?(request); end

  def name(); end

  def optional_parts(); end

  def parts(); end

  def path(); end

  def precedence(); end

  def precedence=(precedence); end

  def required_default?(key); end

  def required_defaults(); end

  def required_keys(); end

  def required_parts(); end

  def requirements(); end

  def score(constraints); end

  def segment_keys(); end

  def segments(); end

  def verb(); end
end

class ActionDispatch::Journey::Route
end

class ActionDispatch::Journey::Router
  def initialize(routes); end

  def recognize(rails_req); end

  def routes(); end

  def routes=(routes); end

  def serve(req); end

  def visualizer(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::RoutingError
end

class ActionDispatch::Journey::Router::RoutingError
end

class ActionDispatch::Journey::Router::Strexp
  def anchor(); end

  def ast(); end

  def initialize(ast, path, requirements, separators, anchor=T.unsafe(nil)); end

  def path(); end

  def requirements(); end

  def separators(); end
end

class ActionDispatch::Journey::Router::Strexp
  def self.build(path, requirements, separators, anchor=T.unsafe(nil)); end

  def self.compile(*_); end
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape(component, pattern); end

  def escape_fragment(fragment); end

  def escape_path(path); end

  def escape_segment(segment); end

  def percent_encode(unsafe); end

  def unescape_uri(uri); end
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
end

class ActionDispatch::Journey::Router::Utils
  def self.escape_fragment(fragment); end

  def self.escape_path(path); end

  def self.escape_segment(segment); end

  def self.normalize_path(path); end

  def self.unescape_uri(uri); end
end

class ActionDispatch::Journey::Router
end

class ActionDispatch::Journey::Routes
  include ::Enumerable
  def add_route(app, path, conditions, defaults, name=T.unsafe(nil)); end

  def ast(); end

  def clear(); end

  def each(&block); end

  def empty?(); end

  def last(); end

  def length(); end

  def named_routes(); end

  def partitioned_routes(); end

  def routes(); end

  def simulator(); end

  def size(); end
end

class ActionDispatch::Journey::Routes
end

class ActionDispatch::Journey::Scanner
  def eos?(); end

  def next_token(); end

  def pos(); end

  def pre_match(); end

  def scan_setup(str); end
end

class ActionDispatch::Journey::Scanner
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot
end

class ActionDispatch::Journey::Visitors::Dot
end

class ActionDispatch::Journey::Visitors::Each
  def block(); end

  def initialize(block); end
end

class ActionDispatch::Journey::Visitors::Each
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::String
end

class ActionDispatch::Journey::Visitors::String
end

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
end

module ActionDispatch::Journey::Visitors
end

module ActionDispatch::Journey
end

class ActionDispatch::MiddlewareStack
  include ::Enumerable
  def [](i); end

  def assert_index(index, where); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def each(&blk); end

  def initialize(*args); end

  def insert(index, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, *args, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def size(); end

  def swap(target, *args, &block); end

  def unshift(*args, &block); end

  def use(*args, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def classcache(); end

  def initialize(klass_or_name, *args, &block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::MiddlewareStack::Middleware
end

class ActionDispatch::MiddlewareStack
end

class ActionDispatch::ParamsParser
  def call(env); end

  def initialize(app, parsers=T.unsafe(nil)); end
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ParamsParser::ParseError
  def initialize(message, original_exception); end

  def original_exception(); end
end

class ActionDispatch::ParamsParser::ParseError
end

class ActionDispatch::ParamsParser
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::PublicExceptions
end

class ActionDispatch::Railtie
end

class ActionDispatch::Railtie
end

class ActionDispatch::Reloader
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Deprecation::Reporting
  def _cleanup_callbacks(); end

  def _cleanup_callbacks?(); end

  def _prepare_callbacks(); end

  def _prepare_callbacks?(); end

  def _run_cleanup_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def call(env); end

  def cleanup!(); end

  def initialize(app, condition=T.unsafe(nil)); end

  def prepare!(); end
end

class ActionDispatch::Reloader
  extend ::ActiveSupport::DescendantsTracker
  def self._cleanup_callbacks(); end

  def self._cleanup_callbacks=(val); end

  def self._cleanup_callbacks?(); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(val); end

  def self._prepare_callbacks?(); end

  def self.cleanup!(); end

  def self.prepare!(); end

  def self.to_cleanup(*args, &block); end

  def self.to_prepare(*args, &block); end
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, check_ip_spoofing=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def filter_proxies(ips); end

  def initialize(env, middleware); end

  def ips_from(header); end
end

class ActionDispatch::RemoteIp::GetIp
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp
end

class ActionDispatch::Request
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def check_path_parameters!(); end

  def cookie_jar(); end

  def deep_munge(hash); end

  def flash(); end

  def from(); end

  def gateway_interface(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(obj); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_user(); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def reset_session(); end

  def server_name(); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def uuid(); end

  def xml_http_request?(); end
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(obj); end
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app); end
end

class ActionDispatch::RequestId
end

class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin
  def [](*args, &block); end

  def []=(*args, &block); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def content_type=(content_type); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(obj); end

  def default_headers(); end

  def default_headers=(obj); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def each(*args, &block); end

  def header(); end

  def header=(header); end

  def headers=(headers); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), options=T.unsafe(nil)); end

  def location=(url); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def response_code(); end

  def sending!(); end

  def sending?(); end

  def sending_file=(sending_file); end

  def sent!(); end

  def sent?(); end

  def set_cookie(key, value); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def to_ary(); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
end

class ActionDispatch::Response
  def self.default_charset(); end

  def self.default_charset=(obj); end

  def self.default_headers(); end

  def self.default_headers=(obj); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::ConsoleFormatter
  def header(routes); end

  def no_routes(); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::Endpoint
  def app(); end

  def dispatcher?(); end

  def matches?(req); end

  def redirect?(); end
end

class ActionDispatch::Routing::Endpoint
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::HtmlTableFormatter
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  def initialize(set); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def root(options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Base
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

module ActionDispatch::Routing::Mapper::Concerns
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, dispatcher_p); end

  def serve(req); end
end

class ActionDispatch::Routing::Mapper::Constraints
end

class ActionDispatch::Routing::Mapper::Mapping
  def anchor(); end

  def as(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(scope, set, path, defaults, as, options); end

  def requirements(); end

  def to(); end

  def to_route(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, path, as, options); end
end

module ActionDispatch::Routing::Mapper::Resources
  def action_options?(options); end

  def add_route(action, options); end

  def apply_common_behavior_for(method, resources, options, &block); end

  def canonical_action?(action); end

  def decomposed_match(path, options); end

  def name_for_action(as, action); end

  def nested(); end

  def nested_options(); end

  def nested_scope?(); end

  def nesting_depth(); end

  def new(); end

  def param_constraint(); end

  def param_constraint?(); end

  def parent_resource(); end

  def path_for_action(action, path); end

  def prefix_name_for_action(as, action); end

  def resource_method_scope?(); end

  def resource_scope(kind, resource); end

  def resource_scope?(); end

  def resources_path_names(options); end

  def scope_action_options(); end

  def scope_action_options?(); end

  def set_member_mappings_for_resource(); end

  def shallow_nesting_depth(); end

  def shallow_scope(path, options=T.unsafe(nil)); end

  def using_match_shorthand?(path, options); end

  def with_exclusive_scope(); end

  def with_scope_level(kind); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def options(); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow=(value); end

  def shallow?(); end

  def shallow_scope(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::Resource
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, options); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
end

class ActionDispatch::Routing::Mapper::Scope
  def [](key); end

  def []=(k, v); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def fetch(key, &block); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def scope_level(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil)); end

  def controller(controller, options=T.unsafe(nil)); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil)); end

  def scope(*args); end
end

module ActionDispatch::Routing::Mapper::Scoping
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

class ActionDispatch::Routing::OptionRedirect
  def options(); end
end

class ActionDispatch::Routing::OptionRedirect
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
end

module ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  def edit_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def edit_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def polymorphic_path(record_or_hash_or_array, options=T.unsafe(nil)); end

  def polymorphic_url(record_or_hash_or_array, options=T.unsafe(nil)); end
end

module ActionDispatch::Routing::PolymorphicRoutes
end

class ActionDispatch::Routing::Redirect
  def block(); end

  def call(env); end

  def initialize(status, block); end

  def path(params, request); end

  def serve(req); end

  def status(); end
end

class ActionDispatch::Routing::Redirect
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionDispatch::Routing::Redirection
end

class ActionDispatch::Routing::RouteSet
  def add_route(app, conditions=T.unsafe(nil), requirements=T.unsafe(nil), defaults=T.unsafe(nil), name=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def append(&block); end

  def call(env); end

  def clear!(); end

  def default_scope(); end

  def default_scope=(default_scope); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def define_mounted_helper(name); end

  def disable_clear_and_finalize(); end

  def disable_clear_and_finalize=(disable_clear_and_finalize); end

  def dispatcher(defaults); end

  def empty?(); end

  def extra_keys(options, recall=T.unsafe(nil)); end

  def finalize!(); end

  def find_relative_url_root(options); end

  def find_script_name(options); end

  def formatter(); end

  def formatter=(formatter); end

  def generate_extras(options, recall=T.unsafe(nil)); end

  def initialize(request_class=T.unsafe(nil)); end

  def mounted_helpers(); end

  def named_routes(); end

  def named_routes=(named_routes); end

  def optimize_routes_generation?(); end

  def path_for(options, route_name=T.unsafe(nil)); end

  def prepend(&block); end

  def recognize_path(path, environment=T.unsafe(nil)); end

  def relative_url_root(); end

  def relative_url_root=(obj); end

  def request_class(); end

  def request_class=(request_class); end

  def resources_path_names(); end

  def resources_path_names=(resources_path_names); end

  def router(); end

  def router=(router); end

  def routes(); end

  def set(); end

  def set=(set); end

  def url_for(options, route_name=T.unsafe(nil), url_strategy=T.unsafe(nil)); end

  def url_helpers(supports_path=T.unsafe(nil)); end
  FULL = ::T.let(nil, ::T.untyped)
  LEGACY = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def controller(params, default_controller=T.unsafe(nil)); end

  def initialize(defaults); end

  def prepare_params!(params); end

  def serve(req); end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
end

class ActionDispatch::Routing::RouteSet::Generator
  def controller(); end

  def current_controller(); end

  def different_controller?(); end

  def generate(); end

  def initialize(named_route, options, recall, set); end

  def named_route(); end

  def normalize_action!(); end

  def normalize_controller!(); end

  def normalize_controller_action_id!(); end

  def normalize_options!(); end

  def normalize_recall!(); end

  def options(); end

  def recall(); end

  def set(); end

  def use_recall_for(key); end

  def use_relative_controller!(); end
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def main_app(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable
  def [](name); end

  def []=(name, route); end

  def add(name, route); end

  def clear(); end

  def clear!(); end

  def each(&blk); end

  def get(name); end

  def helper_names(); end

  def helpers(); end

  def key?(name); end

  def length(); end

  def names(); end

  def path_helpers_module(warn=T.unsafe(nil)); end

  def route_defined?(name); end

  def routes(); end

  def url_helpers_module(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, args, inner_options); end

  def deprecate_string_options(options); end

  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  def initialize(route, options, route_name, url_strategy); end

  def route_name(); end

  def url_strategy(); end
  DEPRECATED_STRING_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
  def arg_size(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def self.create(route, options, route_name, url_strategy); end

  def self.optimize_helper?(route); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
end

class ActionDispatch::Routing::RouteSet
  def self.default_resources_path_names(); end

  def self.relative_url_root(); end

  def self.relative_url_root=(obj); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def action(); end

  def assets_prefix(); end

  def assets_prefix=(assets_prefix); end

  def assets_prefix?(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def json_regexp(); end

  def name(); end

  def path(); end

  def rack_app(); end

  def regexp(); end

  def reqs(); end

  def verb(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesInspector
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers); end

  def method_missing(method, *args); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  def _routes_context(); end

  def _with_routes(routes); end

  def initialize(*_); end

  def optimize_routes_generation?(); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionDispatch::Routing::UrlFor
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Routing
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  YEAR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

module ActionDispatch::Session
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end

  def initialize_sid(); end
end

module ActionDispatch::Session::Compatibility
end

class ActionDispatch::Session::CookieStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
  def destroy_session(env, session_id, options); end
end

class ActionDispatch::Session::CookieStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(env); end
end

module ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::SessionRestoreError
  def initialize(const_error); end

  def original_exception(); end
end

class ActionDispatch::Session::SessionRestoreError
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
end

module ActionDispatch::Session
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ShowExceptions
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, cache_control=T.unsafe(nil)); end
end

class ActionDispatch::Static
end

module ActionDispatch::TestProcess
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def initialize(env=T.unsafe(nil)); end

  def path=(path); end

  def port=(number); end

  def rack_cookies(); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.new(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def error?(); end

  def missing?(); end

  def success?(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

module ActionDispatch
  extend ::ActiveSupport::Autoload
  def self.test_app(); end

  def self.test_app=(obj); end
end

class ActionMailer::Base
  include ::ActionMailer::DeliveryMethods
  include ::ActionMailer::Previews
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::AbstractController::Helpers
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(_helpers); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _process_action_callbacks?(); end

  def _run_process_action_callbacks(&block); end

  def _view_paths(); end

  def _view_paths=(_view_paths); end

  def _view_paths?(); end

  def amazon_ses_settings(); end

  def amazon_ses_settings=(amazon_ses_settings); end

  def amazon_ses_settings?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def attachments(); end

  def collect_responses(headers); end

  def create_parts_from_responses(m, responses); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_i18n_subject(interpolations=T.unsafe(nil)); end

  def default_params(); end

  def default_params=(default_params); end

  def default_params?(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def delivery_method(); end

  def delivery_method=(delivery_method); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(delivery_methods); end

  def delivery_methods?(); end

  def each_template(paths, name, &block); end

  def file_settings(); end

  def file_settings=(file_settings); end

  def file_settings?(); end

  def headers(args=T.unsafe(nil)); end

  def initialize(method_name=T.unsafe(nil), *args); end

  def insert_part(container, response, charset); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def logger(); end

  def logger=(value); end

  def mailer_name(); end

  def message(); end

  def message=(message); end

  def perform_deliveries(); end

  def perform_deliveries=(obj); end

  def preview_interceptors(); end

  def preview_path(); end

  def process(method_name, *args); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(obj); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def sendmail_settings(); end

  def sendmail_settings=(sendmail_settings); end

  def sendmail_settings?(); end

  def set_content_type(m, user_content_type, class_default); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(smtp_settings); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(test_settings); end

  def test_settings?(); end
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::LateAttachmentsProxy
  def []=(_name, _content); end

  def inline(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::LateAttachmentsProxy
end

class ActionMailer::Base::NullMail
  def body(); end

  def header(); end

  def method_missing(*args); end

  def respond_to?(string, include_all=T.unsafe(nil)); end
end

class ActionMailer::Base::NullMail
end

class ActionMailer::Base
  extend ::ActionMailer::DeliveryMethods::ClassMethods
  extend ::ActionMailer::Previews::ClassMethods
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(val); end

  def self._process_action_callbacks?(); end

  def self._view_paths(); end

  def self._view_paths=(val); end

  def self._view_paths?(); end

  def self.amazon_ses_settings(); end

  def self.amazon_ses_settings=(val); end

  def self.amazon_ses_settings?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default(value=T.unsafe(nil)); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_options=(value=T.unsafe(nil)); end

  def self.default_params(); end

  def self.default_params=(val); end

  def self.default_params?(); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.deliver_mail(mail); end

  def self.delivery_method(); end

  def self.delivery_method=(val); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(val); end

  def self.delivery_methods?(); end

  def self.file_settings(); end

  def self.file_settings=(val); end

  def self.file_settings?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mailer_name(); end

  def self.mailer_name=(mailer_name); end

  def self.method_missing(method_name, *args); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(obj); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(obj); end

  def self.preview_path(); end

  def self.preview_path=(obj); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(obj); end

  def self.receive(raw_mail); end

  def self.register_interceptor(interceptor); end

  def self.register_interceptors(*interceptors); end

  def self.register_observer(observer); end

  def self.register_observers(*observers); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.respond_to?(method, include_private=T.unsafe(nil)); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(val); end

  def self.sendmail_settings?(); end

  def self.set_payload_for_mail(payload, mail); end

  def self.show_previews(); end

  def self.show_previews=(obj); end

  def self.smtp_settings(); end

  def self.smtp_settings=(val); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(val); end

  def self.test_settings?(); end
end

class ActionMailer::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

class ActionMailer::Collector
end

class ActionMailer::DeliveryJob
  def perform(mailer, mail_method, delivery_method, *args); end
end

class ActionMailer::DeliveryJob
end

module ActionMailer::DeliveryMethods
  def wrap_delivery_behavior!(*args); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  def add_delivery_method(symbol, klass, default_options=T.unsafe(nil)); end

  def deliveries(*args, &block); end

  def deliveries=(arg); end

  def wrap_delivery_behavior(mail, method=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionMailer::DeliveryMethods::ClassMethods
end

module ActionMailer::DeliveryMethods
  extend ::ActiveSupport::Concern
end

class ActionMailer::InlinePreviewInterceptor
  include ::Base64
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

class ActionMailer::LogSubscriber
  def deliver(event); end

  def process(event); end

  def receive(event); end
end

class ActionMailer::LogSubscriber
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

module ActionMailer::MailHelper
end

class ActionMailer::MessageDelivery
  def deliver(); end

  def deliver!(); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer, mail_method, *args); end

  def message(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::MessageDelivery
end

class ActionMailer::Preview
end

class ActionMailer::Preview
  extend ::ActiveSupport::DescendantsTracker
  def self.all(); end

  def self.call(email); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.inform_preview_interceptors(message); end

  def self.load_previews(); end

  def self.preview_name(); end

  def self.preview_path(); end

  def self.show_previews(); end
end

module ActionMailer::Previews
end

module ActionMailer::Previews::ClassMethods
  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end
end

module ActionMailer::Previews::ClassMethods
end

module ActionMailer::Previews
  extend ::ActiveSupport::Concern
end

class ActionMailer::Railtie
end

class ActionMailer::Railtie
end

class ActionMailer::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def _mailer_class(); end

  def _mailer_class=(_mailer_class); end

  def _mailer_class?(); end
end

module ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def initialize_test_deliveries(); end

  def restore_delivery_method(); end

  def restore_test_deliveries(); end

  def set_delivery_method(method); end

  def set_expected_mail(); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
  def determine_default_mailer(name); end

  def mailer_class(); end

  def tests(mailer); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
end

module ActionMailer::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  extend ::ActionMailer::TestCase::Behavior::ClassMethods
  def self._mailer_class(); end

  def self._mailer_class=(val); end

  def self._mailer_class?(); end
end

module ActionMailer::TestHelper
  def assert_emails(number); end

  def assert_no_emails(&block); end
end

module ActionMailer::TestHelper
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionMailer::VERSION
end

module ActionMailer
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActionPack
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
end

module ActionPack
  def self.gem_version(); end

  def self.version(); end
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  def extract_details(options); end

  def find_file(*args, &block); end

  def find_template(*args, &block); end

  def formats(*args, &block); end

  def initialize(lookup_context); end

  def instrument(name, options=T.unsafe(nil)); end

  def prepend_formats(formats); end

  def render(); end

  def template_exists?(*args, &block); end

  def with_fallbacks(*args, &block); end

  def with_layout_format(*args, &block); end
end

class ActionView::AbstractRenderer
end

class ActionView::Base
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ERB::Util
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::AlphabeticalPaginate::ViewHelpers
  include ::WillPaginate::ActionView
  include ::WillPaginate::ViewHelpers
  include ::WillPaginate::I18n
  include ::Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::RenderingHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers::TextHelper
  include ::Sprockets::Rails::Utils
  def _routes(); end

  def _routes=(_routes); end

  def _routes?(); end

  def assets_environment(); end

  def assets_environment=(assets_environment); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(assets_manifest); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(assets_precompile); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(assets_prefix); end

  def assets_prefix?(); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(check_precompiled_asset); end

  def check_precompiled_asset?(); end

  def config(); end

  def config=(config); end

  def debug_assets(); end

  def debug_assets=(debug_assets); end

  def debug_assets?(); end

  def default_formats(); end

  def default_formats=(obj); end

  def digest_assets(); end

  def digest_assets=(digest_assets); end

  def digest_assets?(); end

  def field_error_proc(); end

  def field_error_proc=(obj); end

  def formats(*args, &block); end

  def formats=(arg); end

  def initialize(context=T.unsafe(nil), assigns=T.unsafe(nil), controller=T.unsafe(nil), formats=T.unsafe(nil)); end

  def locale(*args, &block); end

  def locale=(arg); end

  def logger=(logger); end

  def logger?(); end

  def lookup_context(*args, &block); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(precompiled_asset_checker); end

  def precompiled_asset_checker?(); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(obj); end

  def raise_on_missing_translations(); end

  def raise_on_missing_translations=(obj); end

  def resolve_assets_with(); end

  def resolve_assets_with=(resolve_assets_with); end

  def resolve_assets_with?(); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(obj); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(unknown_asset_fallback); end

  def unknown_asset_fallback?(); end

  def view_paths(*args, &block); end

  def view_paths=(arg); end

  def view_renderer(); end

  def view_renderer=(view_renderer); end
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(val); end

  def self._routes?(); end

  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.default_form_builder(); end

  def self.default_form_builder=(obj); end

  def self.default_formats(); end

  def self.default_formats=(obj); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(obj); end

  def self.logger(); end

  def self.logger=(val); end

  def self.logger?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(obj); end

  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(obj); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(obj); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end

  def self.xss_safe?(); end
end

module ActionView::CompiledTemplates
end

module ActionView::CompiledTemplates
end

module ActionView::Context
  include ::ActionView::CompiledTemplates
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

module ActionView::Context
end

class ActionView::DependencyTracker
end

class ActionView::DependencyTracker::ERBTracker
  def dependencies(); end

  def initialize(name, template); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::ERBTracker
  def self.call(name, template); end
end

class ActionView::DependencyTracker
  def self.find_dependencies(name, template); end

  def self.register_tracker(extension, tracker); end

  def self.remove_tracker(handler); end
end

class ActionView::Digestor
  def cache(); end

  def dependencies(); end

  def digest(); end

  def finder(); end

  def initialize(options); end

  def name(); end

  def nested_dependencies(); end

  def options(); end
end

class ActionView::Digestor
  def self.cache(); end

  def self.digest(options); end
end

class ActionView::FallbackFileSystemResolver
  def decorate(*_); end
end

class ActionView::FallbackFileSystemResolver
  def self.instances(); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path, pattern=T.unsafe(nil)); end

  def to_path(); end
end

class ActionView::FileSystemResolver
end

module ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::RenderingHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelInstanceTag
  def content_tag(*_); end

  def error_message(); end

  def error_wrapping(html_tag); end

  def object(); end

  def tag(type, options, *_); end
end

module ActionView::Helpers::ActiveModelInstanceTag
end

module ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def audio_tag(*sources); end

  def auto_discovery_link_tag(type=T.unsafe(nil), url_options=T.unsafe(nil), tag_options=T.unsafe(nil)); end

  def favicon_link_tag(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_alt(src); end

  def image_tag(source, options=T.unsafe(nil)); end

  def javascript_include_tag(*sources); end

  def stylesheet_link_tag(*sources); end

  def video_tag(*sources); end
end

module ActionView::Helpers::AssetTagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::AssetUrlHelper
  def asset_path(source, options=T.unsafe(nil)); end

  def asset_url(source, options=T.unsafe(nil)); end

  def audio_path(source, options=T.unsafe(nil)); end

  def audio_url(source, options=T.unsafe(nil)); end

  def compute_asset_extname(source, options=T.unsafe(nil)); end

  def compute_asset_host(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def compute_asset_path(source, options=T.unsafe(nil)); end

  def font_path(source, options=T.unsafe(nil)); end

  def font_url(source, options=T.unsafe(nil)); end

  def image_path(source, options=T.unsafe(nil)); end

  def image_url(source, options=T.unsafe(nil)); end

  def javascript_path(source, options=T.unsafe(nil)); end

  def javascript_url(source, options=T.unsafe(nil)); end

  def path_to_asset(source, options=T.unsafe(nil)); end

  def path_to_audio(source, options=T.unsafe(nil)); end

  def path_to_font(source, options=T.unsafe(nil)); end

  def path_to_image(source, options=T.unsafe(nil)); end

  def path_to_javascript(source, options=T.unsafe(nil)); end

  def path_to_stylesheet(source, options=T.unsafe(nil)); end

  def path_to_video(source, options=T.unsafe(nil)); end

  def stylesheet_path(source, options=T.unsafe(nil)); end

  def stylesheet_url(source, options=T.unsafe(nil)); end

  def url_to_asset(source, options=T.unsafe(nil)); end

  def url_to_audio(source, options=T.unsafe(nil)); end

  def url_to_font(source, options=T.unsafe(nil)); end

  def url_to_image(source, options=T.unsafe(nil)); end

  def url_to_javascript(source, options=T.unsafe(nil)); end

  def url_to_stylesheet(source, options=T.unsafe(nil)); end

  def url_to_video(source, options=T.unsafe(nil)); end

  def video_path(source, options=T.unsafe(nil)); end

  def video_url(source, options=T.unsafe(nil)); end
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
end

module ActionView::Helpers::AtomFeedHelper
  def atom_feed(options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::AtomFeedHelper
end

module ActionView::Helpers::CacheHelper
  def cache(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_fragment_name(name=T.unsafe(nil), options=T.unsafe(nil)); end

  def cache_if(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_unless(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::CacheHelper
end

module ActionView::Helpers::CaptureHelper
  def capture(*args); end

  def content_for(name, content=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def content_for?(name); end

  def provide(name, content=T.unsafe(nil), &block); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ActionView::Helpers::CaptureHelper
end

module ActionView::Helpers::ControllerHelper
  def action_name(*args, &block); end

  def assign_controller(controller); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*args, &block); end

  def controller_path(*args, &block); end

  def cookies(*args, &block); end

  def flash(*args, &block); end

  def headers(*args, &block); end

  def logger(); end

  def params(*args, &block); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*args, &block); end

  def response(*args, &block); end

  def session(*args, &block); end
end

module ActionView::Helpers::ControllerHelper
end

module ActionView::Helpers::CsrfHelper
  def csrf_meta_tag(); end

  def csrf_meta_tags(); end
end

module ActionView::Helpers::CsrfHelper
end

module ActionView::Helpers::DateHelper
  def date_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def distance_of_time_in_words(from_time, to_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def distance_of_time_in_words_to_now(from_time, options=T.unsafe(nil)); end

  def select_date(date=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_datetime(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_day(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_hour(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_minute(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_month(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_second(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_time(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_year(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_ago_in_words(from_time, options=T.unsafe(nil)); end

  def time_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_tag(date_or_time, *args, &block); end
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
end

class ActionView::Helpers::DateTimeSelector
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def initialize(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_date(); end

  def select_datetime(); end

  def select_day(); end

  def select_hour(); end

  def select_minute(); end

  def select_month(); end

  def select_second(); end

  def select_time(); end

  def select_year(); end
  AMPM_TRANSLATION = ::T.let(nil, ::T.untyped)
  DEFAULT_PREFIX = ::T.let(nil, ::T.untyped)
  POSITION = ::T.let(nil, ::T.untyped)
end

class ActionView::Helpers::DateTimeSelector
end

module ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def debug(object); end
end

module ActionView::Helpers::DebugHelper
end

class ActionView::Helpers::FormBuilder
  include ::ActionView::ModelNaming
  def button(value=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box(method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def collection_check_boxes(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def color_field(method, options=T.unsafe(nil)); end

  def date_field(method, options=T.unsafe(nil)); end

  def date_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_field(method, options=T.unsafe(nil)); end

  def datetime_local_field(method, options=T.unsafe(nil)); end

  def datetime_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def email_field(method, options=T.unsafe(nil)); end

  def emitted_hidden_id?(); end

  def field_helpers(); end

  def field_helpers=(field_helpers); end

  def field_helpers?(); end

  def fields_for(record_name, record_object=T.unsafe(nil), fields_options=T.unsafe(nil), &block); end

  def file_field(method, options=T.unsafe(nil)); end

  def grouped_collection_select(method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def hidden_field(method, options=T.unsafe(nil)); end

  def index(); end

  def initialize(object_name, object, template, options); end

  def label(method, text=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(method, options=T.unsafe(nil)); end

  def multipart(); end

  def multipart=(multipart); end

  def multipart?(); end

  def number_field(method, options=T.unsafe(nil)); end

  def object(); end

  def object=(object); end

  def object_name(); end

  def object_name=(object_name); end

  def options(); end

  def options=(options); end

  def password_field(method, options=T.unsafe(nil)); end

  def phone_field(method, options=T.unsafe(nil)); end

  def radio_button(method, tag_value, options=T.unsafe(nil)); end

  def range_field(method, options=T.unsafe(nil)); end

  def search_field(method, options=T.unsafe(nil)); end

  def select(method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def submit(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field(method, options=T.unsafe(nil)); end

  def text_area(method, options=T.unsafe(nil)); end

  def text_field(method, options=T.unsafe(nil)); end

  def time_field(method, options=T.unsafe(nil)); end

  def time_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_zone_select(method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def to_model(); end

  def to_partial_path(); end

  def url_field(method, options=T.unsafe(nil)); end

  def week_field(method, options=T.unsafe(nil)); end
end

class ActionView::Helpers::FormBuilder
  def self._to_partial_path(); end

  def self.field_helpers(); end

  def self.field_helpers=(val); end

  def self.field_helpers?(); end
end

module ActionView::Helpers::FormHelper
  include ::ActionView::ModelNaming
  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_for(record, options=T.unsafe(nil), &block); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def collection_check_boxes(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_options_for_select(grouped_options, selected_key=T.unsafe(nil), options=T.unsafe(nil)); end

  def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key=T.unsafe(nil)); end

  def options_for_select(container, selected=T.unsafe(nil)); end

  def options_from_collection_for_select(collection, value_method, text_method, selected=T.unsafe(nil)); end

  def select(object, method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def time_zone_options_for_select(selected=T.unsafe(nil), priority_zones=T.unsafe(nil), model=T.unsafe(nil)); end

  def time_zone_select(object, method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormOptionsHelper
end

module ActionView::Helpers::FormTagHelper
  def button_tag(content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box_tag(name, value=T.unsafe(nil), checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def color_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def date_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_local_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def email_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def embed_authenticity_token_in_remote_forms(); end

  def embed_authenticity_token_in_remote_forms=(obj); end

  def field_set_tag(legend=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field_tag(name, options=T.unsafe(nil)); end

  def form_tag(url_for_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def hidden_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_submit_tag(source, options=T.unsafe(nil)); end

  def label_tag(name=T.unsafe(nil), content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def number_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def password_field_tag(name=T.unsafe(nil), value=T.unsafe(nil), options=T.unsafe(nil)); end

  def phone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def radio_button_tag(name, value, checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def range_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_tag(name, option_tags=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_tag(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_area_tag(name, content=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def time_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def url_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def utf8_enforcer_tag(); end

  def week_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormTagHelper
  extend ::ActiveSupport::Concern
  def self.embed_authenticity_token_in_remote_forms(); end

  def self.embed_authenticity_token_in_remote_forms=(obj); end
end

module ActionView::Helpers::JavaScriptHelper
  def escape_javascript(javascript); end

  def j(javascript); end

  def javascript_cdata_section(content); end

  def javascript_tag(content_or_options_with_block=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
end

module ActionView::Helpers::NumberHelper
  def number_to_currency(number, options=T.unsafe(nil)); end

  def number_to_human(number, options=T.unsafe(nil)); end

  def number_to_human_size(number, options=T.unsafe(nil)); end

  def number_to_percentage(number, options=T.unsafe(nil)); end

  def number_to_phone(number, options=T.unsafe(nil)); end

  def number_with_delimiter(number, options=T.unsafe(nil)); end

  def number_with_precision(number, options=T.unsafe(nil)); end
end

module ActionView::Helpers::NumberHelper
end

module ActionView::Helpers::OutputSafetyHelper
  def raw(stringish); end

  def safe_join(array, sep=T.unsafe(nil)); end
end

module ActionView::Helpers::OutputSafetyHelper
end

module ActionView::Helpers::RecordTagHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def content_tag_for(tag_name, single_or_multiple_records, prefix=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def div_for(record, *args, &block); end
end

module ActionView::Helpers::RecordTagHelper
end

module ActionView::Helpers::RenderingHelper
  def _layout_for(*args, &block); end

  def render(options=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

module ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::SanitizeHelper
  def sanitize(html, options=T.unsafe(nil)); end

  def sanitize_css(style); end

  def strip_links(html); end

  def strip_tags(html); end
end

module ActionView::Helpers::SanitizeHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def cdata_section(content); end

  def content_tag(name, content_or_options_with_block=T.unsafe(nil), options=T.unsafe(nil), escape=T.unsafe(nil), &block); end

  def escape_once(html); end

  def tag(name, options=T.unsafe(nil), open=T.unsafe(nil), escape=T.unsafe(nil)); end
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::Tags
end

class ActionView::Helpers::Tags::Base
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::ActiveModelInstanceTag
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def initialize(object_name, method_name, template_object, options=T.unsafe(nil)); end

  def render(); end
end

class ActionView::Helpers::Tags::Base
end

class ActionView::Helpers::Tags::CheckBox
  include ::ActionView::Helpers::Tags::Checkable
  def initialize(object_name, method_name, template_object, checked_value, unchecked_value, options); end
end

class ActionView::Helpers::Tags::CheckBox
end

module ActionView::Helpers::Tags::Checkable
  def input_checked?(object, options); end
end

module ActionView::Helpers::Tags::Checkable
end

class ActionView::Helpers::Tags::CollectionCheckBoxes
  include ::ActionView::Helpers::Tags::CollectionHelpers
  def render(&block); end
end

class ActionView::Helpers::Tags::CollectionCheckBoxes::CheckBoxBuilder
  def check_box(extra_html_options=T.unsafe(nil)); end
end

class ActionView::Helpers::Tags::CollectionCheckBoxes::CheckBoxBuilder
end

class ActionView::Helpers::Tags::CollectionCheckBoxes
end

module ActionView::Helpers::Tags::CollectionHelpers
  def initialize(object_name, method_name, template_object, collection, value_method, text_method, options, html_options); end
end

class ActionView::Helpers::Tags::CollectionHelpers::Builder
  def initialize(template_object, object_name, method_name, object, sanitized_attribute_name, text, value, input_html_options); end

  def label(label_html_options=T.unsafe(nil), &block); end

  def object(); end

  def text(); end

  def value(); end
end

class ActionView::Helpers::Tags::CollectionHelpers::Builder
end

module ActionView::Helpers::Tags::CollectionHelpers
end

class ActionView::Helpers::Tags::CollectionRadioButtons
  include ::ActionView::Helpers::Tags::CollectionHelpers
  def render(&block); end
end

class ActionView::Helpers::Tags::CollectionRadioButtons::RadioButtonBuilder
  def radio_button(extra_html_options=T.unsafe(nil)); end
end

class ActionView::Helpers::Tags::CollectionRadioButtons::RadioButtonBuilder
end

class ActionView::Helpers::Tags::CollectionRadioButtons
end

class ActionView::Helpers::Tags::CollectionSelect
  def initialize(object_name, method_name, template_object, collection, value_method, text_method, options, html_options); end
end

class ActionView::Helpers::Tags::CollectionSelect
end

class ActionView::Helpers::Tags::ColorField
end

class ActionView::Helpers::Tags::ColorField
end

class ActionView::Helpers::Tags::DateField
end

class ActionView::Helpers::Tags::DateField
end

class ActionView::Helpers::Tags::DateSelect
  def initialize(object_name, method_name, template_object, options, html_options); end
end

class ActionView::Helpers::Tags::DateSelect
  def self.select_type(); end
end

class ActionView::Helpers::Tags::DatetimeField
end

class ActionView::Helpers::Tags::DatetimeField
end

class ActionView::Helpers::Tags::DatetimeLocalField
end

class ActionView::Helpers::Tags::DatetimeLocalField
end

class ActionView::Helpers::Tags::DatetimeSelect
end

class ActionView::Helpers::Tags::DatetimeSelect
end

class ActionView::Helpers::Tags::EmailField
end

class ActionView::Helpers::Tags::EmailField
end

class ActionView::Helpers::Tags::FileField
end

class ActionView::Helpers::Tags::FileField
end

class ActionView::Helpers::Tags::GroupedCollectionSelect
  def initialize(object_name, method_name, template_object, collection, group_method, group_label_method, option_key_method, option_value_method, options, html_options); end
end

class ActionView::Helpers::Tags::GroupedCollectionSelect
end

class ActionView::Helpers::Tags::HiddenField
end

class ActionView::Helpers::Tags::HiddenField
end

class ActionView::Helpers::Tags::Label
  def initialize(object_name, method_name, template_object, content_or_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def render(&block); end
end

class ActionView::Helpers::Tags::Label::LabelBuilder
  def initialize(template_object, object_name, method_name, object, tag_value); end

  def object(); end

  def translation(); end
end

class ActionView::Helpers::Tags::Label::LabelBuilder
end

class ActionView::Helpers::Tags::Label
end

class ActionView::Helpers::Tags::MonthField
end

class ActionView::Helpers::Tags::MonthField
end

class ActionView::Helpers::Tags::NumberField
end

class ActionView::Helpers::Tags::NumberField
end

class ActionView::Helpers::Tags::PasswordField
end

class ActionView::Helpers::Tags::PasswordField
end

module ActionView::Helpers::Tags::Placeholderable
  def initialize(*_); end
end

module ActionView::Helpers::Tags::Placeholderable
end

class ActionView::Helpers::Tags::RadioButton
  include ::ActionView::Helpers::Tags::Checkable
  def initialize(object_name, method_name, template_object, tag_value, options); end
end

class ActionView::Helpers::Tags::RadioButton
end

class ActionView::Helpers::Tags::RangeField
end

class ActionView::Helpers::Tags::RangeField
end

class ActionView::Helpers::Tags::SearchField
end

class ActionView::Helpers::Tags::SearchField
end

class ActionView::Helpers::Tags::Select
  def initialize(object_name, method_name, template_object, choices, options, html_options); end
end

class ActionView::Helpers::Tags::Select
end

class ActionView::Helpers::Tags::TelField
end

class ActionView::Helpers::Tags::TelField
end

class ActionView::Helpers::Tags::TextArea
  include ::ActionView::Helpers::Tags::Placeholderable
end

class ActionView::Helpers::Tags::TextArea
end

class ActionView::Helpers::Tags::TextField
  include ::ActionView::Helpers::Tags::Placeholderable
end

class ActionView::Helpers::Tags::TextField
  def self.field_type(); end
end

class ActionView::Helpers::Tags::TimeField
end

class ActionView::Helpers::Tags::TimeField
end

class ActionView::Helpers::Tags::TimeSelect
end

class ActionView::Helpers::Tags::TimeSelect
end

class ActionView::Helpers::Tags::TimeZoneSelect
  def initialize(object_name, method_name, template_object, priority_zones, options, html_options); end
end

class ActionView::Helpers::Tags::TimeZoneSelect
end

class ActionView::Helpers::Tags::Translator
  def initialize(object, object_name, method_and_value, scope); end

  def method_and_value(); end

  def model(); end

  def object_name(); end

  def scope(); end

  def translate(); end
end

class ActionView::Helpers::Tags::Translator
end

class ActionView::Helpers::Tags::UrlField
end

class ActionView::Helpers::Tags::UrlField
end

class ActionView::Helpers::Tags::WeekField
end

class ActionView::Helpers::Tags::WeekField
end

module ActionView::Helpers::Tags
  extend ::ActiveSupport::Autoload
end

module ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def concat(string); end

  def current_cycle(name=T.unsafe(nil)); end

  def cycle(first_value, *values); end

  def excerpt(text, phrase, options=T.unsafe(nil)); end

  def highlight(text, phrases, options=T.unsafe(nil)); end

  def pluralize(count, singular, plural=T.unsafe(nil)); end

  def reset_cycle(name=T.unsafe(nil)); end

  def safe_concat(string); end

  def simple_format(text, html_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def truncate(text, options=T.unsafe(nil), &block); end

  def word_wrap(text, options=T.unsafe(nil)); end
end

module ActionView::Helpers::TextHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def l(*args); end

  def localize(*args); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

module ActionView::Helpers::TranslationHelper
end

module ActionView::Helpers::UrlHelper
  def _back_url(); end

  def button_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless_current(name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def mail_to(email_address, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def url_for(options=T.unsafe(nil)); end
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

class ActionView::I18nProxy
  def initialize(original_config, lookup_context); end

  def locale=(value); end

  def lookup_context(); end

  def original_config(); end
end

class ActionView::I18nProxy
end

module ActionView::Layouts
  def _layout_conditions(*args, &block); end

  def _normalize_options(options); end

  def action_has_layout=(action_has_layout); end

  def action_has_layout?(); end

  def initialize(*_); end
end

module ActionView::Layouts
  extend ::ActiveSupport::Concern
end

class ActionView::LogSubscriber
  def from_rails_root(string); end

  def rails_root(); end

  def render_collection(event); end

  def render_partial(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber
end

class ActionView::LookupContext
  include ::ActionView::LookupContext::Accessors
  include ::ActionView::LookupContext::DetailsCache
  include ::ActionView::LookupContext::ViewPaths
  def fallbacks(); end

  def fallbacks=(obj); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def registered_details(); end

  def registered_details=(obj); end

  def rendered_format(); end

  def rendered_format=(rendered_format); end

  def skip_default_locale!(); end

  def with_layout_format(); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def initialize_details(details); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
end

module ActionView::LookupContext::Accessors
end

module ActionView::LookupContext::DetailsCache
  def _set_detail(key, value); end

  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

module ActionView::LookupContext::DetailsCache
end

class ActionView::LookupContext::DetailsKey
  def object_hash(); end
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.get(details); end
end

module ActionView::LookupContext::ViewPaths
  def args_for_lookup(name, prefixes, partial, keys, details_options); end

  def detail_args_for(options); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_file(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def normalize_name(name, prefixes); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def view_paths(); end

  def view_paths=(paths); end

  def with_fallbacks(); end
end

module ActionView::LookupContext::ViewPaths
end

class ActionView::LookupContext
  def self.fallbacks(); end

  def self.fallbacks=(obj); end

  def self.register_detail(name, options=T.unsafe(nil), &block); end

  def self.registered_details(); end

  def self.registered_details=(obj); end
end

class ActionView::MissingRequestError
end

class ActionView::MissingRequestError
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *_); end
end

module ActionView::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

module ActionView::ModelNaming
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OutputBuffer
  def append=(value); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialDigestor
end

class ActionView::PartialDigestor
end

class ActionView::PartialRenderer
  def initialize(*_); end

  def render(context, options, block); end
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::PartialRenderer
end

class ActionView::PathResolver
  def initialize(pattern=T.unsafe(nil)); end
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
end

class ActionView::PathSet
  include ::Enumerable
  def +(array); end

  def <<(*args); end

  def [](*args, &block); end

  def compact(); end

  def concat(*args); end

  def each(*args, &block); end

  def exists?(path, prefixes, *args); end

  def find(*args); end

  def find_all(path, prefixes=T.unsafe(nil), *args); end

  def find_file(path, prefixes=T.unsafe(nil), *args); end

  def include?(*args, &block); end

  def initialize(paths=T.unsafe(nil)); end

  def insert(*args); end

  def paths(); end

  def pop(*args, &block); end

  def push(*args); end

  def size(*args, &block); end

  def to_ary(); end

  def unshift(*args); end
end

class ActionView::PathSet
end

class ActionView::Railtie
end

class ActionView::Railtie
end

module ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def dom_class(record_or_class, prefix=T.unsafe(nil)); end

  def dom_id(record, prefix=T.unsafe(nil)); end

  def record_key_for_dom_id(record); end
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  extend ::ActionView::RecordIdentifier
  extend ::ActionView::ModelNaming
end

class ActionView::Renderer
  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_template(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def process(*_); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_context_class=(view_context_class); end

  def view_renderer(); end
end

module ActionView::Rendering
  extend ::ActiveSupport::Concern
end

class ActionView::Resolver
  def caching(); end

  def caching=(obj); end

  def caching?(*args, &block); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_all_anywhere(name, prefix, partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::Resolver::Cache
  def cache(key, name, prefix, partial, locals); end

  def clear(); end
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

class ActionView::Resolver::Cache::SmallCache
  def initialize(options=T.unsafe(nil)); end
end

class ActionView::Resolver::Cache::SmallCache
end

class ActionView::Resolver::Cache
end

class ActionView::Resolver::Path
  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end
end

class ActionView::Resolver::Path
  def self.build(name, prefix, partial); end
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(obj); end

  def self.caching?(); end
end

module ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  def _routes_context(); end

  def default_url_options=(obj); end

  def optimize_routes_generation?(); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(obj); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::Template
  def compile(mod); end

  def compile!(view); end

  def encode!(); end

  def formats(); end

  def formats=(formats); end

  def handle_render_error(view, e); end

  def handler(); end

  def identifier(); end

  def identifier_method_name(); end

  def initialize(source, identifier, handler, details); end

  def instrument(action, &block); end

  def locals(); end

  def locals=(locals); end

  def locals_code(); end

  def method_name(); end

  def original_encoding(); end

  def refresh(view); end

  def render(view, locals, buffer=T.unsafe(nil), &block); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def updated_at(); end

  def variants(); end

  def variants=(variants); end

  def virtual_path(); end

  def virtual_path=(virtual_path); end
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Error
  def annoted_source_code(); end

  def file_name(); end

  def initialize(template, original_exception); end

  def line_number(); end

  def original_exception(); end

  def source_extract(indentation=T.unsafe(nil), output=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::HTML
  def formats(); end

  def identifier(); end

  def initialize(string, type=T.unsafe(nil)); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::HTML
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template); end

  def default_format(); end

  def default_format=(default_format); end

  def default_format?(); end

  def require_engine(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(val); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template); end

  def erb_implementation(); end

  def erb_implementation=(erb_implementation); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(erb_trim_mode); end

  def erb_trim_mode?(); end

  def escape_whitelist(); end

  def escape_whitelist=(escape_whitelist); end

  def escape_whitelist?(); end

  def handles_encoding?(); end

  def supports_streaming?(); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB
  def self.call(template); end

  def self.erb_implementation(); end

  def self.erb_implementation=(val); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(val); end

  def self.erb_trim_mode?(); end

  def self.escape_whitelist(); end

  def self.escape_whitelist=(val); end

  def self.escape_whitelist?(); end
end

class ActionView::Template::Handlers::Erubis
  def flush_newline_if_pending(src); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::Erubis
end

class ActionView::Template::Handlers::Raw
  def call(template); end
end

class ActionView::Template::Handlers::Raw
end

module ActionView::Template::Handlers
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Text
  def formats(); end

  def identifier(); end

  def initialize(string, type=T.unsafe(nil)); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Text
end

class ActionView::Template::Types
  def type_klass(); end

  def type_klass=(obj); end
end

class ActionView::Template::Types::Type
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_s(*args, &block); end

  def to_str(*args, &block); end

  def to_sym(*args, &block); end

  def types(); end

  def types=(obj); end
end

class ActionView::Template::Types::Type
  def self.[](type); end

  def self.register(*t); end

  def self.types(); end

  def self.types=(obj); end
end

class ActionView::Template::Types
  def self.[](type); end

  def self.delegate_to(klass); end

  def self.type_klass(); end

  def self.type_klass=(obj); end
end

class ActionView::Template
  extend ::ActiveSupport::Autoload
  extend ::ActionView::Template::Handlers
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::TagAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::TemplateAssertions
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::RenderingHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(_helpers); end

  def _helpers?(); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::ModelNaming
  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*args, &block); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*_); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::ClassMethods
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

module ActionView::TestCase::Behavior::Locals
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
end

module ActionView::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionView::TestCase::TestController
  include ::ActionDispatch::TestProcess
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
end

module ActionView::ViewPaths
  def _prefixes(); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*args, &block); end

  def formats=(arg); end

  def locale(*args, &block); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*args, &block); end

  def view_paths(*args, &block); end
end

module ActionView::ViewPaths
  extend ::ActiveSupport::Concern
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActionView
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveJob
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  TYPE_WHITELIST = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  extend ::ActiveJob::Arguments
end

class ActiveJob::Base
  include ::ActiveJob::Core
  include ::ActiveJob::QueueAdapter
  include ::ActiveJob::QueueName
  include ::ActiveJob::Enqueuing
  include ::ActiveSupport::Rescuable
  include ::ActiveJob::Execution
  include ::ActiveSupport::Callbacks
  include ::ActiveJob::Callbacks
  include ::ActiveJob::Logging
  include ::ActiveJob::Translation
  def _enqueue_callbacks(); end

  def _enqueue_callbacks?(); end

  def _perform_callbacks(); end

  def _perform_callbacks?(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def arguments(); end

  def arguments=(arguments); end

  def job_id(); end

  def job_id=(job_id); end

  def locale(); end

  def locale=(locale); end

  def logger(); end

  def logger=(obj); end

  def queue_name=(queue_name); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def scheduled_at(); end

  def scheduled_at=(scheduled_at); end

  def serialized_arguments=(serialized_arguments); end
end

class ActiveJob::Base
  extend ::ActiveSupport::DescendantsTracker
  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(val); end

  def self._enqueue_callbacks?(); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(val); end

  def self._perform_callbacks?(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.queue_name(); end

  def self.queue_name=(val); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(val); end

  def self.queue_name_delimiter?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end
end

module ActiveJob::Callbacks
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Concern
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*args); end

  def perform_now(*args); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  def initialize(*arguments); end

  def serialize(); end
end

module ActiveJob::Core
  extend ::ActiveSupport::Concern
end

class ActiveJob::DeserializationError
  def initialize(e); end

  def original_exception(); end
end

class ActiveJob::DeserializationError
end

module ActiveJob::Enqueuing
  def enqueue(options=T.unsafe(nil)); end

  def retry_job(options=T.unsafe(nil)); end
end

module ActiveJob::Enqueuing
  extend ::ActiveSupport::Concern
end

module ActiveJob::Execution
  def perform(*_); end

  def perform_now(); end
end

module ActiveJob::Execution
  extend ::ActiveSupport::Concern
end

module ActiveJob::Logging
end

module ActiveJob::Logging
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueueAdapter
end

module ActiveJob::QueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueueAdapters
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::InlineAdapter
  def self.enqueue(job); end

  def self.enqueue_at(*_); end
end

class ActiveJob::QueueAdapters::TestAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def name(*args, &block); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  extend ::ActiveSupport::Autoload
end

module ActiveJob::QueueName
  def queue_name(); end
end

module ActiveJob::QueueName
  extend ::ActiveSupport::Concern
end

class ActiveJob::Railtie
end

class ActiveJob::Railtie
end

class ActiveJob::SerializationError
end

class ActiveJob::SerializationError
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
  def assert_enqueued_jobs(number); end

  def assert_enqueued_with(args=T.unsafe(nil), &_block); end

  def assert_no_enqueued_jobs(&block); end

  def assert_no_performed_jobs(&block); end

  def assert_performed_jobs(number); end

  def assert_performed_with(args=T.unsafe(nil), &_block); end

  def enqueued_jobs(*args, &block); end

  def enqueued_jobs=(arg); end

  def perform_enqueued_jobs(); end

  def performed_jobs(*args, &block); end

  def performed_jobs=(arg); end

  def queue_adapter(); end
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper
end

module ActiveJob::TestHelper
  extend ::ActiveSupport::Concern
end

module ActiveJob::Translation
end

module ActiveJob::Translation
  extend ::ActiveSupport::Concern
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::VERSION
end

module ActiveJob
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveModel::AttributeMethods
  def attribute_method?(attr_name); end

  def attribute_missing(match, *args, &block); end

  def method_missing(method, *args, &block); end

  def respond_to?(method, include_private_methods=T.unsafe(nil)); end

  def respond_to_without_attributes?(*_); end
  CALL_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
  NAME_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods
  extend ::ActiveSupport::Concern
end

class ActiveModel::BlockValidator
  def initialize(options, &block); end
end

class ActiveModel::BlockValidator
end

module ActiveModel::Callbacks
  def define_model_callbacks(*callbacks); end
end

module ActiveModel::Callbacks
  def self.extended(base); end
end

module ActiveModel::Conversion
  def to_key(); end

  def to_model(); end

  def to_param(); end

  def to_partial_path(); end
end

module ActiveModel::Conversion
  extend ::ActiveSupport::Concern
end

module ActiveModel::Dirty
  def attribute_was(attr); end

  def attributes_changed_by_setter(); end

  def changed(); end

  def changed_attributes(); end

  def changes(); end

  def previous_changes(); end

  def restore_attributes(attributes=T.unsafe(nil)); end
end

module ActiveModel::Dirty
  extend ::ActiveSupport::Concern
end

class ActiveModel::EachValidator
  def attributes(); end

  def check_validity!(); end

  def initialize(options); end

  def validate_each(record, attribute, value); end
end

class ActiveModel::EachValidator
end

class ActiveModel::Errors
  include ::Enumerable
  def [](attribute); end

  def []=(attribute, error); end

  def add_on_blank(attributes, options=T.unsafe(nil)); end

  def add_on_empty(attributes, options=T.unsafe(nil)); end

  def clear(); end

  def count(); end

  def delete(key); end

  def each(&blk); end

  def empty?(); end

  def full_message(attribute, message); end

  def full_messages_for(attribute); end

  def generate_message(attribute, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def get(key); end

  def has_key?(attribute); end

  def include?(attribute); end

  def initialize(base); end

  def key?(attribute); end

  def keys(); end

  def messages(); end

  def set(key, value); end

  def size(); end

  def to_a(); end

  def to_hash(full_messages=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def values(); end
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::ForbiddenAttributesError
end

class ActiveModel::ForbiddenAttributesError
end

module ActiveModel::ForbiddenAttributesProtection
  def sanitize_for_mass_assignment(attributes); end

  def sanitize_forbidden_attributes(attributes); end
end

module ActiveModel::ForbiddenAttributesProtection
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

module ActiveModel::MassAssignmentSecurity
  include ::ActiveModel::ForbiddenAttributesProtection
  def mass_assignment_authorizer(role); end

  def sanitize_for_mass_assignment(attributes, role=T.unsafe(nil)); end
end

module ActiveModel::MassAssignmentSecurity
  extend ::ActiveSupport::Concern
end

class ActiveModel::MissingAttributeError
end

class ActiveModel::MissingAttributeError
end

module ActiveModel::Model
  def initialize(params=T.unsafe(nil)); end

  def persisted?(); end
end

module ActiveModel::Model
  extend ::ActiveSupport::Concern
end

class ActiveModel::Name
  include ::Comparable
  def !~(*args, &block); end

  def ==(arg); end

  def ===(arg); end

  def =~(*args, &block); end

  def as_json(*args, &block); end

  def cache_key(); end

  def collection(); end

  def element(); end

  def eql?(*args, &block); end

  def human(options=T.unsafe(nil)); end

  def i18n_key(); end

  def initialize(klass, namespace=T.unsafe(nil), name=T.unsafe(nil)); end

  def name(); end

  def param_key(); end

  def plural(); end

  def route_key(); end

  def singular(); end

  def singular_route_key(); end

  def to_s(*args, &block); end

  def to_str(*args, &block); end
end

class ActiveModel::Name
end

module ActiveModel::Naming
  def model_name(); end
end

module ActiveModel::Naming
  def self.extended(base); end

  def self.param_key(record_or_class); end

  def self.plural(record_or_class); end

  def self.route_key(record_or_class); end

  def self.singular(record_or_class); end

  def self.singular_route_key(record_or_class); end

  def self.uncountable?(record_or_class); end
end

class ActiveModel::Railtie
end

class ActiveModel::Railtie
end

module ActiveModel::SecurePassword
  MAX_PASSWORD_LENGTH_ALLOWED = ::T.let(nil, ::T.untyped)
end

module ActiveModel::SecurePassword::InstanceMethodsOnActivation
  def authenticate(unencrypted_password); end

  def password(); end

  def password=(unencrypted_password); end

  def password_confirmation=(unencrypted_password); end
end

module ActiveModel::SecurePassword::InstanceMethodsOnActivation
end

module ActiveModel::SecurePassword
  extend ::ActiveSupport::Concern
  def self.min_cost(); end

  def self.min_cost=(min_cost); end
end

module ActiveModel::Serialization
  def read_attribute_for_serialization(*_); end

  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveModel::Serialization
end

module ActiveModel::Serializers
end

module ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  def as_json(options=T.unsafe(nil)); end

  def from_json(json, include_root=T.unsafe(nil)); end
end

module ActiveModel::Serializers::JSON
  extend ::ActiveSupport::Concern
end

module ActiveModel::Serializers::Xml
  include ::ActiveModel::Serialization
  def from_xml(xml); end

  def to_xml(options=T.unsafe(nil), &block); end
end

class ActiveModel::Serializers::Xml::Serializer
  def initialize(serializable, options=T.unsafe(nil)); end

  def options(); end

  def serializable_collection(); end

  def serializable_hash(); end

  def serialize(); end
end

class ActiveModel::Serializers::Xml::Serializer::Attribute
  def compute_type(); end

  def decorations(); end

  def initialize(name, serializable, value); end

  def name(); end

  def type(); end

  def value(); end
end

class ActiveModel::Serializers::Xml::Serializer::Attribute
end

class ActiveModel::Serializers::Xml::Serializer
end

module ActiveModel::Serializers::Xml
  extend ::ActiveSupport::Concern
end

module ActiveModel::Serializers
  extend ::ActiveSupport::Autoload
end

class ActiveModel::StrictValidationFailed
end

class ActiveModel::StrictValidationFailed
end

class ActiveModel::TestCase
end

class ActiveModel::TestCase
end

module ActiveModel::Translation
  include ::ActiveModel::Naming
  def human_attribute_name(attribute, options=T.unsafe(nil)); end

  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveModel::Translation
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
end

module ActiveModel::Validations
  def invalid?(context=T.unsafe(nil)); end

  def read_attribute_for_validation(*_); end

  def run_validations!(); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end

  def validates_with(*args, &block); end
end

module ActiveModel::Validations::Callbacks
  def run_validations!(); end
end

module ActiveModel::Validations::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveModel::Validations::HelperMethods
  def validates_absence_of(*attr_names); end

  def validates_acceptance_of(*attr_names); end

  def validates_confirmation_of(*attr_names); end

  def validates_exclusion_of(*attr_names); end

  def validates_format_of(*attr_names); end

  def validates_inclusion_of(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_numericality_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end
end

module ActiveModel::Validations
  extend ::ActiveSupport::Concern
end

class ActiveModel::Validator
  def initialize(options=T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def validate(record); end
end

class ActiveModel::Validator
  def self.kind(); end
end

module ActiveModel
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveRecord
  Fixtures = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Aggregations
  def clear_aggregation_cache(); end
end

module ActiveRecord::Aggregations
  extend ::ActiveSupport::Concern
end

class ActiveRecord::AssociationNotFoundError
  def initialize(record, association_name); end
end

class ActiveRecord::AssociationRelation
  def initialize(klass, table, association); end

  def proxy_association(); end
end

class ActiveRecord::AssociationRelation
end

module ActiveRecord::Associations
  def association(name); end

  def association_cache(); end

  def clear_association_cache(); end
end

class ActiveRecord::Associations::CollectionProxy
  def <<(*records); end

  def any?(&block); end

  def append(*records); end

  def average(*args, &block); end

  def build(attributes=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def bulk_import(*args, &block); end

  def calculate(*args, &block); end

  def clear(); end

  def concat(*records); end

  def create(attributes=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*records); end

  def delete_all(dependent=T.unsafe(nil)); end

  def destroy(*records); end

  def destroy_all(); end

  def distinct(); end

  def fifth(*args); end

  def find(*args, &block); end

  def find_nth(*args, &block); end

  def first(*args); end

  def forty_two(*args); end

  def fourth(*args); end

  def ids(*args, &block); end

  def import(*args, &block); end

  def include?(record); end

  def initialize(klass, association); end

  def last(*args); end

  def length(); end

  def load_target(); end

  def many?(&block); end

  def maximum(*args, &block); end

  def minimum(*args, &block); end

  def new(attributes=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def pluck(*args, &block); end

  def prepend(*args); end

  def proxy_association(); end

  def push(*records); end

  def replace(other_array); end

  def scope(); end

  def second(*args); end

  def select(*fields, &block); end

  def sum(*args, &block); end

  def take(n=T.unsafe(nil)); end

  def target(); end

  def third(*args); end

  def to_ary(); end

  def uniq(); end
end

class ActiveRecord::Associations::CollectionProxy
end

module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Attribute
  def ==(other); end

  def came_from_user?(); end

  def changed_from?(old_value); end

  def changed_in_place_from?(old_value); end

  def initialize(name, value_before_type_cast, type); end

  def initialized?(); end

  def name(); end

  def original_value(); end

  def type(); end

  def type_cast(*_); end

  def value(); end

  def value_before_type_cast(); end

  def value_for_database(); end

  def with_cast_value(value); end

  def with_value_from_database(value); end

  def with_value_from_user(value); end
end

class ActiveRecord::Attribute::WithCastValue
  def type_cast(value); end
end

class ActiveRecord::Attribute::WithCastValue
end

class ActiveRecord::Attribute
  def self.from_database(name, value, type); end

  def self.from_user(name, value, type); end

  def self.null(name); end

  def self.uninitialized(name, type); end

  def self.with_cast_value(name, value, type); end
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def assign_attributes(new_attributes); end

  def attributes=(new_attributes); end
end

module ActiveRecord::AttributeAssignment
  extend ::ActiveSupport::Concern
end

class ActiveRecord::AttributeAssignmentError
  def attribute(); end

  def exception(); end

  def initialize(message, exception, attribute); end
end

module ActiveRecord::AttributeDecorators
end

module ActiveRecord::AttributeDecorators
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  def [](attr_name); end

  def []=(attr_name, value); end

  def arel_attributes_with_values_for_create(attribute_names); end

  def arel_attributes_with_values_for_update(attribute_names); end

  def attribute_for_inspect(attr_name); end

  def attribute_method?(attr_name); end

  def attribute_names(); end

  def attribute_present?(attribute); end

  def attributes(); end

  def clone_attribute_value(reader_method, attribute_name); end

  def has_attribute?(attr_name); end

  def respond_to?(name, include_private=T.unsafe(nil)); end
  BLACKLISTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  def attributes_before_type_cast(); end

  def read_attribute_before_type_cast(attr_name); end
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Dirty
  def attribute_changed_in_place?(attr_name); end

  def changed_attributes(); end

  def changes(); end

  def changes_applied(); end

  def clear_changes_information(); end

  def reload(*_); end

  def save(*_); end

  def save!(*_); end
end

module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::PrimaryKey
  def attribute_method?(attr_name); end

  def id(); end

  def id=(value); end

  def id?(); end

  def id_before_type_cast(); end

  def id_was(); end

  def to_key(); end
end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Query
  def query_attribute(attr_name); end
end

module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Read
  def _read_attribute(attr_name); end

  def read_attribute(attr_name, &block); end
  ID = ::T.let(nil, ::T.untyped)
  ReaderMethodCache = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Write
  def raw_write_attribute(attr_name, value); end

  def write_attribute(attr_name, value); end
  WriterMethodCache = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::AttributeSet
  def ==(other); end

  def [](name); end

  def attributes(); end

  def fetch_value(name); end

  def initialize(attributes); end

  def key?(name); end

  def keys(); end

  def reset(key); end

  def to_h(); end

  def to_hash(); end

  def values_before_type_cast(); end

  def write_cast_value(name, value); end

  def write_from_database(name, value); end

  def write_from_user(name, value); end
end

class ActiveRecord::AttributeSet::Builder
  def always_initialized(); end

  def build_from_database(values=T.unsafe(nil), additional_types=T.unsafe(nil)); end

  def initialize(types, always_initialized=T.unsafe(nil)); end

  def types(); end
end

class ActiveRecord::AttributeSet::Builder
end

class ActiveRecord::AttributeSet
end

module ActiveRecord::Attributes
end

module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AutosaveAssociation
  def changed_for_autosave?(); end

  def destroyed_by_association(); end

  def destroyed_by_association=(reflection); end

  def mark_for_destruction(); end

  def marked_for_destruction?(); end

  def reload(options=T.unsafe(nil)); end
end

module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Base
  include ::ActiveRecord::Core
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::AttributeDecorators
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::Callbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::Aggregations
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serializers::Xml
  include ::ActiveModel::Serialization
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::MassAssignmentSecurity::Core
  include ::ActiveModel::MassAssignmentSecurity
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::MassAssignmentSecurity::AttributeAssignment
  include ::ActiveRecord::MassAssignmentSecurity::Persistence
  include ::ActiveRecord::MassAssignmentSecurity::Validations
  include ::ActiveRecord::MassAssignmentSecurity::NestedAttributes
  include ::ActiveRecord::MassAssignmentSecurity::Inheritance
  include ::GlobalID::Identification
  include ::AlphabeticalPaginate::ControllerHelpers
  include ::Paperclip::Validators::HelperMethods
  def _accessible_attributes(); end

  def _accessible_attributes?(); end

  def _active_authorizer(); end

  def _active_authorizer?(); end

  def _commit_callbacks(); end

  def _commit_callbacks?(); end

  def _create_callbacks(); end

  def _create_callbacks?(); end

  def _destroy_callbacks(); end

  def _destroy_callbacks?(); end

  def _find_callbacks(); end

  def _find_callbacks?(); end

  def _initialize_callbacks(); end

  def _initialize_callbacks?(); end

  def _mass_assignment_sanitizer(); end

  def _mass_assignment_sanitizer?(); end

  def _protected_attributes(); end

  def _protected_attributes?(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _rollback_callbacks?(); end

  def _run_commit_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _save_callbacks?(); end

  def _touch_callbacks(); end

  def _touch_callbacks?(); end

  def _update_callbacks(); end

  def _update_callbacks?(); end

  def _uses_mass_assignment_security(); end

  def _uses_mass_assignment_security?(); end

  def _validate_callbacks(); end

  def _validate_callbacks?(); end

  def _validation_callbacks(); end

  def _validation_callbacks?(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def column_for_attribute(*args, &block); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_scopes(); end

  def default_timezone(); end

  def defined_enums(); end

  def defined_enums?(); end

  def dump_schema_after_migration(); end

  def find_by_statement_cache(); end

  def find_by_statement_cache=(find_by_statement_cache); end

  def find_by_statement_cache?(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def model_name(*args, &block); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_writes(); end

  def partial_writes?(); end

  def persistable_attribute_names(*args, &block); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def raise_in_transactional_callbacks(); end

  def record_timestamps(); end

  def record_timestamps=(record_timestamps); end

  def record_timestamps?(); end

  def schema_format(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def synchronize(instances, key=T.unsafe(nil)); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def timestamped_migrations(); end

  def type_for_attribute(*args, &block); end

  def validation_context(); end
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

class ActiveRecord::Base
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveRecord::Translation
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveModel::Callbacks
  extend ::ActiveModel::Validations::HelperMethods
  extend ::AlphabeticalPaginate::ControllerHelpers
  extend ::WillPaginate::PerPage
  extend ::WillPaginate::PerPage::Inheritance
  extend ::WillPaginate::ActiveRecord::Pagination
  extend ::WillPaginate::ActiveRecord::BaseMethods
  extend ::SorbetRails::CustomFinderMethods
  extend ::ActiveRecord::Import::Connection
  def self._accessible_attributes(); end

  def self._accessible_attributes=(val); end

  def self._accessible_attributes?(); end

  def self._active_authorizer(); end

  def self._active_authorizer=(val); end

  def self._active_authorizer?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(val); end

  def self._attr_readonly?(); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(val); end

  def self._commit_callbacks?(); end

  def self._create_callbacks(); end

  def self._create_callbacks=(val); end

  def self._create_callbacks?(); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(val); end

  def self._destroy_callbacks?(); end

  def self._find_callbacks(); end

  def self._find_callbacks=(val); end

  def self._find_callbacks?(); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(val); end

  def self._initialize_callbacks?(); end

  def self._mass_assignment_sanitizer(); end

  def self._mass_assignment_sanitizer=(val); end

  def self._mass_assignment_sanitizer?(); end

  def self._protected_attributes(); end

  def self._protected_attributes=(val); end

  def self._protected_attributes?(); end

  def self._reflections(); end

  def self._reflections=(val); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(val); end

  def self._rollback_callbacks?(); end

  def self._save_callbacks(); end

  def self._save_callbacks=(val); end

  def self._save_callbacks?(); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(val); end

  def self._touch_callbacks?(); end

  def self._update_callbacks(); end

  def self._update_callbacks=(val); end

  def self._update_callbacks?(); end

  def self._uses_mass_assignment_security(); end

  def self._uses_mass_assignment_security=(val); end

  def self._uses_mass_assignment_security?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(val); end

  def self._validate_callbacks?(); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(val); end

  def self._validation_callbacks?(); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.after_find(*args, &block); end

  def self.after_initialize(*args, &block); end

  def self.after_touch(*args, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(val); end

  def self.aggregate_reflections?(); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(val); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(val); end

  def self.attribute_method_matchers?(); end

  def self.attribute_type_decorations(); end

  def self.attribute_type_decorations=(val); end

  def self.attribute_type_decorations?(); end

  def self.bulk_import(*args); end

  def self.bulk_import!(*args); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(val); end

  def self.cache_timestamp_format?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(val); end

  def self.default_connection_handler?(); end

  def self.default_scopes(); end

  def self.default_scopes=(val); end

  def self.default_timezone(); end

  def self.default_timezone=(obj); end

  def self.defined_enums(); end

  def self.defined_enums=(val); end

  def self.defined_enums?(); end

  def self.disable_implicit_join_references=(value); end

  def self.dump_schema_after_migration(); end

  def self.dump_schema_after_migration=(obj); end

  def self.find_by_statement_cache(); end

  def self.find_by_statement_cache=(val); end

  def self.find_by_statement_cache?(); end

  def self.import(*args); end

  def self.import!(*args); end

  def self.import_helper(*args); end

  def self.import_with_validations(column_names, array_of_attributes, options=T.unsafe(nil)); end

  def self.import_without_validations_or_callbacks(column_names, array_of_attributes, options=T.unsafe(nil)); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.inherited(child); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(val); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.maintain_test_schema(); end

  def self.maintain_test_schema=(obj); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(val); end

  def self.nested_attributes_options?(); end

  def self.nulldb_connection(config); end

  def self.partial_writes(); end

  def self.partial_writes=(val); end

  def self.partial_writes?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(val); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(obj); end

  def self.raise_in_transactional_callbacks(); end

  def self.raise_in_transactional_callbacks=(obj); end

  def self.record_timestamps(); end

  def self.record_timestamps=(val); end

  def self.record_timestamps?(); end

  def self.sbr_old_inherited(subclass); end

  def self.schema_format(); end

  def self.schema_format=(obj); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(val); end

  def self.schema_migrations_table_name?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(val); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(val); end

  def self.store_full_sti_class?(); end

  def self.supports_import?(*args); end

  def self.supports_on_duplicate_key_update?(); end

  def self.supports_setting_primary_key_of_imported_objects?(); end

  def self.synchronize(instances, keys=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(val); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(val); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(obj); end

  def self.timestamped_migrations(); end

  def self.timestamped_migrations=(obj); end

  def self.user_provided_columns(); end

  def self.user_provided_columns=(val); end

  def self.user_provided_columns?(); end

  def self.user_provided_defaults(); end

  def self.user_provided_defaults=(val); end

  def self.user_provided_defaults?(); end
end

module ActiveRecord::Batches
  def find_each(options=T.unsafe(nil)); end

  def find_in_batches(options=T.unsafe(nil)); end
end

module ActiveRecord::Batches
end

module ActiveRecord::Calculations
  def average(column_name, options=T.unsafe(nil)); end

  def calculate(operation, column_name, options=T.unsafe(nil)); end

  def count(column_name=T.unsafe(nil), options=T.unsafe(nil)); end

  def ids(); end

  def maximum(column_name, options=T.unsafe(nil)); end

  def minimum(column_name, options=T.unsafe(nil)); end

  def pluck(*column_names); end

  def sum(*args); end
end

module ActiveRecord::Calculations
end

module ActiveRecord::Callbacks
  def destroy(); end

  def touch(*_); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Coders
end

class ActiveRecord::Coders::JSON
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def dump(obj); end

  def initialize(object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

module ActiveRecord::Coders
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::TimestampDefaultDeprecation
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveSupport::Callbacks
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::ColumnDumper
  include ::ActiveRecord::Import::AbstractAdapter::InstanceMethods
  include ::Paperclip::Schema::Statements
  def _checkin_callbacks(); end

  def _checkin_callbacks?(); end

  def _checkout_callbacks(); end

  def _checkout_callbacks?(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def case_insensitive_comparison(table, attribute, column, value); end

  def case_sensitive_comparison(table, attribute, column, value); end

  def case_sensitive_modifier(node, table_attribute); end

  def clear_cache!(); end

  def close(); end

  def collector(); end

  def column_for(table_name, column_name); end

  def column_name_for_operation(operation, node); end

  def create_savepoint(name=T.unsafe(nil)); end

  def current_savepoint_name(); end

  def delete(*_); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def disconnect!(); end

  def enable_extension(name); end

  def expire(); end

  def extensions(); end

  def extract_limit(sql_type); end

  def extract_precision(sql_type); end

  def extract_scale(sql_type); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), pool=T.unsafe(nil)); end

  def initialize_type_map(m); end

  def insert(*_); end

  def lease(); end

  def log(sql, name=T.unsafe(nil), binds=T.unsafe(nil), statement_name=T.unsafe(nil)); end

  def logger(); end

  def lookup_cast_type(sql_type); end

  def new_column(name, default, cast_type, sql_type=T.unsafe(nil), null=T.unsafe(nil)); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def raw_connection(); end

  def reconnect!(); end

  def register_class_with_limit(mapping, key, klass); end

  def release_savepoint(name=T.unsafe(nil)); end

  def reload_type_map(); end

  def requires_reloading?(); end

  def reset!(); end

  def rollback_db_transaction(*_); end

  def rollback_to_savepoint(*_); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def schema_creation(); end

  def substitute_at(column, _unused=T.unsafe(nil)); end

  def supports_bulk_alter?(); end

  def supports_ddl_transactions?(); end

  def supports_explain?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_migrations?(); end

  def supports_partial_index?(); end

  def supports_primary_key?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_views?(); end

  def translate_exception(exception, message); end

  def translate_exception_class(e, sql); end

  def type_map(); end

  def unprepared_statement(); end

  def update(*_); end

  def valid_type?(type); end

  def verify!(*ignored); end

  def visitor(); end

  def visitor=(visitor); end

  def without_prepared_statement?(binds); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::BindCollector
  def compile(bvs, conn); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::BindCollector
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SQLString
  def compile(bvs, conn); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SQLString
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
  def accept(o); end

  def initialize(conn); end

  def visit_AddColumn(o); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable
  def initialize(version_string); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  extend ::ActiveSupport::DescendantsTracker
  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(val); end

  def self._checkin_callbacks?(); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(val); end

  def self._checkout_callbacks?(); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  def add_column_sql(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_index_length(option_strings, column_names, options=T.unsafe(nil)); end

  def add_index_sql(table_name, column_name, options=T.unsafe(nil)); end

  def add_timestamps_sql(table_name, options=T.unsafe(nil)); end

  def bulk_change_table(table_name, operations); end

  def change_column_sql(table_name, column_name, type, options=T.unsafe(nil)); end

  def charset(); end

  def collation(); end

  def create_database(name, options=T.unsafe(nil)); end

  def current_database(); end

  def data_sources(name=T.unsafe(nil), database=T.unsafe(nil), like=T.unsafe(nil)); end

  def drop_database(name); end

  def each_hash(result); end

  def emulate_booleans(); end

  def emulate_booleans=(emulate_booleans); end

  def emulate_booleans?(); end

  def error_number(exception); end

  def execute(sql, name=T.unsafe(nil)); end

  def execute_and_free(sql, name=T.unsafe(nil)); end

  def indexes(table_name, name=T.unsafe(nil)); end

  def initialize(connection, logger, connection_options, config); end

  def new_column(field, default, cast_type, sql_type=T.unsafe(nil), null=T.unsafe(nil), collation=T.unsafe(nil), extra=T.unsafe(nil)); end

  def pk_and_sequence_for(table); end

  def primary_key(table); end

  def quote_column_name(name); end

  def quote_table_name(name); end

  def recreate_database(name, options=T.unsafe(nil)); end

  def register_integer_type(mapping, key, options); end

  def remove_column_sql(table_name, column_name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def remove_columns_sql(table_name, *column_names); end

  def remove_index_sql(table_name, options=T.unsafe(nil)); end

  def remove_timestamps_sql(table_name, options=T.unsafe(nil)); end

  def rename_column_sql(table_name, column_name, new_column_name); end

  def show_variable(name); end

  def strict_mode?(); end

  def supports_datetime_with_precision?(); end

  def table_exists?(name); end

  def tables(name=T.unsafe(nil), database=T.unsafe(nil), like=T.unsafe(nil)); end
  INDEX_TYPES = ::T.let(nil, ::T.untyped)
  INDEX_USINGS = ::T.let(nil, ::T.untyped)
  LOST_CONNECTION_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  QUOTED_FALSE = ::T.let(nil, ::T.untyped)
  QUOTED_TRUE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter::Column
  def blob_or_text_column?(); end

  def case_sensitive?(); end

  def collation(); end

  def extra(); end

  def extract_default(); end

  def initialize(name, default, cast_type, sql_type=T.unsafe(nil), null=T.unsafe(nil), collation=T.unsafe(nil), strict=T.unsafe(nil), extra=T.unsafe(nil)); end

  def strict(); end
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter::Column
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter::MysqlDateTime
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter::MysqlDateTime
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter::MysqlString
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter::MysqlString
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter
  def self.emulate_booleans(); end

  def self.emulate_booleans=(val); end

  def self.emulate_booleans?(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_column(name, type, options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
end

class ActiveRecord::ConnectionAdapters::Column
  def ==(other); end

  def accessor(*args, &block); end

  def binary?(*args, &block); end

  def cast_type(); end

  def changed?(*args, &block); end

  def default(); end

  def default_function(); end

  def eql?(other); end

  def has_default?(); end

  def human_name(); end

  def initialize(name, default, cast_type, sql_type=T.unsafe(nil), null=T.unsafe(nil)); end

  def klass(*args, &block); end

  def limit(*args, &block); end

  def name(); end

  def null(); end

  def number?(*args, &block); end

  def precision(*args, &block); end

  def scale(*args, &block); end

  def sql_type(); end

  def text?(*args, &block); end

  def type(*args, &block); end

  def type_cast_for_database(*args, &block); end

  def type_cast_for_schema(*args, &block); end

  def type_cast_from_database(*args, &block); end

  def type_cast_from_user(*args, &block); end

  def with_type(type); end
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::Column::Format
  ISO_DATE = ::T.let(nil, ::T.untyped)
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::Column::Format
end

class ActiveRecord::ConnectionAdapters::Column
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def primary_key?(); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
end

module ActiveRecord::ConnectionAdapters::ColumnDumper
  def column_spec(column, types); end

  def migration_keys(); end

  def prepare_column_options(column, types); end
end

module ActiveRecord::ConnectionAdapters::ColumnDumper
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def active_connections?(); end

  def clear_active_connections!(); end

  def clear_all_connections!(); end

  def clear_reloadable_connections!(); end

  def connected?(klass); end

  def connection_pool_list(); end

  def connection_pools(); end

  def establish_connection(owner, spec); end

  def remove_connection(owner); end

  def retrieve_connection(klass); end

  def retrieve_connection_pool(klass); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
end

class ActiveRecord::ConnectionAdapters::ConnectionManagement
  def call(env); end

  def initialize(app); end
end

class ActiveRecord::ConnectionAdapters::ConnectionManagement
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  def active_connection?(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connections(); end

  def disconnect!(); end

  def initialize(spec); end

  def reap(); end

  def reaper(); end

  def release_connection(with_id=T.unsafe(nil)); end

  def remove(conn); end

  def size(); end

  def spec(); end

  def with_connection(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
  def adapter_method(); end

  def config(); end

  def initialize(config, adapter_method); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
  def configurations(); end

  def initialize(configurations); end

  def resolve(config); end

  def resolve_all(); end

  def spec(config); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def allowed_index_name_length(); end

  def column_name_length(); end

  def columns_per_multicolumn_index(); end

  def columns_per_table(); end

  def in_clause_length(); end

  def index_name_length(); end

  def indexes_per_table(); end

  def joins_per_query(); end

  def sql_query_length(); end

  def table_alias_length(); end

  def table_name_length(); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*args, &block); end

  def binds_from_relation(relation, binds); end

  def cacheable_query(arel); end

  def commit_db_transaction(); end

  def commit_transaction(*args, &block); end

  def current_transaction(*args, &block); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def delete_sql(sql, name=T.unsafe(nil)); end

  def empty_insert_statement_value(); end

  def exec_delete(sql, name, binds); end

  def exec_insert(sql, name, binds, pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def exec_update(sql, name, binds); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_sql(sql, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def join_to_delete(delete, select, key); end

  def join_to_update(update, select); end

  def last_inserted_id(result); end

  def open_transactions(*args, &block); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*args, &block); end

  def sanitize_limit(limit); end

  def select(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil)); end

  def sql_for_insert(sql, pk, id_value, sequence_name, binds); end

  def subquery_for(key, select); end

  def supports_statement_cache?(); end

  def to_sql(arel, binds=T.unsafe(nil)); end

  def transaction(options=T.unsafe(nil)); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def transaction_state(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def update_sql(sql, name=T.unsafe(nil)); end

  def within_new_transaction(*args, &block); end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def primary_key(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::Mysql2Adapter
  include ::ActiveRecord::Import::Mysql2Adapter
  include ::ActiveRecord::Import::MysqlAdapter
  include ::ActiveRecord::Import::ImportSupport
  def create(sql, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_without_stmt(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def explain(arel, binds=T.unsafe(nil)); end

  def quote_string(string); end

  def select_rows(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  MAX_INDEX_LENGTH_FOR_UTF8MB4 = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::Mysql2Adapter::ExplainPrettyPrinter
  def pp(result, elapsed); end
end

class ActiveRecord::ConnectionAdapters::Mysql2Adapter::ExplainPrettyPrinter
end

class ActiveRecord::ConnectionAdapters::Mysql2Adapter
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter
  def add_fk_constraint(*args); end

  def add_index(table_name, column_names, options=T.unsafe(nil)); end

  def add_pk_constraint(*args); end

  def checkpoint!(); end

  def columns(table_name, name=T.unsafe(nil)); end

  def create(statement, name=T.unsafe(nil), primary_key=T.unsafe(nil), object_id=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def delete(statement, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def enable_extension(*_); end

  def exec_query(statement, name=T.unsafe(nil), binds=T.unsafe(nil), options=T.unsafe(nil)); end

  def execute(statement, name=T.unsafe(nil)); end

  def execution_log(); end

  def execution_log_since_checkpoint(); end

  def indexes(table_name, name=T.unsafe(nil)); end

  def initialize(config=T.unsafe(nil)); end

  def insert(statement, name=T.unsafe(nil), primary_key=T.unsafe(nil), object_id=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def primary_key(table_name); end

  def select(statement, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_all(statement, name=T.unsafe(nil), binds=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_one(statement, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(statement, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(statement, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(statement, name=T.unsafe(nil)); end

  def tables(); end

  def update(statement, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def views(); end
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::Checkpoint
  def initialize(); end
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::Checkpoint
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::Column
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::Column
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::Configuration
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::Configuration
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::EmptyResult
  def >(num); end

  def bind_column_meta(columns); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def column_types(); end

  def columns(); end

  def includes_column?(name); end

  def rows(); end
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::EmptyResult
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::NullObject
  def method_missing(*args, &block); end

  def to_a(); end
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::NullObject
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::Statement
  def ==(other); end

  def content(); end

  def entry_point(); end

  def initialize(entry_point, content=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::NullDBAdapter::Statement
end

ActiveRecord::ConnectionAdapters::NullDBAdapter::TableDefinition = ActiveRecord::ConnectionAdapters::TableDefinition

class ActiveRecord::ConnectionAdapters::NullDBAdapter
  def self.insinuate_into_spec(config); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record); end

  def closed?(); end

  def joinable?(); end

  def open?(); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def cache(); end

  def clear_query_cache(); end

  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache(); end

  def query_cache_enabled(); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def uncached(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def self.dirties_query_cache(base, *method_names); end

  def self.included(base); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def quote(value, column=T.unsafe(nil)); end

  def quote_column_name(column_name); end

  def quote_string(s); end

  def quote_table_name(table_name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_date(value); end

  def quoted_false(); end

  def quoted_true(); end

  def type_cast(value, column); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::Quoting
end

class ActiveRecord::ConnectionAdapters::RealTransaction
end

class ActiveRecord::ConnectionAdapters::RealTransaction
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def initialize(connection, savepoint_name, options); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name=T.unsafe(nil)); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def release_savepoint(name=T.unsafe(nil)); end

  def supports_savepoints?(); end
end

module ActiveRecord::ConnectionAdapters::Savepoints
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(table_name); end

  def clear!(); end

  def clear_table_cache!(table_name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def connection(); end

  def connection=(connection); end

  def initialize(conn); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(table_name); end

  def size(); end

  def table_exists?(name); end

  def tables(name); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::TimestampDefaultDeprecation
  def add_belongs_to(table_name, ref_name, options=T.unsafe(nil)); end

  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_foreign_key(from_table, to_table, options=T.unsafe(nil)); end

  def add_index(table_name, column_name, options=T.unsafe(nil)); end

  def add_index_options(table_name, column_name, options=T.unsafe(nil)); end

  def add_index_sort_order(option_strings, column_names, options=T.unsafe(nil)); end

  def add_reference(table_name, ref_name, options=T.unsafe(nil)); end

  def add_timestamps(table_name, options=T.unsafe(nil)); end

  def assume_migrated_upto_version(version, migrations_paths=T.unsafe(nil)); end

  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def change_column_default(table_name, column_name, default); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def column_exists?(table_name, column_name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def columns(table_name); end

  def columns_for_distinct(columns, orders); end

  def create_join_table(table_1, table_2, options=T.unsafe(nil)); end

  def create_table(table_name, options=T.unsafe(nil)); end

  def data_source_exists?(name); end

  def data_sources(); end

  def drop_join_table(table_1, table_2, options=T.unsafe(nil)); end

  def drop_table(table_name, options=T.unsafe(nil)); end

  def dump_schema_information(); end

  def foreign_key_column_for(table_name); end

  def foreign_keys(table_name); end

  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name, default); end

  def index_name_for_remove(table_name, options=T.unsafe(nil)); end

  def initialize_schema_migrations_table(); end

  def native_database_types(); end

  def options_include_default?(options); end

  def quoted_columns_for_index(column_names, options=T.unsafe(nil)); end

  def remove_belongs_to(table_name, ref_name, options=T.unsafe(nil)); end

  def remove_column(table_name, column_name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def remove_columns(table_name, *column_names); end

  def remove_foreign_key(from_table, options_or_to_table=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end

  def remove_index!(table_name, index_name); end

  def remove_reference(table_name, ref_name, options=T.unsafe(nil)); end

  def remove_timestamps(table_name, options=T.unsafe(nil)); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_column_indexes(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def rename_table_indexes(table_name, new_name); end

  def table_alias_for(table_name); end

  def table_exists?(table_name); end

  def type_to_sql(type, limit=T.unsafe(nil), precision=T.unsafe(nil), scale=T.unsafe(nil)); end

  def update_table_definition(table_name, base); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::Table
  include ::Paperclip::Schema::TableDefinition
  def binary(*args); end

  def boolean(*args); end

  def date(*args); end

  def datetime(*args); end

  def decimal(*args); end

  def float(*args); end

  def initialize(table_name, base); end

  def integer(*args); end

  def name(); end

  def string(*args); end

  def text(*args); end

  def time(*args); end

  def timestamp(*args); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::TimestampDefaultDeprecation
  include ::Paperclip::Schema::TableDefinition
  def as(); end

  def bigint(*args); end

  def binary(*args); end

  def boolean(*args); end

  def date(*args); end

  def datetime(*args); end

  def decimal(*args); end

  def float(*args); end

  def foreign_key(table_name, options=T.unsafe(nil)); end

  def foreign_keys(); end

  def indexes(); end

  def indexes=(indexes); end

  def initialize(types, name, temporary, options, as=T.unsafe(nil)); end

  def integer(*args); end

  def name(); end

  def new_column_definition(name, type, options); end

  def options(); end

  def primary_key(name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def string(*args); end

  def temporary(); end

  def text(*args); end

  def time(*args); end

  def timestamp(*args); end
end

module ActiveRecord::ConnectionAdapters::TimestampDefaultDeprecation
  def emit_warning_if_null_unspecified(sym, options); end
end

module ActiveRecord::ConnectionAdapters::TimestampDefaultDeprecation
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record); end

  def closed?(); end

  def commit(); end

  def commit_records(); end

  def connection(); end

  def full_rollback?(); end

  def initialize(connection, options); end

  def joinable=(joinable); end

  def joinable?(); end

  def open?(); end

  def records(); end

  def rollback(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::Transaction
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(options=T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def initialize(connection); end

  def open_transactions(); end

  def rollback_transaction(); end

  def within_new_transaction(options=T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def initialize(state=T.unsafe(nil)); end

  def parent(); end

  def rolledback?(); end

  def set_state(state); end
  VALID_STATES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionState
end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*args, &block); end

  def clear_all_connections!(*args, &block); end

  def clear_cache!(); end

  def clear_reloadable_connections!(*args, &block); end

  def connected?(); end

  def connection(); end

  def connection_config(); end

  def connection_id(); end

  def connection_id=(connection_id); end

  def connection_pool(); end

  def establish_connection(spec=T.unsafe(nil)); end

  def mysql2_connection(config); end

  def remove_connection(klass=T.unsafe(nil)); end

  def retrieve_connection(); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionHandling::MergeAndResolveDefaultUrlConfig
  def initialize(raw_configurations); end

  def resolve(); end
end

class ActiveRecord::ConnectionHandling::MergeAndResolveDefaultUrlConfig
end

module ActiveRecord::ConnectionHandling
end

module ActiveRecord::Core
  def ==(comparison_object); end

  def connection_handler(); end

  def encode_with(coder); end

  def eql?(comparison_object); end

  def freeze(); end

  def frozen?(); end

  def hash(); end

  def init_with(coder); end

  def initialize(attributes=T.unsafe(nil), options=T.unsafe(nil)); end

  def inspect(); end

  def pretty_print(pp); end

  def readonly!(); end

  def readonly?(); end

  def slice(*methods); end
end

module ActiveRecord::Core
  extend ::ActiveSupport::Concern
end

module ActiveRecord::CounterCache
  def actually_destroyed?(); end

  def clear_destroy_state(); end
end

module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation
  def all?(*args, &block); end

  def array_delegable?(method); end

  def collect(*args, &block); end

  def columns_hash(*args, &block); end

  def connection(*args, &block); end

  def each(*args, &block); end

  def include?(*args, &block); end

  def join(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def method_missing(method, *args, &block); end

  def primary_key(*args, &block); end

  def quoted_primary_key(*args, &block); end

  def quoted_table_name(*args, &block); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def table_name(*args, &block); end

  def to_ary(*args, &block); end

  def to_xml(*args, &block); end

  def to_yaml(*args, &block); end
  BLACKLISTED_ARRAY_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Delegation::ClassSpecificRelation
  def method_missing(method, *args, &block); end
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DeleteRestrictionError
  def initialize(name); end
end

class ActiveRecord::DuplicateMigrationNameError
  def initialize(name); end
end

class ActiveRecord::DuplicateMigrationVersionError
  def initialize(version); end
end

module ActiveRecord::DynamicMatchers
  def respond_to?(name, include_private=T.unsafe(nil)); end
end

class ActiveRecord::DynamicMatchers::FindBy
  include ::ActiveRecord::DynamicMatchers::Finder
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindByBang
  include ::ActiveRecord::DynamicMatchers::Finder
end

class ActiveRecord::DynamicMatchers::FindByBang
end

module ActiveRecord::DynamicMatchers::Finder
  def attributes_hash(); end

  def body(); end

  def finder(); end

  def result(); end

  def signature(); end
end

module ActiveRecord::DynamicMatchers::Finder
end

class ActiveRecord::DynamicMatchers::Method
  def attribute_names(); end

  def body(); end

  def define(); end

  def initialize(model, name); end

  def model(); end

  def name(); end

  def valid?(); end
end

class ActiveRecord::DynamicMatchers::Method
  def self.match(model, name); end

  def self.matchers(); end

  def self.pattern(); end

  def self.prefix(); end

  def self.suffix(); end
end

module ActiveRecord::DynamicMatchers
end

class ActiveRecord::EagerLoadPolymorphicError
  def initialize(reflection); end
end

module ActiveRecord::Enum
  def enum(*args, **kwargs); end

  def inherited(base); end

  def old_enum(definitions); end
  ENUM_CONFLICT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Enum
  def self.extended(base); end
end

module ActiveRecord::Explain
  def collecting_queries_for_explain(); end

  def exec_explain(queries); end
end

module ActiveRecord::Explain
end

class ActiveRecord::ExplainRegistry
  def collect(); end

  def collect=(collect); end

  def collect?(); end

  def queries(); end

  def queries=(queries); end

  def reset(); end
end

class ActiveRecord::ExplainRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.collect?(*args, &block); end
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  def ignore_payload?(payload); end

  def start(name, id, payload); end
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ExplainSubscriber
end

module ActiveRecord::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def fifth(); end

  def fifth!(); end

  def find(*args); end

  def find_by(*args); end

  def find_by!(*args); end

  def find_last(); end

  def find_nth(index, offset); end

  def find_nth!(index); end

  def find_nth_with_limit(offset, limit); end

  def find_one(id); end

  def find_some(ids); end

  def find_take(); end

  def find_with_ids(*ids); end

  def first(limit=T.unsafe(nil)); end

  def first!(); end

  def forty_two(); end

  def forty_two!(); end

  def fourth(); end

  def fourth!(); end

  def last(limit=T.unsafe(nil)); end

  def last!(); end

  def raise_record_not_found_exception!(ids, result_size, expected_size); end

  def second(); end

  def second!(); end

  def take(limit=T.unsafe(nil)); end

  def take!(); end

  def third(); end

  def third!(); end
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
end

class ActiveRecord::Fixture
  include ::Enumerable
  def [](key); end

  def class_name(); end

  def each(&blk); end

  def find(); end

  def fixture(); end

  def initialize(fixture, model_class); end

  def model_class(); end

  def to_hash(); end
end

class ActiveRecord::Fixture::FixtureError
end

class ActiveRecord::Fixture::FixtureError
end

class ActiveRecord::Fixture::FormatError
end

class ActiveRecord::Fixture::FormatError
end

class ActiveRecord::Fixture
end

class ActiveRecord::FixtureSet
  def [](x); end

  def []=(k, v); end

  def all_loaded_fixtures(); end

  def all_loaded_fixtures=(obj); end

  def config(); end

  def each(&block); end

  def fixtures(); end

  def initialize(connection, name, class_name, path, config=T.unsafe(nil)); end

  def model_class(); end

  def name(); end

  def size(); end

  def table_name(); end

  def table_rows(); end
  MAX_ID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::FixtureSet::ClassCache
  def [](fs_name); end

  def initialize(class_names, config); end
end

class ActiveRecord::FixtureSet::ClassCache
end

class ActiveRecord::FixtureSet::File
  include ::Enumerable
  def each(&block); end

  def initialize(file); end
end

class ActiveRecord::FixtureSet::File
  def self.open(file); end
end

class ActiveRecord::FixtureSet::HasManyThroughProxy
  def lhs_key(); end

  def rhs_key(); end
end

class ActiveRecord::FixtureSet::HasManyThroughProxy
end

class ActiveRecord::FixtureSet::ReflectionProxy
  def initialize(association); end

  def join_table(); end

  def name(); end

  def primary_key_type(); end
end

class ActiveRecord::FixtureSet::ReflectionProxy
end

class ActiveRecord::FixtureSet::RenderContext
end

class ActiveRecord::FixtureSet::RenderContext
  def self.create_subclass(); end
end

class ActiveRecord::FixtureSet
  def self.all_loaded_fixtures(); end

  def self.all_loaded_fixtures=(obj); end

  def self.cache_fixtures(connection, fixtures_map); end

  def self.cache_for_connection(connection); end

  def self.cached_fixtures(connection, keys_to_fetch=T.unsafe(nil)); end

  def self.context_class(); end

  def self.create_fixtures(fixtures_directory, fixture_set_names, class_names=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.default_fixture_model_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.default_fixture_table_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.fixture_is_cached?(connection, table_name); end

  def self.identify(label, column_type=T.unsafe(nil)); end

  def self.instantiate_all_loaded_fixtures(object, load_instances=T.unsafe(nil)); end

  def self.instantiate_fixtures(object, fixture_set, load_instances=T.unsafe(nil)); end

  def self.reset_cache(); end

  def self.update_all_loaded_fixtures(fixtures_map); end
end

class ActiveRecord::HasManyThroughAssociationNotFoundError
  def initialize(owner_class_name, reflection); end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name, reflection, source_reflection); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name, reflection, source_reflection); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name, reflection); end
end

class ActiveRecord::HasManyThroughCantAssociateNewRecords
  def initialize(owner, reflection); end
end

class ActiveRecord::HasManyThroughCantAssociateNewRecords
end

class ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner, reflection); end
end

class ActiveRecord::HasManyThroughCantDissociateNewRecords
  def initialize(owner, reflection); end
end

class ActiveRecord::HasManyThroughCantDissociateNewRecords
end

class ActiveRecord::HasManyThroughNestedAssociationsAreReadonly
  def initialize(owner, reflection); end
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name, reflection); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name, reflection, through_reflection); end
end

class ActiveRecord::IllegalMigrationNameError
  def initialize(name); end
end

module ActiveRecord::Import
  ADAPTER_PATH = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Import::AbstractAdapter
end

module ActiveRecord::Import::AbstractAdapter::InstanceMethods
  def after_import_synchronize(instances); end

  def increment_locking_column!(table_name, results, locking_column); end

  def insert_many(sql, values, _options=T.unsafe(nil), *args); end

  def next_value_for_sequence(sequence_name); end

  def post_sql_statements(table_name, options); end

  def pre_sql_statements(options); end

  def supports_on_duplicate_key_update?(); end
end

module ActiveRecord::Import::AbstractAdapter::InstanceMethods
end

module ActiveRecord::Import::AbstractAdapter
end

module ActiveRecord::Import::Connection
  def establish_connection(args=T.unsafe(nil)); end
end

module ActiveRecord::Import::Connection
end

module ActiveRecord::Import::ConnectionAdapters
end

module ActiveRecord::Import::ConnectionAdapters
end

module ActiveRecord::Import::ImportSupport
  def supports_import?(); end
end

module ActiveRecord::Import::ImportSupport
end

class ActiveRecord::Import::MissingColumnError
  def initialize(name, index); end
end

class ActiveRecord::Import::MissingColumnError
end

module ActiveRecord::Import::Mysql2Adapter
  include ::ActiveRecord::Import::MysqlAdapter
  include ::ActiveRecord::Import::ImportSupport
end

module ActiveRecord::Import::Mysql2Adapter
end

module ActiveRecord::Import::MysqlAdapter
  include ::ActiveRecord::Import::ImportSupport
  def add_column_for_on_duplicate_key_update(column, options=T.unsafe(nil)); end

  def duplicate_key_update_error?(exception); end

  def increment_locking_column!(table_name, results, locking_column); end

  def insert_many(sql, values, options=T.unsafe(nil), *args); end

  def max_allowed_packet(); end

  def pre_sql_statements(options); end

  def sql_for_on_duplicate_key_update(table_name, *args); end

  def sql_for_on_duplicate_key_update_as_array(table_name, locking_column, arr); end

  def sql_for_on_duplicate_key_update_as_hash(table_name, locking_column, hsh); end
  NO_MAX_PACKET = ::T.let(nil, ::T.untyped)
  QUERY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Import::MysqlAdapter
end

class ActiveRecord::Import::Result
  def failed_instances(); end

  def failed_instances=(_); end

  def ids(); end

  def ids=(_); end

  def num_inserts(); end

  def num_inserts=(_); end

  def results(); end

  def results=(_); end
end

class ActiveRecord::Import::Result
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Import::Validator
  def init_validations(klass); end

  def initialize(klass, options=T.unsafe(nil)); end

  def valid_model?(model); end
end

class ActiveRecord::Import::Validator
end

class ActiveRecord::Import::ValueSetTooLargeError
  def initialize(msg=T.unsafe(nil), size=T.unsafe(nil)); end

  def size(); end
end

class ActiveRecord::Import::ValueSetTooLargeError
end

class ActiveRecord::Import::ValueSetsBytesParser
  def initialize(values, options); end

  def max_bytes(); end

  def parse(); end

  def reserved_bytes(); end

  def values(); end
end

class ActiveRecord::Import::ValueSetsBytesParser
  def self.parse(values, options); end
end

class ActiveRecord::Import::ValueSetsRecordsParser
  def initialize(values, options); end

  def max_records(); end

  def parse(); end

  def values(); end
end

class ActiveRecord::Import::ValueSetsRecordsParser
  def self.parse(values, options); end
end

module ActiveRecord::Import
  def self.base_adapter(adapter); end

  def self.load_from_connection_pool(connection_pool); end

  def self.require_adapter(adapter); end
end

module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Integration
  def cache_key(*timestamp_names); end

  def to_param(); end
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InverseOfAssociationNotFoundError
  def initialize(reflection, associated_class=T.unsafe(nil)); end
end

class ActiveRecord::LazyAttributeHash
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def additional_types(); end

  def delegate_hash(); end

  def initialize(types, values, additional_types); end

  def initialized_keys(); end

  def key?(key); end

  def materialize(); end

  def select(); end

  def transform_values(*args, &block); end

  def types(); end

  def values(); end
end

class ActiveRecord::LazyAttributeHash
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter::Rails41
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(klass, coder); end
end

class ActiveRecord::Locking::LockingType
  def encode_with(coder); end

  def init_with(coder); end

  def type_cast_from_database(value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Locking::LockingType
end

module ActiveRecord::Locking::Optimistic
  def locking_enabled?(); end
end

module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Locking::Pessimistic
  def lock!(lock=T.unsafe(nil)); end
end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::LogSubscriber
  def odd?(); end

  def render_bind(column, value); end

  def sql(event); end
  IGNORE_PAYLOAD_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::LogSubscriber
  def self.reset_runtime(); end

  def self.runtime(); end

  def self.runtime=(value); end
end

module ActiveRecord::MassAssignmentSecurity
end

module ActiveRecord::MassAssignmentSecurity::AttributeAssignment
  def assign_attributes(new_attributes, options=T.unsafe(nil)); end

  def mass_assignment_options(); end

  def mass_assignment_role(); end
end

module ActiveRecord::MassAssignmentSecurity::AttributeAssignment
  extend ::ActiveSupport::Concern
end

module ActiveRecord::MassAssignmentSecurity::Core
end

module ActiveRecord::MassAssignmentSecurity::Core
end

module ActiveRecord::MassAssignmentSecurity::Inheritance
end

module ActiveRecord::MassAssignmentSecurity::Inheritance
  extend ::ActiveSupport::Concern
end

module ActiveRecord::MassAssignmentSecurity::NestedAttributes
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::MassAssignmentSecurity::NestedAttributes
  extend ::ActiveSupport::Concern
end

module ActiveRecord::MassAssignmentSecurity::Persistence
  def update(attributes, options=T.unsafe(nil)); end

  def update!(attributes, options=T.unsafe(nil)); end

  def update_attributes(attributes, options=T.unsafe(nil)); end

  def update_attributes!(attributes, options=T.unsafe(nil)); end
end

module ActiveRecord::MassAssignmentSecurity::Persistence
  extend ::ActiveSupport::Concern
end

module ActiveRecord::MassAssignmentSecurity::Validations
end

module ActiveRecord::MassAssignmentSecurity::Validations
  extend ::ActiveSupport::Concern
end

module ActiveRecord::MassAssignmentSecurity
end

class ActiveRecord::Migration
  def announce(message); end

  def connection(); end

  def copy(destination, sources, options=T.unsafe(nil)); end

  def disable_ddl_transaction(); end

  def down(); end

  def exec_migration(conn, direction); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def method_missing(method, *arguments, &block); end

  def migrate(direction); end

  def name(); end

  def name=(name); end

  def next_migration_number(number); end

  def proper_table_name(name, options=T.unsafe(nil)); end

  def reversible(); end

  def revert(*migration_classes); end

  def reverting?(); end

  def run(*migration_classes); end

  def say(message, subitem=T.unsafe(nil)); end

  def say_with_time(message); end

  def suppress_messages(); end

  def table_name_options(config=T.unsafe(nil)); end

  def up(); end

  def verbose(); end

  def verbose=(obj); end

  def version(); end

  def version=(version); end

  def write(text=T.unsafe(nil)); end
end

class ActiveRecord::Migration::CheckPending
  def call(env); end

  def initialize(app); end
end

class ActiveRecord::Migration::CheckPending
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  include ::Paperclip::Schema::CommandRecorder
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def respond_to?(*args); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

module ActiveRecord::Migration::JoinTable
end

module ActiveRecord::Migration::JoinTable
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def down(); end

  def up(); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
end

class ActiveRecord::Migration
  def self.check_pending!(connection=T.unsafe(nil)); end

  def self.delegate(); end

  def self.delegate=(delegate); end

  def self.disable_ddl_transaction(); end

  def self.disable_ddl_transaction!(); end

  def self.disable_ddl_transaction=(disable_ddl_transaction); end

  def self.load_schema_if_pending!(); end

  def self.maintain_test_schema!(); end

  def self.method_missing(name, *args, &block); end

  def self.migrate(direction); end

  def self.verbose(); end

  def self.verbose=(obj); end
end

class ActiveRecord::MigrationError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::MigrationProxy
  def announce(*args, &block); end

  def basename(); end

  def disable_ddl_transaction(*args, &block); end

  def initialize(name, version, filename, scope); end

  def migrate(*args, &block); end

  def mtime(); end

  def write(*args, &block); end
end

class ActiveRecord::MigrationProxy
end

class ActiveRecord::Migrator
  def current(); end

  def current_migration(); end

  def current_version(); end

  def initialize(direction, migrations, target_version=T.unsafe(nil)); end

  def migrate(); end

  def migrated(); end

  def migrations(); end

  def pending_migrations(); end

  def run(); end

  def runnable(); end
end

class ActiveRecord::Migrator
  def self.any_migrations?(); end

  def self.current_version(connection=T.unsafe(nil)); end

  def self.down(migrations_paths, target_version=T.unsafe(nil), &block); end

  def self.forward(migrations_paths, steps=T.unsafe(nil)); end

  def self.get_all_versions(connection=T.unsafe(nil)); end

  def self.last_migration(); end

  def self.last_version(); end

  def self.migrate(migrations_paths, target_version=T.unsafe(nil), &block); end

  def self.migration_files(paths); end

  def self.migrations(paths); end

  def self.migrations_path(); end

  def self.migrations_path=(migrations_path); end

  def self.migrations_paths(); end

  def self.migrations_paths=(migrations_paths); end

  def self.migrations_status(paths); end

  def self.needs_migration?(connection=T.unsafe(nil)); end

  def self.open(migrations_paths); end

  def self.parse_migration_filename(filename); end

  def self.rollback(migrations_paths, steps=T.unsafe(nil)); end

  def self.run(direction, migrations_paths, target_version); end

  def self.schema_migrations_table_name(); end

  def self.up(migrations_paths, target_version=T.unsafe(nil)); end
end

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  def self.derive_join_table_name(first_table, second_table); end
end

class ActiveRecord::MultiparameterAssignmentErrors
  def errors(); end

  def initialize(errors); end
end

module ActiveRecord::NestedAttributes
  def _destroy(); end
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
end

module ActiveRecord::NoTouching
  def no_touching?(); end

  def touch(*_); end
end

module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern
  def self.applied_to?(klass); end

  def self.apply_to(klass); end
end

class ActiveRecord::NullMigration
  def initialize(); end
end

class ActiveRecord::NullMigration
end

module ActiveRecord::NullRelation
  def any?(); end

  def average(*_); end

  def calculate(operation, _column_name, _options=T.unsafe(nil)); end

  def count(*_); end

  def delete(_id_or_array); end

  def delete_all(_conditions=T.unsafe(nil)); end

  def empty?(); end

  def exec_queries(); end

  def exists?(_id=T.unsafe(nil)); end

  def many?(); end

  def maximum(*_); end

  def minimum(*_); end

  def or(other); end

  def pluck(*column_names); end

  def size(); end

  def sum(*_); end

  def to_sql(); end

  def update_all(_updates, _conditions=T.unsafe(nil), _options=T.unsafe(nil)); end
end

module ActiveRecord::NullRelation
end

class ActiveRecord::PendingMigrationError
  def initialize(); end
end

module ActiveRecord::Persistence
  def delete(); end

  def destroy(); end

  def destroy!(); end
end

module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern
end

class ActiveRecord::PredicateBuilder
  BASIC_OBJECT_HANDLER = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
end

class ActiveRecord::PredicateBuilder
  def self.build_from_hash(klass, attributes, default_table); end

  def self.can_be_bound?(value); end

  def self.convert_value_to_association_ids(value, primary_key); end

  def self.expand(klass, table, column, value); end

  def self.polymorphic_base_class_from_value(value); end

  def self.references(attributes); end

  def self.register_handler(klass, handler); end

  def self.resolve_column_aliases(klass, hash); end
end

class ActiveRecord::QueryCache
  def call(env); end

  def initialize(app); end
end

module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end

  def uncached(&block); end
end

module ActiveRecord::QueryCache::ClassMethods
end

class ActiveRecord::QueryCache
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  def _select!(*fields); end

  def arel(); end

  def bind(value); end

  def bind!(value); end

  def bind_values(); end

  def bind_values=(values); end

  def check_cached_relation(); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(values); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(values); end

  def extensions(); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_value(); end

  def from_value=(value); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(values); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def having_values(); end

  def having_values=(values); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(values); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(values); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(values); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(values); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(values); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def sanitize_forbidden_attributes(attributes); end

  def select(*fields); end

  def select_values(); end

  def select_values=(values); end

  def uniq(value=T.unsafe(nil)); end

  def uniq!(value=T.unsafe(nil)); end

  def uniq_value(); end

  def uniq_value=(value); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(values); end

  def where(opts=T.unsafe(nil), *rest); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end

  def where_values(); end

  def where_values=(values); end
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::QueryMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Querying
  def any?(*args, &block); end

  def average(*args, &block); end

  def calculate(*args, &block); end

  def count(*args, &block); end

  def count_by_sql(sql); end

  def create_with(*args, &block); end

  def delete(*args, &block); end

  def delete_all(*args, &block); end

  def destroy(*args, &block); end

  def destroy_all(*args, &block); end

  def distinct(*args, &block); end

  def eager_load(*args, &block); end

  def except(*args, &block); end

  def exists?(*args, &block); end

  def fifth(*args, &block); end

  def fifth!(*args, &block); end

  def find(*args, &block); end

  def find_by(*args, &block); end

  def find_by!(*args, &block); end

  def find_by_sql(sql, binds=T.unsafe(nil)); end

  def find_each(*args, &block); end

  def find_in_batches(*args, &block); end

  def find_or_create_by(*args, &block); end

  def find_or_create_by!(*args, &block); end

  def find_or_initialize_by(*args, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def first_or_create(*args, &block); end

  def first_or_create!(*args, &block); end

  def first_or_initialize(*args, &block); end

  def forty_two(*args, &block); end

  def forty_two!(*args, &block); end

  def fourth(*args, &block); end

  def fourth!(*args, &block); end

  def from(*args, &block); end

  def group(*args, &block); end

  def having(*args, &block); end

  def ids(*args, &block); end

  def includes(*args, &block); end

  def joins(*args, &block); end

  def last(*args, &block); end

  def last!(*args, &block); end

  def limit(*args, &block); end

  def lock(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def minimum(*args, &block); end

  def none(*args, &block); end

  def offset(*args, &block); end

  def or(*args, &block); end

  def order(*args, &block); end

  def pluck(*args, &block); end

  def preload(*args, &block); end

  def readonly(*args, &block); end

  def references(*args, &block); end

  def reorder(*args, &block); end

  def rewhere(*args, &block); end

  def second(*args, &block); end

  def second!(*args, &block); end

  def select(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take!(*args, &block); end

  def third(*args, &block); end

  def third!(*args, &block); end

  def uniq(*args, &block); end

  def unscope(*args, &block); end

  def update(*args, &block); end

  def update_all(*args, &block); end

  def where(*args, &block); end
end

module ActiveRecord::Querying
end

class ActiveRecord::Railtie
end

class ActiveRecord::Railtie
end

module ActiveRecord::Railties
end

module ActiveRecord::Railties::ControllerRuntime
  def append_info_to_payload(payload); end

  def cleanup_view_runtime(); end

  def db_runtime(); end

  def db_runtime=(db_runtime); end

  def process_action(action, *args); end
end

module ActiveRecord::Railties::ControllerRuntime
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Railties
end

class ActiveRecord::ReadOnlyAssociation
  def initialize(reflection); end
end

class ActiveRecord::ReadOnlyAssociation
end

module ActiveRecord::ReadonlyAttributes
end

module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::RecordInvalid
  def initialize(record); end

  def record(); end
end

class ActiveRecord::RecordNotDestroyed
  def initialize(message, record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotSaved
  def initialize(message, record=T.unsafe(nil)); end

  def record(); end
end

module ActiveRecord::Reflection
end

module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  def self.add_aggregate_reflection(ar, name, reflection); end

  def self.add_reflection(ar, name, reflection); end

  def self.create(macro, name, scope, options, ar); end
end

class ActiveRecord::Relation
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  include ::AlphabeticalPaginate::ControllerHelpers
  include ::WillPaginate::ActiveRecord::Pagination
  include ::SorbetRails::CustomFinderMethods
  def ==(other); end

  def _update_record(values, id, id_was); end

  def build(*args, &block); end

  def create(*args, &block); end

  def create!(*args, &block); end

  def delete(id_or_array); end

  def destroy(id); end

  def destroy_all(conditions=T.unsafe(nil)); end

  def eager_loading?(); end

  def encode_with(coder); end

  def explain(); end

  def find_or_create_by(attributes, options=T.unsafe(nil), &block); end

  def find_or_create_by!(attributes, options=T.unsafe(nil), &block); end

  def find_or_initialize_by(attributes, options=T.unsafe(nil), &block); end

  def first_or_create(attributes=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def first_or_create!(attributes=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def first_or_initialize(attributes=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def initialize(klass, table, values=T.unsafe(nil)); end

  def insert(values); end

  def joined_includes_values(); end

  def klass(); end

  def load(); end

  def loaded(); end

  def loaded?(); end

  def model(); end

  def new(*args, &block); end

  def reload(); end

  def reset(); end

  def scope_for_create(); end

  def scoping(); end

  def substitute_values(values); end

  def table(); end

  def to_a(); end

  def to_sql(); end

  def update(id, attributes); end

  def update_all(updates); end

  def values(); end

  def where_values_hash(relation_table_name=T.unsafe(nil)); end
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation
  extend ::AlphabeticalPaginate::ControllerHelpers
end

class ActiveRecord::Result
  include ::Enumerable
  def [](idx); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def collect!(); end

  def column_types(); end

  def columns(); end

  def each(&blk); end

  def empty?(); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(); end

  def length(); end

  def map!(); end

  def rows(); end

  def to_ary(); end

  def to_hash(); end
  IDENTITY_TYPE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::RuntimeRegistry
  def connection_handler(); end

  def connection_handler=(connection_handler); end

  def connection_id(); end

  def connection_id=(connection_id); end

  def sql_runtime(); end

  def sql_runtime=(sql_runtime); end
end

class ActiveRecord::RuntimeRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.connection_handler(); end

  def self.connection_handler=(x); end

  def self.connection_id(); end

  def self.connection_id=(x); end

  def self.sql_runtime(); end

  def self.sql_runtime=(x); end
end

module ActiveRecord::Sanitization
  def quoted_id(); end
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Schema
  def define(info, &block); end

  def migrations_paths(); end
end

class ActiveRecord::SchemaDumper
  def dump(stream); end

  def ignore_tables(); end

  def ignore_tables=(obj); end

  def initialize(connection, options=T.unsafe(nil)); end
end

class ActiveRecord::SchemaDumper
  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.ignore_tables(); end

  def self.ignore_tables=(obj); end
end

class ActiveRecord::SchemaMigration
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class ActiveRecord::SchemaMigration::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class ActiveRecord::SchemaMigration::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

class ActiveRecord::SchemaMigration
  def self.create_table(limit=T.unsafe(nil)); end

  def self.drop_table(); end

  def self.index_name(); end

  def self.normalize_migration_number(number); end

  def self.normalized_versions(); end
end

module ActiveRecord::Scoping
  def initialize_internals_callback(); end

  def populate_with_current_scope_attributes(); end
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::Serialization
  def serializable_hash(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil), &block); end
end

module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::SpawnMethods
  def except(*skips); end

  def merge(other); end

  def merge!(other); end

  def only(*onlies); end

  def spawn(); end
end

module ActiveRecord::SpawnMethods
end

class ActiveRecord::StaleObjectError
  def attempted_action(); end

  def initialize(record, attempted_action); end

  def record(); end
end

class ActiveRecord::StatementCache
  def bind_map(); end

  def call(params, klass, connection); end

  def execute(params, klass, connection); end

  def initialize(query_builder, bind_map); end

  def query_builder(); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bind_values); end
end

class ActiveRecord::StatementCache::BindMap
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::Params
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQuery
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Query
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache
  def self.create(connection, block=T.unsafe(nil)); end

  def self.partial_query(visitor, ast, collector); end

  def self.query(visitor, ast); end
end

class ActiveRecord::StatementInvalid
  def initialize(message, original_exception=T.unsafe(nil)); end

  def original_exception(); end
end

module ActiveRecord::Store
  def read_store_attribute(store_attribute, key); end

  def write_store_attribute(store_attribute, key, value); end
end

module ActiveRecord::Store
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Tasks
end

class ActiveRecord::Tasks::DatabaseAlreadyExists
end

class ActiveRecord::Tasks::DatabaseAlreadyExists
end

class ActiveRecord::Tasks::DatabaseNotSupported
end

class ActiveRecord::Tasks::DatabaseNotSupported
end

module ActiveRecord::Tasks::DatabaseTasks
  def charset(*arguments); end

  def charset_current(environment=T.unsafe(nil)); end

  def check_schema_file(filename); end

  def collation(*arguments); end

  def collation_current(environment=T.unsafe(nil)); end

  def create(*arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil)); end

  def current_config(options=T.unsafe(nil)); end

  def current_config=(current_config); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(*arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def load_schema(format=T.unsafe(nil), file=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_schema_current_if_exists(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_schema_for(configuration, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_file(format=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def structure_dump(*arguments); end

  def structure_load(*arguments); end
  LOCAL_HOSTS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename); end

  def structure_load(filename); end
  ACCESS_DENIED_ERROR = ::T.let(nil, ::T.untyped)
  DEFAULT_CHARSET = ::T.let(nil, ::T.untyped)
  DEFAULT_COLLATION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::NullDBDatabaseTasks
  def clear_active_connections!(); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::NullDBDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename); end

  def structure_load(filename); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename); end

  def structure_load(filename); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Timestamp
end

module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Transactions
  def add_to_transaction(); end

  def clear_transaction_record_state(); end

  def committed!(should_run_callbacks=T.unsafe(nil)); end

  def destroy(); end

  def force_clear_transaction_record_state(); end

  def remember_transaction_record_state(); end

  def restore_transaction_record_state(force=T.unsafe(nil)); end

  def rollback_active_record_state!(); end

  def rolledback!(force_restore_state=T.unsafe(nil), should_run_callbacks=T.unsafe(nil)); end

  def save(*_); end

  def save!(*_); end

  def touch(*_); end

  def transaction(options=T.unsafe(nil), &block); end

  def transaction_include_any_action?(actions); end

  def transaction_record_state(state); end

  def with_transaction_returning_status(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  CALLBACK_WARN_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Translation
  include ::ActiveModel::Translation
  include ::ActiveModel::Naming
  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveRecord::Translation
end

class ActiveRecord::Type::BigInteger
end

class ActiveRecord::Type::BigInteger
end

class ActiveRecord::Type::Binary
  def changed_in_place?(raw_old_value, value); end
end

class ActiveRecord::Type::Binary::Data
  def ==(other); end

  def hex(); end

  def initialize(value); end

  def to_str(); end
end

class ActiveRecord::Type::Binary::Data
end

class ActiveRecord::Type::Binary
end

class ActiveRecord::Type::Date
end

class ActiveRecord::Type::Date
end

class ActiveRecord::Type::DateTime
  include ::ActiveRecord::Type::TimeValue
  def has_precision?(); end
end

class ActiveRecord::Type::DateTime
end

class ActiveRecord::Type::Decimal
  include ::ActiveRecord::Type::Numeric
end

class ActiveRecord::Type::Decimal
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecimalWithoutScale
end

module ActiveRecord::Type::Decorator
  def encode_with(coder); end

  def init_with(coder); end
end

module ActiveRecord::Type::Decorator
end

class ActiveRecord::Type::Float
  include ::ActiveRecord::Type::Numeric
end

class ActiveRecord::Type::Float
end

class ActiveRecord::Type::HashLookupTypeMap
  def alias_type(type, alias_type); end

  def key?(key); end

  def keys(); end
end

class ActiveRecord::Type::HashLookupTypeMap
end

class ActiveRecord::Type::Integer
  include ::ActiveRecord::Type::Numeric
  def initialize(*_); end

  def range(); end
end

class ActiveRecord::Type::Integer
end

module ActiveRecord::Type::Mutable
  def changed_in_place?(raw_old_value, new_value); end

  def type_cast_from_user(value); end
end

module ActiveRecord::Type::Mutable
end

module ActiveRecord::Type::Numeric
  def changed?(old_value, _new_value, new_value_before_type_cast); end

  def number?(); end

  def type_cast(value); end
end

module ActiveRecord::Type::Numeric
end

class ActiveRecord::Type::Serialized
  include ::ActiveRecord::Type::Mutable
  include ::ActiveRecord::Type::Decorator
  def accessor(); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def initialize(subtype, coder); end

  def inspect(); end

  def subtype(); end

  def type_cast_for_database(value); end

  def type_cast_from_database(value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Type::Serialized
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Time
  include ::ActiveRecord::Type::TimeValue
end

class ActiveRecord::Type::Time
end

module ActiveRecord::Type::TimeValue
  def klass(); end

  def type_cast_for_schema(value); end
end

module ActiveRecord::Type::TimeValue
end

class ActiveRecord::Type::TypeMap
  def alias_type(key, target_key); end

  def clear(); end

  def fetch(lookup_key, *args, &block); end

  def lookup(lookup_key, *args); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::TypeMap
end

class ActiveRecord::Type::UnsignedInteger
end

class ActiveRecord::Type::UnsignedInteger
end

class ActiveRecord::UnknownMigrationVersionError
  def initialize(version); end
end

class ActiveRecord::UnknownPrimaryKey
  def initialize(model, description=T.unsafe(nil)); end

  def model(); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
end

module ActiveRecord::Validations
  def perform_validations(options=T.unsafe(nil)); end

  def raise_record_invalid(); end

  def save(options=T.unsafe(nil)); end

  def save!(options=T.unsafe(nil)); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end

  def validate!(context=T.unsafe(nil)); end
end

module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
end

class ActiveRecord::XmlSerializer
end

class ActiveRecord::XmlSerializer::Attribute
end

class ActiveRecord::XmlSerializer::Attribute
end

class ActiveRecord::XmlSerializer
end

module ActiveRecord
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

class ActiveRecordOverrides
  include ::Singleton
  def enum_calls(); end

  def get_enum_call(klass, enum_sym); end

  def store_enum_call(klass, kwargs); end
end

class ActiveRecordOverrides
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(obj); end
end

module ActiveSupport::Autoload
  def autoload(const_name, path=T.unsafe(nil)); end

  def autoload_at(path); end

  def autoload_under(path); end

  def autoloads(); end

  def eager_autoload(); end

  def eager_load!(); end
end

module ActiveSupport::Autoload
  def self.extended(base); end
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
end

class ActiveSupport::BacktraceCleaner
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::Benchmarkable
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, options=T.unsafe(nil)); end

  def size(); end

  def value(); end
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
end

class ActiveSupport::Cache::FileStore
  def cache_path(); end

  def initialize(cache_path, options=T.unsafe(nil)); end
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
end

class ActiveSupport::Cache::MemoryStore
  def cached_size(key, entry); end

  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::MemoryStore
end

class ActiveSupport::Cache::NullStore
end

class ActiveSupport::Cache::NullStore
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_entry(key, options); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil)); end

  def fetch_multi(*names); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key_matcher(pattern, options); end

  def logger(); end

  def logger=(obj); end

  def mute(); end

  def options(); end

  def read(name, options=T.unsafe(nil)); end

  def read_entry(key, options); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_entry(key, entry, options); end
end

class ActiveSupport::Cache::Store
  def self.instrument(); end

  def self.instrument=(boolean); end

  def self.logger(); end

  def self.logger=(obj); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_entry(key, options); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def read_entry(key, options); end

  def set_cache_value(value, name, amount, options); end

  def with_local_cache(); end

  def write_entry(key, entry, options); end
end

class ActiveSupport::Cache::Strategy::LocalCache::LocalCacheRegistry
  def cache_for(local_cache_key); end

  def set_cache_for(local_cache_key, value); end
end

class ActiveSupport::Cache::Strategy::LocalCache::LocalCacheRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.cache_for(l); end

  def self.set_cache_for(l, v); end
end

class ActiveSupport::Cache::Strategy::LocalCache::LocalStore
  def initialize(); end

  def synchronize(); end

  def write_entry(key, value, options); end
end

class ActiveSupport::Cache::Strategy::LocalCache::LocalStore
end

class ActiveSupport::Cache::Strategy::LocalCache::Middleware
  def call(env); end

  def initialize(name, local_cache_key); end

  def local_cache_key(); end

  def name(); end

  def new(app); end
end

class ActiveSupport::Cache::Strategy::LocalCache::Middleware
end

module ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.lookup_store(*store_option); end
end

class ActiveSupport::CachingKeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(key_generator); end
end

class ActiveSupport::CachingKeyGenerator
end

module ActiveSupport::Callbacks
  def run_callbacks(kind, &block); end
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Concern
  def append_features(base); end

  def class_methods(&class_methods_module_definition); end

  def included(base=T.unsafe(nil), &block); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
  def initialize(); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
end

module ActiveSupport::Concern
  def self.extended(base); end
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Dependencies
  def autoload_module!(into, const_name, qualified_name, path_suffix); end

  def autoload_once_paths(); end

  def autoload_once_paths=(obj); end

  def autoload_paths(); end

  def autoload_paths=(obj); end

  def autoloadable_module?(path_suffix); end

  def autoloaded?(desc); end

  def autoloaded_constants(); end

  def autoloaded_constants=(obj); end

  def clear(); end

  def constant_watch_stack(); end

  def constant_watch_stack=(obj); end

  def constantize(name); end

  def depend_on(file_name, message=T.unsafe(nil)); end

  def explicitly_unloadable_constants(); end

  def explicitly_unloadable_constants=(obj); end

  def history(); end

  def history=(obj); end

  def hook!(); end

  def load?(); end

  def load_file(path, const_paths=T.unsafe(nil)); end

  def load_missing_constant(from_mod, const_name); end

  def load_once_path?(path); end

  def loadable_constants_for_path(path, bases=T.unsafe(nil)); end

  def loaded(); end

  def loaded=(obj); end

  def loading(); end

  def loading=(obj); end

  def log(msg); end

  def log_activity(); end

  def log_activity=(obj); end

  def log_activity?(); end

  def log_call(*args); end

  def logger(); end

  def logger=(obj); end

  def mark_for_unload(const_desc); end

  def mechanism(); end

  def mechanism=(obj); end

  def new_constants_in(*descs); end

  def qualified_const_defined?(path); end

  def qualified_name_for(mod, name); end

  def reference(klass); end

  def remove_constant(const); end

  def remove_unloadable_constants!(); end

  def require_or_load(file_name, const_path=T.unsafe(nil)); end

  def safe_constantize(name); end

  def search_for_file(path_suffix); end

  def to_constant_name(desc); end

  def unhook!(); end

  def warnings_on_first_load(); end

  def warnings_on_first_load=(obj); end

  def will_unload?(const_desc); end
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies::Blamable
  def blame_file!(file); end

  def blamed_files(); end

  def copy_blame!(exc); end

  def describe_blame(); end
end

module ActiveSupport::Dependencies::Blamable
end

class ActiveSupport::Dependencies::ClassCache
  def [](key); end

  def clear!(); end

  def empty?(); end

  def get(key); end

  def key?(key); end

  def safe_get(key); end

  def store(klass); end
end

class ActiveSupport::Dependencies::ClassCache
end

module ActiveSupport::Dependencies::Loadable
  def load_dependency(file); end

  def require_dependency(file_name, message=T.unsafe(nil)); end

  def require_or_load(file_name); end

  def unloadable(const_desc); end
end

module ActiveSupport::Dependencies::Loadable
  def self.exclude_from(base); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def const_missing(const_name); end

  def guess_for_anonymous(const_name); end

  def unloadable(const_desc=T.unsafe(nil)); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def self.append_features(base); end

  def self.exclude_from(base); end
end

class ActiveSupport::Dependencies::WatchStack
  include ::Enumerable
  def each(&block); end

  def new_constants(); end

  def watch_namespaces(namespaces); end

  def watching?(); end
end

class ActiveSupport::Dependencies::WatchStack
end

module ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies
end

class ActiveSupport::Deprecation
  include ::Singleton
  include ::ActiveSupport::Deprecation::InstanceDelegator
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end
end

module ActiveSupport::Deprecation::Behavior
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def initialize(old_const, new_const, deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, &block); end
end

module ActiveSupport::Deprecation::InstanceDelegator
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end

  def method_added(method_name); end
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
end

module ActiveSupport::Deprecation::InstanceDelegator
  def self.included(base); end
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
end

module ActiveSupport::Deprecation::Reporting
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::Reporting
end

class ActiveSupport::Deprecation
  extend ::Singleton::SingletonClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def self.behavior(*args, &block); end

  def self.behavior=(arg); end

  def self.debug(*args, &block); end

  def self.debug=(arg); end

  def self.deprecate_methods(*args, &block); end

  def self.deprecation_horizon(*args, &block); end

  def self.deprecation_horizon=(arg); end

  def self.deprecation_warning(*args, &block); end

  def self.gem_name(*args, &block); end

  def self.gem_name=(arg); end

  def self.initialize(*args, &block); end

  def self.instance(); end

  def self.silence(*args, &block); end

  def self.silenced(*args, &block); end

  def self.silenced=(arg); end

  def self.warn(*args, &block); end
end

class ActiveSupport::DeprecationException
end

class ActiveSupport::DeprecationException
end

module ActiveSupport::DescendantsTracker
  def descendants(); end

  def direct_descendants(); end

  def inherited(base); end
end

module ActiveSupport::DescendantsTracker
  def self.clear(); end

  def self.descendants(klass); end

  def self.direct_descendants(klass); end

  def self.store_inherited(klass, descendant); end
end

class ActiveSupport::Duration
  def -@(); end

  def initialize(value, parts); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def parts(); end

  def parts=(parts); end

  def since(time=T.unsafe(nil)); end

  def sum(sign, time=T.unsafe(nil)); end

  def until(time=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

class ActiveSupport::Duration
  def self.===(other); end
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::FileUpdateChecker
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

class ActiveSupport::HashWithIndifferentAccess
  def []=(key, value); end

  def convert_key(key); end

  def convert_value(value, options=T.unsafe(nil)); end

  def default(key=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, *extras); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash, &block); end

  def merge!(other_hash); end

  def regular_update(*_); end

  def regular_writer(_, _1); end

  def reject(*args, &block); end

  def replace(other_hash); end

  def select(*args, &block); end

  def set_defaults(target); end

  def store(key, value); end

  def transform_values(*args, &block); end

  def update(other_hash); end

  def values_at(*indices); end
end

class ActiveSupport::HashWithIndifferentAccess
  def self.[](*args); end

  def self.new_from_hash_copying_default(hash); end
end

class ActiveSupport::Inflector::Inflections
  def acronym(word); end

  def acronym_regex(); end

  def acronyms(); end

  def clear(scope=T.unsafe(nil)); end

  def human(rule, replacement); end

  def humans(); end

  def irregular(singular, plural); end

  def plural(rule, replacement); end

  def plurals(); end

  def singular(rule, replacement); end

  def singulars(); end

  def uncountable(*words); end

  def uncountables(); end
end

class ActiveSupport::Inflector::Inflections
  def self.instance(locale=T.unsafe(nil)); end
end

module ActiveSupport::Inflector
  extend ::ActiveSupport::Inflector
end

class ActiveSupport::InheritableOptions
  def inheritable_copy(); end

  def initialize(parent=T.unsafe(nil)); end
end

class ActiveSupport::InheritableOptions
end

module ActiveSupport::JSON
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.const_missing(name); end

  def self.encode_big_decimal_as_string(); end

  def self.encode_big_decimal_as_string=(as_string); end

  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json, options=T.unsafe(nil)); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
end

class ActiveSupport::LegacyKeyGenerator
  def generate_key(salt); end

  def initialize(secret); end
  SECRET_MIN_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LegacyKeyGenerator
end

class ActiveSupport::LogSubscriber
  def color(text, color, bold=T.unsafe(nil)); end

  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.colorize_logging(); end

  def self.colorize_logging=(obj); end

  def self.flush_all!(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(logger); end
end

class ActiveSupport::Logger
  include ::ActiveSupport::LoggerThreadSafeLevel
  include ::LoggerSilence
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def initialize(*args); end

  def silencer(); end

  def silencer=(obj); end

  def unknown?(); end
end

class ActiveSupport::Logger::SimpleFormatter
  def call(severity, timestamp, progname, msg); end
end

class ActiveSupport::Logger::SimpleFormatter
end

class ActiveSupport::Logger
  def self.broadcast(logger); end

  def self.logger_outputs_to?(logger, *sources); end

  def self.silencer(); end

  def self.silencer=(obj); end
end

module ActiveSupport::LoggerThreadSafeLevel
  def after_initialize(); end

  def level(); end

  def local_level(); end

  def local_level=(level); end

  def local_log_id(); end
end

module ActiveSupport::LoggerThreadSafeLevel
  extend ::ActiveSupport::Concern
end

class ActiveSupport::MessageEncryptor
  def decrypt_and_verify(value); end

  def encrypt_and_sign(value); end

  def initialize(secret, *signature_key_or_options); end
  DEFAULT_CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end

  def self.load(value); end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
  def self.key_len(cipher=T.unsafe(nil)); end
end

class ActiveSupport::MessageVerifier
  def generate(value); end

  def initialize(secret, options=T.unsafe(nil)); end

  def verify(signed_message); end
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

module ActiveSupport::Multibyte
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*args, &block); end

  def acts_like_string?(*args, &block); end

  def capitalize(); end

  def capitalize!(*args); end

  def chars(string); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def swapcase(); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def translate_offset(byte_offset); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
  def self.consumes?(string); end
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def downcase(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def pack_graphemes(unpacked); end

  def reorder_characters(codepoints); end

  def swapcase(string); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def unpack_graphemes(string); end

  def upcase(string); end
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class ActiveSupport::Multibyte::Unicode::Codepoint
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
  def self.codepoints_to_pattern(array_of_codepoints); end
end

module ActiveSupport::Multibyte
  def self.proxy_class(); end

  def self.proxy_class=(klass); end
end

module ActiveSupport::Notifications
end

class ActiveSupport::Notifications::Event
  def <<(event); end

  def children(); end

  def duration(); end

  def end(); end

  def end=(_); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def parent_of?(event); end

  def payload(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Fanout
  include ::Mutex_m
  def finish(name, id, payload); end

  def initialize(); end

  def listeners_for(name); end

  def listening?(name); end

  def lock(); end

  def locked?(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), block=T.unsafe(nil)); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def finish(name, id, payload); end

  def initialize(delegate); end

  def matches?(_); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end

  def initialize(pattern, delegate); end

  def matches?(name); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  def self.new(pattern, listener); end
end

class ActiveSupport::Notifications::Fanout
end

class ActiveSupport::Notifications::InstrumentationRegistry
  def instrumenter_for(notifier); end
end

class ActiveSupport::Notifications::InstrumentationRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveSupport::Notifications::Instrumenter
  def finish(name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  def self.instrument(name, payload=T.unsafe(nil)); end

  def self.instrumenter(); end

  def self.notifier(); end

  def self.notifier=(notifier); end

  def self.publish(name, *args); end

  def self.subscribe(*args, &block); end

  def self.subscribed(callback, *args, &block); end

  def self.unsubscribe(subscriber_or_name); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(namespace); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(validate_float); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(val); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(val); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DELIMITED_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::NumberHelper
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedHash
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(_); end

  def method_missing(name, *args); end
end

class ActiveSupport::OrderedOptions
end

module ActiveSupport::PerThreadRegistry
  def instance(); end

  def method_missing(name, *args, &block); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
end

class ActiveSupport::Railtie
end

class ActiveSupport::Railtie
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def prepend!(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
end

module ActiveSupport::SecurityUtils
end

module ActiveSupport::SecurityUtils
  def self.secure_compare(a, b); end

  def self.variable_size_secure_compare(a, b); end
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

class ActiveSupport::Subscriber
  def self.add_event_subscriber(event); end

  def self.attach_to(namespace, subscriber=T.unsafe(nil), notifier=T.unsafe(nil)); end

  def self.method_added(event); end

  def self.namespace(); end

  def self.notifier(); end

  def self.subscriber(); end

  def self.subscribers(); end
end

class ActiveSupport::SubscriberQueueRegistry
  def get_queue(queue_key); end
end

class ActiveSupport::SubscriberQueueRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*args, &block); end

  def flush(); end

  def pop_tags(*args, &block); end

  def push_tags(*args, &block); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
end

module ActiveSupport::TaggedLogging
  def self.new(logger); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Testing::SetupAndTeardown
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveRecord::TestFixtures
  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _setup_callbacks?(); end

  def _teardown_callbacks(); end

  def _teardown_callbacks?(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_nothing_raised(*args); end

  def assert_raise(*exp); end

  def config(); end

  def config=(config); end

  def config?(); end

  def fixture_class_names(); end

  def fixture_class_names=(fixture_class_names); end

  def fixture_class_names?(); end

  def fixture_path(); end

  def fixture_path?(); end

  def fixture_table_names(); end

  def fixture_table_names=(fixture_table_names); end

  def fixture_table_names?(); end

  def method_name(); end

  def pre_loaded_fixtures(); end

  def pre_loaded_fixtures=(pre_loaded_fixtures); end

  def pre_loaded_fixtures?(); end

  def use_instantiated_fixtures(); end

  def use_instantiated_fixtures=(use_instantiated_fixtures); end

  def use_instantiated_fixtures?(); end

  def use_transactional_fixtures(); end

  def use_transactional_fixtures=(use_transactional_fixtures); end

  def use_transactional_fixtures?(); end
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveSupport::Testing::Declarative
  def self._setup_callbacks(); end

  def self._setup_callbacks=(val); end

  def self._setup_callbacks?(); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(val); end

  def self._teardown_callbacks?(); end

  def self.config(); end

  def self.config=(val); end

  def self.config?(); end

  def self.fixture_class_names(); end

  def self.fixture_class_names=(val); end

  def self.fixture_class_names?(); end

  def self.fixture_path(); end

  def self.fixture_path=(val); end

  def self.fixture_path?(); end

  def self.fixture_table_names(); end

  def self.fixture_table_names=(val); end

  def self.fixture_table_names?(); end

  def self.my_tests_are_order_dependent!(); end

  def self.pre_loaded_fixtures(); end

  def self.pre_loaded_fixtures=(val); end

  def self.pre_loaded_fixtures?(); end

  def self.test_order=(new_order); end

  def self.use_instantiated_fixtures(); end

  def self.use_instantiated_fixtures=(val); end

  def self.use_instantiated_fixtures?(); end

  def self.use_transactional_fixtures(); end

  def self.use_transactional_fixtures=(val); end

  def self.use_transactional_fixtures?(); end
end

module ActiveSupport::Testing
end

module ActiveSupport::Testing::Assertions
  def assert_difference(expression, difference=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::ConstantLookup
end

module ActiveSupport::Testing::ConstantLookup
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Declarative
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), &block); end

  def assert_not_deprecated(&block); end

  def collect_deprecations(); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::Isolation
  include ::ActiveSupport::Testing::Isolation::Forking
  def _run_class_setup(); end

  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Forking
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
end

module ActiveSupport::Testing::Isolation
  def self.forking_env?(); end

  def self.included(klass); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  extend ::ActiveSupport::Concern
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::Testing::SimpleStubs
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TimeHelpers
  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end
end

module ActiveSupport::Testing::TimeHelpers
end

module ActiveSupport::Testing
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable
  def acts_like_time?(); end

  def comparable_time(); end

  def encode_with(coder); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmt?(); end

  def gmt_offset(); end

  def gmtime(); end

  def gmtoff(); end

  def in(other); end

  def init_with(coder); end

  def initialize(utc_time, time_zone, local_time=T.unsafe(nil), period=T.unsafe(nil)); end

  def is_a?(klass); end

  def isdst(); end

  def iso8601(fraction_digits=T.unsafe(nil)); end

  def kind_of?(klass); end

  def marshal_dump(); end

  def marshal_load(variables); end

  def method_missing(sym, *args, &block); end

  def respond_to?(sym, include_priv=T.unsafe(nil)); end

  def rfc822(); end

  def since(other); end

  def time_zone(); end

  def to_date(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def tv_sec(); end
end

class ActiveSupport::TimeZone
  include ::Comparable
  def =~(re); end

  def at(secs); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(name, utc_offset=T.unsafe(nil), tzinfo=T.unsafe(nil)); end

  def local_to_utc(time, dst=T.unsafe(nil)); end

  def name(); end

  def parse(str, now=T.unsafe(nil)); end

  def period_for_local(time, dst=T.unsafe(nil)); end

  def period_for_utc(time); end

  def periods_for_local(time); end

  def tzinfo(); end

  def utc_offset(); end

  def utc_to_local(time); end
  MAPPING = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITHOUT_COLON = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITH_COLON = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  def self.create(*_); end

  def self.find_tzinfo(name); end

  def self.new(name); end

  def self.seconds_to_utc_offset(seconds, colon=T.unsafe(nil)); end

  def self.zones_map(); end
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
end

class ActiveSupport::XMLConverter
  def initialize(xml, disallowed_types=T.unsafe(nil)); end

  def to_h(); end
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter::DisallowedType
  def initialize(type); end
end

class ActiveSupport::XMLConverter::DisallowedType
end

class ActiveSupport::XMLConverter
end

module ActiveSupport::XmlMini
  def _dasherize(key); end

  def _parse_binary(bin, entity); end

  def _parse_file(file, entity); end

  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*args, &block); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport::XmlMini_REXML
  def parse(data); end
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  extend ::ActiveSupport::XmlMini_REXML
end

module ActiveSupport
  extend ::ActiveSupport::Autoload
  def self.encode_big_decimal_as_string(*args, &block); end

  def self.encode_big_decimal_as_string=(arg); end

  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(arg); end

  def self.execute_hook(base, options, block); end

  def self.gem_version(); end

  def self.json_encoder(*args, &block); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(obj); end

  def self.run_load_hooks(name, base=T.unsafe(nil)); end

  def self.test_order(); end

  def self.test_order=(new_order); end

  def self.time_precision(*args, &block); end

  def self.time_precision=(arg); end

  def self.to_time_preserves_timezone(); end

  def self.to_time_preserves_timezone=(value); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(arg); end

  def self.version(); end
end

module Addressable
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeOverflow
end

class Addressable::IDNA::PunycodeOverflow
end

module Addressable::IDNA
  def self.to_ascii(input); end

  def self.to_unicode(input); end

  def self.unicode_normalize_kc(input); end
end

class Addressable::Template
  def ==(template); end

  def eql?(template); end

  def expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def extract(uri, processor=T.unsafe(nil)); end

  def generate(params=T.unsafe(nil), recall=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(pattern); end

  def keys(); end

  def match(uri, processor=T.unsafe(nil)); end

  def named_captures(); end

  def names(); end

  def partial_expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def pattern(); end

  def source(); end

  def to_regexp(); end

  def variable_defaults(); end

  def variables(); end
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::MatchData
  def [](key, len=T.unsafe(nil)); end

  def captures(); end

  def initialize(uri, template, mapping); end

  def keys(); end

  def mapping(); end

  def names(); end

  def post_match(); end

  def pre_match(); end

  def string(); end

  def template(); end

  def to_a(); end

  def uri(); end

  def values(); end

  def values_at(*indexes); end

  def variables(); end
end

class Addressable::Template::MatchData
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template
end

class Addressable::URI
  def +(uri); end

  def ==(uri); end

  def ===(uri); end

  def absolute?(); end

  def authority(); end

  def authority=(new_authority); end

  def basename(); end

  def default_port(); end

  def defer_validation(); end

  def display_uri(); end

  def domain(); end

  def empty?(); end

  def eql?(uri); end

  def extname(); end

  def fragment(); end

  def fragment=(new_fragment); end

  def host(); end

  def host=(new_host); end

  def hostname(); end

  def hostname=(new_hostname); end

  def inferred_port(); end

  def initialize(options=T.unsafe(nil)); end

  def ip_based?(); end

  def join(uri); end

  def join!(uri); end

  def merge(hash); end

  def merge!(uri); end

  def normalize(); end

  def normalize!(); end

  def normalized_authority(); end

  def normalized_fragment(); end

  def normalized_host(); end

  def normalized_password(); end

  def normalized_path(); end

  def normalized_port(); end

  def normalized_query(*flags); end

  def normalized_scheme(); end

  def normalized_site(); end

  def normalized_user(); end

  def normalized_userinfo(); end

  def omit(*components); end

  def omit!(*components); end

  def origin(); end

  def origin=(new_origin); end

  def password(); end

  def password=(new_password); end

  def path(); end

  def path=(new_path); end

  def port(); end

  def port=(new_port); end

  def query(); end

  def query=(new_query); end

  def query_values(return_type=T.unsafe(nil)); end

  def query_values=(new_query_values); end

  def relative?(); end

  def remove_composite_values(); end

  def replace_self(uri); end

  def request_uri(); end

  def request_uri=(new_request_uri); end

  def route_from(uri); end

  def route_to(uri); end

  def scheme(); end

  def scheme=(new_scheme); end

  def site(); end

  def site=(new_site); end

  def split_path(path); end

  def tld(); end

  def tld=(new_tld); end

  def to_hash(); end

  def to_str(); end

  def user(); end

  def user=(new_user); end

  def userinfo(); end

  def userinfo=(new_userinfo); end

  def validate(); end
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI
  def self.convert_path(path); end

  def self.encode(uri, return_type=T.unsafe(nil)); end

  def self.encode_component(component, character_class=T.unsafe(nil), upcase_encoded=T.unsafe(nil)); end

  def self.escape(uri, return_type=T.unsafe(nil)); end

  def self.form_encode(form_values, sort=T.unsafe(nil)); end

  def self.form_unencode(encoded_value); end

  def self.heuristic_parse(uri, hints=T.unsafe(nil)); end

  def self.ip_based_schemes(); end

  def self.join(*uris); end

  def self.normalize_component(component, character_class=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.normalize_path(path); end

  def self.normalized_encode(uri, return_type=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.port_mapping(); end

  def self.unencode(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unencode_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
end

module Addressable
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class AllowableFieldType
  def autosave_associated_records_for_field_type(*args); end

  def autosave_associated_records_for_object_type(*args); end

  def autosave_associated_records_for_sample_type(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class AllowableFieldType::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class AllowableFieldType::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class AllowableFieldType::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module AllowableFieldType::GeneratedAssociationMethods
  def build_field_type(*args, &block); end

  def build_object_type(*args, &block); end

  def build_sample_type(*args, &block); end

  def create_field_type(*args, &block); end

  def create_field_type!(*args, &block); end

  def create_object_type(*args, &block); end

  def create_object_type!(*args, &block); end

  def create_sample_type(*args, &block); end

  def create_sample_type!(*args, &block); end
end

module AlphabeticalPaginate
  VERSION = ::T.let(nil, ::T.untyped)
end

module AlphabeticalPaginate::ControllerHelpers
  def alpha_paginate(current_field, params=T.unsafe(nil)); end
end

module AlphabeticalPaginate::ControllerHelpers
  def self.included(base); end
end

class AlphabeticalPaginate::Engine
end

class AlphabeticalPaginate::Engine
end

class AlphabeticalPaginate::Language
  def all_field(); end

  def code(); end

  def default_letter(); end

  def initialize(code); end

  def letters_range(); end

  def letters_regexp(); end

  def output_letter(l); end

  def russian?(); end

  def slugged_letters(); end

  def slugged_regexp(); end
  APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class AlphabeticalPaginate::Language
end

class AlphabeticalPaginate::Railtie
end

class AlphabeticalPaginate::Railtie
end

module AlphabeticalPaginate::ViewHelpers
  def alphabetical_paginate(options=T.unsafe(nil)); end
end

module AlphabeticalPaginate::ViewHelpers
end

module AlphabeticalPaginate
end

class Anemone::Engine
end

class Anemone::Railtie
end

class Anemone::Worker
  include ::Anemone::Worker::GeneratedAssociationMethods
end

class Anemone::Worker::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Anemone::Worker::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Anemone::Worker::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Anemone::Worker::GeneratedAssociationMethods
end

module Anemone::Worker::GeneratedAssociationMethods
end

module AngularRailsCsrf
end

module AngularRailsCsrf::Concern
  def set_xsrf_token_cookie(); end

  def verified_request?(); end
end

module AngularRailsCsrf::Concern
  extend ::ActiveSupport::Concern
end

class AngularRailsCsrf::Railtie
end

class AngularRailsCsrf::Railtie
end

module AngularRailsCsrf
end

class Announcement
  include ::Announcement::GeneratedAssociationMethods
end

class Announcement::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Announcement::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Announcement::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Announcement::GeneratedAssociationMethods
end

module Announcement::GeneratedAssociationMethods
end

class ApplicationJob
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAssociationMethods
end

class ApplicationRecord::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class ApplicationRecord::ActiveRecord_AssociationRelation
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
end

class ApplicationRecord::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class ApplicationRecord::ActiveRecord_Relation
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Arel::AliasPredication
  def as(other); end
end

module Arel::AliasPredication
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Attributes
end

class Arel::Attributes::Attribute
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
  def lower(); end
end

class Arel::Attributes::Attribute
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Float
end

class Arel::Attributes::Float
end

class Arel::Attributes::Integer
end

class Arel::Attributes::Integer
end

class Arel::Attributes::String
end

class Arel::Attributes::String
end

class Arel::Attributes::Time
end

class Arel::Attributes::Time
end

class Arel::Attributes::Undefined
end

class Arel::Attributes::Undefined
end

module Arel::Attributes
  def self.for(column); end
end

module Arel::Collectors
end

class Arel::Collectors::Bind
  def <<(str); end

  def add_bind(bind); end

  def compile(bvs); end

  def substitute_binds(bvs); end

  def value(); end
end

class Arel::Collectors::Bind
end

class Arel::Collectors::PlainString
  def <<(str); end

  def value(); end
end

class Arel::Collectors::PlainString
end

class Arel::Collectors::SQLString
  def add_bind(bind); end

  def compile(bvs); end

  def initialize(*_); end
end

class Arel::Collectors::SQLString
end

module Arel::Collectors
end

module Arel::Compatibility
end

class Arel::Compatibility::Wheres
  include ::Enumerable
  def each(&blk); end

  def initialize(engine, collection); end
end

module Arel::Compatibility::Wheres::Value
  def name(); end

  def value(); end

  def visitor(); end

  def visitor=(visitor); end
end

module Arel::Compatibility::Wheres::Value
end

class Arel::Compatibility::Wheres
end

module Arel::Compatibility
end

module Arel::Crud
  def compile_delete(); end

  def compile_insert(values); end

  def compile_update(values, pk); end

  def create_insert(); end
end

module Arel::Crud
end

class Arel::DeleteManager
  def from(relation); end

  def wheres=(list); end
end

class Arel::DeleteManager
end

module Arel::Expressions
  def average(); end

  def count(distinct=T.unsafe(nil)); end

  def extract(field); end

  def maximum(); end

  def minimum(); end

  def sum(); end
end

module Arel::Expressions
end

module Arel::FactoryMethods
  def create_and(clauses); end

  def create_false(); end

  def create_join(to, constraint=T.unsafe(nil), klass=T.unsafe(nil)); end

  def create_on(expr); end

  def create_string_join(to); end

  def create_table_alias(relation, name); end

  def create_true(); end

  def grouping(expr); end

  def lower(column); end
end

module Arel::FactoryMethods
end

class Arel::InsertManager
  def columns(); end

  def create_values(values, columns); end

  def insert(fields); end

  def into(table); end

  def select(select); end

  def values=(val); end
end

class Arel::InsertManager
end

module Arel::Math
  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end
end

module Arel::Math
end

Arel::Node = Arel::Nodes::Node

module Arel::Nodes
end

class Arel::Nodes::Addition
  def initialize(left, right); end
end

class Arel::Nodes::Addition
end

class Arel::Nodes::And
  def ==(other); end

  def children(); end

  def eql?(other); end

  def initialize(children); end

  def left(); end

  def right(); end
end

class Arel::Nodes::And
end

class Arel::Nodes::As
end

class Arel::Nodes::As
end

class Arel::Nodes::Ascending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Ascending
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Between
end

class Arel::Nodes::Between
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Binary
  def ==(other); end

  def eql?(other); end

  def initialize(left, right); end

  def left(); end

  def left=(left); end

  def right(); end

  def right=(right); end
end

class Arel::Nodes::Binary
end

class Arel::Nodes::BindParam
end

class Arel::Nodes::BindParam
end

class Arel::Nodes::Casted
  def ==(other); end

  def attribute(); end

  def eql?(other); end

  def initialize(val, attribute); end

  def val(); end
end

class Arel::Nodes::Casted
end

class Arel::Nodes::Count
  def initialize(expr, distinct=T.unsafe(nil), aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Count
end

class Arel::Nodes::CurrentRow
  def eql?(other); end
end

class Arel::Nodes::CurrentRow
end

class Arel::Nodes::DeleteStatement
  def initialize(relation=T.unsafe(nil), wheres=T.unsafe(nil)); end

  def relation(); end

  def relation=(relation); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::DeleteStatement
end

class Arel::Nodes::Descending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Descending
end

class Arel::Nodes::Distinct
  def eql?(other); end
end

class Arel::Nodes::Distinct
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::Division
  def initialize(left, right); end
end

class Arel::Nodes::Division
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::Equality
  def operand1(); end

  def operand2(); end

  def operator(); end
end

class Arel::Nodes::Equality
end

class Arel::Nodes::Except
end

class Arel::Nodes::Except
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Extract
  include ::Arel::AliasPredication
  include ::Arel::Predications
  def field(); end

  def field=(field); end

  def initialize(expr, field); end
end

class Arel::Nodes::Extract
end

class Arel::Nodes::False
  def eql?(other); end
end

class Arel::Nodes::False
end

class Arel::Nodes::Following
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Following
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::Function
  include ::Arel::Predications
  include ::Arel::WindowPredications
  include ::Arel::OrderPredications
  def alias(); end

  def alias=(_); end

  def as(aliaz); end

  def distinct(); end

  def distinct=(distinct); end

  def eql?(other); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(expr, aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Function
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::Group
end

class Arel::Nodes::Group
end

class Arel::Nodes::Grouping
  include ::Arel::Predications
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::Having
end

class Arel::Nodes::Having
end

class Arel::Nodes::In
end

class Arel::Nodes::In
end

class Arel::Nodes::InfixOperation
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::OrderPredications
  include ::Arel::AliasPredication
  include ::Arel::Math
  def initialize(operator, left, right); end

  def operator(); end
end

class Arel::Nodes::InfixOperation
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InsertStatement
  def ==(other); end

  def columns(); end

  def columns=(columns); end

  def eql?(other); end

  def relation(); end

  def relation=(relation); end

  def select=(select); end

  def values(); end

  def values=(values); end
end

class Arel::Nodes::InsertStatement
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Join
end

class Arel::Nodes::Join
end

class Arel::Nodes::JoinSource
  def empty?(); end

  def initialize(single_source, joinop=T.unsafe(nil)); end
end

class Arel::Nodes::JoinSource
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Matches
  def escape(); end

  def initialize(left, right, escape=T.unsafe(nil)); end
end

class Arel::Nodes::Matches
end

class Arel::Nodes::Max
end

class Arel::Nodes::Max
end

class Arel::Nodes::Min
end

class Arel::Nodes::Min
end

class Arel::Nodes::Multiplication
  def initialize(left, right); end
end

class Arel::Nodes::Multiplication
end

class Arel::Nodes::NamedFunction
  def ==(other); end

  def initialize(name, expr, aliaz=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedFunction
end

class Arel::Nodes::NamedWindow
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedWindow
end

class Arel::Nodes::Node
  include ::Arel::FactoryMethods
  include ::Enumerable
  def and(right); end

  def each(&block); end

  def not(); end

  def or(right); end

  def to_sql(engine=T.unsafe(nil)); end
end

class Arel::Nodes::Node
end

class Arel::Nodes::Not
end

class Arel::Nodes::Not
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::Offset
end

class Arel::Nodes::Offset
end

class Arel::Nodes::On
end

class Arel::Nodes::On
end

class Arel::Nodes::Or
end

class Arel::Nodes::Or
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::Over
  include ::Arel::AliasPredication
  def initialize(left, right=T.unsafe(nil)); end

  def operator(); end
end

class Arel::Nodes::Over
end

class Arel::Nodes::Preceding
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Preceding
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Range
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Range
end

class Arel::Nodes::Regexp
end

class Arel::Nodes::Regexp
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::Rows
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Rows
end

class Arel::Nodes::SelectCore
  def ==(other); end

  def eql?(other); end

  def from(); end

  def from=(value); end

  def froms(); end

  def froms=(value); end

  def groups(); end

  def groups=(groups); end

  def having(); end

  def having=(having); end

  def projections(); end

  def projections=(projections); end

  def set_quantifier(); end

  def set_quantifier=(set_quantifier); end

  def source(); end

  def source=(source); end

  def top(); end

  def top=(top); end

  def wheres(); end

  def wheres=(wheres); end

  def windows(); end

  def windows=(windows); end
end

class Arel::Nodes::SelectCore
end

class Arel::Nodes::SelectStatement
  def ==(other); end

  def cores(); end

  def eql?(other); end

  def initialize(cores=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(); end

  def lock=(lock); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def with(); end

  def with=(with); end
end

class Arel::Nodes::SelectStatement
end

class Arel::Nodes::SqlLiteral
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  def encode_with(coder); end
end

class Arel::Nodes::SqlLiteral
end

class Arel::Nodes::StringJoin
  def initialize(left, right=T.unsafe(nil)); end
end

class Arel::Nodes::StringJoin
end

class Arel::Nodes::Subtraction
  def initialize(left, right); end
end

class Arel::Nodes::Subtraction
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Sum
end

class Arel::Nodes::TableAlias
  def [](name); end

  def engine(); end

  def name(); end

  def relation(); end

  def table_alias(); end

  def table_name(); end
end

class Arel::Nodes::TableAlias
end

class Arel::Nodes::Top
end

class Arel::Nodes::Top
end

class Arel::Nodes::True
  def eql?(other); end
end

class Arel::Nodes::True
end

class Arel::Nodes::Unary
  def ==(other); end

  def eql?(other); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end

  def value(); end
end

class Arel::Nodes::Unary
end

class Arel::Nodes::Union
end

class Arel::Nodes::Union
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnqualifiedColumn
  def attribute(); end

  def attribute=(attribute); end

  def column(); end

  def name(); end

  def relation(); end
end

class Arel::Nodes::UnqualifiedColumn
end

class Arel::Nodes::UpdateStatement
  def ==(other); end

  def eql?(other); end

  def key(); end

  def key=(key); end

  def limit(); end

  def limit=(limit); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def values(); end

  def values=(values); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::UpdateStatement
end

class Arel::Nodes::Values
  def columns(); end

  def columns=(columns); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(exprs, columns=T.unsafe(nil)); end
end

class Arel::Nodes::Values
end

class Arel::Nodes::Window
  def ==(other); end

  def eql?(other); end

  def frame(expr); end

  def framing(); end

  def framing=(framing); end

  def order(*expr); end

  def orders(); end

  def orders=(orders); end

  def partition(*expr); end

  def partitions(); end

  def partitions=(partitions); end

  def range(expr=T.unsafe(nil)); end

  def rows(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Window
end

class Arel::Nodes::With
  def children(); end
end

class Arel::Nodes::With
end

class Arel::Nodes::WithRecursive
end

class Arel::Nodes::WithRecursive
end

module Arel::Nodes
  def self.build_quoted(other, attribute=T.unsafe(nil)); end
end

module Arel::OrderPredications
  def asc(); end

  def desc(); end
end

module Arel::OrderPredications
end

module Arel::Predications
  def between(other); end

  def does_not_match(other, escape=T.unsafe(nil)); end

  def does_not_match_all(others, escape=T.unsafe(nil)); end

  def does_not_match_any(others, escape=T.unsafe(nil)); end

  def eq(other); end

  def eq_all(others); end

  def eq_any(others); end

  def gt(right); end

  def gt_all(others); end

  def gt_any(others); end

  def gteq(right); end

  def gteq_all(others); end

  def gteq_any(others); end

  def in(other); end

  def in_all(others); end

  def in_any(others); end

  def lt(right); end

  def lt_all(others); end

  def lt_any(others); end

  def lteq(right); end

  def lteq_all(others); end

  def lteq_any(others); end

  def matches(other, escape=T.unsafe(nil)); end

  def matches_all(others, escape=T.unsafe(nil)); end

  def matches_any(others, escape=T.unsafe(nil)); end

  def not_between(other); end

  def not_eq(other); end

  def not_eq_all(others); end

  def not_eq_any(others); end

  def not_in(other); end

  def not_in_all(others); end

  def not_in_any(others); end
end

module Arel::Predications
end

class Arel::SelectManager
  include ::Arel::Crud
  def as(other); end

  def constraints(); end

  def distinct(value=T.unsafe(nil)); end

  def distinct_on(value); end

  def except(other); end

  def exists(); end

  def from(table); end

  def froms(); end

  def group(*columns); end

  def having(*exprs); end

  def initialize(engine, table=T.unsafe(nil)); end

  def intersect(other); end

  def join(relation, klass=T.unsafe(nil)); end

  def join_sources(); end

  def limit(); end

  def limit=(limit); end

  def lock(locking=T.unsafe(nil)); end

  def locked(); end

  def minus(other); end

  def offset(); end

  def offset=(amount); end

  def on(*exprs); end

  def order(*expr); end

  def orders(); end

  def outer_join(relation); end

  def project(*projections); end

  def projections(); end

  def projections=(projections); end

  def skip(amount); end

  def source(); end

  def take(limit); end

  def taken(); end

  def union(operation, other=T.unsafe(nil)); end

  def where_sql(); end

  def window(name); end

  def with(*subqueries); end
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::SelectManager::Row
  def id(); end

  def method_missing(name, *args); end
end

class Arel::SelectManager::Row
end

class Arel::SelectManager
end

class Arel::Table
  include ::Arel::Crud
  include ::Arel::FactoryMethods
  def ==(other); end

  def [](name); end

  def alias(name=T.unsafe(nil)); end

  def aliases(); end

  def aliases=(aliases); end

  def delete_manager(); end

  def engine(); end

  def engine=(engine); end

  def eql?(other); end

  def from(table); end

  def group(*columns); end

  def having(expr); end

  def initialize(name, engine=T.unsafe(nil)); end

  def insert_manager(); end

  def join(relation, klass=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def order(*expr); end

  def outer_join(relation); end

  def primary_key(); end

  def project(*things); end

  def select_manager(); end

  def skip(amount); end

  def table_alias(); end

  def table_alias=(table_alias); end

  def table_name(); end

  def take(amount); end

  def update_manager(); end

  def where(condition); end
end

class Arel::Table
  def self.engine(); end

  def self.engine=(engine); end
end

class Arel::TreeManager
  include ::Arel::FactoryMethods
  def ast(); end

  def bind_values(); end

  def bind_values=(bind_values); end

  def engine(); end

  def initialize(engine); end

  def to_dot(); end

  def to_sql(); end

  def visitor(); end

  def where(expr); end
end

class Arel::TreeManager
end

class Arel::UpdateManager
  def key(); end

  def key=(key); end

  def order(*expr); end

  def set(values); end

  def table(table); end

  def take(limit); end

  def wheres=(exprs); end
end

class Arel::UpdateManager
end

module Arel::Visitors
  ENGINE_VISITORS = ::T.let(nil, ::T.untyped)
  VISITORS = ::T.let(nil, ::T.untyped)
end

module Arel::Visitors::BindVisitor
  def accept(node, collector, &block); end

  def initialize(target); end
end

module Arel::Visitors::BindVisitor
end

class Arel::Visitors::DepthFirst
  def initialize(block=T.unsafe(nil)); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
end

class Arel::Visitors::Dot
  def accept(object, collector); end
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Node
  def fields(); end

  def fields=(fields); end

  def id(); end

  def id=(id); end

  def initialize(name, id, fields=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Visitors::Dot::Node
end

class Arel::Visitors::Dot
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::Informix
end

class Arel::Visitors::Informix
end

class Arel::Visitors::MSSQL
end

class Arel::Visitors::MSSQL::RowNumber
  def children(); end

  def children=(_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def self.[](*_); end

  def self.members(); end
end

class Arel::Visitors::MSSQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::Reduce
  def accept(object, collector); end
end

class Arel::Visitors::Reduce
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::ToSql
  def compile(node, &block); end

  def initialize(connection); end
  AND = ::T.let(nil, ::T.untyped)
  COMMA = ::T.let(nil, ::T.untyped)
  DISTINCT = ::T.let(nil, ::T.untyped)
  GROUP_BY = ::T.let(nil, ::T.untyped)
  ORDER_BY = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  WHERE = ::T.let(nil, ::T.untyped)
  WINDOW = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::ToSql
end

class Arel::Visitors::Visitor
  def accept(object); end

  def visit_ActiveRecord_Relation_WhereClause(o, collector); end
end

class Arel::Visitors::Visitor
  def self.dispatch_cache(); end
end

class Arel::Visitors::WhereSql
end

class Arel::Visitors::WhereSql
end

module Arel::Visitors
  def self.for(engine); end

  def self.visitor_for(engine); end
end

module Arel::WindowPredications
  def over(expr=T.unsafe(nil)); end
end

module Arel::WindowPredications
end

module Arel
  def self.sql(raw_sql); end

  def self.star(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def alpha_paginate(current_field, params=T.unsafe(nil)); end

  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def paginate(options=T.unsafe(nil)); end

  def place(*values); end

  def replace(_); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_default_s(); end

  def to_h(); end

  def to_json(options=T.unsafe(nil)); end

end

class Array
  def self.try_convert(_); end

  def self.wrap(object); end
end

module Aws
  CORE_GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::ARN
  def account_id(); end

  def initialize(options=T.unsafe(nil)); end

  def partition(); end

  def region(); end

  def resource(); end

  def service(); end

  def valid?(); end
end

class Aws::ARN
end

module Aws::ARNParser
end

module Aws::ARNParser
  def self.arn?(str); end

  def self.parse(arn_str); end
end

class Aws::AssumeRoleCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def client(); end
end

class Aws::AssumeRoleCredentials
  def self.assume_role_options(); end
end

class Aws::AssumeRoleWebIdentityCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def client(); end
end

class Aws::AssumeRoleWebIdentityCredentials
  def self.assume_role_web_identity_options(); end
end

module Aws::AsyncClientStubs
  include ::Aws::ClientStubs
  def send_events(); end

  def setup_stubbing(); end
end

class Aws::AsyncClientStubs::StubStream
  def close(); end

  def closed?(); end

  def data(bytes, options=T.unsafe(nil)); end

  def send_events(); end

  def send_events=(send_events); end

  def state(); end
end

class Aws::AsyncClientStubs::StubStream
end

module Aws::AsyncClientStubs
end

module Aws::Binary
end

class Aws::Binary::DecodeHandler
end

class Aws::Binary::DecodeHandler
end

class Aws::Binary::EncodeHandler
end

class Aws::Binary::EncodeHandler
end

class Aws::Binary::EventBuilder
  include ::Seahorse::Model::Shapes
  def apply(event_type, params); end

  def initialize(serializer_class, rules); end
end

class Aws::Binary::EventBuilder
end

class Aws::Binary::EventParser
  include ::Seahorse::Model::Shapes
  def apply(raw_event); end

  def initialize(parser_class, rules, error_refs, output_ref); end
end

class Aws::Binary::EventParser
end

class Aws::Binary::EventStreamDecoder
  def events(); end

  def initialize(protocol, rules, output_ref, error_refs, io, event_stream_handler=T.unsafe(nil)); end

  def write(chunk); end
end

class Aws::Binary::EventStreamDecoder
end

class Aws::Binary::EventStreamEncoder
  def encode(event_type, params); end

  def initialize(protocol, rules, input_ref, signer); end

  def prior_signature(); end

  def prior_signature=(prior_signature); end

  def rules(); end
end

class Aws::Binary::EventStreamEncoder
end

module Aws::Binary
end

module Aws::ClientSideMonitoring
end

class Aws::ClientSideMonitoring::Publisher
  def agent_host(); end

  def agent_host=(value); end

  def agent_port(); end

  def agent_port=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def publish(request_metrics); end

  def send_datagram(msg); end
end

class Aws::ClientSideMonitoring::Publisher
end

class Aws::ClientSideMonitoring::RequestMetrics
  def add_call_attempt(attempt); end

  def api_call(); end

  def api_call_attempts(); end

  def build_call_attempt(opts=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end
  FIELD_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCall
  def api(); end

  def attempt_count(); end

  def client_id(); end

  def complete(opts=T.unsafe(nil)); end

  def final_aws_exception(); end

  def final_aws_exception_message(); end

  def final_http_status_code(); end

  def final_sdk_exception(); end

  def final_sdk_exception_message(); end

  def initialize(service, api, client_id, version, timestamp, region); end

  def latency(); end

  def max_retries_exceeded(); end

  def region(); end

  def service(); end

  def timestamp(); end

  def to_json(*a); end

  def user_agent(); end

  def version(); end
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCall
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCallAttempt
  def access_key(); end

  def api(); end

  def aws_exception(); end

  def aws_exception=(aws_exception); end

  def aws_exception_msg(); end

  def aws_exception_msg=(aws_exception_msg); end

  def client_id(); end

  def fqdn(); end

  def fqdn=(fqdn); end

  def http_status_code(); end

  def http_status_code=(http_status_code); end

  def initialize(service, api, client_id, version, timestamp, fqdn, region, user_agent, access_key, session_token); end

  def region(); end

  def region=(region); end

  def request_latency(); end

  def request_latency=(request_latency); end

  def sdk_exception(); end

  def sdk_exception=(sdk_exception); end

  def sdk_exception_msg(); end

  def sdk_exception_msg=(sdk_exception_msg); end

  def service(); end

  def session_token(); end

  def timestamp(); end

  def to_json(*a); end

  def user_agent(); end

  def version(); end

  def x_amz_id_2(); end

  def x_amz_id_2=(x_amz_id_2); end

  def x_amz_request_id(); end

  def x_amz_request_id=(x_amz_request_id); end

  def x_amzn_request_id(); end

  def x_amzn_request_id=(x_amzn_request_id); end
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCallAttempt
end

class Aws::ClientSideMonitoring::RequestMetrics
end

module Aws::ClientSideMonitoring
end

module Aws::ClientStubs
  def api_requests(options=T.unsafe(nil)); end

  def next_stub(context); end

  def setup_stubbing(); end

  def stub_data(operation_name, data=T.unsafe(nil)); end

  def stub_responses(operation_name, *stubs); end
end

module Aws::ClientStubs
end

module Aws::CredentialProvider
  def credentials(); end

  def set?(); end
end

module Aws::CredentialProvider
end

class Aws::CredentialProviderChain
  def initialize(config=T.unsafe(nil)); end

  def resolve(); end
end

class Aws::CredentialProviderChain
end

class Aws::Credentials
  def access_key_id(); end

  def credentials(); end

  def initialize(access_key_id, secret_access_key, session_token=T.unsafe(nil)); end

  def secret_access_key(); end

  def session_token(); end

  def set?(); end
end

class Aws::Credentials
end

module Aws::Deprecations
  def deprecated(method, options=T.unsafe(nil)); end
end

module Aws::Deprecations
end

class Aws::ECSCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def retries(); end
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::ECSCredentials::Non200Response
end

class Aws::ECSCredentials::Non200Response
end

class Aws::ECSCredentials
end

class Aws::EagerLoader
  def load(klass_or_module); end

  def loaded(); end
end

class Aws::EagerLoader
end

class Aws::EmptyStructure
  include ::Aws::Structure
end

class Aws::EmptyStructure
end

class Aws::EndpointCache
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def delete_polling_thread(key); end

  def extract_key(ctx); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def max_entries(); end

  def max_threads(); end

  def pool(); end

  def stop_polling!(); end

  def threads_key?(key); end

  def update(key, ctx); end

  def update_polling_pool(key, thread); end
  MAX_ENTRIES = ::T.let(nil, ::T.untyped)
  MAX_THREADS = ::T.let(nil, ::T.untyped)
end

class Aws::EndpointCache::Endpoint
  def address(); end

  def expired?(); end

  def initialize(options); end
  CACHE_PERIOD = ::T.let(nil, ::T.untyped)
end

class Aws::EndpointCache::Endpoint
end

class Aws::EndpointCache
end

module Aws::Errors
end

class Aws::Errors::ChecksumError
end

class Aws::Errors::ChecksumError
end

class Aws::Errors::CredentialSourceConflictError
end

class Aws::Errors::CredentialSourceConflictError
end

module Aws::Errors::DynamicErrors
  def const_missing(constant); end

  def error_class(error_code); end
end

module Aws::Errors::DynamicErrors
  def self.extended(submodule); end
end

class Aws::Errors::EndpointDiscoveryError
  def initialize(*args); end
end

class Aws::Errors::EndpointDiscoveryError
end

class Aws::Errors::EventError
  def error_code(); end

  def error_message(); end

  def event_type(); end

  def initialize(event_type, code, message); end
end

class Aws::Errors::EventError
end

class Aws::Errors::EventStreamBuilderError
end

class Aws::Errors::EventStreamBuilderError
end

class Aws::Errors::EventStreamParserError
end

class Aws::Errors::EventStreamParserError
end

class Aws::Errors::InvalidARNError
end

class Aws::Errors::InvalidARNError
end

class Aws::Errors::InvalidARNPartitionError
  def initialize(*args); end
end

class Aws::Errors::InvalidARNPartitionError
end

class Aws::Errors::InvalidARNRegionError
  def initialize(*args); end
end

class Aws::Errors::InvalidARNRegionError
end

class Aws::Errors::InvalidCredentialSourceError
end

class Aws::Errors::InvalidCredentialSourceError
end

class Aws::Errors::InvalidProcessCredentialsPayload
end

class Aws::Errors::InvalidProcessCredentialsPayload
end

class Aws::Errors::MetadataParserError
  def initialize(*args); end
end

class Aws::Errors::MetadataParserError
end

class Aws::Errors::MissingContentLength
  def initialize(*args); end
end

class Aws::Errors::MissingContentLength
end

class Aws::Errors::MissingCredentialsError
  def initialize(*args); end
end

class Aws::Errors::MissingCredentialsError
end

class Aws::Errors::MissingEndpointHostLabelValue
  def initialize(name); end
end

class Aws::Errors::MissingEndpointHostLabelValue
end

class Aws::Errors::MissingRegionError
  def initialize(*args); end
end

class Aws::Errors::MissingRegionError
end

class Aws::Errors::MissingWebIdentityTokenFile
  def initialize(*args); end
end

class Aws::Errors::MissingWebIdentityTokenFile
end

class Aws::Errors::NoSourceCredentialsError
end

class Aws::Errors::NoSourceCredentialsError
end

class Aws::Errors::NoSourceProfileError
end

class Aws::Errors::NoSourceProfileError
end

class Aws::Errors::NoSuchEndpointError
  def context(); end

  def endpoint(); end

  def initialize(options=T.unsafe(nil)); end

  def original_error(); end
end

class Aws::Errors::NoSuchEndpointError
end

class Aws::Errors::NoSuchProfileError
end

class Aws::Errors::NoSuchProfileError
end

class Aws::Errors::NonSupportedRubyVersionError
end

class Aws::Errors::NonSupportedRubyVersionError
end

class Aws::Errors::RetryCapacityNotAvailableError
  def initialize(*args); end
end

class Aws::Errors::RetryCapacityNotAvailableError
end

class Aws::Errors::ServiceError
  def code(); end

  def context(); end

  def data(); end

  def initialize(context, message, data=T.unsafe(nil)); end

  def retryable?(); end

  def throttling?(); end
end

class Aws::Errors::ServiceError
  def self.code(); end

  def self.code=(code); end
end

class Aws::Errors::SignalEventError
end

class Aws::Errors::SignalEventError
end

module Aws::Errors
end

class Aws::EventEmitter
  def emit(type, params); end

  def encoder(); end

  def encoder=(encoder); end

  def on(type, callback); end

  def signal(type, event); end

  def signal_queue(); end

  def signal_queue=(signal_queue); end

  def stream(); end

  def stream=(stream); end

  def validate_event(); end

  def validate_event=(validate_event); end
end

class Aws::EventEmitter
end

module Aws::EventStream
end

class Aws::EventStream::Decoder
  include ::Enumerable
  def decode(io, &block); end

  def decode_chunk(chunk=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::EventStream::Decoder
end

class Aws::EventStream::Encoder
  def encode(message, io=T.unsafe(nil)); end

  def encode_headers(message); end

  def encode_message(message); end
  MAX_HEADERS_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_PAYLOAD_LENGTH = ::T.let(nil, ::T.untyped)
  OVERHEAD_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::EventStream::Encoder
end

module Aws::EventStream::Errors
end

class Aws::EventStream::Errors::EventHeadersLengthExceedError
  def initialize(*args); end
end

class Aws::EventStream::Errors::EventHeadersLengthExceedError
end

class Aws::EventStream::Errors::EventPayloadLengthExceedError
  def initialize(*args); end
end

class Aws::EventStream::Errors::EventPayloadLengthExceedError
end

class Aws::EventStream::Errors::IncompleteMessageError
  def initialize(*args); end
end

class Aws::EventStream::Errors::IncompleteMessageError
end

class Aws::EventStream::Errors::MessageChecksumError
  def initialize(*args); end
end

class Aws::EventStream::Errors::MessageChecksumError
end

class Aws::EventStream::Errors::PreludeChecksumError
  def initialize(*args); end
end

class Aws::EventStream::Errors::PreludeChecksumError
end

class Aws::EventStream::Errors::ReadBytesExceedLengthError
  def initialize(target_byte, total_len); end
end

class Aws::EventStream::Errors::ReadBytesExceedLengthError
end

module Aws::EventStream::Errors
end

class Aws::EventStream::HeaderValue
  def initialize(options); end

  def type(); end

  def value(); end
end

class Aws::EventStream::HeaderValue
end

class Aws::EventStream::Message
  def headers(); end

  def initialize(options); end

  def payload(); end
end

class Aws::EventStream::Message
end

module Aws::EventStream::Types
end

module Aws::EventStream::Types
  def self.pattern(); end

  def self.types(); end
end

module Aws::EventStream
end

class Aws::IniParser
end

class Aws::IniParser
  def self.ini_parse(raw); end
end

class Aws::InstanceProfileCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def retries(); end
  METADATA_PATH_BASE = ::T.let(nil, ::T.untyped)
  METADATA_TOKEN_PATH = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::InstanceProfileCredentials::Non200Response
end

class Aws::InstanceProfileCredentials::Non200Response
end

class Aws::InstanceProfileCredentials::Token
  def expired?(); end

  def initialize(value, ttl); end

  def value(); end
end

class Aws::InstanceProfileCredentials::Token
end

class Aws::InstanceProfileCredentials::TokenExpiredError
end

class Aws::InstanceProfileCredentials::TokenExpiredError
end

class Aws::InstanceProfileCredentials::TokenRetrivalError
end

class Aws::InstanceProfileCredentials::TokenRetrivalError
end

class Aws::InstanceProfileCredentials
end

module Aws::Json
  ENGINE_DUMP_OPTIONS = ::T.let(nil, ::T.untyped)
  ENGINE_ERRORS = ::T.let(nil, ::T.untyped)
  ENGINE_LOAD_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Aws::Json::Builder
  include ::Seahorse::Model::Shapes
  def initialize(rules); end

  def serialize(params); end

  def to_json(params); end
end

class Aws::Json::Builder
end

Aws::Json::ENGINE = Oj

class Aws::Json::ErrorHandler
end

class Aws::Json::ErrorHandler
end

class Aws::Json::Handler
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Aws::Json::Handler
end

class Aws::Json::ParseError
  def error(); end

  def initialize(error); end
end

class Aws::Json::ParseError
end

class Aws::Json::Parser
  include ::Seahorse::Model::Shapes
  def initialize(rules); end

  def parse(json, target=T.unsafe(nil)); end
end

class Aws::Json::Parser
end

module Aws::Json
  def self.dump(value); end

  def self.load(json); end

  def self.load_file(path); end
end

module Aws::KMS
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Client
  include ::Aws::ClientStubs
  def cancel_key_deletion(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def connect_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_alias(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_grant(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def decrypt(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_alias(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_imported_key_material(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_custom_key_stores(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_key_rotation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disconnect_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_key_rotation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def encrypt(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_data_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_data_key_pair(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_data_key_pair_without_plaintext(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_data_key_without_plaintext(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_random(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_key_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_key_rotation_status(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_parameters_for_import(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_public_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def import_key_material(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(*args); end

  def list_aliases(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_grants(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_key_policies(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_keys(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_resource_tags(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_retirable_grants(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_key_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def re_encrypt(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def retire_grant(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def revoke_grant(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def schedule_key_deletion(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def sign(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def tag_resource(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def untag_resource(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_alias(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_key_description(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def verify(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def waiter_names(); end
end

class Aws::KMS::Client
  def self.errors_module(); end

  def self.identifier(); end
end

module Aws::KMS::ClientApi
  include ::Seahorse::Model
  API = ::T.let(nil, ::T.untyped)
  AWSAccountIdType = ::T.let(nil, ::T.untyped)
  AlgorithmSpec = ::T.let(nil, ::T.untyped)
  AliasList = ::T.let(nil, ::T.untyped)
  AliasListEntry = ::T.let(nil, ::T.untyped)
  AliasNameType = ::T.let(nil, ::T.untyped)
  AlreadyExistsException = ::T.let(nil, ::T.untyped)
  ArnType = ::T.let(nil, ::T.untyped)
  BooleanType = ::T.let(nil, ::T.untyped)
  CancelKeyDeletionRequest = ::T.let(nil, ::T.untyped)
  CancelKeyDeletionResponse = ::T.let(nil, ::T.untyped)
  CiphertextType = ::T.let(nil, ::T.untyped)
  CloudHsmClusterIdType = ::T.let(nil, ::T.untyped)
  CloudHsmClusterInUseException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterInvalidConfigurationException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotActiveException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotFoundException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotRelatedException = ::T.let(nil, ::T.untyped)
  ConnectCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  ConnectCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  ConnectionErrorCodeType = ::T.let(nil, ::T.untyped)
  ConnectionStateType = ::T.let(nil, ::T.untyped)
  CreateAliasRequest = ::T.let(nil, ::T.untyped)
  CreateCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  CreateCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  CreateGrantRequest = ::T.let(nil, ::T.untyped)
  CreateGrantResponse = ::T.let(nil, ::T.untyped)
  CreateKeyRequest = ::T.let(nil, ::T.untyped)
  CreateKeyResponse = ::T.let(nil, ::T.untyped)
  CustomKeyStoreHasCMKsException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreIdType = ::T.let(nil, ::T.untyped)
  CustomKeyStoreInvalidStateException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNameInUseException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNameType = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNotFoundException = ::T.let(nil, ::T.untyped)
  CustomKeyStoresList = ::T.let(nil, ::T.untyped)
  CustomKeyStoresListEntry = ::T.let(nil, ::T.untyped)
  CustomerMasterKeySpec = ::T.let(nil, ::T.untyped)
  DataKeyPairSpec = ::T.let(nil, ::T.untyped)
  DataKeySpec = ::T.let(nil, ::T.untyped)
  DateType = ::T.let(nil, ::T.untyped)
  DecryptRequest = ::T.let(nil, ::T.untyped)
  DecryptResponse = ::T.let(nil, ::T.untyped)
  DeleteAliasRequest = ::T.let(nil, ::T.untyped)
  DeleteCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  DeleteCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  DeleteImportedKeyMaterialRequest = ::T.let(nil, ::T.untyped)
  DependencyTimeoutException = ::T.let(nil, ::T.untyped)
  DescribeCustomKeyStoresRequest = ::T.let(nil, ::T.untyped)
  DescribeCustomKeyStoresResponse = ::T.let(nil, ::T.untyped)
  DescribeKeyRequest = ::T.let(nil, ::T.untyped)
  DescribeKeyResponse = ::T.let(nil, ::T.untyped)
  DescriptionType = ::T.let(nil, ::T.untyped)
  DisableKeyRequest = ::T.let(nil, ::T.untyped)
  DisableKeyRotationRequest = ::T.let(nil, ::T.untyped)
  DisabledException = ::T.let(nil, ::T.untyped)
  DisconnectCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  DisconnectCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  EnableKeyRequest = ::T.let(nil, ::T.untyped)
  EnableKeyRotationRequest = ::T.let(nil, ::T.untyped)
  EncryptRequest = ::T.let(nil, ::T.untyped)
  EncryptResponse = ::T.let(nil, ::T.untyped)
  EncryptionAlgorithmSpec = ::T.let(nil, ::T.untyped)
  EncryptionAlgorithmSpecList = ::T.let(nil, ::T.untyped)
  EncryptionContextKey = ::T.let(nil, ::T.untyped)
  EncryptionContextType = ::T.let(nil, ::T.untyped)
  EncryptionContextValue = ::T.let(nil, ::T.untyped)
  ErrorMessageType = ::T.let(nil, ::T.untyped)
  ExpirationModelType = ::T.let(nil, ::T.untyped)
  ExpiredImportTokenException = ::T.let(nil, ::T.untyped)
  GenerateDataKeyPairRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyPairResponse = ::T.let(nil, ::T.untyped)
  GenerateDataKeyPairWithoutPlaintextRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyPairWithoutPlaintextResponse = ::T.let(nil, ::T.untyped)
  GenerateDataKeyRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyResponse = ::T.let(nil, ::T.untyped)
  GenerateDataKeyWithoutPlaintextRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyWithoutPlaintextResponse = ::T.let(nil, ::T.untyped)
  GenerateRandomRequest = ::T.let(nil, ::T.untyped)
  GenerateRandomResponse = ::T.let(nil, ::T.untyped)
  GetKeyPolicyRequest = ::T.let(nil, ::T.untyped)
  GetKeyPolicyResponse = ::T.let(nil, ::T.untyped)
  GetKeyRotationStatusRequest = ::T.let(nil, ::T.untyped)
  GetKeyRotationStatusResponse = ::T.let(nil, ::T.untyped)
  GetParametersForImportRequest = ::T.let(nil, ::T.untyped)
  GetParametersForImportResponse = ::T.let(nil, ::T.untyped)
  GetPublicKeyRequest = ::T.let(nil, ::T.untyped)
  GetPublicKeyResponse = ::T.let(nil, ::T.untyped)
  GrantConstraints = ::T.let(nil, ::T.untyped)
  GrantIdType = ::T.let(nil, ::T.untyped)
  GrantList = ::T.let(nil, ::T.untyped)
  GrantListEntry = ::T.let(nil, ::T.untyped)
  GrantNameType = ::T.let(nil, ::T.untyped)
  GrantOperation = ::T.let(nil, ::T.untyped)
  GrantOperationList = ::T.let(nil, ::T.untyped)
  GrantTokenList = ::T.let(nil, ::T.untyped)
  GrantTokenType = ::T.let(nil, ::T.untyped)
  ImportKeyMaterialRequest = ::T.let(nil, ::T.untyped)
  ImportKeyMaterialResponse = ::T.let(nil, ::T.untyped)
  IncorrectKeyException = ::T.let(nil, ::T.untyped)
  IncorrectKeyMaterialException = ::T.let(nil, ::T.untyped)
  IncorrectTrustAnchorException = ::T.let(nil, ::T.untyped)
  InvalidAliasNameException = ::T.let(nil, ::T.untyped)
  InvalidArnException = ::T.let(nil, ::T.untyped)
  InvalidCiphertextException = ::T.let(nil, ::T.untyped)
  InvalidGrantIdException = ::T.let(nil, ::T.untyped)
  InvalidGrantTokenException = ::T.let(nil, ::T.untyped)
  InvalidImportTokenException = ::T.let(nil, ::T.untyped)
  InvalidKeyUsageException = ::T.let(nil, ::T.untyped)
  InvalidMarkerException = ::T.let(nil, ::T.untyped)
  KMSInternalException = ::T.let(nil, ::T.untyped)
  KMSInvalidSignatureException = ::T.let(nil, ::T.untyped)
  KMSInvalidStateException = ::T.let(nil, ::T.untyped)
  KeyIdType = ::T.let(nil, ::T.untyped)
  KeyList = ::T.let(nil, ::T.untyped)
  KeyListEntry = ::T.let(nil, ::T.untyped)
  KeyManagerType = ::T.let(nil, ::T.untyped)
  KeyMetadata = ::T.let(nil, ::T.untyped)
  KeyState = ::T.let(nil, ::T.untyped)
  KeyStorePasswordType = ::T.let(nil, ::T.untyped)
  KeyUnavailableException = ::T.let(nil, ::T.untyped)
  KeyUsageType = ::T.let(nil, ::T.untyped)
  LimitExceededException = ::T.let(nil, ::T.untyped)
  LimitType = ::T.let(nil, ::T.untyped)
  ListAliasesRequest = ::T.let(nil, ::T.untyped)
  ListAliasesResponse = ::T.let(nil, ::T.untyped)
  ListGrantsRequest = ::T.let(nil, ::T.untyped)
  ListGrantsResponse = ::T.let(nil, ::T.untyped)
  ListKeyPoliciesRequest = ::T.let(nil, ::T.untyped)
  ListKeyPoliciesResponse = ::T.let(nil, ::T.untyped)
  ListKeysRequest = ::T.let(nil, ::T.untyped)
  ListKeysResponse = ::T.let(nil, ::T.untyped)
  ListResourceTagsRequest = ::T.let(nil, ::T.untyped)
  ListResourceTagsResponse = ::T.let(nil, ::T.untyped)
  ListRetirableGrantsRequest = ::T.let(nil, ::T.untyped)
  MalformedPolicyDocumentException = ::T.let(nil, ::T.untyped)
  MarkerType = ::T.let(nil, ::T.untyped)
  MessageType = ::T.let(nil, ::T.untyped)
  NotFoundException = ::T.let(nil, ::T.untyped)
  NumberOfBytesType = ::T.let(nil, ::T.untyped)
  OriginType = ::T.let(nil, ::T.untyped)
  PendingWindowInDaysType = ::T.let(nil, ::T.untyped)
  PlaintextType = ::T.let(nil, ::T.untyped)
  PolicyNameList = ::T.let(nil, ::T.untyped)
  PolicyNameType = ::T.let(nil, ::T.untyped)
  PolicyType = ::T.let(nil, ::T.untyped)
  PrincipalIdType = ::T.let(nil, ::T.untyped)
  PublicKeyType = ::T.let(nil, ::T.untyped)
  PutKeyPolicyRequest = ::T.let(nil, ::T.untyped)
  ReEncryptRequest = ::T.let(nil, ::T.untyped)
  ReEncryptResponse = ::T.let(nil, ::T.untyped)
  RetireGrantRequest = ::T.let(nil, ::T.untyped)
  RevokeGrantRequest = ::T.let(nil, ::T.untyped)
  ScheduleKeyDeletionRequest = ::T.let(nil, ::T.untyped)
  ScheduleKeyDeletionResponse = ::T.let(nil, ::T.untyped)
  SignRequest = ::T.let(nil, ::T.untyped)
  SignResponse = ::T.let(nil, ::T.untyped)
  SigningAlgorithmSpec = ::T.let(nil, ::T.untyped)
  SigningAlgorithmSpecList = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
  TagException = ::T.let(nil, ::T.untyped)
  TagKeyList = ::T.let(nil, ::T.untyped)
  TagKeyType = ::T.let(nil, ::T.untyped)
  TagList = ::T.let(nil, ::T.untyped)
  TagResourceRequest = ::T.let(nil, ::T.untyped)
  TagValueType = ::T.let(nil, ::T.untyped)
  TrustAnchorCertificateType = ::T.let(nil, ::T.untyped)
  UnsupportedOperationException = ::T.let(nil, ::T.untyped)
  UntagResourceRequest = ::T.let(nil, ::T.untyped)
  UpdateAliasRequest = ::T.let(nil, ::T.untyped)
  UpdateCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  UpdateCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  UpdateKeyDescriptionRequest = ::T.let(nil, ::T.untyped)
  VerifyRequest = ::T.let(nil, ::T.untyped)
  VerifyResponse = ::T.let(nil, ::T.untyped)
  WrappingKeySpec = ::T.let(nil, ::T.untyped)
end

module Aws::KMS::ClientApi
end

module Aws::KMS::Errors
end

class Aws::KMS::Errors::AlreadyExistsException
end

class Aws::KMS::Errors::AlreadyExistsException
end

class Aws::KMS::Errors::CloudHsmClusterInUseException
end

class Aws::KMS::Errors::CloudHsmClusterInUseException
end

class Aws::KMS::Errors::CloudHsmClusterInvalidConfigurationException
end

class Aws::KMS::Errors::CloudHsmClusterInvalidConfigurationException
end

class Aws::KMS::Errors::CloudHsmClusterNotActiveException
end

class Aws::KMS::Errors::CloudHsmClusterNotActiveException
end

class Aws::KMS::Errors::CloudHsmClusterNotFoundException
end

class Aws::KMS::Errors::CloudHsmClusterNotFoundException
end

class Aws::KMS::Errors::CloudHsmClusterNotRelatedException
end

class Aws::KMS::Errors::CloudHsmClusterNotRelatedException
end

class Aws::KMS::Errors::CustomKeyStoreHasCMKsException
end

class Aws::KMS::Errors::CustomKeyStoreHasCMKsException
end

class Aws::KMS::Errors::CustomKeyStoreInvalidStateException
end

class Aws::KMS::Errors::CustomKeyStoreInvalidStateException
end

class Aws::KMS::Errors::CustomKeyStoreNameInUseException
end

class Aws::KMS::Errors::CustomKeyStoreNameInUseException
end

class Aws::KMS::Errors::CustomKeyStoreNotFoundException
end

class Aws::KMS::Errors::CustomKeyStoreNotFoundException
end

class Aws::KMS::Errors::DependencyTimeoutException
end

class Aws::KMS::Errors::DependencyTimeoutException
end

class Aws::KMS::Errors::DisabledException
end

class Aws::KMS::Errors::DisabledException
end

class Aws::KMS::Errors::ExpiredImportTokenException
end

class Aws::KMS::Errors::ExpiredImportTokenException
end

class Aws::KMS::Errors::IncorrectKeyException
end

class Aws::KMS::Errors::IncorrectKeyException
end

class Aws::KMS::Errors::IncorrectKeyMaterialException
end

class Aws::KMS::Errors::IncorrectKeyMaterialException
end

class Aws::KMS::Errors::IncorrectTrustAnchorException
end

class Aws::KMS::Errors::IncorrectTrustAnchorException
end

class Aws::KMS::Errors::InvalidAliasNameException
end

class Aws::KMS::Errors::InvalidAliasNameException
end

class Aws::KMS::Errors::InvalidArnException
end

class Aws::KMS::Errors::InvalidArnException
end

class Aws::KMS::Errors::InvalidCiphertextException
end

class Aws::KMS::Errors::InvalidCiphertextException
end

class Aws::KMS::Errors::InvalidGrantIdException
end

class Aws::KMS::Errors::InvalidGrantIdException
end

class Aws::KMS::Errors::InvalidGrantTokenException
end

class Aws::KMS::Errors::InvalidGrantTokenException
end

class Aws::KMS::Errors::InvalidImportTokenException
end

class Aws::KMS::Errors::InvalidImportTokenException
end

class Aws::KMS::Errors::InvalidKeyUsageException
end

class Aws::KMS::Errors::InvalidKeyUsageException
end

class Aws::KMS::Errors::InvalidMarkerException
end

class Aws::KMS::Errors::InvalidMarkerException
end

class Aws::KMS::Errors::KMSInternalException
end

class Aws::KMS::Errors::KMSInternalException
end

class Aws::KMS::Errors::KMSInvalidSignatureException
end

class Aws::KMS::Errors::KMSInvalidSignatureException
end

class Aws::KMS::Errors::KMSInvalidStateException
end

class Aws::KMS::Errors::KMSInvalidStateException
end

class Aws::KMS::Errors::KeyUnavailableException
end

class Aws::KMS::Errors::KeyUnavailableException
end

class Aws::KMS::Errors::LimitExceededException
end

class Aws::KMS::Errors::LimitExceededException
end

class Aws::KMS::Errors::MalformedPolicyDocumentException
end

class Aws::KMS::Errors::MalformedPolicyDocumentException
end

class Aws::KMS::Errors::NotFoundException
end

class Aws::KMS::Errors::NotFoundException
end

class Aws::KMS::Errors::ServiceError
end

class Aws::KMS::Errors::ServiceError
end

class Aws::KMS::Errors::TagException
end

class Aws::KMS::Errors::TagException
end

class Aws::KMS::Errors::UnsupportedOperationException
end

class Aws::KMS::Errors::UnsupportedOperationException
end

module Aws::KMS::Errors
  extend ::Aws::Errors::DynamicErrors
end

class Aws::KMS::Resource
  def client(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::KMS::Resource
end

module Aws::KMS::Types
end

class Aws::KMS::Types::AliasListEntry
  include ::Aws::Structure
end

class Aws::KMS::Types::AliasListEntry
end

class Aws::KMS::Types::AlreadyExistsException
  include ::Aws::Structure
end

class Aws::KMS::Types::AlreadyExistsException
end

class Aws::KMS::Types::CancelKeyDeletionRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::CancelKeyDeletionRequest
end

class Aws::KMS::Types::CancelKeyDeletionResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::CancelKeyDeletionResponse
end

class Aws::KMS::Types::CloudHsmClusterInUseException
  include ::Aws::Structure
end

class Aws::KMS::Types::CloudHsmClusterInUseException
end

class Aws::KMS::Types::CloudHsmClusterInvalidConfigurationException
  include ::Aws::Structure
end

class Aws::KMS::Types::CloudHsmClusterInvalidConfigurationException
end

class Aws::KMS::Types::CloudHsmClusterNotActiveException
  include ::Aws::Structure
end

class Aws::KMS::Types::CloudHsmClusterNotActiveException
end

class Aws::KMS::Types::CloudHsmClusterNotFoundException
  include ::Aws::Structure
end

class Aws::KMS::Types::CloudHsmClusterNotFoundException
end

class Aws::KMS::Types::CloudHsmClusterNotRelatedException
  include ::Aws::Structure
end

class Aws::KMS::Types::CloudHsmClusterNotRelatedException
end

class Aws::KMS::Types::ConnectCustomKeyStoreRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ConnectCustomKeyStoreRequest
end

class Aws::KMS::Types::ConnectCustomKeyStoreResponse
end

class Aws::KMS::Types::ConnectCustomKeyStoreResponse
end

class Aws::KMS::Types::CreateAliasRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::CreateAliasRequest
end

class Aws::KMS::Types::CreateCustomKeyStoreRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::CreateCustomKeyStoreRequest
end

class Aws::KMS::Types::CreateCustomKeyStoreResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::CreateCustomKeyStoreResponse
end

class Aws::KMS::Types::CreateGrantRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::CreateGrantRequest
end

class Aws::KMS::Types::CreateGrantResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::CreateGrantResponse
end

class Aws::KMS::Types::CreateKeyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::CreateKeyRequest
end

class Aws::KMS::Types::CreateKeyResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::CreateKeyResponse
end

class Aws::KMS::Types::CustomKeyStoreHasCMKsException
  include ::Aws::Structure
end

class Aws::KMS::Types::CustomKeyStoreHasCMKsException
end

class Aws::KMS::Types::CustomKeyStoreInvalidStateException
  include ::Aws::Structure
end

class Aws::KMS::Types::CustomKeyStoreInvalidStateException
end

class Aws::KMS::Types::CustomKeyStoreNameInUseException
  include ::Aws::Structure
end

class Aws::KMS::Types::CustomKeyStoreNameInUseException
end

class Aws::KMS::Types::CustomKeyStoreNotFoundException
  include ::Aws::Structure
end

class Aws::KMS::Types::CustomKeyStoreNotFoundException
end

class Aws::KMS::Types::CustomKeyStoresListEntry
  include ::Aws::Structure
end

class Aws::KMS::Types::CustomKeyStoresListEntry
end

class Aws::KMS::Types::DecryptRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DecryptRequest
end

class Aws::KMS::Types::DecryptResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::DecryptResponse
end

class Aws::KMS::Types::DeleteAliasRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DeleteAliasRequest
end

class Aws::KMS::Types::DeleteCustomKeyStoreRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DeleteCustomKeyStoreRequest
end

class Aws::KMS::Types::DeleteCustomKeyStoreResponse
end

class Aws::KMS::Types::DeleteCustomKeyStoreResponse
end

class Aws::KMS::Types::DeleteImportedKeyMaterialRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DeleteImportedKeyMaterialRequest
end

class Aws::KMS::Types::DependencyTimeoutException
  include ::Aws::Structure
end

class Aws::KMS::Types::DependencyTimeoutException
end

class Aws::KMS::Types::DescribeCustomKeyStoresRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DescribeCustomKeyStoresRequest
end

class Aws::KMS::Types::DescribeCustomKeyStoresResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::DescribeCustomKeyStoresResponse
end

class Aws::KMS::Types::DescribeKeyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DescribeKeyRequest
end

class Aws::KMS::Types::DescribeKeyResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::DescribeKeyResponse
end

class Aws::KMS::Types::DisableKeyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DisableKeyRequest
end

class Aws::KMS::Types::DisableKeyRotationRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DisableKeyRotationRequest
end

class Aws::KMS::Types::DisabledException
  include ::Aws::Structure
end

class Aws::KMS::Types::DisabledException
end

class Aws::KMS::Types::DisconnectCustomKeyStoreRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::DisconnectCustomKeyStoreRequest
end

class Aws::KMS::Types::DisconnectCustomKeyStoreResponse
end

class Aws::KMS::Types::DisconnectCustomKeyStoreResponse
end

class Aws::KMS::Types::EnableKeyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::EnableKeyRequest
end

class Aws::KMS::Types::EnableKeyRotationRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::EnableKeyRotationRequest
end

class Aws::KMS::Types::EncryptRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::EncryptRequest
end

class Aws::KMS::Types::EncryptResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::EncryptResponse
end

class Aws::KMS::Types::ExpiredImportTokenException
  include ::Aws::Structure
end

class Aws::KMS::Types::ExpiredImportTokenException
end

class Aws::KMS::Types::GenerateDataKeyPairRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateDataKeyPairRequest
end

class Aws::KMS::Types::GenerateDataKeyPairResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateDataKeyPairResponse
end

class Aws::KMS::Types::GenerateDataKeyPairWithoutPlaintextRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateDataKeyPairWithoutPlaintextRequest
end

class Aws::KMS::Types::GenerateDataKeyPairWithoutPlaintextResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateDataKeyPairWithoutPlaintextResponse
end

class Aws::KMS::Types::GenerateDataKeyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateDataKeyRequest
end

class Aws::KMS::Types::GenerateDataKeyResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateDataKeyResponse
end

class Aws::KMS::Types::GenerateDataKeyWithoutPlaintextRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateDataKeyWithoutPlaintextRequest
end

class Aws::KMS::Types::GenerateDataKeyWithoutPlaintextResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateDataKeyWithoutPlaintextResponse
end

class Aws::KMS::Types::GenerateRandomRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateRandomRequest
end

class Aws::KMS::Types::GenerateRandomResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GenerateRandomResponse
end

class Aws::KMS::Types::GetKeyPolicyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GetKeyPolicyRequest
end

class Aws::KMS::Types::GetKeyPolicyResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GetKeyPolicyResponse
end

class Aws::KMS::Types::GetKeyRotationStatusRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GetKeyRotationStatusRequest
end

class Aws::KMS::Types::GetKeyRotationStatusResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GetKeyRotationStatusResponse
end

class Aws::KMS::Types::GetParametersForImportRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GetParametersForImportRequest
end

class Aws::KMS::Types::GetParametersForImportResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GetParametersForImportResponse
end

class Aws::KMS::Types::GetPublicKeyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::GetPublicKeyRequest
end

class Aws::KMS::Types::GetPublicKeyResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::GetPublicKeyResponse
end

class Aws::KMS::Types::GrantConstraints
  include ::Aws::Structure
end

class Aws::KMS::Types::GrantConstraints
end

class Aws::KMS::Types::GrantListEntry
  include ::Aws::Structure
end

class Aws::KMS::Types::GrantListEntry
end

class Aws::KMS::Types::ImportKeyMaterialRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ImportKeyMaterialRequest
end

class Aws::KMS::Types::ImportKeyMaterialResponse
end

class Aws::KMS::Types::ImportKeyMaterialResponse
end

class Aws::KMS::Types::IncorrectKeyException
  include ::Aws::Structure
end

class Aws::KMS::Types::IncorrectKeyException
end

class Aws::KMS::Types::IncorrectKeyMaterialException
  include ::Aws::Structure
end

class Aws::KMS::Types::IncorrectKeyMaterialException
end

class Aws::KMS::Types::IncorrectTrustAnchorException
  include ::Aws::Structure
end

class Aws::KMS::Types::IncorrectTrustAnchorException
end

class Aws::KMS::Types::InvalidAliasNameException
  include ::Aws::Structure
end

class Aws::KMS::Types::InvalidAliasNameException
end

class Aws::KMS::Types::InvalidArnException
  include ::Aws::Structure
end

class Aws::KMS::Types::InvalidArnException
end

class Aws::KMS::Types::InvalidCiphertextException
  include ::Aws::Structure
end

class Aws::KMS::Types::InvalidCiphertextException
end

class Aws::KMS::Types::InvalidGrantIdException
  include ::Aws::Structure
end

class Aws::KMS::Types::InvalidGrantIdException
end

class Aws::KMS::Types::InvalidGrantTokenException
  include ::Aws::Structure
end

class Aws::KMS::Types::InvalidGrantTokenException
end

class Aws::KMS::Types::InvalidImportTokenException
  include ::Aws::Structure
end

class Aws::KMS::Types::InvalidImportTokenException
end

class Aws::KMS::Types::InvalidKeyUsageException
  include ::Aws::Structure
end

class Aws::KMS::Types::InvalidKeyUsageException
end

class Aws::KMS::Types::InvalidMarkerException
  include ::Aws::Structure
end

class Aws::KMS::Types::InvalidMarkerException
end

class Aws::KMS::Types::KMSInternalException
  include ::Aws::Structure
end

class Aws::KMS::Types::KMSInternalException
end

class Aws::KMS::Types::KMSInvalidSignatureException
  include ::Aws::Structure
end

class Aws::KMS::Types::KMSInvalidSignatureException
end

class Aws::KMS::Types::KMSInvalidStateException
  include ::Aws::Structure
end

class Aws::KMS::Types::KMSInvalidStateException
end

class Aws::KMS::Types::KeyListEntry
  include ::Aws::Structure
end

class Aws::KMS::Types::KeyListEntry
end

class Aws::KMS::Types::KeyMetadata
  include ::Aws::Structure
end

class Aws::KMS::Types::KeyMetadata
end

class Aws::KMS::Types::KeyUnavailableException
  include ::Aws::Structure
end

class Aws::KMS::Types::KeyUnavailableException
end

class Aws::KMS::Types::LimitExceededException
  include ::Aws::Structure
end

class Aws::KMS::Types::LimitExceededException
end

class Aws::KMS::Types::ListAliasesRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ListAliasesRequest
end

class Aws::KMS::Types::ListAliasesResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::ListAliasesResponse
end

class Aws::KMS::Types::ListGrantsRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ListGrantsRequest
end

class Aws::KMS::Types::ListGrantsResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::ListGrantsResponse
end

class Aws::KMS::Types::ListKeyPoliciesRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ListKeyPoliciesRequest
end

class Aws::KMS::Types::ListKeyPoliciesResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::ListKeyPoliciesResponse
end

class Aws::KMS::Types::ListKeysRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ListKeysRequest
end

class Aws::KMS::Types::ListKeysResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::ListKeysResponse
end

class Aws::KMS::Types::ListResourceTagsRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ListResourceTagsRequest
end

class Aws::KMS::Types::ListResourceTagsResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::ListResourceTagsResponse
end

class Aws::KMS::Types::ListRetirableGrantsRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ListRetirableGrantsRequest
end

class Aws::KMS::Types::MalformedPolicyDocumentException
  include ::Aws::Structure
end

class Aws::KMS::Types::MalformedPolicyDocumentException
end

class Aws::KMS::Types::NotFoundException
  include ::Aws::Structure
end

class Aws::KMS::Types::NotFoundException
end

class Aws::KMS::Types::PutKeyPolicyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::PutKeyPolicyRequest
end

class Aws::KMS::Types::ReEncryptRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ReEncryptRequest
end

class Aws::KMS::Types::ReEncryptResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::ReEncryptResponse
end

class Aws::KMS::Types::RetireGrantRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::RetireGrantRequest
end

class Aws::KMS::Types::RevokeGrantRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::RevokeGrantRequest
end

class Aws::KMS::Types::ScheduleKeyDeletionRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::ScheduleKeyDeletionRequest
end

class Aws::KMS::Types::ScheduleKeyDeletionResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::ScheduleKeyDeletionResponse
end

class Aws::KMS::Types::SignRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::SignRequest
end

class Aws::KMS::Types::SignResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::SignResponse
end

class Aws::KMS::Types::Tag
  include ::Aws::Structure
end

class Aws::KMS::Types::Tag
end

class Aws::KMS::Types::TagException
  include ::Aws::Structure
end

class Aws::KMS::Types::TagException
end

class Aws::KMS::Types::TagResourceRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::TagResourceRequest
end

class Aws::KMS::Types::UnsupportedOperationException
  include ::Aws::Structure
end

class Aws::KMS::Types::UnsupportedOperationException
end

class Aws::KMS::Types::UntagResourceRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::UntagResourceRequest
end

class Aws::KMS::Types::UpdateAliasRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::UpdateAliasRequest
end

class Aws::KMS::Types::UpdateCustomKeyStoreRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::UpdateCustomKeyStoreRequest
end

class Aws::KMS::Types::UpdateCustomKeyStoreResponse
end

class Aws::KMS::Types::UpdateCustomKeyStoreResponse
end

class Aws::KMS::Types::UpdateKeyDescriptionRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::UpdateKeyDescriptionRequest
end

class Aws::KMS::Types::VerifyRequest
  include ::Aws::Structure
end

class Aws::KMS::Types::VerifyRequest
end

class Aws::KMS::Types::VerifyResponse
  include ::Aws::Structure
end

class Aws::KMS::Types::VerifyResponse
end

module Aws::KMS::Types
end

module Aws::KMS
end

module Aws::Log
end

class Aws::Log::Formatter
  def format(response); end

  def initialize(pattern, options=T.unsafe(nil)); end

  def method_missing(method_name, *args); end

  def pattern(); end
end

class Aws::Log::Formatter
  def self.colored(options=T.unsafe(nil)); end

  def self.default(options=T.unsafe(nil)); end

  def self.short(options=T.unsafe(nil)); end
end

class Aws::Log::ParamFilter
  def filter(value); end

  def initialize(options=T.unsafe(nil)); end
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::Log::ParamFilter
end

class Aws::Log::ParamFormatter
  def initialize(options=T.unsafe(nil)); end

  def summarize(value); end
  MAX_STRING_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::Log::ParamFormatter
end

module Aws::Log
end

module Aws::PageableResponse
  def each(&block); end

  def each_page(&block); end

  def last_page?(); end

  def next_page(params=T.unsafe(nil)); end

  def next_page?(); end

  def pager(); end

  def pager=(pager); end
end

class Aws::PageableResponse::LastPageError
  def initialize(response); end

  def response(); end
end

class Aws::PageableResponse::LastPageError
end

module Aws::PageableResponse::UnsafeEnumerableMethods
  def count(); end

  def respond_to?(method_name, *args); end

  def to_h(); end
end

module Aws::PageableResponse::UnsafeEnumerableMethods
end

module Aws::PageableResponse
  def self.extended(base); end
end

class Aws::Pager
  def initialize(options); end

  def limit_key(); end

  def next_tokens(response); end

  def prev_tokens(response); end

  def truncated?(response); end
end

class Aws::Pager::NullPager
  def limit_key(); end

  def next_tokens(); end

  def prev_tokens(); end

  def truncated?(response); end
end

class Aws::Pager::NullPager
end

class Aws::Pager
end

class Aws::ParamConverter
  include ::Seahorse::Model::Shapes
  def close_opened_files(); end

  def convert(params); end

  def initialize(rules); end

  def opened_files(); end
end

class Aws::ParamConverter
  def self.add(shape_class, value_class, converter=T.unsafe(nil), &block); end

  def self.c(shape, value, instance=T.unsafe(nil)); end

  def self.convert(shape, params); end

  def self.ensure_open(file, converter); end
end

class Aws::ParamValidator
  include ::Seahorse::Model::Shapes
  def initialize(rules, options=T.unsafe(nil)); end

  def validate!(params); end
  EXPECTED_GOT = ::T.let(nil, ::T.untyped)
end

class Aws::ParamValidator
  def self.validate!(rules, params); end
end

module Aws::Partitions
end

class Aws::Partitions::EndpointProvider
  def dns_suffix_for(region); end

  def initialize(rules); end

  def resolve(region, service, sts_regional_endpoints); end

  def signing_region(region, service); end
  STS_LEGACY_REGIONS = ::T.let(nil, ::T.untyped)
end

class Aws::Partitions::EndpointProvider
  def self.dns_suffix_for(region); end

  def self.resolve(region, service, sts_regional_endpoints=T.unsafe(nil)); end

  def self.signing_region(region, service); end
end

class Aws::Partitions::Partition
  def initialize(options=T.unsafe(nil)); end

  def name(); end

  def region(region_name); end

  def region?(region_name); end

  def regions(); end

  def service(service_name); end

  def service?(service_name); end

  def services(); end
end

class Aws::Partitions::Partition
  def self.build(partition); end
end

class Aws::Partitions::PartitionList
  include ::Enumerable
  def add_partition(partition); end

  def clear(); end

  def each(&block); end

  def partition(partition_name); end

  def partitions(); end
end

class Aws::Partitions::PartitionList
  def self.build(partitions); end
end

class Aws::Partitions::Region
  def description(); end

  def initialize(options=T.unsafe(nil)); end

  def name(); end

  def partition_name(); end

  def services(); end
end

class Aws::Partitions::Region
  def self.build(region_name, region, partition); end
end

class Aws::Partitions::Service
  def initialize(options=T.unsafe(nil)); end

  def name(); end

  def partition_name(); end

  def partition_region(); end

  def regionalized?(); end

  def regions(); end
end

class Aws::Partitions::Service
  def self.build(service_name, service, partition); end
end

module Aws::Partitions
  extend ::Enumerable
  def self.add(new_partitions); end

  def self.clear(); end

  def self.default_partition_list(); end

  def self.defaults(); end

  def self.each(&block); end

  def self.partition(name); end

  def self.partitions(); end

  def self.service_ids(); end
end

module Aws::Plugins
end

class Aws::Plugins::ClientMetricsPlugin
end

class Aws::Plugins::ClientMetricsPlugin::Handler
end

class Aws::Plugins::ClientMetricsPlugin::Handler
end

class Aws::Plugins::ClientMetricsPlugin
  def self.resolve_client_id(cfg); end

  def self.resolve_client_side_monitoring(cfg); end

  def self.resolve_client_side_monitoring_host(cfg); end

  def self.resolve_client_side_monitoring_port(cfg); end

  def self.resolve_publisher(cfg); end
end

class Aws::Plugins::ClientMetricsSendPlugin
end

class Aws::Plugins::ClientMetricsSendPlugin::AttemptHandler
end

class Aws::Plugins::ClientMetricsSendPlugin::AttemptHandler
end

class Aws::Plugins::ClientMetricsSendPlugin::LatencyHandler
end

class Aws::Plugins::ClientMetricsSendPlugin::LatencyHandler
end

class Aws::Plugins::ClientMetricsSendPlugin
end

class Aws::Plugins::CredentialsConfiguration
end

class Aws::Plugins::CredentialsConfiguration
end

class Aws::Plugins::EndpointDiscovery
end

class Aws::Plugins::EndpointDiscovery::Handler
end

class Aws::Plugins::EndpointDiscovery::Handler
end

class Aws::Plugins::EndpointDiscovery
  def self.resolve_endpoint_discovery(cfg); end
end

class Aws::Plugins::EndpointPattern
end

class Aws::Plugins::EndpointPattern::Handler
end

class Aws::Plugins::EndpointPattern::Handler
end

class Aws::Plugins::EndpointPattern
end

class Aws::Plugins::EventStreamConfiguration
end

class Aws::Plugins::EventStreamConfiguration
end

class Aws::Plugins::GlobalConfiguration
end

class Aws::Plugins::GlobalConfiguration
  def self.add_identifier(identifier); end

  def self.identifiers(); end
end

class Aws::Plugins::HelpfulSocketErrors
end

class Aws::Plugins::HelpfulSocketErrors::Handler
end

class Aws::Plugins::HelpfulSocketErrors::Handler
end

class Aws::Plugins::HelpfulSocketErrors
end

class Aws::Plugins::IdempotencyToken
end

class Aws::Plugins::IdempotencyToken::Handler
end

class Aws::Plugins::IdempotencyToken::Handler
end

class Aws::Plugins::IdempotencyToken
end

class Aws::Plugins::JsonvalueConverter
end

class Aws::Plugins::JsonvalueConverter::Handler
end

class Aws::Plugins::JsonvalueConverter::Handler
end

class Aws::Plugins::JsonvalueConverter
end

class Aws::Plugins::Logging
end

class Aws::Plugins::Logging::Handler
end

class Aws::Plugins::Logging::Handler
end

class Aws::Plugins::Logging
end

class Aws::Plugins::ParamConverter
end

class Aws::Plugins::ParamConverter::Handler
end

class Aws::Plugins::ParamConverter::Handler
end

class Aws::Plugins::ParamConverter
end

class Aws::Plugins::ParamValidator
end

class Aws::Plugins::ParamValidator::Handler
end

class Aws::Plugins::ParamValidator::Handler
end

class Aws::Plugins::ParamValidator
end

module Aws::Plugins::Protocols
end

class Aws::Plugins::Protocols::JsonRpc
end

class Aws::Plugins::Protocols::JsonRpc
end

class Aws::Plugins::Protocols::Query
end

class Aws::Plugins::Protocols::Query
end

class Aws::Plugins::Protocols::RestXml
end

class Aws::Plugins::Protocols::RestXml
end

module Aws::Plugins::Protocols
end

class Aws::Plugins::RegionalEndpoint
  MISSING_REGION = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RegionalEndpoint
  def self.resolve_region(cfg); end
end

class Aws::Plugins::ResponsePaging
end

class Aws::Plugins::ResponsePaging::Handler
end

class Aws::Plugins::ResponsePaging::Handler
end

class Aws::Plugins::ResponsePaging
end

module Aws::Plugins::Retries
end

class Aws::Plugins::Retries::ClientRateLimiter
  def token_bucket_acquire(amount, wait_to_fill=T.unsafe(nil)); end

  def update_sending_rate(is_throttling_error); end
  BETA = ::T.let(nil, ::T.untyped)
  MIN_CAPACITY = ::T.let(nil, ::T.untyped)
  MIN_FILL_RATE = ::T.let(nil, ::T.untyped)
  SCALE_CONSTANT = ::T.let(nil, ::T.untyped)
  SMOOTH = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ClientRateLimiter
end

class Aws::Plugins::Retries::ClockSkew
  def clock_correction(endpoint); end

  def clock_skewed?(context); end

  def estimated_skew(endpoint); end

  def update_clock_correction(context); end

  def update_estimated_skew(context); end
  CLOCK_SKEW_THRESHOLD = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ClockSkew
end

class Aws::Plugins::Retries::ErrorInspector
  def checksum?(); end

  def clock_skew?(context); end

  def endpoint_discovery?(context); end

  def expired_credentials?(); end

  def initialize(error, http_status_code); end

  def modeled_retryable?(); end

  def modeled_throttling?(); end

  def networking?(); end

  def retryable?(context); end

  def server?(); end

  def throttling_error?(); end
  CHECKSUM_ERRORS = ::T.let(nil, ::T.untyped)
  CLOCK_SKEW_ERRORS = ::T.let(nil, ::T.untyped)
  EXPIRED_CREDS = ::T.let(nil, ::T.untyped)
  NETWORKING_ERRORS = ::T.let(nil, ::T.untyped)
  THROTTLING_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ErrorInspector
end

class Aws::Plugins::Retries::RetryQuota
  def checkout_capacity(error_inspector); end

  def initialize(opts=T.unsafe(nil)); end

  def release(capacity_amount); end
  INITIAL_RETRY_TOKENS = ::T.let(nil, ::T.untyped)
  NO_RETRY_INCREMENT = ::T.let(nil, ::T.untyped)
  RETRY_COST = ::T.let(nil, ::T.untyped)
  TIMEOUT_RETRY_COST = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::RetryQuota
end

module Aws::Plugins::Retries
end

class Aws::Plugins::RetryErrors
  DEFAULT_BACKOFF = ::T.let(nil, ::T.untyped)
  EQUAL_JITTER = ::T.let(nil, ::T.untyped)
  FULL_JITTER = ::T.let(nil, ::T.untyped)
  JITTERS = ::T.let(nil, ::T.untyped)
  NO_JITTER = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RetryErrors::Handler
  MAX_BACKOFF = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RetryErrors::Handler
end

class Aws::Plugins::RetryErrors::LegacyHandler
end

class Aws::Plugins::RetryErrors::LegacyHandler
end

class Aws::Plugins::RetryErrors
  def self.resolve_adaptive_retry_wait_to_fill(cfg); end

  def self.resolve_correct_clock_skew(cfg); end

  def self.resolve_max_attempts(cfg); end

  def self.resolve_retry_mode(cfg); end
end

class Aws::Plugins::SignatureV4
  def add_handlers(handlers, cfg); end
end

class Aws::Plugins::SignatureV4::Handler
end

class Aws::Plugins::SignatureV4::Handler
end

class Aws::Plugins::SignatureV4::MissingCredentialsSigner
  def sign_request(*args); end
end

class Aws::Plugins::SignatureV4::MissingCredentialsSigner
end

class Aws::Plugins::SignatureV4
  def self.apply_authtype(context); end

  def self.apply_signature(options=T.unsafe(nil)); end

  def self.build_signer(cfg); end
end

class Aws::Plugins::StubResponses
end

class Aws::Plugins::StubResponses::Handler
  def apply_stub(stub, response, async_mode=T.unsafe(nil)); end

  def signal_error(error, http_resp); end

  def signal_http(stub, http_resp, async_mode=T.unsafe(nil)); end
end

class Aws::Plugins::StubResponses::Handler
end

class Aws::Plugins::StubResponses
end

class Aws::Plugins::TransferEncoding
end

class Aws::Plugins::TransferEncoding::Handler
end

class Aws::Plugins::TransferEncoding::Handler
end

class Aws::Plugins::TransferEncoding
end

class Aws::Plugins::UserAgent
end

class Aws::Plugins::UserAgent::Handler
  def set_user_agent(context); end
end

class Aws::Plugins::UserAgent::Handler
end

class Aws::Plugins::UserAgent
end

module Aws::Plugins
end

class Aws::ProcessCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def initialize(process); end
end

class Aws::ProcessCredentials
end

module Aws::Query
end

class Aws::Query::EC2ParamBuilder
  include ::Seahorse::Model::Shapes
  def apply(ref, params); end

  def initialize(param_list); end

  def params(); end
end

class Aws::Query::EC2ParamBuilder
end

class Aws::Query::Handler
  include ::Seahorse::Model::Shapes
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  METADATA_REF = ::T.let(nil, ::T.untyped)
end

class Aws::Query::Handler::METADATA_STRUCT
  def request_id(); end

  def request_id=(_); end
end

class Aws::Query::Handler::METADATA_STRUCT
  def self.[](*_); end

  def self.members(); end
end

class Aws::Query::Handler::WRAPPER_STRUCT
  def response_metadata(); end

  def response_metadata=(_); end

  def result(); end

  def result=(_); end
end

class Aws::Query::Handler::WRAPPER_STRUCT
  def self.[](*_); end

  def self.members(); end
end

class Aws::Query::Handler
end

class Aws::Query::Param
  def ==(other); end

  def initialize(name, value=T.unsafe(nil)); end

  def name(); end

  def value(); end
end

class Aws::Query::Param
end

class Aws::Query::ParamBuilder
  include ::Seahorse::Model::Shapes
  def apply(ref, params); end

  def initialize(param_list); end

  def params(); end
end

class Aws::Query::ParamBuilder
end

class Aws::Query::ParamList
  include ::Enumerable
  def [](param_name); end

  def []=(param_name, param_value=T.unsafe(nil)); end

  def delete(param_name); end

  def each(&block); end

  def empty?(); end

  def set(param_name, param_value=T.unsafe(nil)); end

  def to_a(); end

  def to_io(); end
end

class Aws::Query::ParamList::IoWrapper
  def initialize(param_list); end

  def param_list(); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end
end

class Aws::Query::ParamList::IoWrapper
end

class Aws::Query::ParamList
end

module Aws::Query
end

module Aws::RefreshingCredentials
  def credentials(); end

  def expiration(); end

  def initialize(options=T.unsafe(nil)); end

  def refresh!(); end
end

module Aws::RefreshingCredentials
end

module Aws::Resources
end

class Aws::Resources::Collection
  include ::Enumerable
  def [](*args, &block); end

  def batches(); end

  def each(&block); end

  def first(count=T.unsafe(nil)); end

  def initialize(batches, options=T.unsafe(nil)); end

  def length(); end

  def limit(limit); end

  def size(); end
end

class Aws::Resources::Collection
  extend ::Aws::Deprecations
end

module Aws::Resources
end

module Aws::Rest
end

class Aws::Rest::Handler
end

class Aws::Rest::Handler
end

module Aws::Rest::Request
end

class Aws::Rest::Request::Body
  include ::Seahorse::Model::Shapes
  def apply(http_req, params); end

  def initialize(serializer_class, rules); end
end

class Aws::Rest::Request::Body
end

class Aws::Rest::Request::Builder
  def apply(context); end
end

class Aws::Rest::Request::Builder
end

class Aws::Rest::Request::Endpoint
  def initialize(rules, request_uri_pattern); end

  def uri(base_uri, params); end
end

class Aws::Rest::Request::Endpoint
end

class Aws::Rest::Request::Headers
  include ::Seahorse::Model::Shapes
  def apply(http_req, params); end

  def initialize(rules); end
end

class Aws::Rest::Request::Headers
end

class Aws::Rest::Request::QuerystringBuilder
  include ::Seahorse::Model::Shapes
  def build(params); end
end

class Aws::Rest::Request::QuerystringBuilder
end

module Aws::Rest::Request
end

module Aws::Rest::Response
end

class Aws::Rest::Response::Body
  include ::Seahorse::Model::Shapes
  def apply(body, data); end

  def initialize(parser_class, rules); end
end

class Aws::Rest::Response::Body
end

class Aws::Rest::Response::Headers
  include ::Seahorse::Model::Shapes
  def apply(http_resp, target); end

  def cast_value(ref, value); end

  def extract_header_map(headers, name, ref, data); end

  def extract_header_value(headers, name, ref, data); end

  def extract_json_trait(value); end

  def initialize(rules); end
end

class Aws::Rest::Response::Headers
end

class Aws::Rest::Response::Parser
  def apply(response); end
end

class Aws::Rest::Response::Parser
end

class Aws::Rest::Response::StatusCode
  def apply(http_resp, data); end

  def initialize(rules); end
end

class Aws::Rest::Response::StatusCode
end

module Aws::Rest::Response
end

module Aws::Rest
end

module Aws::S3
  BUCKET_REGIONS = ::T.let(nil, ::T.untyped)
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Bucket
  def acl(); end

  def clear!(); end

  def client(); end

  def cors(); end

  def create(options=T.unsafe(nil)); end

  def creation_date(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete!(options=T.unsafe(nil)); end

  def delete_objects(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def exists?(options=T.unsafe(nil)); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def lifecycle(); end

  def lifecycle_configuration(); end

  def load(); end

  def logging(); end

  def multipart_uploads(options=T.unsafe(nil)); end

  def name(); end

  def notification(); end

  def object(key); end

  def object_versions(options=T.unsafe(nil)); end

  def objects(options=T.unsafe(nil)); end

  def policy(); end

  def presigned_post(options=T.unsafe(nil)); end

  def put_object(options=T.unsafe(nil)); end

  def reload(); end

  def request_payment(); end

  def tagging(); end

  def url(options=T.unsafe(nil)); end

  def versioning(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end

  def wait_until_not_exists(options=T.unsafe(nil), &block); end

  def website(); end
end

class Aws::S3::Bucket::Collection
end

class Aws::S3::Bucket::Collection
end

class Aws::S3::Bucket
  extend ::Aws::Deprecations
end

class Aws::S3::BucketAcl
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def grants(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def owner(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketAcl::Collection
end

class Aws::S3::BucketAcl::Collection
end

class Aws::S3::BucketAcl
  extend ::Aws::Deprecations
end

class Aws::S3::BucketCors
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def cors_rules(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketCors::Collection
end

class Aws::S3::BucketCors::Collection
end

class Aws::S3::BucketCors
  extend ::Aws::Deprecations
end

class Aws::S3::BucketLifecycle
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def rules(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketLifecycle::Collection
end

class Aws::S3::BucketLifecycle::Collection
end

class Aws::S3::BucketLifecycle
  extend ::Aws::Deprecations
end

class Aws::S3::BucketLifecycleConfiguration
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def rules(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketLifecycleConfiguration::Collection
end

class Aws::S3::BucketLifecycleConfiguration::Collection
end

class Aws::S3::BucketLifecycleConfiguration
  extend ::Aws::Deprecations
end

class Aws::S3::BucketLogging
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def logging_enabled(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketLogging::Collection
end

class Aws::S3::BucketLogging::Collection
end

class Aws::S3::BucketLogging
  extend ::Aws::Deprecations
end

class Aws::S3::BucketNotification
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def lambda_function_configurations(); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def queue_configurations(); end

  def reload(); end

  def topic_configurations(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketNotification::Collection
end

class Aws::S3::BucketNotification::Collection
end

class Aws::S3::BucketNotification
  extend ::Aws::Deprecations
end

class Aws::S3::BucketPolicy
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def policy(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketPolicy::Collection
end

class Aws::S3::BucketPolicy::Collection
end

class Aws::S3::BucketPolicy
  extend ::Aws::Deprecations
end

class Aws::S3::BucketRegionCache
  def [](bucket_name); end

  def []=(bucket_name, region_name); end

  def bucket_added(&block); end

  def clear(); end

  def to_h(); end

  def to_hash(); end
end

class Aws::S3::BucketRegionCache
end

class Aws::S3::BucketRequestPayment
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def payer(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketRequestPayment::Collection
end

class Aws::S3::BucketRequestPayment::Collection
end

class Aws::S3::BucketRequestPayment
  extend ::Aws::Deprecations
end

class Aws::S3::BucketTagging
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def tag_set(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketTagging::Collection
end

class Aws::S3::BucketTagging::Collection
end

class Aws::S3::BucketTagging
  extend ::Aws::Deprecations
end

class Aws::S3::BucketVersioning
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def enable(options=T.unsafe(nil)); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def mfa_delete(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def status(); end

  def suspend(options=T.unsafe(nil)); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketVersioning::Collection
end

class Aws::S3::BucketVersioning::Collection
end

class Aws::S3::BucketVersioning
  extend ::Aws::Deprecations
end

class Aws::S3::BucketWebsite
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def error_document(); end

  def identifiers(*args, &block); end

  def index_document(); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def redirect_all_requests_to(); end

  def reload(); end

  def routing_rules(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketWebsite::Collection
end

class Aws::S3::BucketWebsite::Collection
end

class Aws::S3::BucketWebsite
  extend ::Aws::Deprecations
end

class Aws::S3::Client
  include ::Aws::ClientStubs
  def abort_multipart_upload(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def complete_multipart_upload(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def copy_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_bucket(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_multipart_upload(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_analytics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_cors(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_encryption(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_inventory_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_lifecycle(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_metrics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_replication(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_website(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_object_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_objects(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_public_access_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_accelerate_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_analytics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_cors(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_encryption(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_inventory_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_lifecycle(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_lifecycle_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_location(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_logging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_metrics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_notification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_notification_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_policy(params=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def get_bucket_policy_status(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_replication(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_request_payment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_versioning(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_website(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object(params=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def get_object_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_legal_hold(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_lock_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_retention(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_torrent(params=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def get_public_access_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def head_bucket(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def head_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(*args); end

  def list_bucket_analytics_configurations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_bucket_inventory_configurations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_bucket_metrics_configurations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_buckets(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_multipart_uploads(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_object_versions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_objects(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_objects_v2(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_parts(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_accelerate_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_analytics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_cors(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_encryption(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_inventory_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_lifecycle(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_lifecycle_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_logging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_metrics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_notification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_notification_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_replication(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_request_payment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_versioning(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_website(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_legal_hold(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_lock_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_retention(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_public_access_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def restore_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_object_content(params=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def upload_part(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def upload_part_copy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def wait_until(waiter_name, params=T.unsafe(nil), options=T.unsafe(nil)); end

  def waiter_names(); end
end

class Aws::S3::Client
  def self.errors_module(); end

  def self.identifier(); end
end

module Aws::S3::ClientApi
  include ::Seahorse::Model
  API = ::T.let(nil, ::T.untyped)
  AbortDate = ::T.let(nil, ::T.untyped)
  AbortIncompleteMultipartUpload = ::T.let(nil, ::T.untyped)
  AbortMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  AbortMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  AbortRuleId = ::T.let(nil, ::T.untyped)
  AccelerateConfiguration = ::T.let(nil, ::T.untyped)
  AcceptRanges = ::T.let(nil, ::T.untyped)
  AccessControlPolicy = ::T.let(nil, ::T.untyped)
  AccessControlTranslation = ::T.let(nil, ::T.untyped)
  AccountId = ::T.let(nil, ::T.untyped)
  AllowQuotedRecordDelimiter = ::T.let(nil, ::T.untyped)
  AllowedHeader = ::T.let(nil, ::T.untyped)
  AllowedHeaders = ::T.let(nil, ::T.untyped)
  AllowedMethod = ::T.let(nil, ::T.untyped)
  AllowedMethods = ::T.let(nil, ::T.untyped)
  AllowedOrigin = ::T.let(nil, ::T.untyped)
  AllowedOrigins = ::T.let(nil, ::T.untyped)
  AnalyticsAndOperator = ::T.let(nil, ::T.untyped)
  AnalyticsConfiguration = ::T.let(nil, ::T.untyped)
  AnalyticsConfigurationList = ::T.let(nil, ::T.untyped)
  AnalyticsExportDestination = ::T.let(nil, ::T.untyped)
  AnalyticsFilter = ::T.let(nil, ::T.untyped)
  AnalyticsId = ::T.let(nil, ::T.untyped)
  AnalyticsS3BucketDestination = ::T.let(nil, ::T.untyped)
  AnalyticsS3ExportFileFormat = ::T.let(nil, ::T.untyped)
  Body = ::T.let(nil, ::T.untyped)
  Bucket = ::T.let(nil, ::T.untyped)
  BucketAccelerateStatus = ::T.let(nil, ::T.untyped)
  BucketAlreadyExists = ::T.let(nil, ::T.untyped)
  BucketAlreadyOwnedByYou = ::T.let(nil, ::T.untyped)
  BucketCannedACL = ::T.let(nil, ::T.untyped)
  BucketLifecycleConfiguration = ::T.let(nil, ::T.untyped)
  BucketLocationConstraint = ::T.let(nil, ::T.untyped)
  BucketLoggingStatus = ::T.let(nil, ::T.untyped)
  BucketLogsPermission = ::T.let(nil, ::T.untyped)
  BucketName = ::T.let(nil, ::T.untyped)
  BucketVersioningStatus = ::T.let(nil, ::T.untyped)
  Buckets = ::T.let(nil, ::T.untyped)
  BypassGovernanceRetention = ::T.let(nil, ::T.untyped)
  BytesProcessed = ::T.let(nil, ::T.untyped)
  BytesReturned = ::T.let(nil, ::T.untyped)
  BytesScanned = ::T.let(nil, ::T.untyped)
  CORSConfiguration = ::T.let(nil, ::T.untyped)
  CORSRule = ::T.let(nil, ::T.untyped)
  CORSRules = ::T.let(nil, ::T.untyped)
  CSVInput = ::T.let(nil, ::T.untyped)
  CSVOutput = ::T.let(nil, ::T.untyped)
  CacheControl = ::T.let(nil, ::T.untyped)
  CloudFunction = ::T.let(nil, ::T.untyped)
  CloudFunctionConfiguration = ::T.let(nil, ::T.untyped)
  CloudFunctionInvocationRole = ::T.let(nil, ::T.untyped)
  Code = ::T.let(nil, ::T.untyped)
  Comments = ::T.let(nil, ::T.untyped)
  CommonPrefix = ::T.let(nil, ::T.untyped)
  CommonPrefixList = ::T.let(nil, ::T.untyped)
  CompleteMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  CompleteMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  CompletedMultipartUpload = ::T.let(nil, ::T.untyped)
  CompletedPart = ::T.let(nil, ::T.untyped)
  CompletedPartList = ::T.let(nil, ::T.untyped)
  CompressionType = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  ConfirmRemoveSelfBucketAccess = ::T.let(nil, ::T.untyped)
  ContentDisposition = ::T.let(nil, ::T.untyped)
  ContentEncoding = ::T.let(nil, ::T.untyped)
  ContentLanguage = ::T.let(nil, ::T.untyped)
  ContentLength = ::T.let(nil, ::T.untyped)
  ContentMD5 = ::T.let(nil, ::T.untyped)
  ContentRange = ::T.let(nil, ::T.untyped)
  ContentType = ::T.let(nil, ::T.untyped)
  ContinuationEvent = ::T.let(nil, ::T.untyped)
  CopyObjectOutput = ::T.let(nil, ::T.untyped)
  CopyObjectRequest = ::T.let(nil, ::T.untyped)
  CopyObjectResult = ::T.let(nil, ::T.untyped)
  CopyPartResult = ::T.let(nil, ::T.untyped)
  CopySource = ::T.let(nil, ::T.untyped)
  CopySourceIfMatch = ::T.let(nil, ::T.untyped)
  CopySourceIfModifiedSince = ::T.let(nil, ::T.untyped)
  CopySourceIfNoneMatch = ::T.let(nil, ::T.untyped)
  CopySourceIfUnmodifiedSince = ::T.let(nil, ::T.untyped)
  CopySourceRange = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerAlgorithm = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerKey = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerKeyMD5 = ::T.let(nil, ::T.untyped)
  CopySourceVersionId = ::T.let(nil, ::T.untyped)
  CreateBucketConfiguration = ::T.let(nil, ::T.untyped)
  CreateBucketOutput = ::T.let(nil, ::T.untyped)
  CreateBucketRequest = ::T.let(nil, ::T.untyped)
  CreateMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  CreateMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  CreationDate = ::T.let(nil, ::T.untyped)
  Date = ::T.let(nil, ::T.untyped)
  Days = ::T.let(nil, ::T.untyped)
  DaysAfterInitiation = ::T.let(nil, ::T.untyped)
  DefaultRetention = ::T.let(nil, ::T.untyped)
  Delete = ::T.let(nil, ::T.untyped)
  DeleteBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketCorsRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  DeleteMarker = ::T.let(nil, ::T.untyped)
  DeleteMarkerEntry = ::T.let(nil, ::T.untyped)
  DeleteMarkerReplication = ::T.let(nil, ::T.untyped)
  DeleteMarkerReplicationStatus = ::T.let(nil, ::T.untyped)
  DeleteMarkerVersionId = ::T.let(nil, ::T.untyped)
  DeleteMarkers = ::T.let(nil, ::T.untyped)
  DeleteObjectOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectRequest = ::T.let(nil, ::T.untyped)
  DeleteObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  DeleteObjectsOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectsRequest = ::T.let(nil, ::T.untyped)
  DeletePublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  DeletedObject = ::T.let(nil, ::T.untyped)
  DeletedObjects = ::T.let(nil, ::T.untyped)
  Delimiter = ::T.let(nil, ::T.untyped)
  Description = ::T.let(nil, ::T.untyped)
  Destination = ::T.let(nil, ::T.untyped)
  DisplayName = ::T.let(nil, ::T.untyped)
  ETag = ::T.let(nil, ::T.untyped)
  EmailAddress = ::T.let(nil, ::T.untyped)
  EnableRequestProgress = ::T.let(nil, ::T.untyped)
  EncodingType = ::T.let(nil, ::T.untyped)
  Encryption = ::T.let(nil, ::T.untyped)
  EncryptionConfiguration = ::T.let(nil, ::T.untyped)
  End = ::T.let(nil, ::T.untyped)
  EndEvent = ::T.let(nil, ::T.untyped)
  Error = ::T.let(nil, ::T.untyped)
  ErrorDocument = ::T.let(nil, ::T.untyped)
  Errors = ::T.let(nil, ::T.untyped)
  Event = ::T.let(nil, ::T.untyped)
  EventList = ::T.let(nil, ::T.untyped)
  ExistingObjectReplication = ::T.let(nil, ::T.untyped)
  ExistingObjectReplicationStatus = ::T.let(nil, ::T.untyped)
  Expiration = ::T.let(nil, ::T.untyped)
  ExpirationStatus = ::T.let(nil, ::T.untyped)
  ExpiredObjectDeleteMarker = ::T.let(nil, ::T.untyped)
  Expires = ::T.let(nil, ::T.untyped)
  ExpiresString = ::T.let(nil, ::T.untyped)
  ExposeHeader = ::T.let(nil, ::T.untyped)
  ExposeHeaders = ::T.let(nil, ::T.untyped)
  Expression = ::T.let(nil, ::T.untyped)
  ExpressionType = ::T.let(nil, ::T.untyped)
  FetchOwner = ::T.let(nil, ::T.untyped)
  FieldDelimiter = ::T.let(nil, ::T.untyped)
  FileHeaderInfo = ::T.let(nil, ::T.untyped)
  FilterRule = ::T.let(nil, ::T.untyped)
  FilterRuleList = ::T.let(nil, ::T.untyped)
  FilterRuleName = ::T.let(nil, ::T.untyped)
  FilterRuleValue = ::T.let(nil, ::T.untyped)
  GetBucketAccelerateConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketAccelerateConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketAclOutput = ::T.let(nil, ::T.untyped)
  GetBucketAclRequest = ::T.let(nil, ::T.untyped)
  GetBucketAnalyticsConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketCorsOutput = ::T.let(nil, ::T.untyped)
  GetBucketCorsRequest = ::T.let(nil, ::T.untyped)
  GetBucketEncryptionOutput = ::T.let(nil, ::T.untyped)
  GetBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  GetBucketInventoryConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleOutput = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  GetBucketLocationOutput = ::T.let(nil, ::T.untyped)
  GetBucketLocationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLoggingOutput = ::T.let(nil, ::T.untyped)
  GetBucketLoggingRequest = ::T.let(nil, ::T.untyped)
  GetBucketMetricsConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketNotificationConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketPolicyOutput = ::T.let(nil, ::T.untyped)
  GetBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  GetBucketPolicyStatusOutput = ::T.let(nil, ::T.untyped)
  GetBucketPolicyStatusRequest = ::T.let(nil, ::T.untyped)
  GetBucketReplicationOutput = ::T.let(nil, ::T.untyped)
  GetBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  GetBucketRequestPaymentOutput = ::T.let(nil, ::T.untyped)
  GetBucketRequestPaymentRequest = ::T.let(nil, ::T.untyped)
  GetBucketTaggingOutput = ::T.let(nil, ::T.untyped)
  GetBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  GetBucketVersioningOutput = ::T.let(nil, ::T.untyped)
  GetBucketVersioningRequest = ::T.let(nil, ::T.untyped)
  GetBucketWebsiteOutput = ::T.let(nil, ::T.untyped)
  GetBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  GetObjectAclOutput = ::T.let(nil, ::T.untyped)
  GetObjectAclRequest = ::T.let(nil, ::T.untyped)
  GetObjectLegalHoldOutput = ::T.let(nil, ::T.untyped)
  GetObjectLegalHoldRequest = ::T.let(nil, ::T.untyped)
  GetObjectLockConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetObjectLockConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetObjectOutput = ::T.let(nil, ::T.untyped)
  GetObjectRequest = ::T.let(nil, ::T.untyped)
  GetObjectRetentionOutput = ::T.let(nil, ::T.untyped)
  GetObjectRetentionRequest = ::T.let(nil, ::T.untyped)
  GetObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  GetObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  GetObjectTorrentOutput = ::T.let(nil, ::T.untyped)
  GetObjectTorrentRequest = ::T.let(nil, ::T.untyped)
  GetPublicAccessBlockOutput = ::T.let(nil, ::T.untyped)
  GetPublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  GlacierJobParameters = ::T.let(nil, ::T.untyped)
  Grant = ::T.let(nil, ::T.untyped)
  GrantFullControl = ::T.let(nil, ::T.untyped)
  GrantRead = ::T.let(nil, ::T.untyped)
  GrantReadACP = ::T.let(nil, ::T.untyped)
  GrantWrite = ::T.let(nil, ::T.untyped)
  GrantWriteACP = ::T.let(nil, ::T.untyped)
  Grantee = ::T.let(nil, ::T.untyped)
  Grants = ::T.let(nil, ::T.untyped)
  HeadBucketRequest = ::T.let(nil, ::T.untyped)
  HeadObjectOutput = ::T.let(nil, ::T.untyped)
  HeadObjectRequest = ::T.let(nil, ::T.untyped)
  HostName = ::T.let(nil, ::T.untyped)
  HttpErrorCodeReturnedEquals = ::T.let(nil, ::T.untyped)
  HttpRedirectCode = ::T.let(nil, ::T.untyped)
  ID = ::T.let(nil, ::T.untyped)
  IfMatch = ::T.let(nil, ::T.untyped)
  IfModifiedSince = ::T.let(nil, ::T.untyped)
  IfNoneMatch = ::T.let(nil, ::T.untyped)
  IfUnmodifiedSince = ::T.let(nil, ::T.untyped)
  IndexDocument = ::T.let(nil, ::T.untyped)
  Initiated = ::T.let(nil, ::T.untyped)
  Initiator = ::T.let(nil, ::T.untyped)
  InputSerialization = ::T.let(nil, ::T.untyped)
  InventoryConfiguration = ::T.let(nil, ::T.untyped)
  InventoryConfigurationList = ::T.let(nil, ::T.untyped)
  InventoryDestination = ::T.let(nil, ::T.untyped)
  InventoryEncryption = ::T.let(nil, ::T.untyped)
  InventoryFilter = ::T.let(nil, ::T.untyped)
  InventoryFormat = ::T.let(nil, ::T.untyped)
  InventoryFrequency = ::T.let(nil, ::T.untyped)
  InventoryId = ::T.let(nil, ::T.untyped)
  InventoryIncludedObjectVersions = ::T.let(nil, ::T.untyped)
  InventoryOptionalField = ::T.let(nil, ::T.untyped)
  InventoryOptionalFields = ::T.let(nil, ::T.untyped)
  InventoryS3BucketDestination = ::T.let(nil, ::T.untyped)
  InventorySchedule = ::T.let(nil, ::T.untyped)
  IsEnabled = ::T.let(nil, ::T.untyped)
  IsLatest = ::T.let(nil, ::T.untyped)
  IsPublic = ::T.let(nil, ::T.untyped)
  IsTruncated = ::T.let(nil, ::T.untyped)
  JSONInput = ::T.let(nil, ::T.untyped)
  JSONOutput = ::T.let(nil, ::T.untyped)
  JSONType = ::T.let(nil, ::T.untyped)
  KMSContext = ::T.let(nil, ::T.untyped)
  KeyCount = ::T.let(nil, ::T.untyped)
  KeyMarker = ::T.let(nil, ::T.untyped)
  KeyPrefixEquals = ::T.let(nil, ::T.untyped)
  LambdaFunctionArn = ::T.let(nil, ::T.untyped)
  LambdaFunctionConfiguration = ::T.let(nil, ::T.untyped)
  LambdaFunctionConfigurationList = ::T.let(nil, ::T.untyped)
  LastModified = ::T.let(nil, ::T.untyped)
  LifecycleConfiguration = ::T.let(nil, ::T.untyped)
  LifecycleExpiration = ::T.let(nil, ::T.untyped)
  LifecycleRule = ::T.let(nil, ::T.untyped)
  LifecycleRuleAndOperator = ::T.let(nil, ::T.untyped)
  LifecycleRuleFilter = ::T.let(nil, ::T.untyped)
  LifecycleRules = ::T.let(nil, ::T.untyped)
  ListBucketAnalyticsConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketAnalyticsConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketInventoryConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketInventoryConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketMetricsConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketMetricsConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketsOutput = ::T.let(nil, ::T.untyped)
  ListMultipartUploadsOutput = ::T.let(nil, ::T.untyped)
  ListMultipartUploadsRequest = ::T.let(nil, ::T.untyped)
  ListObjectVersionsOutput = ::T.let(nil, ::T.untyped)
  ListObjectVersionsRequest = ::T.let(nil, ::T.untyped)
  ListObjectsOutput = ::T.let(nil, ::T.untyped)
  ListObjectsRequest = ::T.let(nil, ::T.untyped)
  ListObjectsV2Output = ::T.let(nil, ::T.untyped)
  ListObjectsV2Request = ::T.let(nil, ::T.untyped)
  ListPartsOutput = ::T.let(nil, ::T.untyped)
  ListPartsRequest = ::T.let(nil, ::T.untyped)
  Location = ::T.let(nil, ::T.untyped)
  LocationPrefix = ::T.let(nil, ::T.untyped)
  LoggingEnabled = ::T.let(nil, ::T.untyped)
  MFA = ::T.let(nil, ::T.untyped)
  MFADelete = ::T.let(nil, ::T.untyped)
  MFADeleteStatus = ::T.let(nil, ::T.untyped)
  Marker = ::T.let(nil, ::T.untyped)
  MaxAgeSeconds = ::T.let(nil, ::T.untyped)
  MaxKeys = ::T.let(nil, ::T.untyped)
  MaxParts = ::T.let(nil, ::T.untyped)
  MaxUploads = ::T.let(nil, ::T.untyped)
  Message = ::T.let(nil, ::T.untyped)
  Metadata = ::T.let(nil, ::T.untyped)
  MetadataDirective = ::T.let(nil, ::T.untyped)
  MetadataEntry = ::T.let(nil, ::T.untyped)
  MetadataKey = ::T.let(nil, ::T.untyped)
  MetadataValue = ::T.let(nil, ::T.untyped)
  Metrics = ::T.let(nil, ::T.untyped)
  MetricsAndOperator = ::T.let(nil, ::T.untyped)
  MetricsConfiguration = ::T.let(nil, ::T.untyped)
  MetricsConfigurationList = ::T.let(nil, ::T.untyped)
  MetricsFilter = ::T.let(nil, ::T.untyped)
  MetricsId = ::T.let(nil, ::T.untyped)
  MetricsStatus = ::T.let(nil, ::T.untyped)
  Minutes = ::T.let(nil, ::T.untyped)
  MissingMeta = ::T.let(nil, ::T.untyped)
  MultipartUpload = ::T.let(nil, ::T.untyped)
  MultipartUploadId = ::T.let(nil, ::T.untyped)
  MultipartUploadList = ::T.let(nil, ::T.untyped)
  NextKeyMarker = ::T.let(nil, ::T.untyped)
  NextMarker = ::T.let(nil, ::T.untyped)
  NextPartNumberMarker = ::T.let(nil, ::T.untyped)
  NextToken = ::T.let(nil, ::T.untyped)
  NextUploadIdMarker = ::T.let(nil, ::T.untyped)
  NextVersionIdMarker = ::T.let(nil, ::T.untyped)
  NoSuchBucket = ::T.let(nil, ::T.untyped)
  NoSuchKey = ::T.let(nil, ::T.untyped)
  NoSuchUpload = ::T.let(nil, ::T.untyped)
  NoncurrentVersionExpiration = ::T.let(nil, ::T.untyped)
  NoncurrentVersionTransition = ::T.let(nil, ::T.untyped)
  NoncurrentVersionTransitionList = ::T.let(nil, ::T.untyped)
  NotificationConfiguration = ::T.let(nil, ::T.untyped)
  NotificationConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  NotificationConfigurationFilter = ::T.let(nil, ::T.untyped)
  NotificationId = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  ObjectAlreadyInActiveTierError = ::T.let(nil, ::T.untyped)
  ObjectCannedACL = ::T.let(nil, ::T.untyped)
  ObjectIdentifier = ::T.let(nil, ::T.untyped)
  ObjectIdentifierList = ::T.let(nil, ::T.untyped)
  ObjectKey = ::T.let(nil, ::T.untyped)
  ObjectList = ::T.let(nil, ::T.untyped)
  ObjectLockConfiguration = ::T.let(nil, ::T.untyped)
  ObjectLockEnabled = ::T.let(nil, ::T.untyped)
  ObjectLockEnabledForBucket = ::T.let(nil, ::T.untyped)
  ObjectLockLegalHold = ::T.let(nil, ::T.untyped)
  ObjectLockLegalHoldStatus = ::T.let(nil, ::T.untyped)
  ObjectLockMode = ::T.let(nil, ::T.untyped)
  ObjectLockRetainUntilDate = ::T.let(nil, ::T.untyped)
  ObjectLockRetention = ::T.let(nil, ::T.untyped)
  ObjectLockRetentionMode = ::T.let(nil, ::T.untyped)
  ObjectLockRule = ::T.let(nil, ::T.untyped)
  ObjectLockToken = ::T.let(nil, ::T.untyped)
  ObjectNotInActiveTierError = ::T.let(nil, ::T.untyped)
  ObjectStorageClass = ::T.let(nil, ::T.untyped)
  ObjectVersion = ::T.let(nil, ::T.untyped)
  ObjectVersionId = ::T.let(nil, ::T.untyped)
  ObjectVersionList = ::T.let(nil, ::T.untyped)
  ObjectVersionStorageClass = ::T.let(nil, ::T.untyped)
  OutputLocation = ::T.let(nil, ::T.untyped)
  OutputSerialization = ::T.let(nil, ::T.untyped)
  Owner = ::T.let(nil, ::T.untyped)
  OwnerOverride = ::T.let(nil, ::T.untyped)
  ParquetInput = ::T.let(nil, ::T.untyped)
  Part = ::T.let(nil, ::T.untyped)
  PartNumber = ::T.let(nil, ::T.untyped)
  PartNumberMarker = ::T.let(nil, ::T.untyped)
  Parts = ::T.let(nil, ::T.untyped)
  PartsCount = ::T.let(nil, ::T.untyped)
  Payer = ::T.let(nil, ::T.untyped)
  Permission = ::T.let(nil, ::T.untyped)
  Policy = ::T.let(nil, ::T.untyped)
  PolicyStatus = ::T.let(nil, ::T.untyped)
  Prefix = ::T.let(nil, ::T.untyped)
  Priority = ::T.let(nil, ::T.untyped)
  Progress = ::T.let(nil, ::T.untyped)
  ProgressEvent = ::T.let(nil, ::T.untyped)
  Protocol = ::T.let(nil, ::T.untyped)
  PublicAccessBlockConfiguration = ::T.let(nil, ::T.untyped)
  PutBucketAccelerateConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketAclRequest = ::T.let(nil, ::T.untyped)
  PutBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketCorsRequest = ::T.let(nil, ::T.untyped)
  PutBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  PutBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketLifecycleConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  PutBucketLoggingRequest = ::T.let(nil, ::T.untyped)
  PutBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketNotificationConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketNotificationRequest = ::T.let(nil, ::T.untyped)
  PutBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  PutBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  PutBucketRequestPaymentRequest = ::T.let(nil, ::T.untyped)
  PutBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  PutBucketVersioningRequest = ::T.let(nil, ::T.untyped)
  PutBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  PutObjectAclOutput = ::T.let(nil, ::T.untyped)
  PutObjectAclRequest = ::T.let(nil, ::T.untyped)
  PutObjectLegalHoldOutput = ::T.let(nil, ::T.untyped)
  PutObjectLegalHoldRequest = ::T.let(nil, ::T.untyped)
  PutObjectLockConfigurationOutput = ::T.let(nil, ::T.untyped)
  PutObjectLockConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutObjectOutput = ::T.let(nil, ::T.untyped)
  PutObjectRequest = ::T.let(nil, ::T.untyped)
  PutObjectRetentionOutput = ::T.let(nil, ::T.untyped)
  PutObjectRetentionRequest = ::T.let(nil, ::T.untyped)
  PutObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  PutObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  PutPublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  QueueArn = ::T.let(nil, ::T.untyped)
  QueueConfiguration = ::T.let(nil, ::T.untyped)
  QueueConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  QueueConfigurationList = ::T.let(nil, ::T.untyped)
  Quiet = ::T.let(nil, ::T.untyped)
  QuoteCharacter = ::T.let(nil, ::T.untyped)
  QuoteEscapeCharacter = ::T.let(nil, ::T.untyped)
  QuoteFields = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  RecordDelimiter = ::T.let(nil, ::T.untyped)
  RecordsEvent = ::T.let(nil, ::T.untyped)
  Redirect = ::T.let(nil, ::T.untyped)
  RedirectAllRequestsTo = ::T.let(nil, ::T.untyped)
  ReplaceKeyPrefixWith = ::T.let(nil, ::T.untyped)
  ReplaceKeyWith = ::T.let(nil, ::T.untyped)
  ReplicaKmsKeyID = ::T.let(nil, ::T.untyped)
  ReplicationConfiguration = ::T.let(nil, ::T.untyped)
  ReplicationRule = ::T.let(nil, ::T.untyped)
  ReplicationRuleAndOperator = ::T.let(nil, ::T.untyped)
  ReplicationRuleFilter = ::T.let(nil, ::T.untyped)
  ReplicationRuleStatus = ::T.let(nil, ::T.untyped)
  ReplicationRules = ::T.let(nil, ::T.untyped)
  ReplicationStatus = ::T.let(nil, ::T.untyped)
  ReplicationTime = ::T.let(nil, ::T.untyped)
  ReplicationTimeStatus = ::T.let(nil, ::T.untyped)
  ReplicationTimeValue = ::T.let(nil, ::T.untyped)
  RequestCharged = ::T.let(nil, ::T.untyped)
  RequestPayer = ::T.let(nil, ::T.untyped)
  RequestPaymentConfiguration = ::T.let(nil, ::T.untyped)
  RequestProgress = ::T.let(nil, ::T.untyped)
  ResponseCacheControl = ::T.let(nil, ::T.untyped)
  ResponseContentDisposition = ::T.let(nil, ::T.untyped)
  ResponseContentEncoding = ::T.let(nil, ::T.untyped)
  ResponseContentLanguage = ::T.let(nil, ::T.untyped)
  ResponseContentType = ::T.let(nil, ::T.untyped)
  ResponseExpires = ::T.let(nil, ::T.untyped)
  Restore = ::T.let(nil, ::T.untyped)
  RestoreObjectOutput = ::T.let(nil, ::T.untyped)
  RestoreObjectRequest = ::T.let(nil, ::T.untyped)
  RestoreOutputPath = ::T.let(nil, ::T.untyped)
  RestoreRequest = ::T.let(nil, ::T.untyped)
  RestoreRequestType = ::T.let(nil, ::T.untyped)
  Role = ::T.let(nil, ::T.untyped)
  RoutingRule = ::T.let(nil, ::T.untyped)
  RoutingRules = ::T.let(nil, ::T.untyped)
  Rule = ::T.let(nil, ::T.untyped)
  Rules = ::T.let(nil, ::T.untyped)
  S3KeyFilter = ::T.let(nil, ::T.untyped)
  S3Location = ::T.let(nil, ::T.untyped)
  SSECustomerAlgorithm = ::T.let(nil, ::T.untyped)
  SSECustomerKey = ::T.let(nil, ::T.untyped)
  SSECustomerKeyMD5 = ::T.let(nil, ::T.untyped)
  SSEKMS = ::T.let(nil, ::T.untyped)
  SSEKMSEncryptionContext = ::T.let(nil, ::T.untyped)
  SSEKMSKeyId = ::T.let(nil, ::T.untyped)
  SSES3 = ::T.let(nil, ::T.untyped)
  ScanRange = ::T.let(nil, ::T.untyped)
  SelectObjectContentEventStream = ::T.let(nil, ::T.untyped)
  SelectObjectContentOutput = ::T.let(nil, ::T.untyped)
  SelectObjectContentRequest = ::T.let(nil, ::T.untyped)
  SelectParameters = ::T.let(nil, ::T.untyped)
  ServerSideEncryption = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionByDefault = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionConfiguration = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionRule = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionRules = ::T.let(nil, ::T.untyped)
  Setting = ::T.let(nil, ::T.untyped)
  Size = ::T.let(nil, ::T.untyped)
  SourceSelectionCriteria = ::T.let(nil, ::T.untyped)
  SseKmsEncryptedObjects = ::T.let(nil, ::T.untyped)
  SseKmsEncryptedObjectsStatus = ::T.let(nil, ::T.untyped)
  Start = ::T.let(nil, ::T.untyped)
  StartAfter = ::T.let(nil, ::T.untyped)
  Stats = ::T.let(nil, ::T.untyped)
  StatsEvent = ::T.let(nil, ::T.untyped)
  StorageClass = ::T.let(nil, ::T.untyped)
  StorageClassAnalysis = ::T.let(nil, ::T.untyped)
  StorageClassAnalysisDataExport = ::T.let(nil, ::T.untyped)
  StorageClassAnalysisSchemaVersion = ::T.let(nil, ::T.untyped)
  Suffix = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
  TagCount = ::T.let(nil, ::T.untyped)
  TagSet = ::T.let(nil, ::T.untyped)
  Tagging = ::T.let(nil, ::T.untyped)
  TaggingDirective = ::T.let(nil, ::T.untyped)
  TaggingHeader = ::T.let(nil, ::T.untyped)
  TargetBucket = ::T.let(nil, ::T.untyped)
  TargetGrant = ::T.let(nil, ::T.untyped)
  TargetGrants = ::T.let(nil, ::T.untyped)
  TargetPrefix = ::T.let(nil, ::T.untyped)
  Tier = ::T.let(nil, ::T.untyped)
  Token = ::T.let(nil, ::T.untyped)
  TopicArn = ::T.let(nil, ::T.untyped)
  TopicConfiguration = ::T.let(nil, ::T.untyped)
  TopicConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  TopicConfigurationList = ::T.let(nil, ::T.untyped)
  Transition = ::T.let(nil, ::T.untyped)
  TransitionList = ::T.let(nil, ::T.untyped)
  TransitionStorageClass = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  UploadIdMarker = ::T.let(nil, ::T.untyped)
  UploadPartCopyOutput = ::T.let(nil, ::T.untyped)
  UploadPartCopyRequest = ::T.let(nil, ::T.untyped)
  UploadPartOutput = ::T.let(nil, ::T.untyped)
  UploadPartRequest = ::T.let(nil, ::T.untyped)
  UserMetadata = ::T.let(nil, ::T.untyped)
  Value = ::T.let(nil, ::T.untyped)
  VersionIdMarker = ::T.let(nil, ::T.untyped)
  VersioningConfiguration = ::T.let(nil, ::T.untyped)
  WebsiteConfiguration = ::T.let(nil, ::T.untyped)
  WebsiteRedirectLocation = ::T.let(nil, ::T.untyped)
  Years = ::T.let(nil, ::T.untyped)
end

module Aws::S3::ClientApi
end

module Aws::S3::Encryption
end

class Aws::S3::Encryption::Client
  def client(); end

  def config(*args, &block); end

  def delete_object(*args, &block); end

  def envelope_location(); end

  def get_object(params=T.unsafe(nil), &block); end

  def head_object(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def instruction_file_suffix(); end

  def key_provider(); end

  def put_object(params=T.unsafe(nil)); end
end

class Aws::S3::Encryption::Client
  extend ::Aws::Deprecations
  extend ::Forwardable
end

class Aws::S3::Encryption::DecryptHandler
  POSSIBLE_ENCRYPTION_FORMATS = ::T.let(nil, ::T.untyped)
  POSSIBLE_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  V1_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  V2_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Encryption::DecryptHandler
end

class Aws::S3::Encryption::DefaultCipherProvider
  def decryption_cipher(envelope); end

  def encryption_cipher(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::Encryption::DefaultCipherProvider
end

class Aws::S3::Encryption::DefaultKeyProvider
  include ::Aws::S3::Encryption::KeyProvider
  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::Encryption::DefaultKeyProvider
end

class Aws::S3::Encryption::EncryptHandler
end

class Aws::S3::Encryption::EncryptHandler
end

module Aws::S3::Encryption::Errors
end

class Aws::S3::Encryption::Errors::DecryptionError
end

class Aws::S3::Encryption::Errors::DecryptionError
end

class Aws::S3::Encryption::Errors::EncryptionError
end

class Aws::S3::Encryption::Errors::EncryptionError
end

module Aws::S3::Encryption::Errors
end

class Aws::S3::Encryption::IOAuthDecrypter
  def finalize(); end

  def initialize(options=T.unsafe(nil)); end

  def io(); end

  def write(chunk); end
end

class Aws::S3::Encryption::IOAuthDecrypter
end

class Aws::S3::Encryption::IODecrypter
  def finalize(); end

  def initialize(cipher, io); end

  def io(); end

  def write(chunk); end
end

class Aws::S3::Encryption::IODecrypter
end

class Aws::S3::Encryption::IOEncrypter
  def close(); end

  def initialize(cipher, io); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end
  ONE_MEGABYTE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Encryption::IOEncrypter
end

module Aws::S3::Encryption::KeyProvider
  def encryption_materials(); end

  def key_for(materials_description); end
end

module Aws::S3::Encryption::KeyProvider
end

class Aws::S3::Encryption::KmsCipherProvider
  def decryption_cipher(envelope); end

  def encryption_cipher(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::Encryption::KmsCipherProvider
end

class Aws::S3::Encryption::Materials
  def description(); end

  def initialize(options=T.unsafe(nil)); end

  def key(); end
end

class Aws::S3::Encryption::Materials
end

module Aws::S3::Encryption::Utils
  UNSAFE_MSG = ::T.let(nil, ::T.untyped)
end

module Aws::S3::Encryption::Utils
  def self.aes_cipher(mode, block_mode, key, iv); end

  def self.aes_decryption_cipher(block_mode, key=T.unsafe(nil), iv=T.unsafe(nil)); end

  def self.aes_encryption_cipher(block_mode, key=T.unsafe(nil), iv=T.unsafe(nil)); end

  def self.cipher_size(key); end

  def self.decrypt(key, data); end

  def self.encrypt(key, data); end
end

module Aws::S3::Encryption
end

module Aws::S3::Errors
end

class Aws::S3::Errors::BucketAlreadyExists
end

class Aws::S3::Errors::BucketAlreadyExists
end

class Aws::S3::Errors::BucketAlreadyOwnedByYou
end

class Aws::S3::Errors::BucketAlreadyOwnedByYou
end

class Aws::S3::Errors::NoSuchBucket
end

class Aws::S3::Errors::NoSuchBucket
end

class Aws::S3::Errors::NoSuchKey
end

class Aws::S3::Errors::NoSuchKey
end

class Aws::S3::Errors::NoSuchUpload
end

class Aws::S3::Errors::NoSuchUpload
end

class Aws::S3::Errors::ObjectAlreadyInActiveTierError
end

class Aws::S3::Errors::ObjectAlreadyInActiveTierError
end

class Aws::S3::Errors::ObjectNotInActiveTierError
end

class Aws::S3::Errors::ObjectNotInActiveTierError
end

class Aws::S3::Errors::ServiceError
end

class Aws::S3::Errors::ServiceError
end

module Aws::S3::Errors
  extend ::Aws::Errors::DynamicErrors
end

module Aws::S3::EventStreams
end

class Aws::S3::EventStreams::SelectObjectContentEventStream
  def event_emitter(); end

  def on_cont_event(&block); end

  def on_end_event(&block); end

  def on_error_event(&block); end

  def on_event(&block); end

  def on_initial_response_event(&block); end

  def on_progress_event(&block); end

  def on_records_event(&block); end

  def on_stats_event(&block); end
end

class Aws::S3::EventStreams::SelectObjectContentEventStream
end

module Aws::S3::EventStreams
end

class Aws::S3::FileDownloader
  def client(); end

  def download(destination, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
  MAX_PARTS = ::T.let(nil, ::T.untyped)
  MIN_CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
end

class Aws::S3::FileDownloader
end

class Aws::S3::FilePart
  def close(); end

  def first_byte(); end

  def initialize(options=T.unsafe(nil)); end

  def last_byte(); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def source(); end
end

class Aws::S3::FilePart
end

class Aws::S3::FileUploader
  def client(); end

  def initialize(options=T.unsafe(nil)); end

  def multipart_threshold(); end

  def upload(source, options=T.unsafe(nil)); end
  FIFTEEN_MEGABYTES = ::T.let(nil, ::T.untyped)
end

class Aws::S3::FileUploader
end

class Aws::S3::LegacySigner
  def authorization(request); end

  def canonicalized_headers(request); end

  def canonicalized_resource(endpoint); end

  def credentials(); end

  def digest(secret, string_to_sign); end

  def hmac(key, value); end

  def initialize(credentials, params, force_path_style); end

  def params(); end

  def sign(request); end

  def signature(request); end

  def signed_querystring_params(endpoint); end

  def signing_string_date(request); end

  def string_to_sign(request); end

  def uri_escape(s); end
  SIGNED_QUERYSTRING_PARAMS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::LegacySigner
  def self.sign(context); end
end

class Aws::S3::MultipartFileUploader
  def client(); end

  def initialize(options=T.unsafe(nil)); end

  def upload(source, options=T.unsafe(nil)); end
  CREATE_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_TOO_SMALL = ::T.let(nil, ::T.untyped)
  MAX_PARTS = ::T.let(nil, ::T.untyped)
  MIN_PART_SIZE = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
  UPLOAD_PART_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::MultipartFileUploader::PartList
  def clear!(); end

  def initialize(parts=T.unsafe(nil)); end

  def push(part); end

  def shift(); end

  def to_a(); end
end

class Aws::S3::MultipartFileUploader::PartList
end

class Aws::S3::MultipartFileUploader
end

class Aws::S3::MultipartStreamUploader
  def client(); end

  def initialize(options=T.unsafe(nil)); end

  def upload(options=T.unsafe(nil), &block); end
  CREATE_OPTIONS = ::T.let(nil, ::T.untyped)
  PART_SIZE = ::T.let(nil, ::T.untyped)
  TEMPFILE_PREIX = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
  UPLOAD_PART_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::MultipartStreamUploader
end

class Aws::S3::MultipartUpload
  def abort(options=T.unsafe(nil)); end

  def basic_complete(options=T.unsafe(nil)); end

  def bucket_name(); end

  def client(); end

  def complete(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def initiated(); end

  def initiator(); end

  def key(); end

  def load(); end

  def object(); end

  def object_key(); end

  def owner(); end

  def part(part_number); end

  def parts(options=T.unsafe(nil)); end

  def reload(); end

  def storage_class(); end

  def upload_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::MultipartUpload::Collection
end

class Aws::S3::MultipartUpload::Collection
end

class Aws::S3::MultipartUpload
  extend ::Aws::Deprecations
end

class Aws::S3::MultipartUploadError
  def errors(); end

  def initialize(message, errors); end
end

class Aws::S3::MultipartUploadError
end

class Aws::S3::MultipartUploadPart
  def bucket_name(); end

  def client(); end

  def copy_from(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def etag(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def last_modified(); end

  def load(); end

  def multipart_upload(); end

  def multipart_upload_id(); end

  def object_key(); end

  def part_number(); end

  def reload(); end

  def size(); end

  def upload(options=T.unsafe(nil)); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::MultipartUploadPart::Collection
end

class Aws::S3::MultipartUploadPart::Collection
end

class Aws::S3::MultipartUploadPart
  extend ::Aws::Deprecations
end

class Aws::S3::Object
  def accept_ranges(); end

  def acl(); end

  def bucket(); end

  def bucket_name(); end

  def cache_control(); end

  def client(); end

  def content_disposition(); end

  def content_encoding(); end

  def content_language(); end

  def content_length(); end

  def content_type(); end

  def copy_from(source, options=T.unsafe(nil)); end

  def copy_to(target, options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_marker(); end

  def deprecated_identifiers(); end

  def download_file(destination, options=T.unsafe(nil)); end

  def etag(); end

  def exists?(options=T.unsafe(nil)); end

  def expiration(); end

  def expires(); end

  def expires_string(); end

  def get(options=T.unsafe(nil), &block); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def initiate_multipart_upload(options=T.unsafe(nil)); end

  def key(); end

  def last_modified(); end

  def load(); end

  def metadata(); end

  def missing_meta(); end

  def move_to(target, options=T.unsafe(nil)); end

  def multipart_upload(id); end

  def object_lock_legal_hold_status(); end

  def object_lock_mode(); end

  def object_lock_retain_until_date(); end

  def parts_count(); end

  def presigned_post(options=T.unsafe(nil)); end

  def presigned_url(http_method, params=T.unsafe(nil)); end

  def public_url(options=T.unsafe(nil)); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def replication_status(); end

  def request_charged(); end

  def restore(); end

  def restore_object(options=T.unsafe(nil)); end

  def server_side_encryption(); end

  def size(); end

  def sse_customer_algorithm(); end

  def sse_customer_key_md5(); end

  def ssekms_key_id(); end

  def storage_class(); end

  def upload_file(source, options=T.unsafe(nil)); end

  def upload_stream(options=T.unsafe(nil), &block); end

  def version(id); end

  def version_id(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end

  def wait_until_not_exists(options=T.unsafe(nil), &block); end

  def website_redirect_location(); end
end

class Aws::S3::Object::Collection
  def batch_delete!(options=T.unsafe(nil)); end

  def delete(*args, &block); end

  def deprecated_delete(options=T.unsafe(nil)); end
end

class Aws::S3::Object::Collection
end

class Aws::S3::Object
  extend ::Aws::Deprecations
end

class Aws::S3::ObjectAcl
  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def grants(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def object(); end

  def object_key(); end

  def owner(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def request_charged(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::ObjectAcl::Collection
end

class Aws::S3::ObjectAcl::Collection
end

class Aws::S3::ObjectAcl
  extend ::Aws::Deprecations
end

class Aws::S3::ObjectCopier
  def copy_from(source, options=T.unsafe(nil)); end

  def copy_to(target, options=T.unsafe(nil)); end

  def initialize(object, options=T.unsafe(nil)); end
end

class Aws::S3::ObjectCopier
end

class Aws::S3::ObjectMultipartCopier
  def client(); end

  def copy(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
  API_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_TOO_SMALL = ::T.let(nil, ::T.untyped)
  FIVE_MB = ::T.let(nil, ::T.untyped)
  MAX_PARTS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::ObjectMultipartCopier::PartQueue
  def clear!(); end

  def initialize(parts=T.unsafe(nil)); end

  def shift(); end
end

class Aws::S3::ObjectMultipartCopier::PartQueue
end

class Aws::S3::ObjectMultipartCopier
  def self.options_for(shape_name); end
end

class Aws::S3::ObjectSummary
  def acl(); end

  def bucket(); end

  def bucket_name(); end

  def client(); end

  def content_length(); end

  def copy_from(source, options=T.unsafe(nil)); end

  def copy_to(target, options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def download_file(destination, options=T.unsafe(nil)); end

  def etag(); end

  def exists?(options=T.unsafe(nil)); end

  def get(options=T.unsafe(nil), &block); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def initiate_multipart_upload(options=T.unsafe(nil)); end

  def key(); end

  def last_modified(); end

  def load(); end

  def move_to(target, options=T.unsafe(nil)); end

  def multipart_upload(id); end

  def object(); end

  def owner(); end

  def presigned_post(options=T.unsafe(nil)); end

  def presigned_url(http_method, params=T.unsafe(nil)); end

  def public_url(options=T.unsafe(nil)); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def restore_object(options=T.unsafe(nil)); end

  def size(); end

  def storage_class(); end

  def upload_file(source, options=T.unsafe(nil)); end

  def upload_stream(options=T.unsafe(nil), &block); end

  def version(id); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end

  def wait_until_not_exists(options=T.unsafe(nil), &block); end
end

class Aws::S3::ObjectSummary::Collection
  def batch_delete!(options=T.unsafe(nil)); end

  def delete(*args, &block); end

  def deprecated_delete(options=T.unsafe(nil)); end
end

class Aws::S3::ObjectSummary::Collection
end

class Aws::S3::ObjectSummary
  extend ::Aws::Deprecations
end

class Aws::S3::ObjectVersion
  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def etag(); end

  def get(options=T.unsafe(nil), &block); end

  def head(options=T.unsafe(nil)); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def is_latest(); end

  def key(); end

  def last_modified(); end

  def load(); end

  def object(); end

  def object_key(); end

  def owner(); end

  def reload(); end

  def size(); end

  def storage_class(); end

  def version_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::ObjectVersion::Collection
  def batch_delete!(options=T.unsafe(nil)); end

  def delete(*args, &block); end

  def deprecated_delete(options=T.unsafe(nil)); end
end

class Aws::S3::ObjectVersion::Collection
end

class Aws::S3::ObjectVersion
  extend ::Aws::Deprecations
end

module Aws::S3::Plugins
end

class Aws::S3::Plugins::Accelerate
end

class Aws::S3::Plugins::Accelerate::AccelerateHandler
end

class Aws::S3::Plugins::Accelerate::AccelerateHandler
end

class Aws::S3::Plugins::Accelerate::OptionHandler
end

class Aws::S3::Plugins::Accelerate::OptionHandler
end

class Aws::S3::Plugins::Accelerate
end

class Aws::S3::Plugins::BucketARN
  def add_handlers(handlers, _config); end
end

class Aws::S3::Plugins::BucketARN::Handler
end

class Aws::S3::Plugins::BucketARN::Handler
end

class Aws::S3::Plugins::BucketARN
  def self.resolve_arn!(bucket_name, region, s3_use_arn_region); end

  def self.resolve_url!(url, arn, dualstack=T.unsafe(nil)); end
end

class Aws::S3::Plugins::BucketDns
end

class Aws::S3::Plugins::BucketDns::Handler
end

class Aws::S3::Plugins::BucketDns::Handler
end

class Aws::S3::Plugins::BucketDns
  def self.dns_compatible?(bucket_name, ssl); end

  def self.valid_subdomain?(bucket_name); end
end

class Aws::S3::Plugins::BucketNameRestrictions
end

class Aws::S3::Plugins::BucketNameRestrictions::Handler
end

class Aws::S3::Plugins::BucketNameRestrictions::Handler
end

class Aws::S3::Plugins::BucketNameRestrictions
end

class Aws::S3::Plugins::Dualstack
end

class Aws::S3::Plugins::Dualstack::DualstackHandler
end

class Aws::S3::Plugins::Dualstack::DualstackHandler
end

class Aws::S3::Plugins::Dualstack::OptionHandler
end

class Aws::S3::Plugins::Dualstack::OptionHandler
end

class Aws::S3::Plugins::Dualstack
end

class Aws::S3::Plugins::Expect100Continue
end

class Aws::S3::Plugins::Expect100Continue::Handler
end

class Aws::S3::Plugins::Expect100Continue::Handler
end

class Aws::S3::Plugins::Expect100Continue
end

class Aws::S3::Plugins::GetBucketLocationFix
end

class Aws::S3::Plugins::GetBucketLocationFix::Handler
end

class Aws::S3::Plugins::GetBucketLocationFix::Handler
end

class Aws::S3::Plugins::GetBucketLocationFix
end

class Aws::S3::Plugins::Http200Errors
end

class Aws::S3::Plugins::Http200Errors::Handler
  def check_for_error(context); end
end

class Aws::S3::Plugins::Http200Errors::Handler
end

class Aws::S3::Plugins::Http200Errors
end

class Aws::S3::Plugins::IADRegionalEndpoint
end

class Aws::S3::Plugins::IADRegionalEndpoint::Handler
end

class Aws::S3::Plugins::IADRegionalEndpoint::Handler
end

class Aws::S3::Plugins::IADRegionalEndpoint
  def self.legacy_host(host); end

  def self.resolve_iad_regional_endpoint(cfg); end
end

class Aws::S3::Plugins::LocationConstraint
end

class Aws::S3::Plugins::LocationConstraint::Handler
end

class Aws::S3::Plugins::LocationConstraint::Handler
end

class Aws::S3::Plugins::LocationConstraint
end

class Aws::S3::Plugins::Md5s
  REQUIRED_OPERATIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Plugins::Md5s::Handler
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Plugins::Md5s::Handler
end

class Aws::S3::Plugins::Md5s
end

class Aws::S3::Plugins::Redirects
end

class Aws::S3::Plugins::Redirects::Handler
end

class Aws::S3::Plugins::Redirects::Handler
end

class Aws::S3::Plugins::Redirects
end

class Aws::S3::Plugins::S3HostId
end

class Aws::S3::Plugins::S3HostId::Handler
end

class Aws::S3::Plugins::S3HostId::Handler
end

class Aws::S3::Plugins::S3HostId
end

class Aws::S3::Plugins::S3Signer
  def add_handlers(handlers, cfg); end

  def add_legacy_handler(handlers); end

  def add_v4_handlers(handlers); end
end

class Aws::S3::Plugins::S3Signer::BucketRegionErrorHandler
end

class Aws::S3::Plugins::S3Signer::BucketRegionErrorHandler
end

class Aws::S3::Plugins::S3Signer::CachedBucketRegionHandler
end

class Aws::S3::Plugins::S3Signer::CachedBucketRegionHandler
end

class Aws::S3::Plugins::S3Signer::LegacyHandler
end

class Aws::S3::Plugins::S3Signer::LegacyHandler
end

class Aws::S3::Plugins::S3Signer::V4Handler
end

class Aws::S3::Plugins::S3Signer::V4Handler
end

class Aws::S3::Plugins::S3Signer
  def self.build_v4_signer(options=T.unsafe(nil)); end

  def self.new_hostname(context, region); end
end

class Aws::S3::Plugins::SseCpk
end

class Aws::S3::Plugins::SseCpk::Handler
end

class Aws::S3::Plugins::SseCpk::Handler
end

class Aws::S3::Plugins::SseCpk
end

class Aws::S3::Plugins::UrlEncodedKeys
end

class Aws::S3::Plugins::UrlEncodedKeys::Handler
end

class Aws::S3::Plugins::UrlEncodedKeys::Handler
end

class Aws::S3::Plugins::UrlEncodedKeys
end

module Aws::S3::Plugins
end

class Aws::S3::PresignedPost
  def acl(value); end

  def acl_starts_with(value); end

  def allow_any(*field_names); end

  def cache_control(value); end

  def cache_control_starts_with(value); end

  def content_disposition(value); end

  def content_disposition_starts_with(value); end

  def content_encoding(value); end

  def content_encoding_starts_with(value); end

  def content_length_range(byte_range); end

  def content_type(value); end

  def content_type_starts_with(value); end

  def expires(time); end

  def expires_starts_with(prefix); end

  def fields(); end

  def initialize(credentials, bucket_region, bucket_name, options=T.unsafe(nil)); end

  def key(key); end

  def key_starts_with(prefix); end

  def metadata(hash); end

  def metadata_starts_with(hash); end

  def server_side_encryption(value); end

  def server_side_encryption_aws_kms_key_id(value); end

  def server_side_encryption_customer_algorithm(value); end

  def server_side_encryption_customer_key(value); end

  def server_side_encryption_customer_key_starts_with(prefix); end

  def storage_class(value); end

  def success_action_redirect(value); end

  def success_action_redirect_starts_with(value); end

  def success_action_status(value); end

  def url(); end

  def website_redirect_location(value); end
end

class Aws::S3::PresignedPost
  def self.define_field(field, *args); end
end

class Aws::S3::Presigner
  def initialize(options=T.unsafe(nil)); end

  def presigned_request(method, params=T.unsafe(nil)); end

  def presigned_url(method, params=T.unsafe(nil)); end
  BLACKLISTED_HEADERS = ::T.let(nil, ::T.untyped)
  FIFTEEN_MINUTES = ::T.let(nil, ::T.untyped)
  ONE_WEEK = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Presigner
end

class Aws::S3::Resource
  def bucket(name); end

  def buckets(options=T.unsafe(nil)); end

  def client(); end

  def create_bucket(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::Resource
end

module Aws::S3::Types
end

class Aws::S3::Types::AbortIncompleteMultipartUpload
  include ::Aws::Structure
end

class Aws::S3::Types::AbortIncompleteMultipartUpload
end

class Aws::S3::Types::AbortMultipartUploadOutput
  include ::Aws::Structure
end

class Aws::S3::Types::AbortMultipartUploadOutput
end

class Aws::S3::Types::AbortMultipartUploadRequest
  include ::Aws::Structure
end

class Aws::S3::Types::AbortMultipartUploadRequest
end

class Aws::S3::Types::AccelerateConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::AccelerateConfiguration
end

class Aws::S3::Types::AccessControlPolicy
  include ::Aws::Structure
end

class Aws::S3::Types::AccessControlPolicy
end

class Aws::S3::Types::AccessControlTranslation
  include ::Aws::Structure
end

class Aws::S3::Types::AccessControlTranslation
end

class Aws::S3::Types::AnalyticsAndOperator
  include ::Aws::Structure
end

class Aws::S3::Types::AnalyticsAndOperator
end

class Aws::S3::Types::AnalyticsConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::AnalyticsConfiguration
end

class Aws::S3::Types::AnalyticsExportDestination
  include ::Aws::Structure
end

class Aws::S3::Types::AnalyticsExportDestination
end

class Aws::S3::Types::AnalyticsFilter
  include ::Aws::Structure
end

class Aws::S3::Types::AnalyticsFilter
end

class Aws::S3::Types::AnalyticsS3BucketDestination
  include ::Aws::Structure
end

class Aws::S3::Types::AnalyticsS3BucketDestination
end

class Aws::S3::Types::Bucket
  include ::Aws::Structure
end

class Aws::S3::Types::Bucket
end

class Aws::S3::Types::BucketAlreadyExists
end

class Aws::S3::Types::BucketAlreadyExists
end

class Aws::S3::Types::BucketAlreadyOwnedByYou
end

class Aws::S3::Types::BucketAlreadyOwnedByYou
end

class Aws::S3::Types::BucketLifecycleConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::BucketLifecycleConfiguration
end

class Aws::S3::Types::BucketLoggingStatus
  include ::Aws::Structure
end

class Aws::S3::Types::BucketLoggingStatus
end

class Aws::S3::Types::CORSConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::CORSConfiguration
end

class Aws::S3::Types::CORSRule
  include ::Aws::Structure
end

class Aws::S3::Types::CORSRule
end

class Aws::S3::Types::CSVInput
  include ::Aws::Structure
end

class Aws::S3::Types::CSVInput
end

class Aws::S3::Types::CSVOutput
  include ::Aws::Structure
end

class Aws::S3::Types::CSVOutput
end

class Aws::S3::Types::CloudFunctionConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::CloudFunctionConfiguration
end

class Aws::S3::Types::CommonPrefix
  include ::Aws::Structure
end

class Aws::S3::Types::CommonPrefix
end

class Aws::S3::Types::CompleteMultipartUploadOutput
  include ::Aws::Structure
end

class Aws::S3::Types::CompleteMultipartUploadOutput
end

class Aws::S3::Types::CompleteMultipartUploadRequest
  include ::Aws::Structure
end

class Aws::S3::Types::CompleteMultipartUploadRequest
end

class Aws::S3::Types::CompletedMultipartUpload
  include ::Aws::Structure
end

class Aws::S3::Types::CompletedMultipartUpload
end

class Aws::S3::Types::CompletedPart
  include ::Aws::Structure
end

class Aws::S3::Types::CompletedPart
end

class Aws::S3::Types::Condition
  include ::Aws::Structure
end

class Aws::S3::Types::Condition
end

class Aws::S3::Types::ContinuationEvent
  include ::Aws::Structure
end

class Aws::S3::Types::ContinuationEvent
end

class Aws::S3::Types::CopyObjectOutput
  include ::Aws::Structure
end

class Aws::S3::Types::CopyObjectOutput
end

class Aws::S3::Types::CopyObjectRequest
  include ::Aws::Structure
end

class Aws::S3::Types::CopyObjectRequest
end

class Aws::S3::Types::CopyObjectResult
  include ::Aws::Structure
end

class Aws::S3::Types::CopyObjectResult
end

class Aws::S3::Types::CopyPartResult
  include ::Aws::Structure
end

class Aws::S3::Types::CopyPartResult
end

class Aws::S3::Types::CreateBucketConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::CreateBucketConfiguration
end

class Aws::S3::Types::CreateBucketOutput
  include ::Aws::Structure
end

class Aws::S3::Types::CreateBucketOutput
end

class Aws::S3::Types::CreateBucketRequest
  include ::Aws::Structure
end

class Aws::S3::Types::CreateBucketRequest
end

class Aws::S3::Types::CreateMultipartUploadOutput
  include ::Aws::Structure
end

class Aws::S3::Types::CreateMultipartUploadOutput
end

class Aws::S3::Types::CreateMultipartUploadRequest
  include ::Aws::Structure
end

class Aws::S3::Types::CreateMultipartUploadRequest
end

class Aws::S3::Types::DefaultRetention
  include ::Aws::Structure
end

class Aws::S3::Types::DefaultRetention
end

class Aws::S3::Types::Delete
  include ::Aws::Structure
end

class Aws::S3::Types::Delete
end

class Aws::S3::Types::DeleteBucketAnalyticsConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketAnalyticsConfigurationRequest
end

class Aws::S3::Types::DeleteBucketCorsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketCorsRequest
end

class Aws::S3::Types::DeleteBucketEncryptionRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketEncryptionRequest
end

class Aws::S3::Types::DeleteBucketInventoryConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketInventoryConfigurationRequest
end

class Aws::S3::Types::DeleteBucketLifecycleRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketLifecycleRequest
end

class Aws::S3::Types::DeleteBucketMetricsConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketMetricsConfigurationRequest
end

class Aws::S3::Types::DeleteBucketPolicyRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketPolicyRequest
end

class Aws::S3::Types::DeleteBucketReplicationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketReplicationRequest
end

class Aws::S3::Types::DeleteBucketRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketRequest
end

class Aws::S3::Types::DeleteBucketTaggingRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketTaggingRequest
end

class Aws::S3::Types::DeleteBucketWebsiteRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteBucketWebsiteRequest
end

class Aws::S3::Types::DeleteMarkerEntry
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteMarkerEntry
end

class Aws::S3::Types::DeleteMarkerReplication
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteMarkerReplication
end

class Aws::S3::Types::DeleteObjectOutput
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteObjectOutput
end

class Aws::S3::Types::DeleteObjectRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteObjectRequest
end

class Aws::S3::Types::DeleteObjectTaggingOutput
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteObjectTaggingOutput
end

class Aws::S3::Types::DeleteObjectTaggingRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteObjectTaggingRequest
end

class Aws::S3::Types::DeleteObjectsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteObjectsOutput
end

class Aws::S3::Types::DeleteObjectsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeleteObjectsRequest
end

class Aws::S3::Types::DeletePublicAccessBlockRequest
  include ::Aws::Structure
end

class Aws::S3::Types::DeletePublicAccessBlockRequest
end

class Aws::S3::Types::DeletedObject
  include ::Aws::Structure
end

class Aws::S3::Types::DeletedObject
end

class Aws::S3::Types::Destination
  include ::Aws::Structure
end

class Aws::S3::Types::Destination
end

class Aws::S3::Types::Encryption
  include ::Aws::Structure
end

class Aws::S3::Types::Encryption
end

class Aws::S3::Types::EncryptionConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::EncryptionConfiguration
end

class Aws::S3::Types::EndEvent
  include ::Aws::Structure
end

class Aws::S3::Types::EndEvent
end

class Aws::S3::Types::Error
  include ::Aws::Structure
end

class Aws::S3::Types::Error
end

class Aws::S3::Types::ErrorDocument
  include ::Aws::Structure
end

class Aws::S3::Types::ErrorDocument
end

class Aws::S3::Types::ExistingObjectReplication
  include ::Aws::Structure
end

class Aws::S3::Types::ExistingObjectReplication
end

class Aws::S3::Types::FilterRule
  include ::Aws::Structure
end

class Aws::S3::Types::FilterRule
end

class Aws::S3::Types::GetBucketAccelerateConfigurationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketAccelerateConfigurationOutput
end

class Aws::S3::Types::GetBucketAccelerateConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketAccelerateConfigurationRequest
end

class Aws::S3::Types::GetBucketAclOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketAclOutput
end

class Aws::S3::Types::GetBucketAclRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketAclRequest
end

class Aws::S3::Types::GetBucketAnalyticsConfigurationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketAnalyticsConfigurationOutput
end

class Aws::S3::Types::GetBucketAnalyticsConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketAnalyticsConfigurationRequest
end

class Aws::S3::Types::GetBucketCorsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketCorsOutput
end

class Aws::S3::Types::GetBucketCorsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketCorsRequest
end

class Aws::S3::Types::GetBucketEncryptionOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketEncryptionOutput
end

class Aws::S3::Types::GetBucketEncryptionRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketEncryptionRequest
end

class Aws::S3::Types::GetBucketInventoryConfigurationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketInventoryConfigurationOutput
end

class Aws::S3::Types::GetBucketInventoryConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketInventoryConfigurationRequest
end

class Aws::S3::Types::GetBucketLifecycleConfigurationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketLifecycleConfigurationOutput
end

class Aws::S3::Types::GetBucketLifecycleConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketLifecycleConfigurationRequest
end

class Aws::S3::Types::GetBucketLifecycleOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketLifecycleOutput
end

class Aws::S3::Types::GetBucketLifecycleRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketLifecycleRequest
end

class Aws::S3::Types::GetBucketLocationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketLocationOutput
end

class Aws::S3::Types::GetBucketLocationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketLocationRequest
end

class Aws::S3::Types::GetBucketLoggingOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketLoggingOutput
end

class Aws::S3::Types::GetBucketLoggingRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketLoggingRequest
end

class Aws::S3::Types::GetBucketMetricsConfigurationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketMetricsConfigurationOutput
end

class Aws::S3::Types::GetBucketMetricsConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketMetricsConfigurationRequest
end

class Aws::S3::Types::GetBucketNotificationConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketNotificationConfigurationRequest
end

class Aws::S3::Types::GetBucketPolicyOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketPolicyOutput
end

class Aws::S3::Types::GetBucketPolicyRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketPolicyRequest
end

class Aws::S3::Types::GetBucketPolicyStatusOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketPolicyStatusOutput
end

class Aws::S3::Types::GetBucketPolicyStatusRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketPolicyStatusRequest
end

class Aws::S3::Types::GetBucketReplicationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketReplicationOutput
end

class Aws::S3::Types::GetBucketReplicationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketReplicationRequest
end

class Aws::S3::Types::GetBucketRequestPaymentOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketRequestPaymentOutput
end

class Aws::S3::Types::GetBucketRequestPaymentRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketRequestPaymentRequest
end

class Aws::S3::Types::GetBucketTaggingOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketTaggingOutput
end

class Aws::S3::Types::GetBucketTaggingRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketTaggingRequest
end

class Aws::S3::Types::GetBucketVersioningOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketVersioningOutput
end

class Aws::S3::Types::GetBucketVersioningRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketVersioningRequest
end

class Aws::S3::Types::GetBucketWebsiteOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketWebsiteOutput
end

class Aws::S3::Types::GetBucketWebsiteRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetBucketWebsiteRequest
end

class Aws::S3::Types::GetObjectAclOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectAclOutput
end

class Aws::S3::Types::GetObjectAclRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectAclRequest
end

class Aws::S3::Types::GetObjectLegalHoldOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectLegalHoldOutput
end

class Aws::S3::Types::GetObjectLegalHoldRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectLegalHoldRequest
end

class Aws::S3::Types::GetObjectLockConfigurationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectLockConfigurationOutput
end

class Aws::S3::Types::GetObjectLockConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectLockConfigurationRequest
end

class Aws::S3::Types::GetObjectOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectOutput
end

class Aws::S3::Types::GetObjectRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectRequest
end

class Aws::S3::Types::GetObjectRetentionOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectRetentionOutput
end

class Aws::S3::Types::GetObjectRetentionRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectRetentionRequest
end

class Aws::S3::Types::GetObjectTaggingOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectTaggingOutput
end

class Aws::S3::Types::GetObjectTaggingRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectTaggingRequest
end

class Aws::S3::Types::GetObjectTorrentOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectTorrentOutput
end

class Aws::S3::Types::GetObjectTorrentRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetObjectTorrentRequest
end

class Aws::S3::Types::GetPublicAccessBlockOutput
  include ::Aws::Structure
end

class Aws::S3::Types::GetPublicAccessBlockOutput
end

class Aws::S3::Types::GetPublicAccessBlockRequest
  include ::Aws::Structure
end

class Aws::S3::Types::GetPublicAccessBlockRequest
end

class Aws::S3::Types::GlacierJobParameters
  include ::Aws::Structure
end

class Aws::S3::Types::GlacierJobParameters
end

class Aws::S3::Types::Grant
  include ::Aws::Structure
end

class Aws::S3::Types::Grant
end

class Aws::S3::Types::Grantee
  include ::Aws::Structure
end

class Aws::S3::Types::Grantee
end

class Aws::S3::Types::HeadBucketRequest
  include ::Aws::Structure
end

class Aws::S3::Types::HeadBucketRequest
end

class Aws::S3::Types::HeadObjectOutput
  include ::Aws::Structure
end

class Aws::S3::Types::HeadObjectOutput
end

class Aws::S3::Types::HeadObjectRequest
  include ::Aws::Structure
end

class Aws::S3::Types::HeadObjectRequest
end

class Aws::S3::Types::IndexDocument
  include ::Aws::Structure
end

class Aws::S3::Types::IndexDocument
end

class Aws::S3::Types::Initiator
  include ::Aws::Structure
end

class Aws::S3::Types::Initiator
end

class Aws::S3::Types::InputSerialization
  include ::Aws::Structure
end

class Aws::S3::Types::InputSerialization
end

class Aws::S3::Types::InventoryConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::InventoryConfiguration
end

class Aws::S3::Types::InventoryDestination
  include ::Aws::Structure
end

class Aws::S3::Types::InventoryDestination
end

class Aws::S3::Types::InventoryEncryption
  include ::Aws::Structure
end

class Aws::S3::Types::InventoryEncryption
end

class Aws::S3::Types::InventoryFilter
  include ::Aws::Structure
end

class Aws::S3::Types::InventoryFilter
end

class Aws::S3::Types::InventoryS3BucketDestination
  include ::Aws::Structure
end

class Aws::S3::Types::InventoryS3BucketDestination
end

class Aws::S3::Types::InventorySchedule
  include ::Aws::Structure
end

class Aws::S3::Types::InventorySchedule
end

class Aws::S3::Types::JSONInput
  include ::Aws::Structure
end

class Aws::S3::Types::JSONInput
end

class Aws::S3::Types::JSONOutput
  include ::Aws::Structure
end

class Aws::S3::Types::JSONOutput
end

class Aws::S3::Types::LambdaFunctionConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::LambdaFunctionConfiguration
end

class Aws::S3::Types::LifecycleConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::LifecycleConfiguration
end

class Aws::S3::Types::LifecycleExpiration
  include ::Aws::Structure
end

class Aws::S3::Types::LifecycleExpiration
end

class Aws::S3::Types::LifecycleRule
  include ::Aws::Structure
end

class Aws::S3::Types::LifecycleRule
end

class Aws::S3::Types::LifecycleRuleAndOperator
  include ::Aws::Structure
end

class Aws::S3::Types::LifecycleRuleAndOperator
end

class Aws::S3::Types::LifecycleRuleFilter
  include ::Aws::Structure
end

class Aws::S3::Types::LifecycleRuleFilter
end

class Aws::S3::Types::ListBucketAnalyticsConfigurationsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::ListBucketAnalyticsConfigurationsOutput
end

class Aws::S3::Types::ListBucketAnalyticsConfigurationsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::ListBucketAnalyticsConfigurationsRequest
end

class Aws::S3::Types::ListBucketInventoryConfigurationsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::ListBucketInventoryConfigurationsOutput
end

class Aws::S3::Types::ListBucketInventoryConfigurationsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::ListBucketInventoryConfigurationsRequest
end

class Aws::S3::Types::ListBucketMetricsConfigurationsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::ListBucketMetricsConfigurationsOutput
end

class Aws::S3::Types::ListBucketMetricsConfigurationsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::ListBucketMetricsConfigurationsRequest
end

class Aws::S3::Types::ListBucketsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::ListBucketsOutput
end

class Aws::S3::Types::ListMultipartUploadsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::ListMultipartUploadsOutput
end

class Aws::S3::Types::ListMultipartUploadsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::ListMultipartUploadsRequest
end

class Aws::S3::Types::ListObjectVersionsOutput
  include ::Aws::Structure
  def versions_delete_markers(); end
end

class Aws::S3::Types::ListObjectVersionsOutput
end

class Aws::S3::Types::ListObjectVersionsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::ListObjectVersionsRequest
end

class Aws::S3::Types::ListObjectsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::ListObjectsOutput
end

class Aws::S3::Types::ListObjectsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::ListObjectsRequest
end

class Aws::S3::Types::ListObjectsV2Output
  include ::Aws::Structure
end

class Aws::S3::Types::ListObjectsV2Output
end

class Aws::S3::Types::ListObjectsV2Request
  include ::Aws::Structure
end

class Aws::S3::Types::ListObjectsV2Request
end

class Aws::S3::Types::ListPartsOutput
  include ::Aws::Structure
end

class Aws::S3::Types::ListPartsOutput
end

class Aws::S3::Types::ListPartsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::ListPartsRequest
end

class Aws::S3::Types::LoggingEnabled
  include ::Aws::Structure
end

class Aws::S3::Types::LoggingEnabled
end

class Aws::S3::Types::MetadataEntry
  include ::Aws::Structure
end

class Aws::S3::Types::MetadataEntry
end

class Aws::S3::Types::Metrics
  include ::Aws::Structure
end

class Aws::S3::Types::Metrics
end

class Aws::S3::Types::MetricsAndOperator
  include ::Aws::Structure
end

class Aws::S3::Types::MetricsAndOperator
end

class Aws::S3::Types::MetricsConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::MetricsConfiguration
end

class Aws::S3::Types::MetricsFilter
  include ::Aws::Structure
end

class Aws::S3::Types::MetricsFilter
end

class Aws::S3::Types::MultipartUpload
  include ::Aws::Structure
end

class Aws::S3::Types::MultipartUpload
end

class Aws::S3::Types::NoSuchBucket
end

class Aws::S3::Types::NoSuchBucket
end

class Aws::S3::Types::NoSuchKey
end

class Aws::S3::Types::NoSuchKey
end

class Aws::S3::Types::NoSuchUpload
end

class Aws::S3::Types::NoSuchUpload
end

class Aws::S3::Types::NoncurrentVersionExpiration
  include ::Aws::Structure
end

class Aws::S3::Types::NoncurrentVersionExpiration
end

class Aws::S3::Types::NoncurrentVersionTransition
  include ::Aws::Structure
end

class Aws::S3::Types::NoncurrentVersionTransition
end

class Aws::S3::Types::NotificationConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::NotificationConfiguration
end

class Aws::S3::Types::NotificationConfigurationDeprecated
  include ::Aws::Structure
end

class Aws::S3::Types::NotificationConfigurationDeprecated
end

class Aws::S3::Types::NotificationConfigurationFilter
  include ::Aws::Structure
end

class Aws::S3::Types::NotificationConfigurationFilter
end

class Aws::S3::Types::Object
  include ::Aws::Structure
end

class Aws::S3::Types::Object
end

class Aws::S3::Types::ObjectAlreadyInActiveTierError
end

class Aws::S3::Types::ObjectAlreadyInActiveTierError
end

class Aws::S3::Types::ObjectIdentifier
  include ::Aws::Structure
end

class Aws::S3::Types::ObjectIdentifier
end

class Aws::S3::Types::ObjectLockConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::ObjectLockConfiguration
end

class Aws::S3::Types::ObjectLockLegalHold
  include ::Aws::Structure
end

class Aws::S3::Types::ObjectLockLegalHold
end

class Aws::S3::Types::ObjectLockRetention
  include ::Aws::Structure
end

class Aws::S3::Types::ObjectLockRetention
end

class Aws::S3::Types::ObjectLockRule
  include ::Aws::Structure
end

class Aws::S3::Types::ObjectLockRule
end

class Aws::S3::Types::ObjectNotInActiveTierError
end

class Aws::S3::Types::ObjectNotInActiveTierError
end

class Aws::S3::Types::ObjectVersion
  include ::Aws::Structure
end

class Aws::S3::Types::ObjectVersion
end

class Aws::S3::Types::OutputLocation
  include ::Aws::Structure
end

class Aws::S3::Types::OutputLocation
end

class Aws::S3::Types::OutputSerialization
  include ::Aws::Structure
end

class Aws::S3::Types::OutputSerialization
end

class Aws::S3::Types::Owner
  include ::Aws::Structure
end

class Aws::S3::Types::Owner
end

class Aws::S3::Types::ParquetInput
end

class Aws::S3::Types::ParquetInput
end

class Aws::S3::Types::Part
  include ::Aws::Structure
end

class Aws::S3::Types::Part
end

class Aws::S3::Types::PolicyStatus
  include ::Aws::Structure
end

class Aws::S3::Types::PolicyStatus
end

class Aws::S3::Types::Progress
  include ::Aws::Structure
end

class Aws::S3::Types::Progress
end

class Aws::S3::Types::ProgressEvent
  include ::Aws::Structure
end

class Aws::S3::Types::ProgressEvent
end

class Aws::S3::Types::PublicAccessBlockConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::PublicAccessBlockConfiguration
end

class Aws::S3::Types::PutBucketAccelerateConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketAccelerateConfigurationRequest
end

class Aws::S3::Types::PutBucketAclRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketAclRequest
end

class Aws::S3::Types::PutBucketAnalyticsConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketAnalyticsConfigurationRequest
end

class Aws::S3::Types::PutBucketCorsRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketCorsRequest
end

class Aws::S3::Types::PutBucketEncryptionRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketEncryptionRequest
end

class Aws::S3::Types::PutBucketInventoryConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketInventoryConfigurationRequest
end

class Aws::S3::Types::PutBucketLifecycleConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketLifecycleConfigurationRequest
end

class Aws::S3::Types::PutBucketLifecycleRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketLifecycleRequest
end

class Aws::S3::Types::PutBucketLoggingRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketLoggingRequest
end

class Aws::S3::Types::PutBucketMetricsConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketMetricsConfigurationRequest
end

class Aws::S3::Types::PutBucketNotificationConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketNotificationConfigurationRequest
end

class Aws::S3::Types::PutBucketNotificationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketNotificationRequest
end

class Aws::S3::Types::PutBucketPolicyRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketPolicyRequest
end

class Aws::S3::Types::PutBucketReplicationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketReplicationRequest
end

class Aws::S3::Types::PutBucketRequestPaymentRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketRequestPaymentRequest
end

class Aws::S3::Types::PutBucketTaggingRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketTaggingRequest
end

class Aws::S3::Types::PutBucketVersioningRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketVersioningRequest
end

class Aws::S3::Types::PutBucketWebsiteRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutBucketWebsiteRequest
end

class Aws::S3::Types::PutObjectAclOutput
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectAclOutput
end

class Aws::S3::Types::PutObjectAclRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectAclRequest
end

class Aws::S3::Types::PutObjectLegalHoldOutput
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectLegalHoldOutput
end

class Aws::S3::Types::PutObjectLegalHoldRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectLegalHoldRequest
end

class Aws::S3::Types::PutObjectLockConfigurationOutput
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectLockConfigurationOutput
end

class Aws::S3::Types::PutObjectLockConfigurationRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectLockConfigurationRequest
end

class Aws::S3::Types::PutObjectOutput
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectOutput
end

class Aws::S3::Types::PutObjectRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectRequest
end

class Aws::S3::Types::PutObjectRetentionOutput
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectRetentionOutput
end

class Aws::S3::Types::PutObjectRetentionRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectRetentionRequest
end

class Aws::S3::Types::PutObjectTaggingOutput
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectTaggingOutput
end

class Aws::S3::Types::PutObjectTaggingRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutObjectTaggingRequest
end

class Aws::S3::Types::PutPublicAccessBlockRequest
  include ::Aws::Structure
end

class Aws::S3::Types::PutPublicAccessBlockRequest
end

class Aws::S3::Types::QueueConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::QueueConfiguration
end

class Aws::S3::Types::QueueConfigurationDeprecated
  include ::Aws::Structure
end

class Aws::S3::Types::QueueConfigurationDeprecated
end

class Aws::S3::Types::RecordsEvent
  include ::Aws::Structure
end

class Aws::S3::Types::RecordsEvent
end

class Aws::S3::Types::Redirect
  include ::Aws::Structure
end

class Aws::S3::Types::Redirect
end

class Aws::S3::Types::RedirectAllRequestsTo
  include ::Aws::Structure
end

class Aws::S3::Types::RedirectAllRequestsTo
end

class Aws::S3::Types::ReplicationConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::ReplicationConfiguration
end

class Aws::S3::Types::ReplicationRule
  include ::Aws::Structure
end

class Aws::S3::Types::ReplicationRule
end

class Aws::S3::Types::ReplicationRuleAndOperator
  include ::Aws::Structure
end

class Aws::S3::Types::ReplicationRuleAndOperator
end

class Aws::S3::Types::ReplicationRuleFilter
  include ::Aws::Structure
end

class Aws::S3::Types::ReplicationRuleFilter
end

class Aws::S3::Types::ReplicationTime
  include ::Aws::Structure
end

class Aws::S3::Types::ReplicationTime
end

class Aws::S3::Types::ReplicationTimeValue
  include ::Aws::Structure
end

class Aws::S3::Types::ReplicationTimeValue
end

class Aws::S3::Types::RequestPaymentConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::RequestPaymentConfiguration
end

class Aws::S3::Types::RequestProgress
  include ::Aws::Structure
end

class Aws::S3::Types::RequestProgress
end

class Aws::S3::Types::RestoreObjectOutput
  include ::Aws::Structure
end

class Aws::S3::Types::RestoreObjectOutput
end

class Aws::S3::Types::RestoreObjectRequest
  include ::Aws::Structure
end

class Aws::S3::Types::RestoreObjectRequest
end

class Aws::S3::Types::RestoreRequest
  include ::Aws::Structure
end

class Aws::S3::Types::RestoreRequest
end

class Aws::S3::Types::RoutingRule
  include ::Aws::Structure
end

class Aws::S3::Types::RoutingRule
end

class Aws::S3::Types::Rule
  include ::Aws::Structure
end

class Aws::S3::Types::Rule
end

class Aws::S3::Types::S3KeyFilter
  include ::Aws::Structure
end

class Aws::S3::Types::S3KeyFilter
end

class Aws::S3::Types::S3Location
  include ::Aws::Structure
end

class Aws::S3::Types::S3Location
end

class Aws::S3::Types::SSEKMS
  include ::Aws::Structure
end

class Aws::S3::Types::SSEKMS
end

class Aws::S3::Types::SSES3
end

class Aws::S3::Types::SSES3
end

class Aws::S3::Types::ScanRange
  include ::Aws::Structure
end

class Aws::S3::Types::ScanRange
end

class Aws::S3::Types::SelectObjectContentEventStream
  def event_types(); end
end

class Aws::S3::Types::SelectObjectContentEventStream
end

class Aws::S3::Types::SelectObjectContentOutput
  include ::Aws::Structure
end

class Aws::S3::Types::SelectObjectContentOutput
end

class Aws::S3::Types::SelectObjectContentRequest
  include ::Aws::Structure
end

class Aws::S3::Types::SelectObjectContentRequest
end

class Aws::S3::Types::SelectParameters
  include ::Aws::Structure
end

class Aws::S3::Types::SelectParameters
end

class Aws::S3::Types::ServerSideEncryptionByDefault
  include ::Aws::Structure
end

class Aws::S3::Types::ServerSideEncryptionByDefault
end

class Aws::S3::Types::ServerSideEncryptionConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::ServerSideEncryptionConfiguration
end

class Aws::S3::Types::ServerSideEncryptionRule
  include ::Aws::Structure
end

class Aws::S3::Types::ServerSideEncryptionRule
end

class Aws::S3::Types::SourceSelectionCriteria
  include ::Aws::Structure
end

class Aws::S3::Types::SourceSelectionCriteria
end

class Aws::S3::Types::SseKmsEncryptedObjects
  include ::Aws::Structure
end

class Aws::S3::Types::SseKmsEncryptedObjects
end

class Aws::S3::Types::Stats
  include ::Aws::Structure
end

class Aws::S3::Types::Stats
end

class Aws::S3::Types::StatsEvent
  include ::Aws::Structure
end

class Aws::S3::Types::StatsEvent
end

class Aws::S3::Types::StorageClassAnalysis
  include ::Aws::Structure
end

class Aws::S3::Types::StorageClassAnalysis
end

class Aws::S3::Types::StorageClassAnalysisDataExport
  include ::Aws::Structure
end

class Aws::S3::Types::StorageClassAnalysisDataExport
end

class Aws::S3::Types::Tag
  include ::Aws::Structure
end

class Aws::S3::Types::Tag
end

class Aws::S3::Types::Tagging
  include ::Aws::Structure
end

class Aws::S3::Types::Tagging
end

class Aws::S3::Types::TargetGrant
  include ::Aws::Structure
end

class Aws::S3::Types::TargetGrant
end

class Aws::S3::Types::TopicConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::TopicConfiguration
end

class Aws::S3::Types::TopicConfigurationDeprecated
  include ::Aws::Structure
end

class Aws::S3::Types::TopicConfigurationDeprecated
end

class Aws::S3::Types::Transition
  include ::Aws::Structure
end

class Aws::S3::Types::Transition
end

class Aws::S3::Types::UploadPartCopyOutput
  include ::Aws::Structure
end

class Aws::S3::Types::UploadPartCopyOutput
end

class Aws::S3::Types::UploadPartCopyRequest
  include ::Aws::Structure
end

class Aws::S3::Types::UploadPartCopyRequest
end

class Aws::S3::Types::UploadPartOutput
  include ::Aws::Structure
end

class Aws::S3::Types::UploadPartOutput
end

class Aws::S3::Types::UploadPartRequest
  include ::Aws::Structure
end

class Aws::S3::Types::UploadPartRequest
end

class Aws::S3::Types::VersioningConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::VersioningConfiguration
end

class Aws::S3::Types::WebsiteConfiguration
  include ::Aws::Structure
end

class Aws::S3::Types::WebsiteConfiguration
end

module Aws::S3::Types
end

module Aws::S3::Waiters
end

class Aws::S3::Waiters::BucketExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::S3::Waiters::BucketExists
end

class Aws::S3::Waiters::BucketNotExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::S3::Waiters::BucketNotExists
end

class Aws::S3::Waiters::ObjectExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::S3::Waiters::ObjectExists
end

class Aws::S3::Waiters::ObjectNotExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::S3::Waiters::ObjectNotExists
end

module Aws::S3::Waiters
end

module Aws::S3
end

module Aws::SES
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::SES::Client
  include ::Aws::ClientStubs
  def clone_receipt_rule_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_configuration_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_configuration_set_event_destination(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_configuration_set_tracking_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_custom_verification_email_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_receipt_filter(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_receipt_rule(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_receipt_rule_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_configuration_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_configuration_set_event_destination(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_configuration_set_tracking_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_custom_verification_email_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_identity(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_identity_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_receipt_filter(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_receipt_rule(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_receipt_rule_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_verified_email_address(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_active_receipt_rule_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_configuration_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_receipt_rule(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_receipt_rule_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_account_sending_enabled(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_custom_verification_email_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_identity_dkim_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_identity_mail_from_domain_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_identity_notification_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_identity_policies(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_identity_verification_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_send_quota(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_send_statistics(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(*args); end

  def list_configuration_sets(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_custom_verification_email_templates(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_identities(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_identity_policies(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_receipt_filters(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_receipt_rule_sets(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_templates(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_verified_email_addresses(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_configuration_set_delivery_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_identity_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reorder_receipt_rule_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def send_bounce(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def send_bulk_templated_email(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def send_custom_verification_email(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def send_email(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def send_raw_email(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def send_templated_email(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def set_active_receipt_rule_set(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def set_identity_dkim_enabled(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def set_identity_feedback_forwarding_enabled(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def set_identity_headers_in_notifications_enabled(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def set_identity_mail_from_domain(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def set_identity_notification_topic(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def set_receipt_rule_position(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def test_render_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_account_sending_enabled(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_configuration_set_event_destination(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_configuration_set_reputation_metrics_enabled(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_configuration_set_sending_enabled(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_configuration_set_tracking_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_custom_verification_email_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_receipt_rule(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def verify_domain_dkim(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def verify_domain_identity(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def verify_email_address(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def verify_email_identity(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def wait_until(waiter_name, params=T.unsafe(nil), options=T.unsafe(nil)); end

  def waiter_names(); end
end

class Aws::SES::Client
  def self.errors_module(); end

  def self.identifier(); end
end

module Aws::SES::ClientApi
  include ::Seahorse::Model
  API = ::T.let(nil, ::T.untyped)
  AccountSendingPausedException = ::T.let(nil, ::T.untyped)
  AddHeaderAction = ::T.let(nil, ::T.untyped)
  Address = ::T.let(nil, ::T.untyped)
  AddressList = ::T.let(nil, ::T.untyped)
  AlreadyExistsException = ::T.let(nil, ::T.untyped)
  AmazonResourceName = ::T.let(nil, ::T.untyped)
  ArrivalDate = ::T.let(nil, ::T.untyped)
  BehaviorOnMXFailure = ::T.let(nil, ::T.untyped)
  Body = ::T.let(nil, ::T.untyped)
  BounceAction = ::T.let(nil, ::T.untyped)
  BounceMessage = ::T.let(nil, ::T.untyped)
  BounceSmtpReplyCode = ::T.let(nil, ::T.untyped)
  BounceStatusCode = ::T.let(nil, ::T.untyped)
  BounceType = ::T.let(nil, ::T.untyped)
  BouncedRecipientInfo = ::T.let(nil, ::T.untyped)
  BouncedRecipientInfoList = ::T.let(nil, ::T.untyped)
  BulkEmailDestination = ::T.let(nil, ::T.untyped)
  BulkEmailDestinationList = ::T.let(nil, ::T.untyped)
  BulkEmailDestinationStatus = ::T.let(nil, ::T.untyped)
  BulkEmailDestinationStatusList = ::T.let(nil, ::T.untyped)
  BulkEmailStatus = ::T.let(nil, ::T.untyped)
  CannotDeleteException = ::T.let(nil, ::T.untyped)
  Charset = ::T.let(nil, ::T.untyped)
  Cidr = ::T.let(nil, ::T.untyped)
  CloneReceiptRuleSetRequest = ::T.let(nil, ::T.untyped)
  CloneReceiptRuleSetResponse = ::T.let(nil, ::T.untyped)
  CloudWatchDestination = ::T.let(nil, ::T.untyped)
  CloudWatchDimensionConfiguration = ::T.let(nil, ::T.untyped)
  CloudWatchDimensionConfigurations = ::T.let(nil, ::T.untyped)
  ConfigurationSet = ::T.let(nil, ::T.untyped)
  ConfigurationSetAlreadyExistsException = ::T.let(nil, ::T.untyped)
  ConfigurationSetAttribute = ::T.let(nil, ::T.untyped)
  ConfigurationSetAttributeList = ::T.let(nil, ::T.untyped)
  ConfigurationSetDoesNotExistException = ::T.let(nil, ::T.untyped)
  ConfigurationSetName = ::T.let(nil, ::T.untyped)
  ConfigurationSetSendingPausedException = ::T.let(nil, ::T.untyped)
  ConfigurationSets = ::T.let(nil, ::T.untyped)
  Content = ::T.let(nil, ::T.untyped)
  Counter = ::T.let(nil, ::T.untyped)
  CreateConfigurationSetEventDestinationRequest = ::T.let(nil, ::T.untyped)
  CreateConfigurationSetEventDestinationResponse = ::T.let(nil, ::T.untyped)
  CreateConfigurationSetRequest = ::T.let(nil, ::T.untyped)
  CreateConfigurationSetResponse = ::T.let(nil, ::T.untyped)
  CreateConfigurationSetTrackingOptionsRequest = ::T.let(nil, ::T.untyped)
  CreateConfigurationSetTrackingOptionsResponse = ::T.let(nil, ::T.untyped)
  CreateCustomVerificationEmailTemplateRequest = ::T.let(nil, ::T.untyped)
  CreateReceiptFilterRequest = ::T.let(nil, ::T.untyped)
  CreateReceiptFilterResponse = ::T.let(nil, ::T.untyped)
  CreateReceiptRuleRequest = ::T.let(nil, ::T.untyped)
  CreateReceiptRuleResponse = ::T.let(nil, ::T.untyped)
  CreateReceiptRuleSetRequest = ::T.let(nil, ::T.untyped)
  CreateReceiptRuleSetResponse = ::T.let(nil, ::T.untyped)
  CreateTemplateRequest = ::T.let(nil, ::T.untyped)
  CreateTemplateResponse = ::T.let(nil, ::T.untyped)
  CustomMailFromStatus = ::T.let(nil, ::T.untyped)
  CustomRedirectDomain = ::T.let(nil, ::T.untyped)
  CustomVerificationEmailInvalidContentException = ::T.let(nil, ::T.untyped)
  CustomVerificationEmailTemplate = ::T.let(nil, ::T.untyped)
  CustomVerificationEmailTemplateAlreadyExistsException = ::T.let(nil, ::T.untyped)
  CustomVerificationEmailTemplateDoesNotExistException = ::T.let(nil, ::T.untyped)
  CustomVerificationEmailTemplates = ::T.let(nil, ::T.untyped)
  DefaultDimensionValue = ::T.let(nil, ::T.untyped)
  DeleteConfigurationSetEventDestinationRequest = ::T.let(nil, ::T.untyped)
  DeleteConfigurationSetEventDestinationResponse = ::T.let(nil, ::T.untyped)
  DeleteConfigurationSetRequest = ::T.let(nil, ::T.untyped)
  DeleteConfigurationSetResponse = ::T.let(nil, ::T.untyped)
  DeleteConfigurationSetTrackingOptionsRequest = ::T.let(nil, ::T.untyped)
  DeleteConfigurationSetTrackingOptionsResponse = ::T.let(nil, ::T.untyped)
  DeleteCustomVerificationEmailTemplateRequest = ::T.let(nil, ::T.untyped)
  DeleteIdentityPolicyRequest = ::T.let(nil, ::T.untyped)
  DeleteIdentityPolicyResponse = ::T.let(nil, ::T.untyped)
  DeleteIdentityRequest = ::T.let(nil, ::T.untyped)
  DeleteIdentityResponse = ::T.let(nil, ::T.untyped)
  DeleteReceiptFilterRequest = ::T.let(nil, ::T.untyped)
  DeleteReceiptFilterResponse = ::T.let(nil, ::T.untyped)
  DeleteReceiptRuleRequest = ::T.let(nil, ::T.untyped)
  DeleteReceiptRuleResponse = ::T.let(nil, ::T.untyped)
  DeleteReceiptRuleSetRequest = ::T.let(nil, ::T.untyped)
  DeleteReceiptRuleSetResponse = ::T.let(nil, ::T.untyped)
  DeleteTemplateRequest = ::T.let(nil, ::T.untyped)
  DeleteTemplateResponse = ::T.let(nil, ::T.untyped)
  DeleteVerifiedEmailAddressRequest = ::T.let(nil, ::T.untyped)
  DeliveryOptions = ::T.let(nil, ::T.untyped)
  DescribeActiveReceiptRuleSetRequest = ::T.let(nil, ::T.untyped)
  DescribeActiveReceiptRuleSetResponse = ::T.let(nil, ::T.untyped)
  DescribeConfigurationSetRequest = ::T.let(nil, ::T.untyped)
  DescribeConfigurationSetResponse = ::T.let(nil, ::T.untyped)
  DescribeReceiptRuleRequest = ::T.let(nil, ::T.untyped)
  DescribeReceiptRuleResponse = ::T.let(nil, ::T.untyped)
  DescribeReceiptRuleSetRequest = ::T.let(nil, ::T.untyped)
  DescribeReceiptRuleSetResponse = ::T.let(nil, ::T.untyped)
  Destination = ::T.let(nil, ::T.untyped)
  DiagnosticCode = ::T.let(nil, ::T.untyped)
  DimensionName = ::T.let(nil, ::T.untyped)
  DimensionValueSource = ::T.let(nil, ::T.untyped)
  DkimAttributes = ::T.let(nil, ::T.untyped)
  Domain = ::T.let(nil, ::T.untyped)
  DsnAction = ::T.let(nil, ::T.untyped)
  DsnStatus = ::T.let(nil, ::T.untyped)
  Enabled = ::T.let(nil, ::T.untyped)
  Error = ::T.let(nil, ::T.untyped)
  EventDestination = ::T.let(nil, ::T.untyped)
  EventDestinationAlreadyExistsException = ::T.let(nil, ::T.untyped)
  EventDestinationDoesNotExistException = ::T.let(nil, ::T.untyped)
  EventDestinationName = ::T.let(nil, ::T.untyped)
  EventDestinations = ::T.let(nil, ::T.untyped)
  EventType = ::T.let(nil, ::T.untyped)
  EventTypes = ::T.let(nil, ::T.untyped)
  Explanation = ::T.let(nil, ::T.untyped)
  ExtensionField = ::T.let(nil, ::T.untyped)
  ExtensionFieldList = ::T.let(nil, ::T.untyped)
  ExtensionFieldName = ::T.let(nil, ::T.untyped)
  ExtensionFieldValue = ::T.let(nil, ::T.untyped)
  FailureRedirectionURL = ::T.let(nil, ::T.untyped)
  FromAddress = ::T.let(nil, ::T.untyped)
  FromEmailAddressNotVerifiedException = ::T.let(nil, ::T.untyped)
  GetAccountSendingEnabledResponse = ::T.let(nil, ::T.untyped)
  GetCustomVerificationEmailTemplateRequest = ::T.let(nil, ::T.untyped)
  GetCustomVerificationEmailTemplateResponse = ::T.let(nil, ::T.untyped)
  GetIdentityDkimAttributesRequest = ::T.let(nil, ::T.untyped)
  GetIdentityDkimAttributesResponse = ::T.let(nil, ::T.untyped)
  GetIdentityMailFromDomainAttributesRequest = ::T.let(nil, ::T.untyped)
  GetIdentityMailFromDomainAttributesResponse = ::T.let(nil, ::T.untyped)
  GetIdentityNotificationAttributesRequest = ::T.let(nil, ::T.untyped)
  GetIdentityNotificationAttributesResponse = ::T.let(nil, ::T.untyped)
  GetIdentityPoliciesRequest = ::T.let(nil, ::T.untyped)
  GetIdentityPoliciesResponse = ::T.let(nil, ::T.untyped)
  GetIdentityVerificationAttributesRequest = ::T.let(nil, ::T.untyped)
  GetIdentityVerificationAttributesResponse = ::T.let(nil, ::T.untyped)
  GetSendQuotaResponse = ::T.let(nil, ::T.untyped)
  GetSendStatisticsResponse = ::T.let(nil, ::T.untyped)
  GetTemplateRequest = ::T.let(nil, ::T.untyped)
  GetTemplateResponse = ::T.let(nil, ::T.untyped)
  HeaderName = ::T.let(nil, ::T.untyped)
  HeaderValue = ::T.let(nil, ::T.untyped)
  HtmlPart = ::T.let(nil, ::T.untyped)
  Identity = ::T.let(nil, ::T.untyped)
  IdentityDkimAttributes = ::T.let(nil, ::T.untyped)
  IdentityList = ::T.let(nil, ::T.untyped)
  IdentityMailFromDomainAttributes = ::T.let(nil, ::T.untyped)
  IdentityNotificationAttributes = ::T.let(nil, ::T.untyped)
  IdentityType = ::T.let(nil, ::T.untyped)
  IdentityVerificationAttributes = ::T.let(nil, ::T.untyped)
  InvalidCloudWatchDestinationException = ::T.let(nil, ::T.untyped)
  InvalidConfigurationSetException = ::T.let(nil, ::T.untyped)
  InvalidDeliveryOptionsException = ::T.let(nil, ::T.untyped)
  InvalidFirehoseDestinationException = ::T.let(nil, ::T.untyped)
  InvalidLambdaFunctionException = ::T.let(nil, ::T.untyped)
  InvalidPolicyException = ::T.let(nil, ::T.untyped)
  InvalidRenderingParameterException = ::T.let(nil, ::T.untyped)
  InvalidS3ConfigurationException = ::T.let(nil, ::T.untyped)
  InvalidSNSDestinationException = ::T.let(nil, ::T.untyped)
  InvalidSnsTopicException = ::T.let(nil, ::T.untyped)
  InvalidTemplateException = ::T.let(nil, ::T.untyped)
  InvalidTrackingOptionsException = ::T.let(nil, ::T.untyped)
  InvocationType = ::T.let(nil, ::T.untyped)
  KinesisFirehoseDestination = ::T.let(nil, ::T.untyped)
  LambdaAction = ::T.let(nil, ::T.untyped)
  LastAttemptDate = ::T.let(nil, ::T.untyped)
  LastFreshStart = ::T.let(nil, ::T.untyped)
  LimitExceededException = ::T.let(nil, ::T.untyped)
  ListConfigurationSetsRequest = ::T.let(nil, ::T.untyped)
  ListConfigurationSetsResponse = ::T.let(nil, ::T.untyped)
  ListCustomVerificationEmailTemplatesRequest = ::T.let(nil, ::T.untyped)
  ListCustomVerificationEmailTemplatesResponse = ::T.let(nil, ::T.untyped)
  ListIdentitiesRequest = ::T.let(nil, ::T.untyped)
  ListIdentitiesResponse = ::T.let(nil, ::T.untyped)
  ListIdentityPoliciesRequest = ::T.let(nil, ::T.untyped)
  ListIdentityPoliciesResponse = ::T.let(nil, ::T.untyped)
  ListReceiptFiltersRequest = ::T.let(nil, ::T.untyped)
  ListReceiptFiltersResponse = ::T.let(nil, ::T.untyped)
  ListReceiptRuleSetsRequest = ::T.let(nil, ::T.untyped)
  ListReceiptRuleSetsResponse = ::T.let(nil, ::T.untyped)
  ListTemplatesRequest = ::T.let(nil, ::T.untyped)
  ListTemplatesResponse = ::T.let(nil, ::T.untyped)
  ListVerifiedEmailAddressesResponse = ::T.let(nil, ::T.untyped)
  MailFromDomainAttributes = ::T.let(nil, ::T.untyped)
  MailFromDomainName = ::T.let(nil, ::T.untyped)
  MailFromDomainNotVerifiedException = ::T.let(nil, ::T.untyped)
  Max24HourSend = ::T.let(nil, ::T.untyped)
  MaxItems = ::T.let(nil, ::T.untyped)
  MaxResults = ::T.let(nil, ::T.untyped)
  MaxSendRate = ::T.let(nil, ::T.untyped)
  Message = ::T.let(nil, ::T.untyped)
  MessageData = ::T.let(nil, ::T.untyped)
  MessageDsn = ::T.let(nil, ::T.untyped)
  MessageId = ::T.let(nil, ::T.untyped)
  MessageRejected = ::T.let(nil, ::T.untyped)
  MessageTag = ::T.let(nil, ::T.untyped)
  MessageTagList = ::T.let(nil, ::T.untyped)
  MessageTagName = ::T.let(nil, ::T.untyped)
  MessageTagValue = ::T.let(nil, ::T.untyped)
  MissingRenderingAttributeException = ::T.let(nil, ::T.untyped)
  NextToken = ::T.let(nil, ::T.untyped)
  NotificationAttributes = ::T.let(nil, ::T.untyped)
  NotificationTopic = ::T.let(nil, ::T.untyped)
  NotificationType = ::T.let(nil, ::T.untyped)
  Policy = ::T.let(nil, ::T.untyped)
  PolicyMap = ::T.let(nil, ::T.untyped)
  PolicyName = ::T.let(nil, ::T.untyped)
  PolicyNameList = ::T.let(nil, ::T.untyped)
  ProductionAccessNotGrantedException = ::T.let(nil, ::T.untyped)
  PutConfigurationSetDeliveryOptionsRequest = ::T.let(nil, ::T.untyped)
  PutConfigurationSetDeliveryOptionsResponse = ::T.let(nil, ::T.untyped)
  PutIdentityPolicyRequest = ::T.let(nil, ::T.untyped)
  PutIdentityPolicyResponse = ::T.let(nil, ::T.untyped)
  RawMessage = ::T.let(nil, ::T.untyped)
  RawMessageData = ::T.let(nil, ::T.untyped)
  ReceiptAction = ::T.let(nil, ::T.untyped)
  ReceiptActionsList = ::T.let(nil, ::T.untyped)
  ReceiptFilter = ::T.let(nil, ::T.untyped)
  ReceiptFilterList = ::T.let(nil, ::T.untyped)
  ReceiptFilterName = ::T.let(nil, ::T.untyped)
  ReceiptFilterPolicy = ::T.let(nil, ::T.untyped)
  ReceiptIpFilter = ::T.let(nil, ::T.untyped)
  ReceiptRule = ::T.let(nil, ::T.untyped)
  ReceiptRuleName = ::T.let(nil, ::T.untyped)
  ReceiptRuleNamesList = ::T.let(nil, ::T.untyped)
  ReceiptRuleSetMetadata = ::T.let(nil, ::T.untyped)
  ReceiptRuleSetName = ::T.let(nil, ::T.untyped)
  ReceiptRuleSetsLists = ::T.let(nil, ::T.untyped)
  ReceiptRulesList = ::T.let(nil, ::T.untyped)
  Recipient = ::T.let(nil, ::T.untyped)
  RecipientDsnFields = ::T.let(nil, ::T.untyped)
  RecipientsList = ::T.let(nil, ::T.untyped)
  RemoteMta = ::T.let(nil, ::T.untyped)
  RenderedTemplate = ::T.let(nil, ::T.untyped)
  ReorderReceiptRuleSetRequest = ::T.let(nil, ::T.untyped)
  ReorderReceiptRuleSetResponse = ::T.let(nil, ::T.untyped)
  ReportingMta = ::T.let(nil, ::T.untyped)
  ReputationOptions = ::T.let(nil, ::T.untyped)
  RuleDoesNotExistException = ::T.let(nil, ::T.untyped)
  RuleOrRuleSetName = ::T.let(nil, ::T.untyped)
  RuleSetDoesNotExistException = ::T.let(nil, ::T.untyped)
  S3Action = ::T.let(nil, ::T.untyped)
  S3BucketName = ::T.let(nil, ::T.untyped)
  S3KeyPrefix = ::T.let(nil, ::T.untyped)
  SNSAction = ::T.let(nil, ::T.untyped)
  SNSActionEncoding = ::T.let(nil, ::T.untyped)
  SNSDestination = ::T.let(nil, ::T.untyped)
  SendBounceRequest = ::T.let(nil, ::T.untyped)
  SendBounceResponse = ::T.let(nil, ::T.untyped)
  SendBulkTemplatedEmailRequest = ::T.let(nil, ::T.untyped)
  SendBulkTemplatedEmailResponse = ::T.let(nil, ::T.untyped)
  SendCustomVerificationEmailRequest = ::T.let(nil, ::T.untyped)
  SendCustomVerificationEmailResponse = ::T.let(nil, ::T.untyped)
  SendDataPoint = ::T.let(nil, ::T.untyped)
  SendDataPointList = ::T.let(nil, ::T.untyped)
  SendEmailRequest = ::T.let(nil, ::T.untyped)
  SendEmailResponse = ::T.let(nil, ::T.untyped)
  SendRawEmailRequest = ::T.let(nil, ::T.untyped)
  SendRawEmailResponse = ::T.let(nil, ::T.untyped)
  SendTemplatedEmailRequest = ::T.let(nil, ::T.untyped)
  SendTemplatedEmailResponse = ::T.let(nil, ::T.untyped)
  SentLast24Hours = ::T.let(nil, ::T.untyped)
  SetActiveReceiptRuleSetRequest = ::T.let(nil, ::T.untyped)
  SetActiveReceiptRuleSetResponse = ::T.let(nil, ::T.untyped)
  SetIdentityDkimEnabledRequest = ::T.let(nil, ::T.untyped)
  SetIdentityDkimEnabledResponse = ::T.let(nil, ::T.untyped)
  SetIdentityFeedbackForwardingEnabledRequest = ::T.let(nil, ::T.untyped)
  SetIdentityFeedbackForwardingEnabledResponse = ::T.let(nil, ::T.untyped)
  SetIdentityHeadersInNotificationsEnabledRequest = ::T.let(nil, ::T.untyped)
  SetIdentityHeadersInNotificationsEnabledResponse = ::T.let(nil, ::T.untyped)
  SetIdentityMailFromDomainRequest = ::T.let(nil, ::T.untyped)
  SetIdentityMailFromDomainResponse = ::T.let(nil, ::T.untyped)
  SetIdentityNotificationTopicRequest = ::T.let(nil, ::T.untyped)
  SetIdentityNotificationTopicResponse = ::T.let(nil, ::T.untyped)
  SetReceiptRulePositionRequest = ::T.let(nil, ::T.untyped)
  SetReceiptRulePositionResponse = ::T.let(nil, ::T.untyped)
  StopAction = ::T.let(nil, ::T.untyped)
  StopScope = ::T.let(nil, ::T.untyped)
  Subject = ::T.let(nil, ::T.untyped)
  SubjectPart = ::T.let(nil, ::T.untyped)
  SuccessRedirectionURL = ::T.let(nil, ::T.untyped)
  Template = ::T.let(nil, ::T.untyped)
  TemplateContent = ::T.let(nil, ::T.untyped)
  TemplateData = ::T.let(nil, ::T.untyped)
  TemplateDoesNotExistException = ::T.let(nil, ::T.untyped)
  TemplateMetadata = ::T.let(nil, ::T.untyped)
  TemplateMetadataList = ::T.let(nil, ::T.untyped)
  TemplateName = ::T.let(nil, ::T.untyped)
  TestRenderTemplateRequest = ::T.let(nil, ::T.untyped)
  TestRenderTemplateResponse = ::T.let(nil, ::T.untyped)
  TextPart = ::T.let(nil, ::T.untyped)
  Timestamp = ::T.let(nil, ::T.untyped)
  TlsPolicy = ::T.let(nil, ::T.untyped)
  TrackingOptions = ::T.let(nil, ::T.untyped)
  TrackingOptionsAlreadyExistsException = ::T.let(nil, ::T.untyped)
  TrackingOptionsDoesNotExistException = ::T.let(nil, ::T.untyped)
  UpdateAccountSendingEnabledRequest = ::T.let(nil, ::T.untyped)
  UpdateConfigurationSetEventDestinationRequest = ::T.let(nil, ::T.untyped)
  UpdateConfigurationSetEventDestinationResponse = ::T.let(nil, ::T.untyped)
  UpdateConfigurationSetReputationMetricsEnabledRequest = ::T.let(nil, ::T.untyped)
  UpdateConfigurationSetSendingEnabledRequest = ::T.let(nil, ::T.untyped)
  UpdateConfigurationSetTrackingOptionsRequest = ::T.let(nil, ::T.untyped)
  UpdateConfigurationSetTrackingOptionsResponse = ::T.let(nil, ::T.untyped)
  UpdateCustomVerificationEmailTemplateRequest = ::T.let(nil, ::T.untyped)
  UpdateReceiptRuleRequest = ::T.let(nil, ::T.untyped)
  UpdateReceiptRuleResponse = ::T.let(nil, ::T.untyped)
  UpdateTemplateRequest = ::T.let(nil, ::T.untyped)
  UpdateTemplateResponse = ::T.let(nil, ::T.untyped)
  VerificationAttributes = ::T.let(nil, ::T.untyped)
  VerificationStatus = ::T.let(nil, ::T.untyped)
  VerificationToken = ::T.let(nil, ::T.untyped)
  VerificationTokenList = ::T.let(nil, ::T.untyped)
  VerifyDomainDkimRequest = ::T.let(nil, ::T.untyped)
  VerifyDomainDkimResponse = ::T.let(nil, ::T.untyped)
  VerifyDomainIdentityRequest = ::T.let(nil, ::T.untyped)
  VerifyDomainIdentityResponse = ::T.let(nil, ::T.untyped)
  VerifyEmailAddressRequest = ::T.let(nil, ::T.untyped)
  VerifyEmailIdentityRequest = ::T.let(nil, ::T.untyped)
  VerifyEmailIdentityResponse = ::T.let(nil, ::T.untyped)
  WorkmailAction = ::T.let(nil, ::T.untyped)
end

module Aws::SES::ClientApi
end

module Aws::SES::Errors
end

class Aws::SES::Errors::AccountSendingPausedException
end

class Aws::SES::Errors::AccountSendingPausedException
end

class Aws::SES::Errors::AlreadyExistsException
  def name(); end
end

class Aws::SES::Errors::AlreadyExistsException
end

class Aws::SES::Errors::CannotDeleteException
  def name(); end
end

class Aws::SES::Errors::CannotDeleteException
end

class Aws::SES::Errors::ConfigurationSetAlreadyExistsException
  def configuration_set_name(); end
end

class Aws::SES::Errors::ConfigurationSetAlreadyExistsException
end

class Aws::SES::Errors::ConfigurationSetDoesNotExistException
  def configuration_set_name(); end
end

class Aws::SES::Errors::ConfigurationSetDoesNotExistException
end

class Aws::SES::Errors::ConfigurationSetSendingPausedException
  def configuration_set_name(); end
end

class Aws::SES::Errors::ConfigurationSetSendingPausedException
end

class Aws::SES::Errors::CustomVerificationEmailInvalidContentException
end

class Aws::SES::Errors::CustomVerificationEmailInvalidContentException
end

class Aws::SES::Errors::CustomVerificationEmailTemplateAlreadyExistsException
  def custom_verification_email_template_name(); end
end

class Aws::SES::Errors::CustomVerificationEmailTemplateAlreadyExistsException
end

class Aws::SES::Errors::CustomVerificationEmailTemplateDoesNotExistException
  def custom_verification_email_template_name(); end
end

class Aws::SES::Errors::CustomVerificationEmailTemplateDoesNotExistException
end

class Aws::SES::Errors::EventDestinationAlreadyExistsException
  def configuration_set_name(); end

  def event_destination_name(); end
end

class Aws::SES::Errors::EventDestinationAlreadyExistsException
end

class Aws::SES::Errors::EventDestinationDoesNotExistException
  def configuration_set_name(); end

  def event_destination_name(); end
end

class Aws::SES::Errors::EventDestinationDoesNotExistException
end

class Aws::SES::Errors::FromEmailAddressNotVerifiedException
  def from_email_address(); end
end

class Aws::SES::Errors::FromEmailAddressNotVerifiedException
end

class Aws::SES::Errors::InvalidCloudWatchDestinationException
  def configuration_set_name(); end

  def event_destination_name(); end
end

class Aws::SES::Errors::InvalidCloudWatchDestinationException
end

class Aws::SES::Errors::InvalidConfigurationSetException
end

class Aws::SES::Errors::InvalidConfigurationSetException
end

class Aws::SES::Errors::InvalidDeliveryOptionsException
end

class Aws::SES::Errors::InvalidDeliveryOptionsException
end

class Aws::SES::Errors::InvalidFirehoseDestinationException
  def configuration_set_name(); end

  def event_destination_name(); end
end

class Aws::SES::Errors::InvalidFirehoseDestinationException
end

class Aws::SES::Errors::InvalidLambdaFunctionException
  def function_arn(); end
end

class Aws::SES::Errors::InvalidLambdaFunctionException
end

class Aws::SES::Errors::InvalidPolicyException
end

class Aws::SES::Errors::InvalidPolicyException
end

class Aws::SES::Errors::InvalidRenderingParameterException
  def template_name(); end
end

class Aws::SES::Errors::InvalidRenderingParameterException
end

class Aws::SES::Errors::InvalidS3ConfigurationException
  def bucket(); end
end

class Aws::SES::Errors::InvalidS3ConfigurationException
end

class Aws::SES::Errors::InvalidSNSDestinationException
  def configuration_set_name(); end

  def event_destination_name(); end
end

class Aws::SES::Errors::InvalidSNSDestinationException
end

class Aws::SES::Errors::InvalidSnsTopicException
  def topic(); end
end

class Aws::SES::Errors::InvalidSnsTopicException
end

class Aws::SES::Errors::InvalidTemplateException
  def template_name(); end
end

class Aws::SES::Errors::InvalidTemplateException
end

class Aws::SES::Errors::InvalidTrackingOptionsException
end

class Aws::SES::Errors::InvalidTrackingOptionsException
end

class Aws::SES::Errors::LimitExceededException
end

class Aws::SES::Errors::LimitExceededException
end

class Aws::SES::Errors::MailFromDomainNotVerifiedException
end

class Aws::SES::Errors::MailFromDomainNotVerifiedException
end

class Aws::SES::Errors::MessageRejected
end

class Aws::SES::Errors::MessageRejected
end

class Aws::SES::Errors::MissingRenderingAttributeException
  def template_name(); end
end

class Aws::SES::Errors::MissingRenderingAttributeException
end

class Aws::SES::Errors::ProductionAccessNotGrantedException
end

class Aws::SES::Errors::ProductionAccessNotGrantedException
end

class Aws::SES::Errors::RuleDoesNotExistException
  def name(); end
end

class Aws::SES::Errors::RuleDoesNotExistException
end

class Aws::SES::Errors::RuleSetDoesNotExistException
  def name(); end
end

class Aws::SES::Errors::RuleSetDoesNotExistException
end

class Aws::SES::Errors::ServiceError
end

class Aws::SES::Errors::ServiceError
end

class Aws::SES::Errors::TemplateDoesNotExistException
  def template_name(); end
end

class Aws::SES::Errors::TemplateDoesNotExistException
end

class Aws::SES::Errors::TrackingOptionsAlreadyExistsException
  def configuration_set_name(); end
end

class Aws::SES::Errors::TrackingOptionsAlreadyExistsException
end

class Aws::SES::Errors::TrackingOptionsDoesNotExistException
  def configuration_set_name(); end
end

class Aws::SES::Errors::TrackingOptionsDoesNotExistException
end

module Aws::SES::Errors
  extend ::Aws::Errors::DynamicErrors
end

class Aws::SES::Resource
  def client(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::SES::Resource
end

module Aws::SES::Types
end

class Aws::SES::Types::AccountSendingPausedException
end

class Aws::SES::Types::AccountSendingPausedException
end

class Aws::SES::Types::AddHeaderAction
  include ::Aws::Structure
end

class Aws::SES::Types::AddHeaderAction
end

class Aws::SES::Types::AlreadyExistsException
  include ::Aws::Structure
end

class Aws::SES::Types::AlreadyExistsException
end

class Aws::SES::Types::Body
  include ::Aws::Structure
end

class Aws::SES::Types::Body
end

class Aws::SES::Types::BounceAction
  include ::Aws::Structure
end

class Aws::SES::Types::BounceAction
end

class Aws::SES::Types::BouncedRecipientInfo
  include ::Aws::Structure
end

class Aws::SES::Types::BouncedRecipientInfo
end

class Aws::SES::Types::BulkEmailDestination
  include ::Aws::Structure
end

class Aws::SES::Types::BulkEmailDestination
end

class Aws::SES::Types::BulkEmailDestinationStatus
  include ::Aws::Structure
end

class Aws::SES::Types::BulkEmailDestinationStatus
end

class Aws::SES::Types::CannotDeleteException
  include ::Aws::Structure
end

class Aws::SES::Types::CannotDeleteException
end

class Aws::SES::Types::CloneReceiptRuleSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CloneReceiptRuleSetRequest
end

class Aws::SES::Types::CloneReceiptRuleSetResponse
end

class Aws::SES::Types::CloneReceiptRuleSetResponse
end

class Aws::SES::Types::CloudWatchDestination
  include ::Aws::Structure
end

class Aws::SES::Types::CloudWatchDestination
end

class Aws::SES::Types::CloudWatchDimensionConfiguration
  include ::Aws::Structure
end

class Aws::SES::Types::CloudWatchDimensionConfiguration
end

class Aws::SES::Types::ConfigurationSet
  include ::Aws::Structure
end

class Aws::SES::Types::ConfigurationSet
end

class Aws::SES::Types::ConfigurationSetAlreadyExistsException
  include ::Aws::Structure
end

class Aws::SES::Types::ConfigurationSetAlreadyExistsException
end

class Aws::SES::Types::ConfigurationSetDoesNotExistException
  include ::Aws::Structure
end

class Aws::SES::Types::ConfigurationSetDoesNotExistException
end

class Aws::SES::Types::ConfigurationSetSendingPausedException
  include ::Aws::Structure
end

class Aws::SES::Types::ConfigurationSetSendingPausedException
end

class Aws::SES::Types::Content
  include ::Aws::Structure
end

class Aws::SES::Types::Content
end

class Aws::SES::Types::CreateConfigurationSetEventDestinationRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CreateConfigurationSetEventDestinationRequest
end

class Aws::SES::Types::CreateConfigurationSetEventDestinationResponse
end

class Aws::SES::Types::CreateConfigurationSetEventDestinationResponse
end

class Aws::SES::Types::CreateConfigurationSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CreateConfigurationSetRequest
end

class Aws::SES::Types::CreateConfigurationSetResponse
end

class Aws::SES::Types::CreateConfigurationSetResponse
end

class Aws::SES::Types::CreateConfigurationSetTrackingOptionsRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CreateConfigurationSetTrackingOptionsRequest
end

class Aws::SES::Types::CreateConfigurationSetTrackingOptionsResponse
end

class Aws::SES::Types::CreateConfigurationSetTrackingOptionsResponse
end

class Aws::SES::Types::CreateCustomVerificationEmailTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CreateCustomVerificationEmailTemplateRequest
end

class Aws::SES::Types::CreateReceiptFilterRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CreateReceiptFilterRequest
end

class Aws::SES::Types::CreateReceiptFilterResponse
end

class Aws::SES::Types::CreateReceiptFilterResponse
end

class Aws::SES::Types::CreateReceiptRuleRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CreateReceiptRuleRequest
end

class Aws::SES::Types::CreateReceiptRuleResponse
end

class Aws::SES::Types::CreateReceiptRuleResponse
end

class Aws::SES::Types::CreateReceiptRuleSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CreateReceiptRuleSetRequest
end

class Aws::SES::Types::CreateReceiptRuleSetResponse
end

class Aws::SES::Types::CreateReceiptRuleSetResponse
end

class Aws::SES::Types::CreateTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::CreateTemplateRequest
end

class Aws::SES::Types::CreateTemplateResponse
end

class Aws::SES::Types::CreateTemplateResponse
end

class Aws::SES::Types::CustomVerificationEmailInvalidContentException
end

class Aws::SES::Types::CustomVerificationEmailInvalidContentException
end

class Aws::SES::Types::CustomVerificationEmailTemplate
  include ::Aws::Structure
end

class Aws::SES::Types::CustomVerificationEmailTemplate
end

class Aws::SES::Types::CustomVerificationEmailTemplateAlreadyExistsException
  include ::Aws::Structure
end

class Aws::SES::Types::CustomVerificationEmailTemplateAlreadyExistsException
end

class Aws::SES::Types::CustomVerificationEmailTemplateDoesNotExistException
  include ::Aws::Structure
end

class Aws::SES::Types::CustomVerificationEmailTemplateDoesNotExistException
end

class Aws::SES::Types::DeleteConfigurationSetEventDestinationRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteConfigurationSetEventDestinationRequest
end

class Aws::SES::Types::DeleteConfigurationSetEventDestinationResponse
end

class Aws::SES::Types::DeleteConfigurationSetEventDestinationResponse
end

class Aws::SES::Types::DeleteConfigurationSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteConfigurationSetRequest
end

class Aws::SES::Types::DeleteConfigurationSetResponse
end

class Aws::SES::Types::DeleteConfigurationSetResponse
end

class Aws::SES::Types::DeleteConfigurationSetTrackingOptionsRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteConfigurationSetTrackingOptionsRequest
end

class Aws::SES::Types::DeleteConfigurationSetTrackingOptionsResponse
end

class Aws::SES::Types::DeleteConfigurationSetTrackingOptionsResponse
end

class Aws::SES::Types::DeleteCustomVerificationEmailTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteCustomVerificationEmailTemplateRequest
end

class Aws::SES::Types::DeleteIdentityPolicyRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteIdentityPolicyRequest
end

class Aws::SES::Types::DeleteIdentityPolicyResponse
end

class Aws::SES::Types::DeleteIdentityPolicyResponse
end

class Aws::SES::Types::DeleteIdentityRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteIdentityRequest
end

class Aws::SES::Types::DeleteIdentityResponse
end

class Aws::SES::Types::DeleteIdentityResponse
end

class Aws::SES::Types::DeleteReceiptFilterRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteReceiptFilterRequest
end

class Aws::SES::Types::DeleteReceiptFilterResponse
end

class Aws::SES::Types::DeleteReceiptFilterResponse
end

class Aws::SES::Types::DeleteReceiptRuleRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteReceiptRuleRequest
end

class Aws::SES::Types::DeleteReceiptRuleResponse
end

class Aws::SES::Types::DeleteReceiptRuleResponse
end

class Aws::SES::Types::DeleteReceiptRuleSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteReceiptRuleSetRequest
end

class Aws::SES::Types::DeleteReceiptRuleSetResponse
end

class Aws::SES::Types::DeleteReceiptRuleSetResponse
end

class Aws::SES::Types::DeleteTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteTemplateRequest
end

class Aws::SES::Types::DeleteTemplateResponse
end

class Aws::SES::Types::DeleteTemplateResponse
end

class Aws::SES::Types::DeleteVerifiedEmailAddressRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DeleteVerifiedEmailAddressRequest
end

class Aws::SES::Types::DeliveryOptions
  include ::Aws::Structure
end

class Aws::SES::Types::DeliveryOptions
end

class Aws::SES::Types::DescribeActiveReceiptRuleSetRequest
end

class Aws::SES::Types::DescribeActiveReceiptRuleSetRequest
end

class Aws::SES::Types::DescribeActiveReceiptRuleSetResponse
  include ::Aws::Structure
end

class Aws::SES::Types::DescribeActiveReceiptRuleSetResponse
end

class Aws::SES::Types::DescribeConfigurationSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DescribeConfigurationSetRequest
end

class Aws::SES::Types::DescribeConfigurationSetResponse
  include ::Aws::Structure
end

class Aws::SES::Types::DescribeConfigurationSetResponse
end

class Aws::SES::Types::DescribeReceiptRuleRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DescribeReceiptRuleRequest
end

class Aws::SES::Types::DescribeReceiptRuleResponse
  include ::Aws::Structure
end

class Aws::SES::Types::DescribeReceiptRuleResponse
end

class Aws::SES::Types::DescribeReceiptRuleSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::DescribeReceiptRuleSetRequest
end

class Aws::SES::Types::DescribeReceiptRuleSetResponse
  include ::Aws::Structure
end

class Aws::SES::Types::DescribeReceiptRuleSetResponse
end

class Aws::SES::Types::Destination
  include ::Aws::Structure
end

class Aws::SES::Types::Destination
end

class Aws::SES::Types::EventDestination
  include ::Aws::Structure
end

class Aws::SES::Types::EventDestination
end

class Aws::SES::Types::EventDestinationAlreadyExistsException
  include ::Aws::Structure
end

class Aws::SES::Types::EventDestinationAlreadyExistsException
end

class Aws::SES::Types::EventDestinationDoesNotExistException
  include ::Aws::Structure
end

class Aws::SES::Types::EventDestinationDoesNotExistException
end

class Aws::SES::Types::ExtensionField
  include ::Aws::Structure
end

class Aws::SES::Types::ExtensionField
end

class Aws::SES::Types::FromEmailAddressNotVerifiedException
  include ::Aws::Structure
end

class Aws::SES::Types::FromEmailAddressNotVerifiedException
end

class Aws::SES::Types::GetAccountSendingEnabledResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetAccountSendingEnabledResponse
end

class Aws::SES::Types::GetCustomVerificationEmailTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::GetCustomVerificationEmailTemplateRequest
end

class Aws::SES::Types::GetCustomVerificationEmailTemplateResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetCustomVerificationEmailTemplateResponse
end

class Aws::SES::Types::GetIdentityDkimAttributesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityDkimAttributesRequest
end

class Aws::SES::Types::GetIdentityDkimAttributesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityDkimAttributesResponse
end

class Aws::SES::Types::GetIdentityMailFromDomainAttributesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityMailFromDomainAttributesRequest
end

class Aws::SES::Types::GetIdentityMailFromDomainAttributesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityMailFromDomainAttributesResponse
end

class Aws::SES::Types::GetIdentityNotificationAttributesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityNotificationAttributesRequest
end

class Aws::SES::Types::GetIdentityNotificationAttributesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityNotificationAttributesResponse
end

class Aws::SES::Types::GetIdentityPoliciesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityPoliciesRequest
end

class Aws::SES::Types::GetIdentityPoliciesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityPoliciesResponse
end

class Aws::SES::Types::GetIdentityVerificationAttributesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityVerificationAttributesRequest
end

class Aws::SES::Types::GetIdentityVerificationAttributesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetIdentityVerificationAttributesResponse
end

class Aws::SES::Types::GetSendQuotaResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetSendQuotaResponse
end

class Aws::SES::Types::GetSendStatisticsResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetSendStatisticsResponse
end

class Aws::SES::Types::GetTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::GetTemplateRequest
end

class Aws::SES::Types::GetTemplateResponse
  include ::Aws::Structure
end

class Aws::SES::Types::GetTemplateResponse
end

class Aws::SES::Types::IdentityDkimAttributes
  include ::Aws::Structure
end

class Aws::SES::Types::IdentityDkimAttributes
end

class Aws::SES::Types::IdentityMailFromDomainAttributes
  include ::Aws::Structure
end

class Aws::SES::Types::IdentityMailFromDomainAttributes
end

class Aws::SES::Types::IdentityNotificationAttributes
  include ::Aws::Structure
end

class Aws::SES::Types::IdentityNotificationAttributes
end

class Aws::SES::Types::IdentityVerificationAttributes
  include ::Aws::Structure
end

class Aws::SES::Types::IdentityVerificationAttributes
end

class Aws::SES::Types::InvalidCloudWatchDestinationException
  include ::Aws::Structure
end

class Aws::SES::Types::InvalidCloudWatchDestinationException
end

class Aws::SES::Types::InvalidConfigurationSetException
end

class Aws::SES::Types::InvalidConfigurationSetException
end

class Aws::SES::Types::InvalidDeliveryOptionsException
end

class Aws::SES::Types::InvalidDeliveryOptionsException
end

class Aws::SES::Types::InvalidFirehoseDestinationException
  include ::Aws::Structure
end

class Aws::SES::Types::InvalidFirehoseDestinationException
end

class Aws::SES::Types::InvalidLambdaFunctionException
  include ::Aws::Structure
end

class Aws::SES::Types::InvalidLambdaFunctionException
end

class Aws::SES::Types::InvalidPolicyException
end

class Aws::SES::Types::InvalidPolicyException
end

class Aws::SES::Types::InvalidRenderingParameterException
  include ::Aws::Structure
end

class Aws::SES::Types::InvalidRenderingParameterException
end

class Aws::SES::Types::InvalidS3ConfigurationException
  include ::Aws::Structure
end

class Aws::SES::Types::InvalidS3ConfigurationException
end

class Aws::SES::Types::InvalidSNSDestinationException
  include ::Aws::Structure
end

class Aws::SES::Types::InvalidSNSDestinationException
end

class Aws::SES::Types::InvalidSnsTopicException
  include ::Aws::Structure
end

class Aws::SES::Types::InvalidSnsTopicException
end

class Aws::SES::Types::InvalidTemplateException
  include ::Aws::Structure
end

class Aws::SES::Types::InvalidTemplateException
end

class Aws::SES::Types::InvalidTrackingOptionsException
end

class Aws::SES::Types::InvalidTrackingOptionsException
end

class Aws::SES::Types::KinesisFirehoseDestination
  include ::Aws::Structure
end

class Aws::SES::Types::KinesisFirehoseDestination
end

class Aws::SES::Types::LambdaAction
  include ::Aws::Structure
end

class Aws::SES::Types::LambdaAction
end

class Aws::SES::Types::LimitExceededException
end

class Aws::SES::Types::LimitExceededException
end

class Aws::SES::Types::ListConfigurationSetsRequest
  include ::Aws::Structure
end

class Aws::SES::Types::ListConfigurationSetsRequest
end

class Aws::SES::Types::ListConfigurationSetsResponse
  include ::Aws::Structure
end

class Aws::SES::Types::ListConfigurationSetsResponse
end

class Aws::SES::Types::ListCustomVerificationEmailTemplatesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::ListCustomVerificationEmailTemplatesRequest
end

class Aws::SES::Types::ListCustomVerificationEmailTemplatesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::ListCustomVerificationEmailTemplatesResponse
end

class Aws::SES::Types::ListIdentitiesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::ListIdentitiesRequest
end

class Aws::SES::Types::ListIdentitiesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::ListIdentitiesResponse
end

class Aws::SES::Types::ListIdentityPoliciesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::ListIdentityPoliciesRequest
end

class Aws::SES::Types::ListIdentityPoliciesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::ListIdentityPoliciesResponse
end

class Aws::SES::Types::ListReceiptFiltersRequest
end

class Aws::SES::Types::ListReceiptFiltersRequest
end

class Aws::SES::Types::ListReceiptFiltersResponse
  include ::Aws::Structure
end

class Aws::SES::Types::ListReceiptFiltersResponse
end

class Aws::SES::Types::ListReceiptRuleSetsRequest
  include ::Aws::Structure
end

class Aws::SES::Types::ListReceiptRuleSetsRequest
end

class Aws::SES::Types::ListReceiptRuleSetsResponse
  include ::Aws::Structure
end

class Aws::SES::Types::ListReceiptRuleSetsResponse
end

class Aws::SES::Types::ListTemplatesRequest
  include ::Aws::Structure
end

class Aws::SES::Types::ListTemplatesRequest
end

class Aws::SES::Types::ListTemplatesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::ListTemplatesResponse
end

class Aws::SES::Types::ListVerifiedEmailAddressesResponse
  include ::Aws::Structure
end

class Aws::SES::Types::ListVerifiedEmailAddressesResponse
end

class Aws::SES::Types::MailFromDomainNotVerifiedException
end

class Aws::SES::Types::MailFromDomainNotVerifiedException
end

class Aws::SES::Types::Message
  include ::Aws::Structure
end

class Aws::SES::Types::Message
end

class Aws::SES::Types::MessageDsn
  include ::Aws::Structure
end

class Aws::SES::Types::MessageDsn
end

class Aws::SES::Types::MessageRejected
end

class Aws::SES::Types::MessageRejected
end

class Aws::SES::Types::MessageTag
  include ::Aws::Structure
end

class Aws::SES::Types::MessageTag
end

class Aws::SES::Types::MissingRenderingAttributeException
  include ::Aws::Structure
end

class Aws::SES::Types::MissingRenderingAttributeException
end

class Aws::SES::Types::ProductionAccessNotGrantedException
end

class Aws::SES::Types::ProductionAccessNotGrantedException
end

class Aws::SES::Types::PutConfigurationSetDeliveryOptionsRequest
  include ::Aws::Structure
end

class Aws::SES::Types::PutConfigurationSetDeliveryOptionsRequest
end

class Aws::SES::Types::PutConfigurationSetDeliveryOptionsResponse
end

class Aws::SES::Types::PutConfigurationSetDeliveryOptionsResponse
end

class Aws::SES::Types::PutIdentityPolicyRequest
  include ::Aws::Structure
end

class Aws::SES::Types::PutIdentityPolicyRequest
end

class Aws::SES::Types::PutIdentityPolicyResponse
end

class Aws::SES::Types::PutIdentityPolicyResponse
end

class Aws::SES::Types::RawMessage
  include ::Aws::Structure
end

class Aws::SES::Types::RawMessage
end

class Aws::SES::Types::ReceiptAction
  include ::Aws::Structure
end

class Aws::SES::Types::ReceiptAction
end

class Aws::SES::Types::ReceiptFilter
  include ::Aws::Structure
end

class Aws::SES::Types::ReceiptFilter
end

class Aws::SES::Types::ReceiptIpFilter
  include ::Aws::Structure
end

class Aws::SES::Types::ReceiptIpFilter
end

class Aws::SES::Types::ReceiptRule
  include ::Aws::Structure
end

class Aws::SES::Types::ReceiptRule
end

class Aws::SES::Types::ReceiptRuleSetMetadata
  include ::Aws::Structure
end

class Aws::SES::Types::ReceiptRuleSetMetadata
end

class Aws::SES::Types::RecipientDsnFields
  include ::Aws::Structure
end

class Aws::SES::Types::RecipientDsnFields
end

class Aws::SES::Types::ReorderReceiptRuleSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::ReorderReceiptRuleSetRequest
end

class Aws::SES::Types::ReorderReceiptRuleSetResponse
end

class Aws::SES::Types::ReorderReceiptRuleSetResponse
end

class Aws::SES::Types::ReputationOptions
  include ::Aws::Structure
end

class Aws::SES::Types::ReputationOptions
end

class Aws::SES::Types::RuleDoesNotExistException
  include ::Aws::Structure
end

class Aws::SES::Types::RuleDoesNotExistException
end

class Aws::SES::Types::RuleSetDoesNotExistException
  include ::Aws::Structure
end

class Aws::SES::Types::RuleSetDoesNotExistException
end

class Aws::SES::Types::S3Action
  include ::Aws::Structure
end

class Aws::SES::Types::S3Action
end

class Aws::SES::Types::SNSAction
  include ::Aws::Structure
end

class Aws::SES::Types::SNSAction
end

class Aws::SES::Types::SNSDestination
  include ::Aws::Structure
end

class Aws::SES::Types::SNSDestination
end

class Aws::SES::Types::SendBounceRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SendBounceRequest
end

class Aws::SES::Types::SendBounceResponse
  include ::Aws::Structure
end

class Aws::SES::Types::SendBounceResponse
end

class Aws::SES::Types::SendBulkTemplatedEmailRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SendBulkTemplatedEmailRequest
end

class Aws::SES::Types::SendBulkTemplatedEmailResponse
  include ::Aws::Structure
end

class Aws::SES::Types::SendBulkTemplatedEmailResponse
end

class Aws::SES::Types::SendCustomVerificationEmailRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SendCustomVerificationEmailRequest
end

class Aws::SES::Types::SendCustomVerificationEmailResponse
  include ::Aws::Structure
end

class Aws::SES::Types::SendCustomVerificationEmailResponse
end

class Aws::SES::Types::SendDataPoint
  include ::Aws::Structure
end

class Aws::SES::Types::SendDataPoint
end

class Aws::SES::Types::SendEmailRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SendEmailRequest
end

class Aws::SES::Types::SendEmailResponse
  include ::Aws::Structure
end

class Aws::SES::Types::SendEmailResponse
end

class Aws::SES::Types::SendRawEmailRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SendRawEmailRequest
end

class Aws::SES::Types::SendRawEmailResponse
  include ::Aws::Structure
end

class Aws::SES::Types::SendRawEmailResponse
end

class Aws::SES::Types::SendTemplatedEmailRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SendTemplatedEmailRequest
end

class Aws::SES::Types::SendTemplatedEmailResponse
  include ::Aws::Structure
end

class Aws::SES::Types::SendTemplatedEmailResponse
end

class Aws::SES::Types::SetActiveReceiptRuleSetRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SetActiveReceiptRuleSetRequest
end

class Aws::SES::Types::SetActiveReceiptRuleSetResponse
end

class Aws::SES::Types::SetActiveReceiptRuleSetResponse
end

class Aws::SES::Types::SetIdentityDkimEnabledRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SetIdentityDkimEnabledRequest
end

class Aws::SES::Types::SetIdentityDkimEnabledResponse
end

class Aws::SES::Types::SetIdentityDkimEnabledResponse
end

class Aws::SES::Types::SetIdentityFeedbackForwardingEnabledRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SetIdentityFeedbackForwardingEnabledRequest
end

class Aws::SES::Types::SetIdentityFeedbackForwardingEnabledResponse
end

class Aws::SES::Types::SetIdentityFeedbackForwardingEnabledResponse
end

class Aws::SES::Types::SetIdentityHeadersInNotificationsEnabledRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SetIdentityHeadersInNotificationsEnabledRequest
end

class Aws::SES::Types::SetIdentityHeadersInNotificationsEnabledResponse
end

class Aws::SES::Types::SetIdentityHeadersInNotificationsEnabledResponse
end

class Aws::SES::Types::SetIdentityMailFromDomainRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SetIdentityMailFromDomainRequest
end

class Aws::SES::Types::SetIdentityMailFromDomainResponse
end

class Aws::SES::Types::SetIdentityMailFromDomainResponse
end

class Aws::SES::Types::SetIdentityNotificationTopicRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SetIdentityNotificationTopicRequest
end

class Aws::SES::Types::SetIdentityNotificationTopicResponse
end

class Aws::SES::Types::SetIdentityNotificationTopicResponse
end

class Aws::SES::Types::SetReceiptRulePositionRequest
  include ::Aws::Structure
end

class Aws::SES::Types::SetReceiptRulePositionRequest
end

class Aws::SES::Types::SetReceiptRulePositionResponse
end

class Aws::SES::Types::SetReceiptRulePositionResponse
end

class Aws::SES::Types::StopAction
  include ::Aws::Structure
end

class Aws::SES::Types::StopAction
end

class Aws::SES::Types::Template
  include ::Aws::Structure
end

class Aws::SES::Types::Template
end

class Aws::SES::Types::TemplateDoesNotExistException
  include ::Aws::Structure
end

class Aws::SES::Types::TemplateDoesNotExistException
end

class Aws::SES::Types::TemplateMetadata
  include ::Aws::Structure
end

class Aws::SES::Types::TemplateMetadata
end

class Aws::SES::Types::TestRenderTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::TestRenderTemplateRequest
end

class Aws::SES::Types::TestRenderTemplateResponse
  include ::Aws::Structure
end

class Aws::SES::Types::TestRenderTemplateResponse
end

class Aws::SES::Types::TrackingOptions
  include ::Aws::Structure
end

class Aws::SES::Types::TrackingOptions
end

class Aws::SES::Types::TrackingOptionsAlreadyExistsException
  include ::Aws::Structure
end

class Aws::SES::Types::TrackingOptionsAlreadyExistsException
end

class Aws::SES::Types::TrackingOptionsDoesNotExistException
  include ::Aws::Structure
end

class Aws::SES::Types::TrackingOptionsDoesNotExistException
end

class Aws::SES::Types::UpdateAccountSendingEnabledRequest
  include ::Aws::Structure
end

class Aws::SES::Types::UpdateAccountSendingEnabledRequest
end

class Aws::SES::Types::UpdateConfigurationSetEventDestinationRequest
  include ::Aws::Structure
end

class Aws::SES::Types::UpdateConfigurationSetEventDestinationRequest
end

class Aws::SES::Types::UpdateConfigurationSetEventDestinationResponse
end

class Aws::SES::Types::UpdateConfigurationSetEventDestinationResponse
end

class Aws::SES::Types::UpdateConfigurationSetReputationMetricsEnabledRequest
  include ::Aws::Structure
end

class Aws::SES::Types::UpdateConfigurationSetReputationMetricsEnabledRequest
end

class Aws::SES::Types::UpdateConfigurationSetSendingEnabledRequest
  include ::Aws::Structure
end

class Aws::SES::Types::UpdateConfigurationSetSendingEnabledRequest
end

class Aws::SES::Types::UpdateConfigurationSetTrackingOptionsRequest
  include ::Aws::Structure
end

class Aws::SES::Types::UpdateConfigurationSetTrackingOptionsRequest
end

class Aws::SES::Types::UpdateConfigurationSetTrackingOptionsResponse
end

class Aws::SES::Types::UpdateConfigurationSetTrackingOptionsResponse
end

class Aws::SES::Types::UpdateCustomVerificationEmailTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::UpdateCustomVerificationEmailTemplateRequest
end

class Aws::SES::Types::UpdateReceiptRuleRequest
  include ::Aws::Structure
end

class Aws::SES::Types::UpdateReceiptRuleRequest
end

class Aws::SES::Types::UpdateReceiptRuleResponse
end

class Aws::SES::Types::UpdateReceiptRuleResponse
end

class Aws::SES::Types::UpdateTemplateRequest
  include ::Aws::Structure
end

class Aws::SES::Types::UpdateTemplateRequest
end

class Aws::SES::Types::UpdateTemplateResponse
end

class Aws::SES::Types::UpdateTemplateResponse
end

class Aws::SES::Types::VerifyDomainDkimRequest
  include ::Aws::Structure
end

class Aws::SES::Types::VerifyDomainDkimRequest
end

class Aws::SES::Types::VerifyDomainDkimResponse
  include ::Aws::Structure
end

class Aws::SES::Types::VerifyDomainDkimResponse
end

class Aws::SES::Types::VerifyDomainIdentityRequest
  include ::Aws::Structure
end

class Aws::SES::Types::VerifyDomainIdentityRequest
end

class Aws::SES::Types::VerifyDomainIdentityResponse
  include ::Aws::Structure
end

class Aws::SES::Types::VerifyDomainIdentityResponse
end

class Aws::SES::Types::VerifyEmailAddressRequest
  include ::Aws::Structure
end

class Aws::SES::Types::VerifyEmailAddressRequest
end

class Aws::SES::Types::VerifyEmailIdentityRequest
  include ::Aws::Structure
end

class Aws::SES::Types::VerifyEmailIdentityRequest
end

class Aws::SES::Types::VerifyEmailIdentityResponse
end

class Aws::SES::Types::VerifyEmailIdentityResponse
end

class Aws::SES::Types::WorkmailAction
  include ::Aws::Structure
end

class Aws::SES::Types::WorkmailAction
end

module Aws::SES::Types
end

module Aws::SES::Waiters
end

class Aws::SES::Waiters::IdentityExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::SES::Waiters::IdentityExists
end

module Aws::SES::Waiters
end

module Aws::SES
end

module Aws::STS
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Client
  include ::Aws::ClientStubs
  def assume_role(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def assume_role_with_saml(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def assume_role_with_web_identity(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def decode_authorization_message(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_access_key_info(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_caller_identity(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_federation_token(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_session_token(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(*args); end

  def waiter_names(); end
end

class Aws::STS::Client
  def self.errors_module(); end

  def self.identifier(); end
end

module Aws::STS::ClientApi
  include ::Seahorse::Model
  API = ::T.let(nil, ::T.untyped)
  AssumeRoleRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleResponse = ::T.let(nil, ::T.untyped)
  AssumeRoleWithSAMLRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleWithSAMLResponse = ::T.let(nil, ::T.untyped)
  AssumeRoleWithWebIdentityRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleWithWebIdentityResponse = ::T.let(nil, ::T.untyped)
  AssumedRoleUser = ::T.let(nil, ::T.untyped)
  Audience = ::T.let(nil, ::T.untyped)
  Credentials = ::T.let(nil, ::T.untyped)
  DecodeAuthorizationMessageRequest = ::T.let(nil, ::T.untyped)
  DecodeAuthorizationMessageResponse = ::T.let(nil, ::T.untyped)
  ExpiredTokenException = ::T.let(nil, ::T.untyped)
  FederatedUser = ::T.let(nil, ::T.untyped)
  GetAccessKeyInfoRequest = ::T.let(nil, ::T.untyped)
  GetAccessKeyInfoResponse = ::T.let(nil, ::T.untyped)
  GetCallerIdentityRequest = ::T.let(nil, ::T.untyped)
  GetCallerIdentityResponse = ::T.let(nil, ::T.untyped)
  GetFederationTokenRequest = ::T.let(nil, ::T.untyped)
  GetFederationTokenResponse = ::T.let(nil, ::T.untyped)
  GetSessionTokenRequest = ::T.let(nil, ::T.untyped)
  GetSessionTokenResponse = ::T.let(nil, ::T.untyped)
  IDPCommunicationErrorException = ::T.let(nil, ::T.untyped)
  IDPRejectedClaimException = ::T.let(nil, ::T.untyped)
  InvalidAuthorizationMessageException = ::T.let(nil, ::T.untyped)
  InvalidIdentityTokenException = ::T.let(nil, ::T.untyped)
  Issuer = ::T.let(nil, ::T.untyped)
  MalformedPolicyDocumentException = ::T.let(nil, ::T.untyped)
  NameQualifier = ::T.let(nil, ::T.untyped)
  PackedPolicyTooLargeException = ::T.let(nil, ::T.untyped)
  PolicyDescriptorType = ::T.let(nil, ::T.untyped)
  RegionDisabledException = ::T.let(nil, ::T.untyped)
  SAMLAssertionType = ::T.let(nil, ::T.untyped)
  Subject = ::T.let(nil, ::T.untyped)
  SubjectType = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
end

module Aws::STS::ClientApi
end

module Aws::STS::Errors
end

class Aws::STS::Errors::ExpiredTokenException
end

class Aws::STS::Errors::ExpiredTokenException
end

class Aws::STS::Errors::IDPCommunicationErrorException
end

class Aws::STS::Errors::IDPCommunicationErrorException
end

class Aws::STS::Errors::IDPRejectedClaimException
end

class Aws::STS::Errors::IDPRejectedClaimException
end

class Aws::STS::Errors::InvalidAuthorizationMessageException
end

class Aws::STS::Errors::InvalidAuthorizationMessageException
end

class Aws::STS::Errors::InvalidIdentityTokenException
end

class Aws::STS::Errors::InvalidIdentityTokenException
end

class Aws::STS::Errors::MalformedPolicyDocumentException
end

class Aws::STS::Errors::MalformedPolicyDocumentException
end

class Aws::STS::Errors::PackedPolicyTooLargeException
end

class Aws::STS::Errors::PackedPolicyTooLargeException
end

class Aws::STS::Errors::RegionDisabledException
end

class Aws::STS::Errors::RegionDisabledException
end

class Aws::STS::Errors::ServiceError
end

class Aws::STS::Errors::ServiceError
end

module Aws::STS::Errors
  extend ::Aws::Errors::DynamicErrors
end

module Aws::STS::Plugins
end

class Aws::STS::Plugins::STSRegionalEndpoints
end

class Aws::STS::Plugins::STSRegionalEndpoints
  def self.resolve_sts_regional_endpoints(cfg); end
end

module Aws::STS::Plugins
end

class Aws::STS::Presigner
  def get_caller_identity_presigned_url(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::STS::Presigner
end

class Aws::STS::Resource
  def client(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::STS::Resource
end

module Aws::STS::Types
end

class Aws::STS::Types::AssumeRoleRequest
  include ::Aws::Structure
end

class Aws::STS::Types::AssumeRoleRequest
end

class Aws::STS::Types::AssumeRoleResponse
  include ::Aws::Structure
end

class Aws::STS::Types::AssumeRoleResponse
end

class Aws::STS::Types::AssumeRoleWithSAMLRequest
  include ::Aws::Structure
end

class Aws::STS::Types::AssumeRoleWithSAMLRequest
end

class Aws::STS::Types::AssumeRoleWithSAMLResponse
  include ::Aws::Structure
end

class Aws::STS::Types::AssumeRoleWithSAMLResponse
end

class Aws::STS::Types::AssumeRoleWithWebIdentityRequest
  include ::Aws::Structure
end

class Aws::STS::Types::AssumeRoleWithWebIdentityRequest
end

class Aws::STS::Types::AssumeRoleWithWebIdentityResponse
  include ::Aws::Structure
end

class Aws::STS::Types::AssumeRoleWithWebIdentityResponse
end

class Aws::STS::Types::AssumedRoleUser
  include ::Aws::Structure
end

class Aws::STS::Types::AssumedRoleUser
end

class Aws::STS::Types::Credentials
  include ::Aws::Structure
end

class Aws::STS::Types::Credentials
end

class Aws::STS::Types::DecodeAuthorizationMessageRequest
  include ::Aws::Structure
end

class Aws::STS::Types::DecodeAuthorizationMessageRequest
end

class Aws::STS::Types::DecodeAuthorizationMessageResponse
  include ::Aws::Structure
end

class Aws::STS::Types::DecodeAuthorizationMessageResponse
end

class Aws::STS::Types::ExpiredTokenException
  include ::Aws::Structure
end

class Aws::STS::Types::ExpiredTokenException
end

class Aws::STS::Types::FederatedUser
  include ::Aws::Structure
end

class Aws::STS::Types::FederatedUser
end

class Aws::STS::Types::GetAccessKeyInfoRequest
  include ::Aws::Structure
end

class Aws::STS::Types::GetAccessKeyInfoRequest
end

class Aws::STS::Types::GetAccessKeyInfoResponse
  include ::Aws::Structure
end

class Aws::STS::Types::GetAccessKeyInfoResponse
end

class Aws::STS::Types::GetCallerIdentityRequest
end

class Aws::STS::Types::GetCallerIdentityRequest
end

class Aws::STS::Types::GetCallerIdentityResponse
  include ::Aws::Structure
end

class Aws::STS::Types::GetCallerIdentityResponse
end

class Aws::STS::Types::GetFederationTokenRequest
  include ::Aws::Structure
end

class Aws::STS::Types::GetFederationTokenRequest
end

class Aws::STS::Types::GetFederationTokenResponse
  include ::Aws::Structure
end

class Aws::STS::Types::GetFederationTokenResponse
end

class Aws::STS::Types::GetSessionTokenRequest
  include ::Aws::Structure
end

class Aws::STS::Types::GetSessionTokenRequest
end

class Aws::STS::Types::GetSessionTokenResponse
  include ::Aws::Structure
end

class Aws::STS::Types::GetSessionTokenResponse
end

class Aws::STS::Types::IDPCommunicationErrorException
  include ::Aws::Structure
end

class Aws::STS::Types::IDPCommunicationErrorException
end

class Aws::STS::Types::IDPRejectedClaimException
  include ::Aws::Structure
end

class Aws::STS::Types::IDPRejectedClaimException
end

class Aws::STS::Types::InvalidAuthorizationMessageException
  include ::Aws::Structure
end

class Aws::STS::Types::InvalidAuthorizationMessageException
end

class Aws::STS::Types::InvalidIdentityTokenException
  include ::Aws::Structure
end

class Aws::STS::Types::InvalidIdentityTokenException
end

class Aws::STS::Types::MalformedPolicyDocumentException
  include ::Aws::Structure
end

class Aws::STS::Types::MalformedPolicyDocumentException
end

class Aws::STS::Types::PackedPolicyTooLargeException
  include ::Aws::Structure
end

class Aws::STS::Types::PackedPolicyTooLargeException
end

class Aws::STS::Types::PolicyDescriptorType
  include ::Aws::Structure
end

class Aws::STS::Types::PolicyDescriptorType
end

class Aws::STS::Types::RegionDisabledException
  include ::Aws::Structure
end

class Aws::STS::Types::RegionDisabledException
end

class Aws::STS::Types::Tag
  include ::Aws::Structure
end

class Aws::STS::Types::Tag
end

module Aws::STS::Types
end

module Aws::STS
end

class Aws::SharedConfig
  def adaptive_retry_wait_to_fill(opts=T.unsafe(nil)); end

  def assume_role_credentials_from_config(opts=T.unsafe(nil)); end

  def assume_role_web_identity_credentials_from_config(opts=T.unsafe(nil)); end

  def config_enabled?(); end

  def config_path(); end

  def correct_clock_skew(opts=T.unsafe(nil)); end

  def credential_process(opts=T.unsafe(nil)); end

  def credentials(opts=T.unsafe(nil)); end

  def credentials_path(); end

  def csm_client_id(opts=T.unsafe(nil)); end

  def csm_enabled(opts=T.unsafe(nil)); end

  def csm_host(opts=T.unsafe(nil)); end

  def csm_port(opts=T.unsafe(nil)); end

  def endpoint_discovery_enabled(opts=T.unsafe(nil)); end

  def fresh(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def loadable?(path); end

  def max_attempts(opts=T.unsafe(nil)); end

  def profile_name(); end

  def region(opts=T.unsafe(nil)); end

  def retry_mode(opts=T.unsafe(nil)); end

  def s3_us_east_1_regional_endpoint(opts=T.unsafe(nil)); end

  def s3_use_arn_region(opts=T.unsafe(nil)); end

  def sts_regional_endpoints(opts=T.unsafe(nil)); end
end

class Aws::SharedConfig
  def self.config_reader(*attrs); end
end

class Aws::SharedCredentials
  include ::Aws::CredentialProvider
  def initialize(options=T.unsafe(nil)); end

  def loadable?(); end

  def path(); end

  def profile_name(); end
  KEY_MAP = ::T.let(nil, ::T.untyped)
end

class Aws::SharedCredentials
end

module Aws::Sigv4
end

class Aws::Sigv4::Credentials
  def access_key_id(); end

  def initialize(options=T.unsafe(nil)); end

  def secret_access_key(); end

  def session_token(); end

  def set?(); end
end

class Aws::Sigv4::Credentials
end

module Aws::Sigv4::Errors
end

class Aws::Sigv4::Errors::MissingCredentialsError
  def initialize(msg=T.unsafe(nil)); end
end

class Aws::Sigv4::Errors::MissingCredentialsError
end

class Aws::Sigv4::Errors::MissingRegionError
  def initialize(*args); end
end

class Aws::Sigv4::Errors::MissingRegionError
end

module Aws::Sigv4::Errors
end

class Aws::Sigv4::Signature
  def canonical_request(); end

  def canonical_request=(canonical_request); end

  def content_sha256(); end

  def content_sha256=(content_sha256); end

  def headers(); end

  def headers=(headers); end

  def initialize(options); end

  def string_to_sign(); end

  def string_to_sign=(string_to_sign); end
end

class Aws::Sigv4::Signature
end

class Aws::Sigv4::Signer
  def apply_checksum_header(); end

  def credentials_provider(); end

  def initialize(options=T.unsafe(nil)); end

  def presign_url(options); end

  def region(); end

  def service(); end

  def sign_event(prior_signature, payload, encoder); end

  def sign_request(request); end

  def unsigned_headers(); end
end

class Aws::Sigv4::Signer
  def self.uri_escape(string); end

  def self.uri_escape_path(path); end
end

class Aws::Sigv4::StaticCredentialsProvider
  def credentials(); end

  def initialize(options=T.unsafe(nil)); end

  def set?(); end
end

class Aws::Sigv4::StaticCredentialsProvider
end

module Aws::Sigv4
end

module Aws::Structure
  def empty?(); end

  def initialize(values=T.unsafe(nil)); end

  def key?(member_name); end

  def to_h(obj=T.unsafe(nil)); end

  def to_hash(obj=T.unsafe(nil)); end

  def to_s(obj=T.unsafe(nil)); end
end

module Aws::Structure
  def self.new(*args); end
end

module Aws::Stubbing
end

class Aws::Stubbing::DataApplicator
  include ::Seahorse::Model::Shapes
  def apply_data(data, stub); end

  def initialize(rules); end
end

class Aws::Stubbing::DataApplicator
end

class Aws::Stubbing::EmptyStub
  include ::Seahorse::Model::Shapes
  def initialize(rules); end

  def stub(); end
end

class Aws::Stubbing::EmptyStub
end

module Aws::Stubbing::Protocols
end

class Aws::Stubbing::Protocols::ApiGateway
end

class Aws::Stubbing::Protocols::ApiGateway
end

class Aws::Stubbing::Protocols::EC2
  def stub_data(api, operation, data); end

  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::EC2
end

class Aws::Stubbing::Protocols::Json
  def stub_data(api, operation, data); end

  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::Json
end

class Aws::Stubbing::Protocols::Query
  def stub_data(api, operation, data); end

  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::Query
end

class Aws::Stubbing::Protocols::Rest
  include ::Seahorse::Model::Shapes
  def stub_data(api, operation, data); end
end

class Aws::Stubbing::Protocols::Rest
end

class Aws::Stubbing::Protocols::RestJson
  def body_for(_, _, rules, data); end

  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::RestJson
end

class Aws::Stubbing::Protocols::RestXml
  def body_for(api, operation, rules, data); end

  def stub_error(error_code); end

  def xmlns(api); end
end

class Aws::Stubbing::Protocols::RestXml
end

module Aws::Stubbing::Protocols
end

class Aws::Stubbing::StubData
  def initialize(operation); end

  def stub(data=T.unsafe(nil)); end
end

class Aws::Stubbing::StubData
end

class Aws::Stubbing::XmlError
  def initialize(error_code); end

  def to_xml(); end
end

class Aws::Stubbing::XmlError
end

module Aws::Stubbing
end

class Aws::TypeBuilder
  def build_type(shape, shapes); end

  def initialize(svc_module); end
end

class Aws::TypeBuilder
end

module Aws::Util
end

module Aws::Util
  def self.copy_hash(hash); end

  def self.deep_copy(obj); end

  def self.deep_merge(left, right); end

  def self.monotonic_milliseconds(); end

  def self.monotonic_seconds(); end

  def self.str_2_bool(str); end
end

module Aws::Waiters
end

module Aws::Waiters::Errors
end

class Aws::Waiters::Errors::FailureStateError
  def initialize(response); end

  def response(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::FailureStateError
end

class Aws::Waiters::Errors::NoSuchWaiterError
  def initialize(waiter_name, waiter_names); end
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::NoSuchWaiterError
end

class Aws::Waiters::Errors::TooManyAttemptsError
  def attempts(); end

  def initialize(attempts); end
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::TooManyAttemptsError
end

class Aws::Waiters::Errors::UnexpectedError
  def error(); end

  def initialize(error); end
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::UnexpectedError
end

class Aws::Waiters::Errors::WaiterFailed
end

class Aws::Waiters::Errors::WaiterFailed
end

module Aws::Waiters::Errors
end

class Aws::Waiters::Poller
  def call(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def operation_name(); end
end

Aws::Waiters::Poller::RAISE_HANDLER = Seahorse::Client::Plugins::RaiseResponseErrors::Handler

class Aws::Waiters::Poller
end

class Aws::Waiters::Waiter
  def before_attempt(&block); end

  def before_wait(&block); end

  def delay(); end

  def delay=(delay); end

  def initialize(options=T.unsafe(nil)); end

  def interval(); end

  def interval=(interval); end

  def max_attempts(); end

  def max_attempts=(max_attempts); end

  def poller(); end

  def wait(options); end
end

Aws::Waiters::Waiter::RAISE_HANDLER = Seahorse::Client::Plugins::RaiseResponseErrors::Handler

class Aws::Waiters::Waiter
end

module Aws::Waiters
end

module Aws::Xml
end

class Aws::Xml::Builder
  include ::Seahorse::Model::Shapes
  def initialize(rules, options=T.unsafe(nil)); end

  def serialize(params); end

  def to_xml(params); end
end

class Aws::Xml::Builder
end

class Aws::Xml::DefaultList
end

class Aws::Xml::DefaultList
end

class Aws::Xml::DefaultMap
end

class Aws::Xml::DefaultMap
end

class Aws::Xml::DocBuilder
  def initialize(options=T.unsafe(nil)); end

  def node(name, *args, &block); end

  def target(); end
end

class Aws::Xml::DocBuilder
end

class Aws::Xml::ErrorHandler
end

class Aws::Xml::ErrorHandler
end

class Aws::Xml::Parser
  include ::Seahorse::Model::Shapes
  def initialize(rules, options=T.unsafe(nil)); end

  def parse(xml, target=T.unsafe(nil), &unhandled_callback); end
  FRAME_CLASSES = ::T.let(nil, ::T.untyped)
end

class Aws::Xml::Parser::BlobFrame
end

class Aws::Xml::Parser::BlobFrame
end

class Aws::Xml::Parser::BooleanFrame
end

class Aws::Xml::Parser::BooleanFrame
end

class Aws::Xml::Parser::FlatListFrame
  def initialize(xml_name, *args); end
end

class Aws::Xml::Parser::FlatListFrame
end

class Aws::Xml::Parser::FloatFrame
end

class Aws::Xml::Parser::FloatFrame
end

class Aws::Xml::Parser::Frame
  include ::Seahorse::Model::Shapes
  def child_frame(xml_name); end

  def consume_child_frame(child); end

  def initialize(path, parent, ref, result); end

  def parent(); end

  def path(); end

  def ref(); end

  def result(); end

  def set_text(value); end

  def yield_unhandled_value(path, value); end
end

class Aws::Xml::Parser::Frame
  def self.new(path, parent, ref, result=T.unsafe(nil)); end
end

class Aws::Xml::Parser::IntegerFrame
end

class Aws::Xml::Parser::IntegerFrame
end

class Aws::Xml::Parser::ListFrame
  def initialize(*args); end
end

class Aws::Xml::Parser::ListFrame
end

class Aws::Xml::Parser::MapEntryFrame
  def initialize(xml_name, *args); end

  def key(); end

  def value(); end
end

class Aws::Xml::Parser::MapEntryFrame
end

class Aws::Xml::Parser::MapFrame
  def initialize(*args); end
end

class Aws::Xml::Parser::MapFrame
end

class Aws::Xml::Parser::NokogiriEngine
  def characters(chars); end

  def comment(*args); end

  def end_document(); end

  def end_element_namespace(*ignored); end

  def error(msg); end

  def initialize(stack); end

  def parse(xml); end

  def start_document(); end

  def start_element_namespace(element_name, attributes=T.unsafe(nil), *ignored); end

  def xmldecl(*args); end
end

class Aws::Xml::Parser::NokogiriEngine
end

class Aws::Xml::Parser::NullFrame
end

class Aws::Xml::Parser::NullFrame
  def self.new(xml_name, parent); end
end

class Aws::Xml::Parser::ParsingError
  def column(); end

  def initialize(msg, line, column); end

  def line(); end
end

class Aws::Xml::Parser::ParsingError
end

class Aws::Xml::Parser::Stack
  def attr(name, value); end

  def child_frame(name); end

  def consume_child_frame(frame); end

  def end_element(*args); end

  def error(msg, line=T.unsafe(nil), column=T.unsafe(nil)); end

  def frame(); end

  def initialize(ref, result=T.unsafe(nil), &unhandled_callback); end

  def result(); end

  def start_element(name); end

  def text(value); end

  def yield_unhandled_value(path, value); end
end

class Aws::Xml::Parser::Stack
end

class Aws::Xml::Parser::StringFrame
end

class Aws::Xml::Parser::StringFrame
end

class Aws::Xml::Parser::StructureFrame
  def initialize(xml_name, parent, ref, result=T.unsafe(nil)); end
end

class Aws::Xml::Parser::StructureFrame
end

class Aws::Xml::Parser::TimestampFrame
  def parse(value); end
end

class Aws::Xml::Parser::TimestampFrame
end

class Aws::Xml::Parser
  def self.engine(); end

  def self.engine=(engine); end

  def self.set_default_engine(); end
end

module Aws::Xml
end

module Aws
  def self.config(); end

  def self.config=(config); end

  def self.eager_autoload!(*args); end

  def self.empty_connection_pools!(); end

  def self.partition(partition_name); end

  def self.partitions(); end

  def self.shared_config(); end

  def self.use_bundled_cert!(); end
end

module BCrypt
end

class BCrypt::Engine
  DEFAULT_COST = ::T.let(nil, ::T.untyped)
  MAX_SALT_LENGTH = ::T.let(nil, ::T.untyped)
  MIN_COST = ::T.let(nil, ::T.untyped)
end

class BCrypt::Engine
  def self.autodetect_cost(salt); end

  def self.calibrate(upper_time_limit_in_ms); end

  def self.cost(); end

  def self.cost=(cost); end

  def self.generate_salt(cost=T.unsafe(nil)); end

  def self.hash_secret(secret, salt, _=T.unsafe(nil)); end

  def self.valid_salt?(salt); end

  def self.valid_secret?(secret); end
end

class BCrypt::Error
end

class BCrypt::Error
end

module BCrypt::Errors
end

class BCrypt::Errors::InvalidCost
end

class BCrypt::Errors::InvalidCost
end

class BCrypt::Errors::InvalidHash
end

class BCrypt::Errors::InvalidHash
end

class BCrypt::Errors::InvalidSalt
end

class BCrypt::Errors::InvalidSalt
end

class BCrypt::Errors::InvalidSecret
end

class BCrypt::Errors::InvalidSecret
end

module BCrypt::Errors
end

class BCrypt::Password
  def ==(secret); end

  def checksum(); end

  def cost(); end

  def initialize(raw_hash); end

  def is_password?(secret); end

  def salt(); end

  def version(); end
end

class BCrypt::Password
  def self.create(secret, options=T.unsafe(nil)); end

  def self.valid_hash?(h); end
end

module BCrypt
end

class BasicObject
  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class BigDecimal
  def _original_to_s(*_); end

  def clone(); end

  def to_d(); end

  def to_default_s(*args); end

  def to_digits(); end

  def to_formatted_s(*args); end
  DEFAULT_STRING_FORMAT = ::T.let(nil, ::T.untyped)
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

class BooleanString
end

class BooleanString
  def self.===(other); end
end

module BooleanStringImpl
  def _is_a_boolean_string?(); end

  def instance_of?(type); end

  def is_a?(type); end

  def kind_of?(type); end
end

module BooleanStringImpl
end

class Budget
  def after_add_for_user_budget_associations(); end

  def after_add_for_user_budget_associations=(after_add_for_user_budget_associations); end

  def after_add_for_user_budget_associations?(); end

  def after_remove_for_user_budget_associations(); end

  def after_remove_for_user_budget_associations=(after_remove_for_user_budget_associations); end

  def after_remove_for_user_budget_associations?(); end

  def autosave_associated_records_for_user_budget_associations(*args); end

  def before_add_for_user_budget_associations(); end

  def before_add_for_user_budget_associations=(before_add_for_user_budget_associations); end

  def before_add_for_user_budget_associations?(); end

  def before_remove_for_user_budget_associations(); end

  def before_remove_for_user_budget_associations=(before_remove_for_user_budget_associations); end

  def before_remove_for_user_budget_associations?(); end

  def validate_associated_records_for_user_budget_associations(*args); end
end

class Budget::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Budget::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Budget::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Budget::GeneratedAssociationMethods
  def user_budget_association_ids(); end

  def user_budget_association_ids=(ids); end
end

class Budget
  def self.after_add_for_user_budget_associations(); end

  def self.after_add_for_user_budget_associations=(val); end

  def self.after_add_for_user_budget_associations?(); end

  def self.after_remove_for_user_budget_associations(); end

  def self.after_remove_for_user_budget_associations=(val); end

  def self.after_remove_for_user_budget_associations?(); end

  def self.before_add_for_user_budget_associations(); end

  def self.before_add_for_user_budget_associations=(val); end

  def self.before_add_for_user_budget_associations?(); end

  def self.before_remove_for_user_budget_associations(); end

  def self.before_remove_for_user_budget_associations=(val); end

  def self.before_remove_for_user_budget_associations?(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def any_instance(); end

  def class_attribute(*attrs); end

  def descendants(); end

  def json_creatable?(); end

  def subclasses(); end

  def superclass_delegating_accessor(*args, &block); end

  def superclass_delegating_accessor_with_deprecation(*args, &block); end

  def superclass_delegating_accessor_without_deprecation(name, options=T.unsafe(nil)); end
end

module ClimateControl
  VERSION = ::T.let(nil, ::T.untyped)
end

class ClimateControl::Environment
  def [](*args, &block); end

  def []=(*args, &block); end

  def delete(*args, &block); end

  def synchronize(); end

  def to_hash(*args, &block); end
end

class ClimateControl::Environment
  extend ::Forwardable
end

class ClimateControl::Modifier
  def initialize(env, environment_overrides=T.unsafe(nil), &block); end

  def process(); end
end

class ClimateControl::Modifier::OverlappingKeysWithChangedValues
  def initialize(hash_1, hash_2); end

  def keys(); end
end

class ClimateControl::Modifier::OverlappingKeysWithChangedValues
end

class ClimateControl::Modifier
end

class ClimateControl::UnassignableValueError
end

class ClimateControl::UnassignableValueError
end

module ClimateControl
  def self.env(); end

  def self.modify(environment_overrides, &block); end
end

module Closure
  COMPILER_JAR = ::T.let(nil, ::T.untyped)
  COMPILER_ROOT = ::T.let(nil, ::T.untyped)
  COMPILER_VERSION = ::T.let(nil, ::T.untyped)
  JAVA_COMMAND = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Closure::Compiler
  def compile(io); end

  def compile_file(files); end

  def compile_files(files); end

  def compress(io); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Closure::Compiler
end

class Closure::Error
end

class Closure::Error
end

module Closure
end

class Code
  include ::Code::GeneratedAssociationMethods
end

class Code::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Code::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Code::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Code::GeneratedAssociationMethods
end

module Code::GeneratedAssociationMethods
end

class Collection
  def after_add_for_part_associations(); end

  def after_add_for_part_associations=(after_add_for_part_associations); end

  def after_add_for_part_associations?(); end

  def after_remove_for_part_associations(); end

  def after_remove_for_part_associations=(after_remove_for_part_associations); end

  def after_remove_for_part_associations?(); end

  def autosave_associated_records_for_part_associations(*args); end

  def before_add_for_part_associations(); end

  def before_add_for_part_associations=(before_add_for_part_associations); end

  def before_add_for_part_associations?(); end

  def before_remove_for_part_associations(); end

  def before_remove_for_part_associations=(before_remove_for_part_associations); end

  def before_remove_for_part_associations?(); end

  def validate_associated_records_for_part_associations(*args); end
end

class Collection::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Collection::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Collection::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Collection::GeneratedAssociationMethods
  def part_association_ids(); end

  def part_association_ids=(ids); end
end

class Collection
  def self.after_add_for_part_associations(); end

  def self.after_add_for_part_associations=(val); end

  def self.after_add_for_part_associations?(); end

  def self.after_remove_for_part_associations(); end

  def self.after_remove_for_part_associations=(val); end

  def self.after_remove_for_part_associations?(); end

  def self.before_add_for_part_associations(); end

  def self.before_add_for_part_associations=(val); end

  def self.before_add_for_part_associations?(); end

  def self.before_remove_for_part_associations(); end

  def self.before_remove_for_part_associations=(val); end

  def self.before_remove_for_part_associations?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class CompositeReadIO
  def initialize(*ios); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class CompositeReadIO
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExchanger
  def exchange(value, timeout=T.unsafe(nil)); end

  def exchange!(value, timeout=T.unsafe(nil)); end

  def try_exchange(value, timeout=T.unsafe(nil)); end
end

class Concurrent::AbstractExchanger
end

class Concurrent::AbstractExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Deprecation
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def auto_terminate=(value); end

  def auto_terminate?(); end

  def fallback_policy(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def kill(); end

  def name(); end

  def running?(); end

  def shutdown(); end

  def shutdown?(); end

  def shuttingdown?(); end

  def wait_for_termination(timeout=T.unsafe(nil)); end
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
end

class Concurrent::AbstractThreadLocalVar
  def allocate_storage(); end

  def bind(value, &block); end

  def default(); end

  def initialize(default=T.unsafe(nil), &default_block); end

  def value(); end

  def value=(value); end
end

class Concurrent::AbstractThreadLocalVar
end

class Concurrent::Agent
  include ::Concurrent::Concern::Observable
  def <<(action); end

  def await(); end

  def await_for(timeout); end

  def await_for!(timeout); end

  def deref(); end

  def error(); end

  def error_mode(); end

  def failed?(); end

  def initialize(initial, opts=T.unsafe(nil)); end

  def post(*args, &action); end

  def reason(); end

  def restart(new_value, opts=T.unsafe(nil)); end

  def send(*args, &action); end

  def send!(*args, &action); end

  def send_off(*args, &action); end

  def send_off!(*args, &action); end

  def send_via(executor, *args, &action); end

  def send_via!(executor, *args, &action); end

  def stopped?(); end

  def value(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
  def initialize(message=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent
  def self.await(*agents); end

  def self.await_for(timeout, *agents); end

  def self.await_for!(timeout, *agents); end
end

class Concurrent::Array
end

class Concurrent::Array
end

module Concurrent::Async
  def async(); end

  def await(); end

  def call(); end

  def cast(); end

  def init_synchronization(); end
end

module Concurrent::Async
  def self.included(base); end

  def self.validate_argc(obj, method, *args); end
end

class Concurrent::Atom
  include ::Concurrent::Concern::Observable
  def compare_and_set(old_value, new_value); end

  def deref(); end

  def initialize(value, opts=T.unsafe(nil)); end

  def reset(new_value); end

  def swap(*args); end

  def value(); end
end

class Concurrent::Atom
  def self.new(*args, &block); end
end

class Concurrent::AtomicBoolean
end

class Concurrent::AtomicBoolean
end

module Concurrent::AtomicDirectUpdate
  def try_update(); end

  def try_update!(); end

  def update(); end
end

module Concurrent::AtomicDirectUpdate
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicMarkableReference
  def compare_and_set(expected_val, new_val, expected_mark, new_mark); end

  def compare_and_swap(expected_val, new_val, expected_mark, new_mark); end

  def get(); end

  def initialize(value=T.unsafe(nil), mark=T.unsafe(nil)); end

  def mark(); end

  def marked?(); end

  def set(new_val, new_mark); end

  def try_update(); end

  def try_update!(); end

  def update(); end

  def value(); end
end

class Concurrent::AtomicMarkableReference
  def self.new(*args, &block); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
end

class Concurrent::AtomicReference
end

class Concurrent::AtomicReference
end

class Concurrent::CachedThreadPool
end

class Concurrent::CachedThreadPool
end

class Concurrent::CancelledOperationError
end

class Concurrent::CancelledOperationError
end

module Concurrent::Collection
end

class Concurrent::Collection::CopyOnNotifyObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnNotifyObserverSet
end

class Concurrent::Collection::CopyOnWriteObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnWriteObserverSet
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
end

class Concurrent::Collection::NonConcurrentMapBackend
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end

  def clear(); end

  def delete(item); end

  def deq(); end

  def empty?(); end

  def enq(item); end

  def has_priority?(item); end

  def include?(item); end

  def initialize(opts=T.unsafe(nil)); end

  def length(); end

  def peek(); end

  def pop(); end

  def push(item); end

  def shift(); end

  def size(); end
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def self.from_list(list, opts=T.unsafe(nil)); end
end

module Concurrent::Collection
end

module Concurrent::Concern
end

module Concurrent::Concern::Deprecation
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def deprecated(message, strip=T.unsafe(nil)); end

  def deprecated_method(old_name, new_name); end
end

module Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
end

module Concurrent::Concern::Dereferenceable
  def apply_deref_options(value); end

  def deref(); end

  def ns_set_deref_options(opts); end

  def set_deref_options(opts=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

module Concurrent::Concern::Dereferenceable
end

module Concurrent::Concern::Logging
  include ::Logger::Severity
  def log(level, progname, message=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Logging
end

module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def compare_and_set_state(next_state, *expected_current); end

  def complete?(); end

  def event(); end

  def exception(*args); end

  def fulfilled?(); end

  def get_arguments_from(opts=T.unsafe(nil)); end

  def if_state(*expected_states); end

  def incomplete?(); end

  def init_obligation(); end

  def no_error!(timeout=T.unsafe(nil)); end

  def ns_check_state?(expected); end

  def ns_set_state(value); end

  def pending?(); end

  def realized?(); end

  def reason(); end

  def rejected?(); end

  def set_state(success, value, reason); end

  def state(); end

  def state=(value); end

  def unscheduled?(); end

  def value(timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end
end

module Concurrent::Concern::Obligation
end

module Concurrent::Concern::Observable
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def observers(); end

  def observers=(observers); end

  def with_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Observable
end

module Concurrent::Concern
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::ConcurrentUpdateError
end

class Concurrent::ConfigurationError
end

class Concurrent::ConfigurationError
end

class Concurrent::CountDownLatch
end

class Concurrent::CountDownLatch
end

class Concurrent::CyclicBarrier
  def broken?(); end

  def initialize(parties, &block); end

  def ns_generation_done(generation, status, continue=T.unsafe(nil)); end

  def ns_initialize(parties, &block); end

  def ns_next_generation(); end

  def number_waiting(); end

  def parties(); end

  def reset(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::CyclicBarrier
end

class Concurrent::Delay
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def initialize(opts=T.unsafe(nil), &block); end

  def ns_initialize(opts, &block); end

  def reconfigure(&block); end
end

class Concurrent::Delay
end

class Concurrent::DependencyCounter
  def initialize(count, &block); end

  def update(time, value, reason); end
end

class Concurrent::DependencyCounter
end

class Concurrent::Error
end

class Concurrent::Error
end

class Concurrent::Event
  def initialize(); end

  def ns_initialize(); end

  def ns_set(); end

  def reset(); end

  def set(); end

  def set?(); end

  def try?(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Event
end

class Concurrent::Exchanger
end

class Concurrent::Exchanger
end

module Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def <<(task); end

  def can_overflow?(); end

  def post(*args, &task); end

  def serialized?(); end
end

module Concurrent::ExecutorService
end

class Concurrent::FixedThreadPool
  def initialize(num_threads, opts=T.unsafe(nil)); end
end

class Concurrent::FixedThreadPool
end

class Concurrent::Future
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def set(value=T.unsafe(nil), &block); end

  def wait_or_cancel(timeout); end
end

class Concurrent::Future
  def self.execute(opts=T.unsafe(nil), &block); end
end

class Concurrent::Hash
end

class Concurrent::Hash
end

class Concurrent::IVar
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def check_for_block_or_value!(block_given, value); end

  def complete(success, value, reason); end

  def complete_without_notification(success, value, reason); end

  def fail(reason=T.unsafe(nil)); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def notify_observers(value, reason); end

  def ns_complete_without_notification(success, value, reason); end

  def ns_initialize(value, opts); end

  def safe_execute(task, args=T.unsafe(nil)); end

  def set(value=T.unsafe(nil)); end

  def try_set(value=T.unsafe(nil), &block); end
end

class Concurrent::IVar
end

class Concurrent::IllegalOperationError
end

class Concurrent::IllegalOperationError
end

class Concurrent::ImmediateExecutor
  include ::Concurrent::SerialExecutorService
  def initialize(); end
end

class Concurrent::ImmediateExecutor
end

class Concurrent::ImmutabilityError
end

class Concurrent::ImmutabilityError
end

module Concurrent::ImmutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::ImmutableStruct
  def self.included(base); end

  def self.new(*args, &block); end
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::InitializationError
end

class Concurrent::InitializationError
end

class Concurrent::LifecycleError
end

class Concurrent::LifecycleError
end

class Concurrent::LockFreeStack
  include ::Enumerable
  def clear(); end

  def clear_each(&block); end

  def clear_if(head); end

  def compare_and_clear(head); end

  def compare_and_pop(head); end

  def compare_and_push(head, value); end

  def each(head=T.unsafe(nil), &blk); end

  def empty?(head=T.unsafe(nil)); end

  def initialize(head=T.unsafe(nil)); end

  def peek(); end

  def pop(); end

  def push(value); end

  def replace_if(head, new_head); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack::Node
  def initialize(value, next_node); end

  def next_node(); end

  def value(); end

  def value=(value); end
end

class Concurrent::LockFreeStack::Node
  def self.[](*_); end
end

class Concurrent::LockFreeStack
  def self.new(*args, &block); end

  def self.of1(value); end

  def self.of2(value1, value2); end
end

class Concurrent::MVar
  include ::Concurrent::Concern::Dereferenceable
  def borrow(timeout=T.unsafe(nil)); end

  def empty?(); end

  def full?(); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil)); end

  def modify(timeout=T.unsafe(nil)); end

  def modify!(); end

  def put(value, timeout=T.unsafe(nil)); end

  def set!(value); end

  def synchronize(&block); end

  def take(timeout=T.unsafe(nil)); end

  def try_put!(value); end

  def try_take!(); end
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  def self.new(*args, &block); end
end

class Concurrent::Map
  def each(&blk); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def value?(value); end

  def values(); end
end

class Concurrent::Map
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::Maybe
  include ::Comparable
  def fulfilled?(); end

  def initialize(just, nothing); end

  def just(); end

  def just?(); end

  def nothing(); end

  def nothing?(); end

  def or(other); end

  def reason(); end

  def rejected?(); end

  def value(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  def self.from(*args); end

  def self.just(value); end

  def self.nothing(error=T.unsafe(nil)); end
end

class Concurrent::MultipleAssignmentError
  def initialize(message=T.unsafe(nil), inspection_data=T.unsafe(nil)); end

  def inspection_data(); end
end

class Concurrent::MultipleAssignmentError
end

class Concurrent::MultipleErrors
  def errors(); end

  def initialize(errors, message=T.unsafe(nil)); end
end

class Concurrent::MultipleErrors
end

module Concurrent::MutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::MutableStruct
  def self.new(*args, &block); end
end

class Concurrent::MutexAtomicBoolean
  def false?(); end

  def initialize(initial=T.unsafe(nil)); end

  def make_false(); end

  def make_true(); end

  def ns_initialize(initial); end

  def true?(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicBoolean
end

class Concurrent::MutexAtomicFixnum
  def compare_and_set(expect, update); end

  def decrement(delta=T.unsafe(nil)); end

  def down(delta=T.unsafe(nil)); end

  def increment(delta=T.unsafe(nil)); end

  def initialize(initial=T.unsafe(nil)); end

  def ns_initialize(initial); end

  def up(delta=T.unsafe(nil)); end

  def update(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicFixnum
end

class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper
  def _compare_and_set(old_value, new_value); end

  def compare_and_swap(old_value, new_value); end

  def get(); end

  def get_and_set(new_value); end

  def initialize(value=T.unsafe(nil)); end

  def ns_initialize(value); end

  def set(new_value); end

  def swap(new_value); end

  def value(); end

  def value=(new_value); end
end

class Concurrent::MutexAtomicReference
end

class Concurrent::MutexCountDownLatch
  def count(); end

  def count_down(); end

  def initialize(count=T.unsafe(nil)); end

  def ns_initialize(count); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::MutexCountDownLatch
end

class Concurrent::MutexSemaphore
  def acquire(permits=T.unsafe(nil)); end

  def available_permits(); end

  def drain_permits(); end

  def initialize(count); end

  def ns_initialize(count); end

  def reduce_permits(reduction); end

  def release(permits=T.unsafe(nil)); end

  def try_acquire(permits=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Concurrent::MutexSemaphore
end

module Concurrent::Options
end

module Concurrent::Options
  def self.executor(executor_identifier); end

  def self.executor_from_options(opts=T.unsafe(nil)); end
end

class Concurrent::Promise
  def catch(&block); end

  def execute(); end

  def flat_map(&block); end

  def initialize(opts=T.unsafe(nil), &block); end

  def notify_child(child); end

  def on_error(&block); end

  def on_fulfill(result); end

  def on_reject(reason); end

  def on_success(&block); end

  def realize(task); end

  def rescue(&block); end

  def root?(); end

  def set(value=T.unsafe(nil), &block); end

  def set_pending(); end

  def set_state!(success, value, reason); end

  def synchronized_set_state!(success, value, reason); end

  def then(*args, &block); end

  def zip(*others); end
end

class Concurrent::Promise
  def self.aggregate(method, *promises); end

  def self.all?(*promises); end

  def self.any?(*promises); end

  def self.execute(opts=T.unsafe(nil), &block); end

  def self.fulfill(value, opts=T.unsafe(nil)); end

  def self.reject(reason, opts=T.unsafe(nil)); end

  def self.zip(*promises); end
end

class Concurrent::PromiseExecutionError
end

class Concurrent::PromiseExecutionError
end

module Concurrent::Promises
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
  def add_callback_clear_delayed_node(node); end

  def add_callback_notify_blocked(promise, index); end

  def blocks(); end

  def callbacks(); end

  def chain(*args, &task); end

  def chain_on(executor, *args, &task); end

  def chain_resolvable(resolvable); end

  def default_executor(); end

  def initialize(promise, default_executor); end

  def internal_state(); end

  def on_resolution(*args, &callback); end

  def on_resolution!(*args, &callback); end

  def on_resolution_using(executor, *args, &callback); end

  def pending?(); end

  def promise(); end

  def resolve_with(state, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolved?(); end

  def state(); end

  def tangle(resolvable); end

  def touch(); end

  def touched?(); end

  def wait(timeout=T.unsafe(nil)); end

  def waiting_threads(); end

  def with_default_executor(executor); end

  def with_hidden_resolvable(); end
end

class Concurrent::Promises::AbstractEventFuture
  def self.new(*args, &block); end
end

class Concurrent::Promises::Event
  def &(other); end

  def any(event_or_future); end

  def delay(); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def to_event(); end

  def to_future(); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Event
end

module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  def any(*futures_and_or_events); end

  def any_event(*futures_and_or_events); end

  def any_event_on(default_executor, *futures_and_or_events); end

  def any_fulfilled_future(*futures_and_or_events); end

  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  def any_resolved_future(*futures_and_or_events); end

  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  def delay(*args, &task); end

  def delay_on(default_executor, *args, &task); end

  def fulfilled_future(value, default_executor=T.unsafe(nil)); end

  def future(*args, &task); end

  def future_on(default_executor, *args, &task); end

  def make_future(argument=T.unsafe(nil), default_executor=T.unsafe(nil)); end

  def rejected_future(reason, default_executor=T.unsafe(nil)); end

  def resolvable_event(); end

  def resolvable_event_on(default_executor=T.unsafe(nil)); end

  def resolvable_future(); end

  def resolvable_future_on(default_executor=T.unsafe(nil)); end

  def resolved_event(default_executor=T.unsafe(nil)); end

  def resolved_future(fulfilled, value, reason, default_executor=T.unsafe(nil)); end

  def schedule(intended_time, *args, &task); end

  def schedule_on(default_executor, intended_time, *args, &task); end

  def zip(*futures_and_or_events); end

  def zip_events(*futures_and_or_events); end

  def zip_events_on(default_executor, *futures_and_or_events); end

  def zip_futures(*futures_and_or_events); end

  def zip_futures_on(default_executor, *futures_and_or_events); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  def default_executor(); end
end

module Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::Promises::FactoryMethods
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

class Concurrent::Promises::Future
  def &(other); end

  def any(event_or_future); end

  def apply(args, block); end

  def delay(); end

  def exception(*args); end

  def flat(level=T.unsafe(nil)); end

  def flat_event(); end

  def flat_future(level=T.unsafe(nil)); end

  def fulfilled?(); end

  def on_fulfillment(*args, &callback); end

  def on_fulfillment!(*args, &callback); end

  def on_fulfillment_using(executor, *args, &callback); end

  def on_rejection(*args, &callback); end

  def on_rejection!(*args, &callback); end

  def on_rejection_using(executor, *args, &callback); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def rejected?(); end

  def rescue(*args, &task); end

  def rescue_on(executor, *args, &task); end

  def result(timeout=T.unsafe(nil)); end

  def run(run_test=T.unsafe(nil)); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def then_on(executor, *args, &task); end

  def to_event(); end

  def to_future(); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Future
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
end

class Concurrent::Promises::ResolvableEvent
  include ::Concurrent::Promises::Resolvable
  def resolve(raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableEvent
end

class Concurrent::Promises::ResolvableFuture
  include ::Concurrent::Promises::Resolvable
  def evaluate_to(*args, &block); end

  def evaluate_to!(*args, &block); end

  def fulfill(value, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def reject(reason, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolve(fulfilled=T.unsafe(nil), value=T.unsafe(nil), reason=T.unsafe(nil), raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def result(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableFuture
end

module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::ReInclude
  def extended(base); end

  def include(*modules); end

  def included(base); end
end

module Concurrent::ReInclude
end

class Concurrent::ReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def has_waiters?(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end

  def write_locked?(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::ReentrantReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def try_read_lock(); end

  def try_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::RejectedExecutionError
end

class Concurrent::RejectedExecutionError
end

class Concurrent::ResourceLimitError
end

class Concurrent::ResourceLimitError
end

class Concurrent::RubyExchanger
  def compare_and_set_slot(expected, value); end

  def slot(); end

  def slot=(value); end

  def swap_slot(value); end

  def update_slot(&block); end
end

class Concurrent::RubyExchanger
  def self.new(*args, &block); end
end

class Concurrent::RubyExecutorService
  def initialize(*args, &block); end
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubyThreadLocalVar
end

class Concurrent::RubyThreadLocalVar
  def self.thread_finalizer(id); end

  def self.thread_local_finalizer(index); end
end

class Concurrent::RubyThreadPoolExecutor
  def completed_task_count(); end

  def idletime(); end

  def initialize(opts=T.unsafe(nil)); end

  def largest_length(); end

  def length(); end

  def max_length(); end

  def max_queue(); end

  def min_length(); end

  def queue_length(); end

  def ready_worker(worker); end

  def remaining_capacity(); end

  def remove_busy_worker(worker); end

  def scheduled_task_count(); end

  def worker_died(worker); end

  def worker_not_old_enough(worker); end

  def worker_task_completed(); end
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
end

class Concurrent::SafeTaskExecutor
  def execute(*args); end

  def initialize(task, opts=T.unsafe(nil)); end
end

class Concurrent::SafeTaskExecutor
end

class Concurrent::ScheduledTask
  include ::Comparable
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def executor(); end

  def initial_delay(); end

  def initialize(delay, opts=T.unsafe(nil), &task); end

  def ns_reschedule(delay); end

  def ns_schedule(delay); end

  def process_task(); end

  def processing?(); end

  def reschedule(delay); end

  def reset(); end

  def schedule_time(); end
end

class Concurrent::ScheduledTask
  def self.execute(delay, opts=T.unsafe(nil), &task); end
end

class Concurrent::Semaphore
end

class Concurrent::Semaphore
end

module Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def serialized?(); end
end

module Concurrent::SerialExecutorService
end

class Concurrent::SerializedExecution
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(); end

  def post(executor, *args, &task); end

  def posts(posts); end
end

class Concurrent::SerializedExecution::Job
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def call(); end

  def executor(); end

  def executor=(_); end
end

class Concurrent::SerializedExecution::Job
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::SerializedExecution
end

class Concurrent::SerializedExecutionDelegator
  include ::Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(executor); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
end

class Concurrent::Set
end

class Concurrent::Set
end

module Concurrent::SettableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::SettableStruct
  def self.new(*args, &block); end
end

class Concurrent::SimpleExecutorService
end

class Concurrent::SimpleExecutorService
  def self.<<(task); end

  def self.post(*args); end
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::SingleThreadExecutor
end

module Concurrent::Synchronization
end

class Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast(); end

  def ns_signal(); end

  def ns_wait(timeout=T.unsafe(nil)); end

  def ns_wait_until(timeout=T.unsafe(nil), &condition); end

  def synchronize(); end
end

class Concurrent::Synchronization::AbstractLockableObject
end

class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier(); end
end

class Concurrent::Synchronization::AbstractObject
  def self.attr_volatile(*names); end
end

module Concurrent::Synchronization::AbstractStruct
  def initialize(*values); end

  def length(); end

  def members(); end

  def ns_each(); end

  def ns_each_pair(); end

  def ns_equality(other); end

  def ns_get(member); end

  def ns_initialize_copy(); end

  def ns_inspect(); end

  def ns_merge(other, &block); end

  def ns_select(); end

  def ns_to_h(); end

  def ns_values(); end

  def ns_values_at(indexes); end

  def pr_underscore(clazz); end

  def size(); end
end

module Concurrent::Synchronization::AbstractStruct
  def self.define_struct_class(parent, base, name, members, &block); end
end

class Concurrent::Synchronization::Condition
  def broadcast(); end

  def initialize(lock); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Condition
  def self.private_new(*args, &block); end
end

module Concurrent::Synchronization::ConditionSignalling
  def ns_broadcast(); end

  def ns_signal(); end
end

module Concurrent::Synchronization::ConditionSignalling
end

class Concurrent::Synchronization::Lock
  def broadcast(); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Lock
end

class Concurrent::Synchronization::LockableObject
  def new_condition(); end
end

class Concurrent::Synchronization::LockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MonitorLockableObject
  def self.new(*args, &block); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::MriObject
  include ::Concurrent::Synchronization::MriAttrVolatile
end

class Concurrent::Synchronization::MriObject
end

class Concurrent::Synchronization::MutexLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MutexLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::Object
end

class Concurrent::Synchronization::Object
  def self.atomic_attribute?(name); end

  def self.atomic_attributes(inherited=T.unsafe(nil)); end

  def self.attr_atomic(*names); end

  def self.ensure_safe_initialization_when_final_fields_are_present(); end

  def self.safe_initialization!(); end

  def self.safe_initialization?(); end
end

module Concurrent::Synchronization::RbxAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::RbxAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::RbxLockableObject
  def initialize(*defaults); end

  def synchronize(&block); end
end

class Concurrent::Synchronization::RbxLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::RbxObject
  include ::Concurrent::Synchronization::RbxAttrVolatile
end

class Concurrent::Synchronization::RbxObject
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::TruffleRubyObject
  include ::Concurrent::Synchronization::TruffleRubyAttrVolatile
end

class Concurrent::Synchronization::TruffleRubyObject
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::Synchronization
end

class Concurrent::TVar
  def initialize(value); end

  def unsafe_increment_version(); end

  def unsafe_lock(); end

  def unsafe_value(); end

  def unsafe_value=(value); end

  def unsafe_version(); end

  def value(); end

  def value=(value); end
end

class Concurrent::TVar
  def self.new(*args, &block); end
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadPoolExecutor
end

class Concurrent::ThreadPoolExecutor
end

module Concurrent::ThreadSafe
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
end

module Concurrent::ThreadSafe
end

class Concurrent::TimeoutError
end

class Concurrent::TimeoutError
end

class Concurrent::TimerSet
  def initialize(opts=T.unsafe(nil)); end

  def post(delay, *args, &task); end
end

class Concurrent::TimerSet
end

class Concurrent::TimerTask
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def execute(); end

  def execution_interval(); end

  def execution_interval=(value); end

  def initialize(opts=T.unsafe(nil), &task); end

  def timeout_interval(); end

  def timeout_interval=(value); end
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  def self.execute(opts=T.unsafe(nil), &task); end
end

class Concurrent::Transaction
  def abort(); end

  def commit(); end

  def read(tvar); end

  def unlock(); end

  def valid?(); end

  def write(tvar, value); end
  ABORTED = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::ReadLogEntry
  def tvar(); end

  def tvar=(_); end

  def version(); end

  def version=(_); end
end

class Concurrent::Transaction::ReadLogEntry
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::Transaction
  def self.current(); end

  def self.current=(transaction); end
end

class Concurrent::Tuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def get(i); end

  def initialize(size); end

  def set(i, value); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class Concurrent::Tuple
end

module Concurrent::Utility
end

module Concurrent::Utility::EngineDetector
  def on_cruby?(); end

  def on_jruby?(); end

  def on_jruby_9000?(); end

  def on_linux?(); end

  def on_osx?(); end

  def on_rbx?(); end

  def on_truffleruby?(); end

  def on_windows?(); end

  def ruby_engine(); end

  def ruby_version(version=T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::EngineDetector
end

module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?(); end

  def c_extensions_loaded?(); end

  def java_extensions_loaded?(); end

  def load_native_extensions(); end
end

module Concurrent::Utility::NativeExtensionLoader
end

module Concurrent::Utility::NativeInteger
  def ensure_integer(value); end

  def ensure_integer_and_bounds(value); end

  def ensure_lower_bound(value); end

  def ensure_positive(value); end

  def ensure_positive_and_no_zero(value); end

  def ensure_upper_bound(value); end
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  extend ::Concurrent::Utility::NativeInteger
end

class Concurrent::Utility::ProcessorCounter
  def physical_processor_count(); end

  def processor_count(); end
end

class Concurrent::Utility::ProcessorCounter
end

module Concurrent::Utility
end

module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  def self.abort_transaction(); end

  def self.atomically(); end

  def self.call_dataflow(method, executor, *inputs, &block); end

  def self.create_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.create_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.dataflow(*inputs, &block); end

  def self.dataflow!(*inputs, &block); end

  def self.dataflow_with(executor, *inputs, &block); end

  def self.dataflow_with!(executor, *inputs, &block); end

  def self.disable_at_exit_handlers!(); end

  def self.executor(executor_identifier); end

  def self.global_fast_executor(); end

  def self.global_immediate_executor(); end

  def self.global_io_executor(); end

  def self.global_logger(); end

  def self.global_logger=(value); end

  def self.global_timer_set(); end

  def self.leave_transaction(); end

  def self.monotonic_time(); end

  def self.new_fast_executor(opts=T.unsafe(nil)); end

  def self.new_io_executor(opts=T.unsafe(nil)); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.processor_counter(); end

  def self.use_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.use_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end
end

module Crass
end

class Crass::Parser
  def consume_at_rule(input=T.unsafe(nil)); end

  def consume_component_value(input=T.unsafe(nil)); end

  def consume_declaration(input=T.unsafe(nil)); end

  def consume_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def consume_function(input=T.unsafe(nil)); end

  def consume_qualified_rule(input=T.unsafe(nil)); end

  def consume_rules(flags=T.unsafe(nil)); end

  def consume_simple_block(input=T.unsafe(nil)); end

  def create_node(type, properties=T.unsafe(nil)); end

  def create_selector(input); end

  def create_style_rule(rule); end

  def initialize(input, options=T.unsafe(nil)); end

  def parse_component_value(input=T.unsafe(nil)); end

  def parse_component_values(input=T.unsafe(nil)); end

  def parse_declaration(input=T.unsafe(nil)); end

  def parse_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def parse_properties(input=T.unsafe(nil)); end

  def parse_rule(input=T.unsafe(nil)); end

  def parse_value(nodes); end

  def tokens(); end
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  def self.parse_properties(input, options=T.unsafe(nil)); end

  def self.parse_rules(input, options=T.unsafe(nil)); end

  def self.parse_stylesheet(input, options=T.unsafe(nil)); end

  def self.stringify(nodes, options=T.unsafe(nil)); end
end

class Crass::Scanner
  def consume(); end

  def consume_rest(); end

  def current(); end

  def eos?(); end

  def initialize(input); end

  def mark(); end

  def marked(); end

  def marker(); end

  def marker=(marker); end

  def peek(length=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def reconsume(); end

  def reset(); end

  def scan(pattern); end

  def scan_until(pattern); end

  def string(); end
end

class Crass::Scanner
end

class Crass::TokenScanner
  def collect(); end

  def consume(); end

  def current(); end

  def initialize(tokens); end

  def peek(); end

  def pos(); end

  def reconsume(); end

  def reset(); end

  def tokens(); end
end

class Crass::TokenScanner
end

class Crass::Tokenizer
  def consume(); end

  def consume_bad_url(); end

  def consume_comments(); end

  def consume_escaped(); end

  def consume_ident(); end

  def consume_name(); end

  def consume_number(); end

  def consume_numeric(); end

  def consume_string(ending=T.unsafe(nil)); end

  def consume_unicode_range(); end

  def consume_url(); end

  def convert_string_to_number(str); end

  def create_token(type, properties=T.unsafe(nil)); end

  def initialize(input, options=T.unsafe(nil)); end

  def preprocess(input); end

  def start_identifier?(text=T.unsafe(nil)); end

  def start_number?(text=T.unsafe(nil)); end

  def tokenize(); end

  def valid_escape?(text=T.unsafe(nil)); end
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  def self.tokenize(input, options=T.unsafe(nil)); end
end

module Crass
  def self.parse(input, options=T.unsafe(nil)); end

  def self.parse_properties(input, options=T.unsafe(nil)); end
end

module DRb
end

class DRb::DRbArray
  def _dump(lv); end

  def initialize(ary); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbBadScheme
end

class DRb::DRbBadScheme
end

class DRb::DRbBadURI
end

class DRb::DRbBadURI
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
  POOL_SIZE = ::T.let(nil, ::T.untyped)
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbConnError
end

class DRb::DRbConnError
end

class DRb::DRbError
end

class DRb::DRbError
end

class DRb::DRbIdConv
  def to_id(obj); end

  def to_obj(ref); end
end

class DRb::DRbIdConv
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbMessage
end

class DRb::DRbObject
  def ==(other); end

  def __drbref(); end

  def __drburi(); end

  def _dump(lv); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end

  def method_missing(msg_id, *a, &b); end

  def respond_to?(msg_id, priv=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self._load(s); end

  def self.new_with(uri, ref); end

  def self.new_with_uri(uri); end

  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
end

module DRb::DRbProtocol
  def self.add_protocol(prot); end

  def self.auto_load(uri); end

  def self.open(uri, config, first=T.unsafe(nil)); end

  def self.open_server(uri, config, first=T.unsafe(nil)); end

  def self.uri_option(uri, config, first=T.unsafe(nil)); end
end

class DRb::DRbRemoteError
  def initialize(error); end

  def reason(); end
end

class DRb::DRbRemoteError
end

class DRb::DRbServer
  def alive?(); end

  def check_insecure_method(obj, msg_id); end

  def config(); end

  def front(); end

  def here?(uri); end

  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end

  def stop_service(); end

  def thread(); end

  def to_id(obj); end

  def to_obj(ref); end

  def uri(); end

  def verbose(); end

  def verbose=(v); end
  INSECURE_METHOD = ::T.let(nil, ::T.untyped)
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_acl(acl); end

  def self.default_argc_limit(argc); end

  def self.default_id_conv(idconv); end

  def self.default_load_limit(sz); end

  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end

  def self.verbose(); end

  def self.verbose=(on); end
end

class DRb::DRbServerNotFound
end

class DRb::DRbServerNotFound
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

module DRb::DRbUndumped
end

class DRb::DRbUnknown
  def _dump(lv); end

  def buf(); end

  def exception(); end

  def initialize(err, buf); end

  def name(); end

  def reload(); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end

  def unknown(); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.config(); end

  def self.current_server(); end

  def self.fetch_server(uri); end

  def self.front(); end

  def self.here?(uri); end

  def self.install_acl(acl); end

  def self.install_id_conv(idconv); end

  def self.mutex(); end

  def self.primary_server(); end

  def self.primary_server=(primary_server); end

  def self.regist_server(server); end

  def self.remove_server(server); end

  def self.start_service(uri=T.unsafe(nil), front=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.stop_service(); end

  def self.thread(); end

  def self.to_id(obj); end

  def self.to_obj(ref); end

  def self.uri(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class DataAssociation
  def autosave_associated_records_for_upload(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class DataAssociation::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class DataAssociation::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class DataAssociation::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module DataAssociation::GeneratedAssociationMethods
  def build_upload(*args, &block); end

  def create_upload(*args, &block); end

  def create_upload!(*args, &block); end
end

class Date
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  def acts_like_date?(); end

  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_end_of_day(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def default_inspect(); end

  def end_of_day(); end

  def in(seconds); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def minus_with_duration(other); end

  def minus_without_duration(_); end

  def noon(); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def readable_inspect(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date
  def self.beginning_of_week(); end

  def self.beginning_of_week=(week_start); end

  def self.beginning_of_week_default(); end

  def self.beginning_of_week_default=(beginning_of_week_default); end

  def self.current(); end

  def self.find_beginning_of_week!(week_start); end

  def self.tomorrow(); end

  def self.yesterday(); end
end

module DateAndTime
end

module DateAndTime::Calculations
  def all_month(); end

  def all_quarter(); end

  def all_week(start_day=T.unsafe(nil)); end

  def all_year(); end

  def at_beginning_of_month(); end

  def at_beginning_of_quarter(); end

  def at_beginning_of_week(start_day=T.unsafe(nil)); end

  def at_beginning_of_year(); end

  def at_end_of_month(); end

  def at_end_of_quarter(); end

  def at_end_of_week(start_day=T.unsafe(nil)); end

  def at_end_of_year(); end

  def beginning_of_month(); end

  def beginning_of_quarter(); end

  def beginning_of_week(start_day=T.unsafe(nil)); end

  def beginning_of_year(); end

  def days_ago(days); end

  def days_since(days); end

  def days_to_week_start(start_day=T.unsafe(nil)); end

  def end_of_month(); end

  def end_of_quarter(); end

  def end_of_week(start_day=T.unsafe(nil)); end

  def end_of_year(); end

  def future?(); end

  def last_month(); end

  def last_quarter(); end

  def last_week(start_day=T.unsafe(nil)); end

  def last_year(); end

  def monday(); end

  def months_ago(months); end

  def months_since(months); end

  def next_month(); end

  def next_quarter(); end

  def next_week(given_day_in_next_week=T.unsafe(nil)); end

  def next_year(); end

  def past?(); end

  def prev_month(); end

  def prev_quarter(); end

  def prev_week(start_day=T.unsafe(nil)); end

  def prev_year(); end

  def sunday(); end

  def today?(); end

  def tomorrow(); end

  def weeks_ago(weeks); end

  def weeks_since(weeks); end

  def years_ago(years); end

  def years_since(years); end

  def yesterday(); end
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
end

module DateAndTime::Calculations
end

module DateAndTime::Compatibility
  def preserve_timezone(); end
end

module DateAndTime::Compatibility
  def self.preserve_timezone(); end

  def self.preserve_timezone=(obj); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
end

module DateAndTime
end

class DateTime
  include ::DateAndTime::Compatibility
  def acts_like_time?(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

module Diff
end

module Diff::LCS
  def diff(other, callbacks=T.unsafe(nil), &block); end

  def lcs(other, &block); end

  def patch(patchset); end

  def patch!(patchset); end

  def patch_me(patchset); end

  def sdiff(other, callbacks=T.unsafe(nil), &block); end

  def traverse_balanced(other, callbacks=T.unsafe(nil), &block); end

  def traverse_sequences(other, callbacks=T.unsafe(nil), &block); end

  def unpatch(patchset); end

  def unpatch!(patchset); end

  def unpatch_me(patchset); end
  VERSION = ::T.let(nil, ::T.untyped)
end

Diff::LCS::BalancedCallbacks = Diff::LCS::DefaultCallbacks

class Diff::LCS::Block
  def changes(); end

  def diff_size(); end

  def initialize(chunk); end

  def insert(); end

  def op(); end

  def remove(); end
end

class Diff::LCS::Block
end

class Diff::LCS::Change
  include ::Comparable
  def ==(other); end

  def action(); end

  def adding?(); end

  def changed?(); end

  def deleting?(); end

  def element(); end

  def finished_a?(); end

  def finished_b?(); end

  def initialize(*args); end

  def position(); end

  def to_a(); end

  def unchanged?(); end
  VALID_ACTIONS = ::T.let(nil, ::T.untyped)
end

Diff::LCS::Change::IntClass = Integer

class Diff::LCS::Change
  def self.from_a(arr); end

  def self.valid_action?(action); end
end

class Diff::LCS::ContextChange
  def inspect(*args); end

  def new_element(); end

  def new_position(); end

  def old_element(); end

  def old_position(); end
end

class Diff::LCS::ContextChange
  def self.simplify(event); end
end

class Diff::LCS::ContextDiffCallbacks
  def change(event); end
end

class Diff::LCS::ContextDiffCallbacks
end

class Diff::LCS::DefaultCallbacks
end

class Diff::LCS::DefaultCallbacks
  def self.change(event); end

  def self.discard_a(event); end

  def self.discard_b(event); end

  def self.match(event); end
end

class Diff::LCS::DiffCallbacks
  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def finish(); end

  def match(event); end
end

class Diff::LCS::DiffCallbacks
end

class Diff::LCS::Hunk
  def blocks(); end

  def diff(format); end

  def end_new(); end

  def end_old(); end

  def file_length_difference(); end

  def flag_context(); end

  def flag_context=(context); end

  def initialize(data_old, data_new, piece, flag_context, file_length_difference); end

  def merge(hunk); end

  def overlaps?(hunk); end

  def start_new(); end

  def start_old(); end

  def unshift(hunk); end
end

class Diff::LCS::Hunk
end

module Diff::LCS::Internals
end

module Diff::LCS::Internals
  def self.analyze_patchset(patchset, depth=T.unsafe(nil)); end

  def self.intuit_diff_direction(src, patchset, limit=T.unsafe(nil)); end

  def self.lcs(a, b); end
end

class Diff::LCS::SDiffCallbacks
  def change(event); end

  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def match(event); end
end

class Diff::LCS::SDiffCallbacks
end

Diff::LCS::SequenceCallbacks = Diff::LCS::DefaultCallbacks

module Diff::LCS
  def self.LCS(seq1, seq2, &block); end

  def self.callbacks_for(callbacks); end

  def self.diff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.lcs(seq1, seq2, &block); end

  def self.patch(src, patchset, direction=T.unsafe(nil)); end

  def self.patch!(src, patchset); end

  def self.sdiff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.traverse_balanced(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.traverse_sequences(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.unpatch!(src, patchset); end
end

module Diff
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  def self.uuid_from_hash(hash_class, uuid_namespace, name); end

  def self.uuid_v3(uuid_namespace, name); end

  def self.uuid_v4(); end

  def self.uuid_v5(uuid_namespace, name); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

class Docile::ChainingFallbackContextProxy
end

class Docile::ChainingFallbackContextProxy
end

module Docile::Execution
end

module Docile::Execution
  def self.exec_in_proxy_context(dsl, proxy_type, *args, &block); end
end

class Docile::FallbackContextProxy
  def initialize(receiver, fallback); end

  def method_missing(method, *args, &block); end
  NON_FALLBACK_METHODS = ::T.let(nil, ::T.untyped)
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class Docile::FallbackContextProxy
end

module Docile
  extend ::Docile::Execution
  def self.dsl_eval(dsl, *args, &block); end

  def self.dsl_eval_immutable(dsl, *args, &block); end

  def self.dsl_eval_with_block_return(dsl, *args, &block); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def as_json(options=T.unsafe(nil)); end

  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def exclude?(object); end

  def grep_v(_); end

  def many?(); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def to_json(options=T.unsafe(nil)); end

  def to_json_with_active_support_encoder(options=T.unsafe(nil)); end

  def to_json_without_active_support_encoder(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

module Erubis
  EMPTY_BINDING = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Erubis::ArrayBufferEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::ArrayBufferEnhancer
  def self.desc(); end
end

module Erubis::ArrayEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::ArrayEnhancer
  def self.desc(); end
end

module Erubis::Basic
end

module Erubis::Basic::Converter
  include ::Erubis::Converter
  def add_expr(src, code, indicator); end

  def convert_input(src, input); end

  def init_converter(properties=T.unsafe(nil)); end

  def pattern(); end

  def pattern=(pattern); end

  def trim(); end

  def trim=(trim); end
  DEFAULT_REGEXP = ::T.let(nil, ::T.untyped)
end

module Erubis::Basic::Converter
  def self.pattern_regexp(pattern); end

  def self.supported_properties(); end
end

class Erubis::Basic::Engine
  include ::Erubis::Evaluator
  include ::Erubis::Basic::Converter
  include ::Erubis::Converter
  include ::Erubis::Generator
end

class Erubis::Basic::Engine
end

module Erubis::Basic
end

module Erubis::BiPatternEnhancer
  def add_text(src, text); end

  def bipattern=(pat); end

  def initialize(input, properties=T.unsafe(nil)); end
end

module Erubis::BiPatternEnhancer
  def self.desc(); end
end

class Erubis::Context
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def each(&blk); end

  def initialize(hash=T.unsafe(nil)); end

  def keys(); end

  def to_hash(); end

  def update(context_or_hash); end
end

class Erubis::Context
end

module Erubis::Converter
  def convert(input); end

  def convert_input(codebuf, input); end

  def detect_spaces_at_bol(text, is_bol); end

  def escape(); end

  def escape=(escape); end

  def init_converter(properties=T.unsafe(nil)); end

  def postamble(); end

  def postamble=(postamble); end

  def preamble(); end

  def preamble=(preamble); end
end

module Erubis::Converter
  def self.supported_properties(); end
end

module Erubis::DeleteIndentEnhancer
  def convert_input(src, input); end
end

module Erubis::DeleteIndentEnhancer
  def self.desc(); end
end

class Erubis::Engine
  def convert!(input); end

  def initialize(input=T.unsafe(nil), properties=T.unsafe(nil)); end

  def process(input, context=T.unsafe(nil), filename=T.unsafe(nil)); end

  def process_proc(proc_obj, context=T.unsafe(nil), filename=T.unsafe(nil)); end
end

class Erubis::Engine
  def self.load_file(filename, properties=T.unsafe(nil)); end
end

module Erubis::ErboutEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::ErboutEnhancer
  def self.desc(); end
end

class Erubis::ErubisError
end

class Erubis::ErubisError
end

class Erubis::Eruby
  include ::Erubis::RubyEvaluator
  include ::Erubis::RubyGenerator
  include ::Erubis::StringBufferEnhancer
end

class Erubis::Eruby
end

module Erubis::EscapeEnhancer
  def add_expr(src, code, indicator); end
end

module Erubis::EscapeEnhancer
  def self.desc(); end
end

class Erubis::EscapedEruby
  include ::Erubis::EscapeEnhancer
end

class Erubis::EscapedEruby
end

module Erubis::Evaluator
  def evaluate(*args); end

  def filename(); end

  def filename=(filename); end

  def init_evaluator(properties); end

  def result(*args); end

  def src(); end

  def src=(src); end
end

module Erubis::Evaluator
  def self.supported_properties(); end
end

class Erubis::FastEruby
  include ::Erubis::InterpolationEnhancer
end

class Erubis::FastEruby
end

module Erubis::Generator
  def add_expr_debug(src, code); end

  def add_expr_escaped(src, code); end

  def add_expr_literal(src, code); end

  def add_postamble(src); end

  def add_preamble(src); end

  def add_stmt(src, code); end

  def add_text(src, text); end

  def escape_text(text); end

  def escaped_expr(code); end

  def escapefunc(); end

  def escapefunc=(escapefunc); end

  def init_generator(properties=T.unsafe(nil)); end
end

module Erubis::Generator
  def self.supported_properties(); end
end

module Erubis::HeaderFooterEnhancer
  def add_text(src, text); end

  def convert(input); end

  def footer(); end

  def footer=(footer); end

  def header(); end

  def header=(header); end
  HEADER_FOOTER_PATTERN = ::T.let(nil, ::T.untyped)
end

module Erubis::HeaderFooterEnhancer
  def self.desc(); end
end

module Erubis::InterpolationEnhancer
  def _add_text_to_str(str, text); end

  def add_expr_escaped(str, code); end

  def add_expr_literal(str, code); end

  def add_text(src, text); end

  def convert_input(src, input); end
end

module Erubis::InterpolationEnhancer
  def self.desc(); end
end

module Erubis::NoCodeEnhancer
  def add_expr(src, code, indicator); end

  def add_postamble(src); end

  def add_preamble(src); end

  def add_stmt(src, code); end

  def add_text(src, text); end
end

module Erubis::NoCodeEnhancer
  def self.desc(); end
end

module Erubis::NoTextEnhancer
  def add_text(src, text); end
end

module Erubis::NoTextEnhancer
  def self.desc(); end
end

class Erubis::NotSupportedError
end

class Erubis::NotSupportedError
end

module Erubis::PI
end

module Erubis::PI::Converter
  include ::Erubis::Converter
  def add_pi_expr(codebuf, code, indicator); end

  def add_pi_stmt(codebuf, code, pi_arg); end

  def convert(input); end

  def convert_input(codebuf, input); end

  def init_converter(properties=T.unsafe(nil)); end

  def pi(); end

  def pi=(pi); end

  def prefix(); end

  def prefix=(prefix); end
end

module Erubis::PI::Converter
  def self.desc(); end

  def self.supported_properties(); end
end

class Erubis::PI::Engine
  include ::Erubis::Evaluator
  include ::Erubis::PI::Converter
  include ::Erubis::Converter
  include ::Erubis::Generator
end

class Erubis::PI::Engine
end

class Erubis::PI::Eruby
  include ::Erubis::RubyEvaluator
  include ::Erubis::RubyGenerator
  include ::Erubis::StringBufferEnhancer
end

class Erubis::PI::Eruby
end

module Erubis::PI
end

module Erubis::PercentLineEnhancer
  include ::Erubis::PrefixedLineEnhancer
  def add_text(src, text); end
end

module Erubis::PercentLineEnhancer
  def self.desc(); end
end

module Erubis::PrefixedLineEnhancer
  def add_text(src, text); end

  def init_generator(properties=T.unsafe(nil)); end
end

module Erubis::PrefixedLineEnhancer
  def self.desc(); end
end

module Erubis::PrintEnabledEnhancer
  def add_preamble(src); end

  def evaluate(context=T.unsafe(nil)); end

  def print(*args); end
end

module Erubis::PrintEnabledEnhancer
  def self.desc(); end
end

module Erubis::PrintOutEnhancer
  def add_expr_escaped(src, code); end

  def add_expr_literal(src, code); end

  def add_postamble(src); end

  def add_preamble(src); end

  def add_text(src, text); end
end

module Erubis::PrintOutEnhancer
  def self.desc(); end
end

module Erubis::RubyEvaluator
  include ::Erubis::Evaluator
  def def_method(object, method_name, filename=T.unsafe(nil)); end

  def evaluate(_context=T.unsafe(nil)); end

  def result(_binding_or_hash=T.unsafe(nil)); end
end

module Erubis::RubyEvaluator
  def self.supported_properties(); end
end

module Erubis::RubyGenerator
  include ::Erubis::Generator
  include ::Erubis::StringBufferEnhancer
  def add_expr_debug(src, code); end

  def add_expr_escaped(src, code); end

  def add_expr_literal(src, code); end

  def add_stmt(src, code); end

  def add_text(src, text); end

  def escape_text(text); end

  def escaped_expr(code); end

  def init_generator(properties=T.unsafe(nil)); end
end

module Erubis::RubyGenerator
  def self.supported_properties(); end
end

module Erubis::SimplifyEnhancer
  def convert(input); end
  SIMPLE_REGEXP = ::T.let(nil, ::T.untyped)
end

module Erubis::SimplifyEnhancer
  def self.desc(); end
end

module Erubis::StdoutEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::StdoutEnhancer
  def self.desc(); end
end

module Erubis::StringBufferEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::StringBufferEnhancer
  def self.desc(); end
end

module Erubis::StringIOEnhancer
  def add_postamble(src); end

  def add_preamble(src); end
end

module Erubis::StringIOEnhancer
  def self.desc(); end
end

class Erubis::XmlEruby
  include ::Erubis::EscapeEnhancer
end

class Erubis::XmlEruby
end

module Erubis::XmlHelper
  ESCAPE_TABLE = ::T.let(nil, ::T.untyped)
end

module Erubis::XmlHelper
  def self.escape_xml(value); end

  def self.escape_xml2(value); end

  def self.url_encode(str); end
end

module Erubis
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable
  def bindings(); end

  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FFI::AbstractMemory
  def [](_); end

  def __copy_from__(_, _1); end

  def clear(); end

  def get(_, _1); end

  def get_array_of_char(_, _1); end

  def get_array_of_double(_, _1); end

  def get_array_of_float(_, _1); end

  def get_array_of_float32(_, _1); end

  def get_array_of_float64(_, _1); end

  def get_array_of_int(_, _1); end

  def get_array_of_int16(_, _1); end

  def get_array_of_int32(_, _1); end

  def get_array_of_int64(_, _1); end

  def get_array_of_int8(_, _1); end

  def get_array_of_long(_, _1); end

  def get_array_of_long_long(_, _1); end

  def get_array_of_pointer(_, _1); end

  def get_array_of_short(_, _1); end

  def get_array_of_string(*_); end

  def get_array_of_uchar(_, _1); end

  def get_array_of_uint(_, _1); end

  def get_array_of_uint16(_, _1); end

  def get_array_of_uint32(_, _1); end

  def get_array_of_uint64(_, _1); end

  def get_array_of_uint8(_, _1); end

  def get_array_of_ulong(_, _1); end

  def get_array_of_ulong_long(_, _1); end

  def get_array_of_ushort(_, _1); end

  def get_bytes(_, _1); end

  def get_char(_); end

  def get_double(_); end

  def get_float(_); end

  def get_float32(_); end

  def get_float64(_); end

  def get_int(_); end

  def get_int16(_); end

  def get_int32(_); end

  def get_int64(_); end

  def get_int8(_); end

  def get_long(_); end

  def get_long_long(_); end

  def get_pointer(_); end

  def get_short(_); end

  def get_string(*_); end

  def get_uchar(_); end

  def get_uint(_); end

  def get_uint16(_); end

  def get_uint32(_); end

  def get_uint64(_); end

  def get_uint8(_); end

  def get_ulong(_); end

  def get_ulong_long(_); end

  def get_ushort(_); end

  def put(_, _1, _2); end

  def put_array_of_char(_, _1); end

  def put_array_of_double(_, _1); end

  def put_array_of_float(_, _1); end

  def put_array_of_float32(_, _1); end

  def put_array_of_float64(_, _1); end

  def put_array_of_int(_, _1); end

  def put_array_of_int16(_, _1); end

  def put_array_of_int32(_, _1); end

  def put_array_of_int64(_, _1); end

  def put_array_of_int8(_, _1); end

  def put_array_of_long(_, _1); end

  def put_array_of_long_long(_, _1); end

  def put_array_of_pointer(_, _1); end

  def put_array_of_short(_, _1); end

  def put_array_of_uchar(_, _1); end

  def put_array_of_uint(_, _1); end

  def put_array_of_uint16(_, _1); end

  def put_array_of_uint32(_, _1); end

  def put_array_of_uint64(_, _1); end

  def put_array_of_uint8(_, _1); end

  def put_array_of_ulong(_, _1); end

  def put_array_of_ulong_long(_, _1); end

  def put_array_of_ushort(_, _1); end

  def put_bytes(*_); end

  def put_char(_, _1); end

  def put_double(_, _1); end

  def put_float(_, _1); end

  def put_float32(_, _1); end

  def put_float64(_, _1); end

  def put_int(_, _1); end

  def put_int16(_, _1); end

  def put_int32(_, _1); end

  def put_int64(_, _1); end

  def put_int8(_, _1); end

  def put_long(_, _1); end

  def put_long_long(_, _1); end

  def put_pointer(_, _1); end

  def put_short(_, _1); end

  def put_string(_, _1); end

  def put_uchar(_, _1); end

  def put_uint(_, _1); end

  def put_uint16(_, _1); end

  def put_uint32(_, _1); end

  def put_uint64(_, _1); end

  def put_uint8(_, _1); end

  def put_ulong(_, _1); end

  def put_ulong_long(_, _1); end

  def put_ushort(_, _1); end

  def read_array_of_char(_); end

  def read_array_of_double(_); end

  def read_array_of_float(_); end

  def read_array_of_int(_); end

  def read_array_of_int16(_); end

  def read_array_of_int32(_); end

  def read_array_of_int64(_); end

  def read_array_of_int8(_); end

  def read_array_of_long(_); end

  def read_array_of_long_long(_); end

  def read_array_of_pointer(_); end

  def read_array_of_short(_); end

  def read_array_of_uchar(_); end

  def read_array_of_uint(_); end

  def read_array_of_uint16(_); end

  def read_array_of_uint32(_); end

  def read_array_of_uint64(_); end

  def read_array_of_uint8(_); end

  def read_array_of_ulong(_); end

  def read_array_of_ulong_long(_); end

  def read_array_of_ushort(_); end

  def read_bytes(_); end

  def read_char(); end

  def read_double(); end

  def read_float(); end

  def read_int(); end

  def read_int16(); end

  def read_int32(); end

  def read_int64(); end

  def read_int8(); end

  def read_long(); end

  def read_long_long(); end

  def read_pointer(); end

  def read_short(); end

  def read_uchar(); end

  def read_uint(); end

  def read_uint16(); end

  def read_uint32(); end

  def read_uint64(); end

  def read_uint8(); end

  def read_ulong(); end

  def read_ulong_long(); end

  def read_ushort(); end

  def size(); end

  def total(); end

  def type_size(); end

  def write_array_of_char(_); end

  def write_array_of_double(_); end

  def write_array_of_float(_); end

  def write_array_of_int(_); end

  def write_array_of_int16(_); end

  def write_array_of_int32(_); end

  def write_array_of_int64(_); end

  def write_array_of_int8(_); end

  def write_array_of_long(_); end

  def write_array_of_long_long(_); end

  def write_array_of_pointer(_); end

  def write_array_of_short(_); end

  def write_array_of_uchar(_); end

  def write_array_of_uint(_); end

  def write_array_of_uint16(_); end

  def write_array_of_uint32(_); end

  def write_array_of_uint64(_); end

  def write_array_of_uint8(_); end

  def write_array_of_ulong(_); end

  def write_array_of_ulong_long(_); end

  def write_array_of_ushort(_); end

  def write_bytes(*_); end

  def write_char(_); end

  def write_double(_); end

  def write_float(_); end

  def write_int(_); end

  def write_int16(_); end

  def write_int32(_); end

  def write_int64(_); end

  def write_int8(_); end

  def write_long(_); end

  def write_long_long(_); end

  def write_pointer(_); end

  def write_short(_); end

  def write_uchar(_); end

  def write_uint(_); end

  def write_uint16(_); end

  def write_uint32(_); end

  def write_uint64(_); end

  def write_uint8(_); end

  def write_ulong(_); end

  def write_ulong_long(_); end

  def write_ushort(_); end
end

class FFI::AbstractMemory
end

class FFI::ArrayType
  def elem_type(); end

  def initialize(_, _1); end

  def length(); end
end

class FFI::ArrayType
end

class FFI::AutoPointer
  def autorelease=(autorelease); end

  def initialize(ptr, proc=T.unsafe(nil), &block); end
end

class FFI::AutoPointer::CallableReleaser
  def release(ptr); end
end

class FFI::AutoPointer::CallableReleaser
end

class FFI::AutoPointer::DefaultReleaser
  def release(ptr); end
end

class FFI::AutoPointer::DefaultReleaser
end

class FFI::AutoPointer::Releaser
  def autorelease(); end

  def autorelease=(autorelease); end

  def call(*args); end

  def free(); end

  def initialize(ptr, proc); end
end

class FFI::AutoPointer::Releaser
end

class FFI::AutoPointer
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end

  def self.native_type(); end
end

class FFI::Bitmask
  def [](*query); end

  def to_native(query, ctx); end
end

class FFI::Bitmask
end

class FFI::Buffer
  def +(_); end

  def initialize(*_); end

  def length(); end

  def order(*_); end

  def slice(_, _1); end
end

class FFI::Buffer
  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end
end

FFI::CallbackInfo = FFI::FunctionType

module FFI::DataConverter
  def from_native(value, ctx); end

  def native_type(type=T.unsafe(nil)); end

  def to_native(value, ctx); end
end

module FFI::DataConverter
end

class FFI::DynamicLibrary
  def find_function(_); end

  def find_symbol(_); end

  def find_variable(_); end

  def initialize(_, _1); end

  def last_error(); end

  def name(); end
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary
  def self.last_error(); end

  def self.open(_, _1); end
end

class FFI::Enum
  include ::FFI::DataConverter
  def [](query); end

  def find(query); end

  def from_native(val, ctx); end

  def initialize(*args); end

  def native_type(); end

  def symbol_map(); end

  def symbols(); end

  def tag(); end

  def to_h(); end

  def to_hash(); end

  def to_native(val, ctx); end
end

class FFI::Enum
end

class FFI::Enums
  def <<(enum); end

  def __map_symbol(symbol); end

  def find(query); end
end

class FFI::Enums
end

class FFI::Function
  def attach(_, _1); end

  def autorelease(); end

  def call(*_); end
end

class FFI::Function
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType
  def initialize(*_); end

  def param_types(); end

  def result_type(); end
end

class FFI::FunctionType
end

module FFI::IO
end

module FFI::IO
  def self.for_fd(fd, mode=T.unsafe(nil)); end

  def self.native_read(io, buf, len); end
end

module FFI::LastError
end

module FFI::LastError
  def self.error(); end

  def self.error=(error); end
end

module FFI::Library
  def attach_function(name, func, args, returns=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_variable(mname, a1, a2=T.unsafe(nil)); end

  def bitmask(*args); end

  def callback(*args); end

  def enum(*args); end

  def enum_type(name); end

  def enum_value(symbol); end

  def ffi_convention(convention=T.unsafe(nil)); end

  def ffi_lib(*names); end

  def ffi_lib_flags(*flags); end

  def ffi_libraries(); end

  def find_type(t); end

  def function_names(name, arg_types); end

  def typedef(old, add, info=T.unsafe(nil)); end
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

module FFI::Library
  def self.extended(mod); end
end

class FFI::ManagedStruct
  def initialize(pointer=T.unsafe(nil)); end
end

class FFI::ManagedStruct
end

class FFI::MemoryPointer
end

class FFI::MemoryPointer
  def self.from_string(_); end
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NotFoundError
  def initialize(function, *libraries); end
end

class FFI::NotFoundError
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

module FFI::Platform
  def self.bsd?(); end

  def self.is_os(os); end

  def self.mac?(); end

  def self.solaris?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class FFI::PlatformError
end

class FFI::PlatformError
end

class FFI::Pointer
  def +(_); end

  def address(); end

  def autorelease=(autorelease); end

  def autorelease?(); end

  def free(); end

  def initialize(*_); end

  def null?(); end

  def order(*_); end

  def read(type); end

  def read_array_of_type(type, reader, length); end

  def read_string(len=T.unsafe(nil)); end

  def read_string_length(len); end

  def read_string_to_null(); end

  def slice(_, _1); end

  def to_i(); end

  def to_ptr(); end

  def write(type, value); end

  def write_array_of_type(type, writer, ary); end

  def write_string(str, len=T.unsafe(nil)); end

  def write_string_length(str, len); end
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  def self.size(); end
end

class FFI::StrPtrConverter
end

class FFI::StrPtrConverter
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end
end

class FFI::Struct
  def [](_); end

  def []=(_, _1); end

  def align(); end

  def alignment(); end

  def clear(); end

  def initialize(*_); end

  def layout(); end

  def members(); end

  def null?(); end

  def offset_of(name); end

  def offsets(); end

  def order(*_); end

  def pointer(); end

  def size(); end

  def to_ptr(); end

  def values(); end
end

class FFI::Struct::InlineArray
  include ::Enumerable
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def initialize(_, _1); end

  def size(); end

  def to_a(); end

  def to_ptr(); end
end

class FFI::Struct::InlineArray
end

class FFI::Struct::ManagedStructConverter
  def from_native(ptr, ctx); end
end

class FFI::Struct::ManagedStructConverter
end

class FFI::Struct
  def self.align(alignment=T.unsafe(nil)); end

  def self.aligned(alignment=T.unsafe(nil)); end

  def self.alignment(); end

  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.auto_ptr(); end

  def self.by_ref(flags=T.unsafe(nil)); end

  def self.by_value(); end

  def self.callback(params, ret); end

  def self.enclosing_module(); end

  def self.find_field_type(type, mod=T.unsafe(nil)); end

  def self.find_type(type, mod=T.unsafe(nil)); end

  def self.in(); end

  def self.layout(*spec); end

  def self.members(); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end

  def self.offset_of(name); end

  def self.offsets(); end

  def self.out(); end

  def self.pack(packed=T.unsafe(nil)); end

  def self.packed(packed=T.unsafe(nil)); end

  def self.ptr(flags=T.unsafe(nil)); end

  def self.size(); end

  def self.size=(size); end

  def self.val(); end
end

class FFI::StructByReference
  include ::FFI::DataConverter
  def initialize(struct_class); end

  def native_type(); end

  def struct_class(); end
end

class FFI::StructByReference
end

class FFI::StructByValue
  def layout(); end

  def struct_class(); end
end

class FFI::StructByValue
end

class FFI::StructLayout
  def [](_); end

  def __union!(); end

  def fields(); end

  def initialize(_, _1, _2); end

  def members(); end

  def offset_of(field_name); end

  def offsets(); end

  def to_a(); end
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::CharArray
  def to_str(); end
end

class FFI::StructLayout::CharArray
end

class FFI::StructLayout::Enum
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::Enum
end

class FFI::StructLayout::Field
  def alignment(); end

  def get(_); end

  def initialize(*_); end

  def name(); end

  def offset(); end

  def put(_, _1); end

  def size(); end

  def type(); end
end

class FFI::StructLayout::Field
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::InnerStruct
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::InnerStruct
end

class FFI::StructLayout::Mapped
  def get(ptr); end

  def initialize(name, offset, type, orig_field); end

  def put(ptr, value); end
end

class FFI::StructLayout::Mapped
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayout
end

class FFI::StructLayoutBuilder
  def add(name, type, offset=T.unsafe(nil)); end

  def add_array(name, type, count, offset=T.unsafe(nil)); end

  def add_field(name, type, offset=T.unsafe(nil)); end

  def add_struct(name, type, offset=T.unsafe(nil)); end

  def alignment(); end

  def alignment=(align); end

  def build(); end

  def packed=(packed); end

  def size(); end

  def size=(size); end

  def union=(is_union); end

  def union?(); end
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::StructLayoutBuilder
end

class FFI::Type
  def alignment(); end

  def initialize(_); end

  def size(); end
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

class FFI::Type::Builtin
end

class FFI::Type::Builtin
end

FFI::Type::Function = FFI::FunctionType

class FFI::Type::Mapped
  def from_native(*_); end

  def native_type(); end

  def to_native(*_); end

  def type(); end
end

class FFI::Type::Mapped
end

FFI::Type::Struct = FFI::StructByValue

class FFI::Type
end

class FFI::Union
end

class FFI::Union
  def self.builder(); end
end

class FFI::VariadicInvoker
  def attach(mod, mname); end

  def call(*args, &block); end

  def init(arg_types, type_map); end

  def initialize(_, _1, _2, _3); end

  def invoke(_, _1); end
end

class FFI::VariadicInvoker
end

module FFI
  def self.add_typedef(old, add); end

  def self.errno(); end

  def self.errno=(error); end

  def self.find_type(name, type_map=T.unsafe(nil)); end

  def self.map_library_name(lib); end

  def self.type_size(type); end

  def self.typedef(old, add); end
end

module FactoryBot
  Deprecation = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FactoryBot::AssociationDefinitionError
end

class FactoryBot::AssociationDefinitionError
end

class FactoryBot::Attribute
  def alias_for?(attr); end

  def association?(); end

  def ignored(); end

  def initialize(name, ignored); end

  def name(); end

  def to_proc(); end
end

class FactoryBot::Attribute::Association
  def factory(); end

  def initialize(name, factory, overrides); end
end

class FactoryBot::Attribute::Association
end

class FactoryBot::Attribute::Dynamic
  def initialize(name, ignored, block); end
end

class FactoryBot::Attribute::Dynamic
end

class FactoryBot::Attribute::Sequence
  def initialize(name, sequence, ignored); end
end

class FactoryBot::Attribute::Sequence
end

class FactoryBot::Attribute
end

class FactoryBot::AttributeAssigner
  def initialize(evaluator, build_class, &instance_builder); end

  def object(); end
end

class FactoryBot::AttributeAssigner
end

class FactoryBot::AttributeDefinitionError
end

class FactoryBot::AttributeDefinitionError
end

class FactoryBot::AttributeList
  include ::Enumerable
  def apply_attributes(attributes_to_apply); end

  def associations(); end

  def define_attribute(attribute); end

  def each(&block); end

  def ignored(); end

  def initialize(name=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def names(); end

  def non_ignored(); end
end

class FactoryBot::AttributeList
end

class FactoryBot::Callback
  def ==(other); end

  def block(); end

  def initialize(name, block); end

  def name(); end

  def run(instance, evaluator); end
end

class FactoryBot::Callback
end

class FactoryBot::CallbacksObserver
  def initialize(callbacks, evaluator); end

  def update(name, result_instance); end
end

class FactoryBot::CallbacksObserver
end

class FactoryBot::Configuration
  def after(*args, &block); end

  def before(*args, &block); end

  def callback(*args, &block); end

  def callback_names(); end

  def callbacks(*args, &block); end

  def constructor(*args, &block); end

  def factories(); end

  def initialize_with(&block); end

  def inline_sequences(); end

  def sequences(); end

  def skip_create(*args, &block); end

  def strategies(); end

  def to_create(*args, &block); end

  def traits(); end
end

class FactoryBot::Configuration
end

class FactoryBot::Declaration
  def ignored(); end

  def initialize(name, ignored=T.unsafe(nil)); end

  def name(); end

  def to_attributes(); end
end

class FactoryBot::Declaration::Association
  def ==(other); end

  def initialize(name, *options); end

  def options(); end
end

class FactoryBot::Declaration::Association
end

class FactoryBot::Declaration::Dynamic
  def ==(other); end

  def block(); end

  def initialize(name, ignored=T.unsafe(nil), block=T.unsafe(nil)); end
end

class FactoryBot::Declaration::Dynamic
end

class FactoryBot::Declaration::Implicit
  def ==(other); end

  def factory(); end

  def initialize(name, factory=T.unsafe(nil), ignored=T.unsafe(nil)); end
end

class FactoryBot::Declaration::Implicit
end

class FactoryBot::Declaration
end

class FactoryBot::DeclarationList
  include ::Enumerable
  def attributes(); end

  def declare_attribute(declaration); end

  def each(&block); end

  def initialize(name=T.unsafe(nil)); end

  def overridable(); end
end

class FactoryBot::DeclarationList
end

class FactoryBot::Decorator
  def initialize(component); end

  def method_missing(name, *args, &block); end

  def send(symbol, *args, &block); end
end

class FactoryBot::Decorator::AttributeHash
  def attributes(); end

  def initialize(component, attributes=T.unsafe(nil)); end
end

class FactoryBot::Decorator::AttributeHash
end

class FactoryBot::Decorator::DisallowsDuplicatesRegistry
  def register(name, item); end
end

class FactoryBot::Decorator::DisallowsDuplicatesRegistry
end

class FactoryBot::Decorator::InvocationTracker
  def __invoked_methods__(); end
end

class FactoryBot::Decorator::InvocationTracker
end

class FactoryBot::Decorator::NewConstructor
  def initialize(component, build_class); end

  def new(*args, &block); end
end

class FactoryBot::Decorator::NewConstructor
end

class FactoryBot::Decorator
  def self.const_missing(name); end
end

class FactoryBot::Definition
  def add_callback(callback); end

  def after(*names, &block); end

  def append_traits(new_traits); end

  def attributes(); end

  def before(*names, &block); end

  def callback(*names, &block); end

  def callbacks(); end

  def compile(); end

  def constructor(); end

  def declarations(); end

  def declare_attribute(*args, &block); end

  def define_constructor(&block); end

  def define_trait(trait); end

  def defined_traits(); end

  def inherit_traits(new_traits); end

  def initialize(name, base_traits=T.unsafe(nil)); end

  def name(); end

  def overridable(); end

  def skip_create(); end

  def to_create(&block); end
end

class FactoryBot::Definition
end

class FactoryBot::DefinitionHierarchy
  def callbacks(*args, &block); end

  def constructor(*args, &block); end

  def to_create(*args, &block); end
end

class FactoryBot::DefinitionHierarchy
  def self.build_from_definition(definition); end
end

class FactoryBot::DefinitionProxy
  def add_attribute(name, &block); end

  def after(*args, &block); end

  def association(name, *options); end

  def before(*args, &block); end

  def callback(*args, &block); end

  def child_factories(); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize(definition, ignore=T.unsafe(nil)); end

  def initialize_with(&block); end

  def method_missing(name, *args, &block); end

  def sequence(name, *args, &block); end

  def singleton_method_added(name); end

  def skip_create(); end

  def to_create(&block); end

  def trait(name, &block); end

  def transient(&block); end
  UNPROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::DefinitionProxy
end

class FactoryBot::DuplicateDefinitionError
end

class FactoryBot::DuplicateDefinitionError
end

class FactoryBot::Evaluation
  include ::Observable
  def create(result_instance); end

  def hash(*args, &block); end

  def initialize(evaluator, attribute_assigner, to_create); end

  def notify(name, result_instance); end

  def object(*args, &block); end
end

class FactoryBot::Evaluation
end

class FactoryBot::Evaluator
  def __override_names__(); end

  def association(factory_name, *traits_and_overrides); end

  def attribute_lists(); end

  def attribute_lists=(attribute_lists); end

  def attribute_lists?(); end

  def increment_sequence(sequence); end

  def initialize(build_strategy, overrides=T.unsafe(nil)); end

  def instance=(object_instance); end

  def method_missing(method_name, *args, &block); end
end

class FactoryBot::Evaluator
  def self.attribute_list(); end

  def self.attribute_lists(); end

  def self.attribute_lists=(val); end

  def self.attribute_lists?(); end

  def self.define_attribute(name, &block); end
end

class FactoryBot::EvaluatorClassDefiner
  def evaluator_class(); end

  def initialize(attributes, parent_class); end
end

class FactoryBot::EvaluatorClassDefiner
end

class FactoryBot::Factory
  def add_callback(*args, &block); end

  def append_traits(*args, &block); end

  def associations(); end

  def attributes(); end

  def build_class(); end

  def build_hierarchy(); end

  def callbacks(); end

  def class_name(); end

  def compile(); end

  def compiled_constructor(); end

  def compiled_to_create(); end

  def constructor(*args, &block); end

  def declare_attribute(*args, &block); end

  def define_trait(*args, &block); end

  def defined_traits(*args, &block); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def hierarchy_instance(); end

  def human_names(); end

  def inherit_traits(*args, &block); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def names(); end

  def run(build_strategy, overrides, &block); end

  def to_create(*args, &block); end

  def with_traits(traits); end
end

class FactoryBot::Factory
end

class FactoryBot::FactoryRunner
  def initialize(name, strategy, traits_and_overrides); end

  def run(runner_strategy=T.unsafe(nil), &block); end
end

class FactoryBot::FactoryRunner
end

module FactoryBot::Internal
end

module FactoryBot::Internal
  def self.after(*args, &block); end

  def self.before(*args, &block); end

  def self.callback_names(*args, &block); end

  def self.callbacks(*args, &block); end

  def self.configuration(); end

  def self.constructor(*args, &block); end

  def self.factories(*args, &block); end

  def self.factory_by_name(name); end

  def self.initialize_with(*args, &block); end

  def self.inline_sequences(*args, &block); end

  def self.register_callback(name); end

  def self.register_default_callbacks(); end

  def self.register_default_strategies(); end

  def self.register_factory(factory); end

  def self.register_inline_sequence(sequence); end

  def self.register_sequence(sequence); end

  def self.register_strategy(strategy_name, strategy_class); end

  def self.register_trait(trait); end

  def self.reset_configuration(); end

  def self.rewind_inline_sequences(); end

  def self.rewind_sequences(); end

  def self.sequence_by_name(name); end

  def self.sequences(*args, &block); end

  def self.skip_create(*args, &block); end

  def self.strategies(*args, &block); end

  def self.strategy_by_name(name); end

  def self.to_create(*args, &block); end

  def self.trait_by_name(name); end

  def self.traits(*args, &block); end
end

class FactoryBot::InvalidCallbackNameError
end

class FactoryBot::InvalidCallbackNameError
end

class FactoryBot::InvalidFactoryError
end

class FactoryBot::InvalidFactoryError
end

class FactoryBot::Linter
  def initialize(factories, strategy: T.unsafe(nil), traits: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def lint!(); end
end

class FactoryBot::Linter::FactoryError
  def initialize(wrapped_error, factory); end

  def location(); end

  def message(); end

  def verbose_message(); end
end

class FactoryBot::Linter::FactoryError
end

class FactoryBot::Linter::FactoryTraitError
  def initialize(wrapped_error, factory, trait_name); end
end

class FactoryBot::Linter::FactoryTraitError
end

class FactoryBot::Linter
end

class FactoryBot::MethodDefinitionError
end

class FactoryBot::MethodDefinitionError
end

class FactoryBot::NullFactory
  def attributes(*args, &block); end

  def callbacks(*args, &block); end

  def class_name(); end

  def compile(); end

  def constructor(*args, &block); end

  def defined_traits(*args, &block); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def to_create(*args, &block); end
end

class FactoryBot::NullFactory
end

class FactoryBot::NullObject
  def initialize(methods_to_respond_to); end

  def method_missing(name, *args, &block); end

  def respond_to?(method, _include_private=T.unsafe(nil)); end
end

class FactoryBot::NullObject
end

class FactoryBot::Registry
  include ::Enumerable
  def [](name); end

  def clear(); end

  def each(&block); end

  def find(name); end

  def initialize(name); end

  def name(); end

  def register(name, item); end

  def registered?(name); end
end

class FactoryBot::Registry
end

class FactoryBot::Sequence
  def initialize(name, *args, &proc); end

  def name(); end

  def names(); end

  def next(scope=T.unsafe(nil)); end

  def rewind(); end
end

class FactoryBot::Sequence::EnumeratorAdapter
  def initialize(value); end

  def next(); end

  def peek(); end

  def rewind(); end
end

class FactoryBot::Sequence::EnumeratorAdapter
end

class FactoryBot::Sequence
end

class FactoryBot::SequenceAbuseError
end

class FactoryBot::SequenceAbuseError
end

module FactoryBot::Strategy
end

class FactoryBot::Strategy::AttributesFor
  def association(runner); end

  def result(evaluation); end
end

class FactoryBot::Strategy::AttributesFor
end

class FactoryBot::Strategy::Build
  def association(runner); end

  def result(evaluation); end
end

class FactoryBot::Strategy::Build
end

class FactoryBot::Strategy::Create
  def association(runner); end

  def result(evaluation); end
end

class FactoryBot::Strategy::Create
end

class FactoryBot::Strategy::Null
  def association(runner); end

  def result(evaluation); end
end

class FactoryBot::Strategy::Null
end

class FactoryBot::Strategy::Stub
  def association(runner); end

  def result(evaluation); end
  DISABLED_PERSISTENCE_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Strategy::Stub
end

module FactoryBot::Strategy
end

class FactoryBot::StrategyCalculator
  def initialize(name_or_object); end

  def strategy(); end
end

class FactoryBot::StrategyCalculator
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def define_strategy_methods(); end

  def initialize(strategy_name); end
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def self.with_index(block, index); end
end

module FactoryBot::Syntax
end

module FactoryBot::Syntax::Default
  include ::FactoryBot::Syntax::Methods
  def define(&block); end

  def modify(&block); end
end

class FactoryBot::Syntax::Default::DSL
  def after(*args, &block); end

  def before(*args, &block); end

  def callback(*args, &block); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize_with(*args, &block); end

  def sequence(name, *args, &block); end

  def skip_create(*args, &block); end

  def to_create(*args, &block); end

  def trait(name, &block); end
end

class FactoryBot::Syntax::Default::DSL
  def self.run(block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def factory(name, _options=T.unsafe(nil), &block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def self.run(block); end
end

module FactoryBot::Syntax::Default
end

module FactoryBot::Syntax::Methods
  def attributes_for(name, *traits_and_overrides, &block); end

  def attributes_for_list(name, amount, *traits_and_overrides, &block); end

  def attributes_for_pair(name, *traits_and_overrides, &block); end

  def build(name, *traits_and_overrides, &block); end

  def build_list(name, amount, *traits_and_overrides, &block); end

  def build_pair(name, *traits_and_overrides, &block); end

  def build_stubbed(name, *traits_and_overrides, &block); end

  def build_stubbed_list(name, amount, *traits_and_overrides, &block); end

  def build_stubbed_pair(name, *traits_and_overrides, &block); end

  def create(name, *traits_and_overrides, &block); end

  def create_list(name, amount, *traits_and_overrides, &block); end

  def create_pair(name, *traits_and_overrides, &block); end

  def generate(name); end

  def generate_list(name, count); end

  def null(name, *traits_and_overrides, &block); end

  def null_list(name, amount, *traits_and_overrides, &block); end

  def null_pair(name, *traits_and_overrides, &block); end
end

module FactoryBot::Syntax::Methods
end

module FactoryBot::Syntax
end

class FactoryBot::SyntaxRunner
  include ::FactoryBot::Syntax::Methods
end

class FactoryBot::SyntaxRunner
end

class FactoryBot::Trait
  def ==(other); end

  def add_callback(*args, &block); end

  def attributes(*args, &block); end

  def block(); end

  def callbacks(*args, &block); end

  def constructor(*args, &block); end

  def declare_attribute(*args, &block); end

  def define_trait(*args, &block); end

  def definition(); end

  def initialize(name, &block); end

  def name(); end

  def names(); end

  def to_create(*args, &block); end
end

class FactoryBot::Trait
end

class FactoryBot::TraitDefinitionError
end

class FactoryBot::TraitDefinitionError
end

module FactoryBot
  extend ::FactoryBot::Syntax::Default
  extend ::FactoryBot::Syntax::Methods
  def self.aliases(); end

  def self.aliases=(aliases); end

  def self.aliases_for(attribute); end

  def self.allow_class_lookup(*args, &block); end

  def self.allow_class_lookup=(*args, &block); end

  def self.allow_class_lookup_with_deprecation(*args, &block); end

  def self.allow_class_lookup_with_deprecation=(*args, &block); end

  def self.allow_class_lookup_without_deprecation(); end

  def self.allow_class_lookup_without_deprecation=(allow_class_lookup_without_deprecation); end

  def self.callback_names(*args, &block); end

  def self.callback_names_with_deprecation(*args, &block); end

  def self.callback_names_without_deprecation(*args, &block); end

  def self.callbacks(*args, &block); end

  def self.callbacks_with_deprecation(*args, &block); end

  def self.callbacks_without_deprecation(*args, &block); end

  def self.configuration(*args, &block); end

  def self.configuration_with_deprecation(*args, &block); end

  def self.configuration_without_deprecation(*args, &block); end

  def self.constructor(*args, &block); end

  def self.constructor_with_deprecation(*args, &block); end

  def self.constructor_without_deprecation(*args, &block); end

  def self.definition_file_paths(); end

  def self.definition_file_paths=(definition_file_paths); end

  def self.factories(*args, &block); end

  def self.factory_by_name(*args, &block); end

  def self.factory_by_name_with_deprecation(*args, &block); end

  def self.factory_by_name_without_deprecation(*args, &block); end

  def self.find_definitions(); end

  def self.initialize_with(*args, &block); end

  def self.initialize_with_with_deprecation(*args, &block); end

  def self.initialize_with_without_deprecation(*args, &block); end

  def self.lint(*args); end

  def self.register_callback(*args, &block); end

  def self.register_callback_with_deprecation(*args, &block); end

  def self.register_callback_without_deprecation(*args, &block); end

  def self.register_default_callbacks(*args, &block); end

  def self.register_default_callbacks_with_deprecation(*args, &block); end

  def self.register_default_callbacks_without_deprecation(*args, &block); end

  def self.register_default_strategies(*args, &block); end

  def self.register_default_strategies_with_deprecation(*args, &block); end

  def self.register_default_strategies_without_deprecation(*args, &block); end

  def self.register_factory(*args, &block); end

  def self.register_factory_with_deprecation(*args, &block); end

  def self.register_factory_without_deprecation(*args, &block); end

  def self.register_sequence(*args, &block); end

  def self.register_sequence_with_deprecation(*args, &block); end

  def self.register_sequence_without_deprecation(*args, &block); end

  def self.register_strategy(*args, &block); end

  def self.register_trait(*args, &block); end

  def self.register_trait_with_deprecation(*args, &block); end

  def self.register_trait_without_deprecation(*args, &block); end

  def self.reload(); end

  def self.reset_configuration(*args, &block); end

  def self.reset_configuration_with_deprecation(*args, &block); end

  def self.reset_configuration_without_deprecation(*args, &block); end

  def self.rewind_sequences(*args, &block); end

  def self.sequence_by_name(*args, &block); end

  def self.sequence_by_name_with_deprecation(*args, &block); end

  def self.sequence_by_name_without_deprecation(*args, &block); end

  def self.sequences(*args, &block); end

  def self.sequences_with_deprecation(*args, &block); end

  def self.sequences_without_deprecation(*args, &block); end

  def self.skip_create(*args, &block); end

  def self.skip_create_with_deprecation(*args, &block); end

  def self.skip_create_without_deprecation(*args, &block); end

  def self.strategies(*args, &block); end

  def self.strategies_with_deprecation(*args, &block); end

  def self.strategies_without_deprecation(*args, &block); end

  def self.strategy_by_name(*args, &block); end

  def self.to_create(*args, &block); end

  def self.to_create_with_deprecation(*args, &block); end

  def self.to_create_without_deprecation(*args, &block); end

  def self.trait_by_name(*args, &block); end

  def self.trait_by_name_with_deprecation(*args, &block); end

  def self.trait_by_name_without_deprecation(*args, &block); end

  def self.traits(*args, &block); end

  def self.traits_with_deprecation(*args, &block); end

  def self.traits_without_deprecation(*args, &block); end

  def self.use_parent_strategy(); end

  def self.use_parent_strategy=(obj); end
end

module FactoryBotRails
end

class FactoryBotRails::DefinitionFilePaths
  def any?(); end

  def directories(); end

  def files(); end

  def initialize(definition_file_paths); end
end

class FactoryBotRails::DefinitionFilePaths
end

class FactoryBotRails::Generator
  def factory_bot_disabled?(); end

  def generator(); end

  def initialize(config); end

  def rails_options(); end

  def run(); end

  def test_framework(); end
end

class FactoryBotRails::Generator
end

module FactoryBotRails::Generators
end

class FactoryBotRails::Generators::NonRSpecGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Generators::NonRSpecGenerator
end

class FactoryBotRails::Generators::NullGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Generators::NullGenerator
end

class FactoryBotRails::Generators::RSpecGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Generators::RSpecGenerator
end

module FactoryBotRails::Generators
end

class FactoryBotRails::Railtie
end

class FactoryBotRails::Railtie
end

class FactoryBotRails::Reloader
  def initialize(app, config); end

  def run(); end
end

class FactoryBotRails::Reloader
end

module FactoryBotRails
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  def to_json(options=T.unsafe(nil)); end
end

module Faraday
  METHODS_WITH_BODY = ::T.let(nil, ::T.untyped)
  METHODS_WITH_QUERY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  def call(env); end

  def close(); end

  def connection(env); end

  def initialize(_app=T.unsafe(nil), opts=T.unsafe(nil), &block); end
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  TIMEOUT_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::EMHttp
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end

  def error_message(client); end

  def parallel?(env); end

  def perform_request(env); end

  def perform_single_request(env); end

  def raise_error(msg); end

  def timeout_message?(msg); end
end

class Faraday::Adapter::EMHttp::Manager
  def add(&block); end

  def check_finished(); end

  def perform_request(); end

  def reset(); end

  def run(); end

  def running?(); end
end

class Faraday::Adapter::EMHttp::Manager
end

module Faraday::Adapter::EMHttp::Options
  def configure_compression(options, env); end

  def configure_proxy(options, env); end

  def configure_socket(options, env); end

  def configure_ssl(options, env); end

  def configure_timeout(options, env); end

  def connection_config(env); end

  def read_body(env); end

  def request_config(env); end

  def request_options(env); end
end

module Faraday::Adapter::EMHttp::Options
end

class Faraday::Adapter::EMHttp
  def self.setup_parallel_manager(_options=T.unsafe(nil)); end
end

class Faraday::Adapter::EMSynchrony
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
  def add(request, method, *args, &block); end

  def run(); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
end

class Faraday::Adapter::EMSynchrony
  def self.setup_parallel_manager(_options=T.unsafe(nil)); end
end

class Faraday::Adapter::Excon
  def build_connection(env); end

  def read_body(env); end
  OPTS_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Excon
end

class Faraday::Adapter::HTTPClient
  def build_connection(env); end

  def configure_client(client); end

  def configure_proxy(client, proxy); end

  def configure_socket(client, bind); end

  def configure_ssl(client, ssl); end

  def configure_timeouts(client, req); end

  def ssl_cert_store(ssl); end

  def ssl_verify_mode(ssl); end
end

class Faraday::Adapter::HTTPClient
end

class Faraday::Adapter::NetHttp
  def build_connection(env); end

  def initialize(app=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def net_http_connection(env); end
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttp
end

class Faraday::Adapter::NetHttpPersistent
  SSL_CONFIGURATIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttpPersistent
end

module Faraday::Adapter::Parallelism
  def inherited(subclass); end

  def supports_parallel=(supports_parallel); end

  def supports_parallel?(); end
end

module Faraday::Adapter::Parallelism
end

class Faraday::Adapter::Patron
  def build_connection(env); end

  def configure_proxy(session, proxy); end

  def configure_ssl(session, ssl); end

  def configure_timeouts(session, req); end
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
end

class Faraday::Adapter::Rack
  def initialize(faraday_app, rack_app); end
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def initialize(host, full, headers, body, block); end

  def matches?(request_host, request_uri, request_headers, request_body); end

  def params_match?(request_params); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def match(request_method, host, path, headers, body); end

  def matches?(stack, host, path, headers, body); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

class Faraday::Adapter
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::DependencyLoader
  extend ::Faraday::Adapter::Parallelism
  extend ::Faraday::AutoloadHelper
end

class Faraday::AdapterRegistry
  def get(name); end

  def set(klass, name=T.unsafe(nil)); end
end

class Faraday::AdapterRegistry
end

module Faraday::AutoloadHelper
  def all_loaded_constants(); end

  def autoload_all(prefix, options); end

  def load_autoloaded_constants(); end
end

module Faraday::AutoloadHelper
end

class Faraday::BadRequestError
end

class Faraday::BadRequestError
end

class Faraday::ClientError
end

class Faraday::ClientError
end

class Faraday::CompositeReadIO
  def close(); end

  def ensure_open_and_readable(); end

  def initialize(*parts); end

  def length(); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Faraday::CompositeReadIO
end

class Faraday::ConflictError
end

class Faraday::ConflictError
end

class Faraday::Connection
  def adapter(*args, &block); end

  def app(*args, &block); end

  def authorization(type, token); end

  def basic_auth(login, pass); end

  def build(*args, &block); end

  def build_exclusive_url(url=T.unsafe(nil), params=T.unsafe(nil), params_encoder=T.unsafe(nil)); end

  def build_request(method); end

  def build_url(url=T.unsafe(nil), extra_params=T.unsafe(nil)); end

  def builder(); end

  def close(); end

  def default_parallel_manager(); end

  def default_parallel_manager=(default_parallel_manager); end

  def delete(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def find_default_proxy(); end

  def get(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def head(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def headers(); end

  def headers=(hash); end

  def host(*args, &block); end

  def host=(*args, &block); end

  def in_parallel(manager=T.unsafe(nil)); end

  def in_parallel?(); end

  def initialize(url=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize_proxy(url, options); end

  def options(*args); end

  def parallel_manager(); end

  def params(); end

  def params=(hash); end

  def patch(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def path_prefix(*args, &block); end

  def path_prefix=(value); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def post(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def proxy(); end

  def proxy=(new_value); end

  def proxy_for_request(url); end

  def proxy_from_env(url); end

  def put(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def request(*args, &block); end

  def response(*args, &block); end

  def run_request(method, url, body, headers); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end

  def set_authorization_header(header_type, *args); end

  def ssl(); end

  def support_parallel?(adapter); end

  def token_auth(token, options=T.unsafe(nil)); end

  def trace(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def url_prefix(); end

  def url_prefix=(url, encoder=T.unsafe(nil)); end

  def use(*args, &block); end

  def with_uri_credentials(uri); end
  METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Connection
  extend ::Forwardable
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionOptions
  def new_builder(block); end
end

class Faraday::ConnectionOptions
end

module Faraday::DecodeMethods
  def add_to_context(is_array, context, value, subkey); end

  def decode(query); end

  def decode_pair(key, value, context); end

  def dehash(hash, depth); end

  def match_context(context, subkey); end

  def new_context(subkey, is_array, context); end

  def prepare_context(context, subkey, is_array, last_subkey); end
  SUBKEYS_REGEX = ::T.let(nil, ::T.untyped)
end

module Faraday::DecodeMethods
end

module Faraday::DependencyLoader
  def dependency(lib=T.unsafe(nil)); end

  def inherited(subclass); end

  def load_error(); end

  def loaded?(); end

  def new(*_); end
end

module Faraday::DependencyLoader
end

module Faraday::EncodeMethods
  def encode(params); end

  def encode_array(parent, value); end

  def encode_hash(parent, value); end

  def encode_pair(parent, value); end
end

module Faraday::EncodeMethods
end

class Faraday::Env
  def []=(key, value); end

  def body(); end

  def body=(value); end

  def clear_body(); end

  def current_body(); end

  def custom_members(); end

  def in_member_set?(key); end

  def needs_body?(); end

  def parallel?(); end

  def params_encoder(*args, &block); end

  def parse_body?(); end

  def success?(); end
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  extend ::Forwardable
  def self.member_set(); end
end

class Faraday::Error
  def exc_msg_and_response(exc, response=T.unsafe(nil)); end

  def exc_msg_and_response!(exc, response=T.unsafe(nil)); end

  def initialize(exc, response=T.unsafe(nil)); end

  def response(); end

  def wrapped_exception(); end
end

class Faraday::Error
end

Faraday::FilePart = UploadIO

module Faraday::FlatParamsEncoder
end

module Faraday::FlatParamsEncoder
  def self.decode(query); end

  def self.encode(params); end

  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::ForbiddenError
end

class Faraday::ForbiddenError
end

class Faraday::Middleware
  def close(); end

  def initialize(app=T.unsafe(nil)); end
end

class Faraday::Middleware
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::DependencyLoader
end

module Faraday::MiddlewareRegistry
  def fetch_middleware(key); end

  def load_middleware(key); end

  def lookup_middleware(key); end

  def middleware_mutex(&block); end

  def register_middleware(autoload_path=T.unsafe(nil), mapping=T.unsafe(nil)); end

  def unregister_middleware(key); end
end

module Faraday::MiddlewareRegistry
end

module Faraday::NestedParamsEncoder
end

module Faraday::NestedParamsEncoder
  extend ::Faraday::EncodeMethods
  extend ::Faraday::DecodeMethods
  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::NilStatusError
end

class Faraday::NilStatusError
end

class Faraday::Options
  def [](key); end

  def clear(); end

  def delete(key); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, *args); end

  def has_key?(key); end

  def has_value?(value); end

  def key?(key); end

  def keys(); end

  def merge(other); end

  def merge!(other); end

  def symbolized_key_set(); end

  def to_hash(); end

  def update(obj); end

  def value?(value); end

  def values_at(*keys); end
end

class Faraday::Options
  def self.attribute_options(); end

  def self.fetch_error_class(); end

  def self.from(value); end

  def self.inherited(subclass); end

  def self.memoized(key, &block); end

  def self.memoized_attributes(); end

  def self.options(mapping); end

  def self.options_for(key); end
end

class Faraday::ParamPart
  def content_id(); end

  def content_type(); end

  def headers(); end

  def initialize(value, content_type, content_id=T.unsafe(nil)); end

  def to_part(boundary, key); end

  def value(); end
end

class Faraday::ParamPart
end

class Faraday::ParsingError
end

class Faraday::ParsingError
end

Faraday::Parts = Parts

class Faraday::ProxyAuthError
end

class Faraday::ProxyAuthError
end

class Faraday::ProxyOptions
  def host(*args, &block); end

  def host=(*args, &block); end

  def path(*args, &block); end

  def path=(*args, &block); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end
end

class Faraday::ProxyOptions
  extend ::Forwardable
end

class Faraday::RackBuilder
  def ==(other); end

  def [](idx); end

  def adapter(klass=T.unsafe(nil), *args, &block); end

  def app(); end

  def build(options=T.unsafe(nil)); end

  def build_env(connection, request); end

  def build_response(connection, request); end

  def delete(handler); end

  def handlers(); end

  def handlers=(handlers); end

  def initialize(handlers=T.unsafe(nil), adapter=T.unsafe(nil), &block); end

  def insert(index, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, *args, &block); end

  def lock!(); end

  def locked?(); end

  def request(key, *args, &block); end

  def response(key, *args, &block); end

  def swap(index, *args, &block); end

  def to_app(); end

  def use(klass, *args, &block); end
  LOCK_ERR = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
  def ==(other); end

  def build(app=T.unsafe(nil)); end

  def initialize(klass, *args, &block); end

  def klass(); end

  def name(); end
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder
end

class Faraday::Request
  def [](key); end

  def []=(key, value); end

  def headers=(hash); end

  def marshal_dump(); end

  def marshal_load(serialised); end

  def params=(hash); end

  def to_env(connection); end

  def url(path, params=T.unsafe(nil)); end
end

class Faraday::Request::Authorization
  def call(env); end

  def initialize(app, type, token); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

class Faraday::Request::Multipart
  def create_multipart(env, params); end

  def has_multipart?(obj); end

  def part(boundary, key, value); end

  def process_params(params, prefix=T.unsafe(nil), pieces=T.unsafe(nil), &block); end

  def unique_boundary(); end
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Multipart
end

class Faraday::Request::Retry
  def build_exception_matcher(exceptions); end

  def calculate_sleep_amount(retries, env); end

  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
end

class Faraday::Request::Retry
end

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  def call(env); end

  def match_content_type(env); end

  def process_request?(env); end

  def request_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::UrlEncoded
  def self.mime_type(); end

  def self.mime_type=(mime_type); end
end

class Faraday::Request
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
  def self.create(request_method); end
end

class Faraday::RequestOptions
  def []=(key, value); end

  def stream_response?(); end
end

class Faraday::RequestOptions
end

class Faraday::ResourceNotFound
end

class Faraday::ResourceNotFound
end

class Faraday::Response
  def [](*args, &block); end

  def apply_request(request_env); end

  def body(); end

  def env(); end

  def finish(env); end

  def finished?(); end

  def headers(); end

  def initialize(env=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(env); end

  def on_complete(&block); end

  def reason_phrase(); end

  def status(); end

  def success?(); end

  def to_hash(); end
end

class Faraday::Response::Logger
  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Faraday::Response::Logger
end

class Faraday::Response::Middleware
  def call(env); end

  def on_complete(env); end
end

class Faraday::Response::Middleware
end

class Faraday::Response::RaiseError
  def response_values(env); end
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
  ServerErrorStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::RaiseError
end

class Faraday::Response
  extend ::Forwardable
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
end

class Faraday::RetriableResponse
end

class Faraday::RetriableResponse
end

class Faraday::SSLError
end

class Faraday::SSLError
end

class Faraday::SSLOptions
  def disable?(); end

  def verify?(); end
end

class Faraday::SSLOptions
end

class Faraday::ServerError
end

class Faraday::ServerError
end

class Faraday::TimeoutError
  def initialize(exc=T.unsafe(nil), response=T.unsafe(nil)); end
end

class Faraday::TimeoutError
end

Faraday::Timer = Timeout

class Faraday::UnauthorizedError
end

class Faraday::UnauthorizedError
end

class Faraday::UnprocessableEntityError
end

class Faraday::UnprocessableEntityError
end

Faraday::UploadIO = UploadIO

module Faraday::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def [](key); end

  def []=(key, val); end

  def delete(key); end

  def fetch(key, *args, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(hash=T.unsafe(nil)); end

  def initialize_names(); end

  def key?(key); end

  def member?(key); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def parse(header_string); end

  def replace(other); end

  def update(other); end
  KeyMap = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def self.from(value); end
end

class Faraday::Utils::ParamsHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def include?(key); end

  def key?(key); end

  def member?(key); end

  def merge(params); end

  def merge!(params); end

  def merge_query(query, encoder=T.unsafe(nil)); end

  def replace(other); end

  def to_query(encoder=T.unsafe(nil)); end

  def update(params); end
end

class Faraday::Utils::ParamsHash
end

module Faraday::Utils
  def self.URI(url); end

  def self.build_nested_query(params); end

  def self.build_query(params); end

  def self.deep_merge(source, hash); end

  def self.deep_merge!(target, hash); end

  def self.default_params_encoder(); end

  def self.default_params_encoder=(default_params_encoder); end

  def self.default_space_encoding(); end

  def self.default_space_encoding=(default_space_encoding); end

  def self.default_uri_parser(); end

  def self.default_uri_parser=(parser); end

  def self.escape(str); end

  def self.normalize_path(url); end

  def self.parse_nested_query(query); end

  def self.parse_query(query); end

  def self.sort_query_params(query); end

  def self.unescape(str); end
end

module Faraday
  def self.default_adapter(); end

  def self.default_adapter=(adapter); end

  def self.default_connection(); end

  def self.default_connection=(default_connection); end

  def self.default_connection_options(); end

  def self.default_connection_options=(options); end

  def self.ignore_env_proxy(); end

  def self.ignore_env_proxy=(ignore_env_proxy); end

  def self.lib_path(); end

  def self.lib_path=(lib_path); end

  def self.new(url=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.require_lib(*libs); end

  def self.require_libs(*libs); end

  def self.respond_to_missing?(symbol, include_private=T.unsafe(nil)); end

  def self.root_path(); end

  def self.root_path=(root_path); end
end

class Fiber
  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end

  def self.yield(*_); end
end

class FieldType
  def after_add_for_allowable_field_types(); end

  def after_add_for_allowable_field_types=(after_add_for_allowable_field_types); end

  def after_add_for_allowable_field_types?(); end

  def after_add_for_field_values(); end

  def after_add_for_field_values=(after_add_for_field_values); end

  def after_add_for_field_values?(); end

  def after_remove_for_allowable_field_types(); end

  def after_remove_for_allowable_field_types=(after_remove_for_allowable_field_types); end

  def after_remove_for_allowable_field_types?(); end

  def after_remove_for_field_values(); end

  def after_remove_for_field_values=(after_remove_for_field_values); end

  def after_remove_for_field_values?(); end

  def autosave_associated_records_for_allowable_field_types(*args); end

  def autosave_associated_records_for_field_values(*args); end

  def autosave_associated_records_for_preferred_field_type(); end

  def autosave_associated_records_for_preferred_operation_type(); end

  def autosave_associated_records_for_sample_type(*args); end

  def before_add_for_allowable_field_types(); end

  def before_add_for_allowable_field_types=(before_add_for_allowable_field_types); end

  def before_add_for_allowable_field_types?(); end

  def before_add_for_field_values(); end

  def before_add_for_field_values=(before_add_for_field_values); end

  def before_add_for_field_values?(); end

  def before_remove_for_allowable_field_types(); end

  def before_remove_for_allowable_field_types=(before_remove_for_allowable_field_types); end

  def before_remove_for_allowable_field_types?(); end

  def before_remove_for_field_values(); end

  def before_remove_for_field_values=(before_remove_for_field_values); end

  def before_remove_for_field_values?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_allowable_field_types(*args); end

  def validate_associated_records_for_field_values(*args); end
end

class FieldType::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class FieldType::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class FieldType::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module FieldType::GeneratedAssociationMethods
  def allowable_field_type_ids(); end

  def allowable_field_type_ids=(ids); end

  def build_preferred_field_type(*args, &block); end

  def build_preferred_operation_type(*args, &block); end

  def build_sample_type(*args, &block); end

  def create_preferred_field_type(*args, &block); end

  def create_preferred_field_type!(*args, &block); end

  def create_preferred_operation_type(*args, &block); end

  def create_preferred_operation_type!(*args, &block); end

  def create_sample_type(*args, &block); end

  def create_sample_type!(*args, &block); end

  def field_value_ids(); end

  def field_value_ids=(ids); end

  def preferred_field_type(*args); end

  def preferred_field_type=(value); end

  def preferred_operation_type(*args); end

  def preferred_operation_type=(value); end

  def sample_type(*args); end

  def sample_type=(value); end
end

class FieldType
  def self.after_add_for_allowable_field_types(); end

  def self.after_add_for_allowable_field_types=(val); end

  def self.after_add_for_allowable_field_types?(); end

  def self.after_add_for_field_values(); end

  def self.after_add_for_field_values=(val); end

  def self.after_add_for_field_values?(); end

  def self.after_remove_for_allowable_field_types(); end

  def self.after_remove_for_allowable_field_types=(val); end

  def self.after_remove_for_allowable_field_types?(); end

  def self.after_remove_for_field_values(); end

  def self.after_remove_for_field_values=(val); end

  def self.after_remove_for_field_values?(); end

  def self.before_add_for_allowable_field_types(); end

  def self.before_add_for_allowable_field_types=(val); end

  def self.before_add_for_allowable_field_types?(); end

  def self.before_add_for_field_values(); end

  def self.before_add_for_field_values=(val); end

  def self.before_add_for_field_values?(); end

  def self.before_remove_for_allowable_field_types(); end

  def self.before_remove_for_allowable_field_types=(val); end

  def self.before_remove_for_allowable_field_types?(); end

  def self.before_remove_for_field_values(); end

  def self.before_remove_for_field_values=(val); end

  def self.before_remove_for_field_values?(); end
end

class FieldValue
  def after_add_for_predecessors(); end

  def after_add_for_predecessors=(after_add_for_predecessors); end

  def after_add_for_predecessors?(); end

  def after_add_for_successors(); end

  def after_add_for_successors=(after_add_for_successors); end

  def after_add_for_successors?(); end

  def after_add_for_wires(); end

  def after_add_for_wires=(after_add_for_wires); end

  def after_add_for_wires?(); end

  def after_add_for_wires_as_dest(); end

  def after_add_for_wires_as_dest=(after_add_for_wires_as_dest); end

  def after_add_for_wires_as_dest?(); end

  def after_add_for_wires_as_source(); end

  def after_add_for_wires_as_source=(after_add_for_wires_as_source); end

  def after_add_for_wires_as_source?(); end

  def after_remove_for_predecessors(); end

  def after_remove_for_predecessors=(after_remove_for_predecessors); end

  def after_remove_for_predecessors?(); end

  def after_remove_for_successors(); end

  def after_remove_for_successors=(after_remove_for_successors); end

  def after_remove_for_successors?(); end

  def after_remove_for_wires(); end

  def after_remove_for_wires=(after_remove_for_wires); end

  def after_remove_for_wires?(); end

  def after_remove_for_wires_as_dest(); end

  def after_remove_for_wires_as_dest=(after_remove_for_wires_as_dest); end

  def after_remove_for_wires_as_dest?(); end

  def after_remove_for_wires_as_source(); end

  def after_remove_for_wires_as_source=(after_remove_for_wires_as_source); end

  def after_remove_for_wires_as_source?(); end

  def autosave_associated_records_for_allowable_field_type(*args); end

  def autosave_associated_records_for_child_item(*args); end

  def autosave_associated_records_for_child_sample(*args); end

  def autosave_associated_records_for_field_type(*args); end

  def autosave_associated_records_for_predecessors(*args); end

  def autosave_associated_records_for_successors(*args); end

  def autosave_associated_records_for_wires(*args); end

  def autosave_associated_records_for_wires_as_dest(*args); end

  def autosave_associated_records_for_wires_as_source(*args); end

  def before_add_for_predecessors(); end

  def before_add_for_predecessors=(before_add_for_predecessors); end

  def before_add_for_predecessors?(); end

  def before_add_for_successors(); end

  def before_add_for_successors=(before_add_for_successors); end

  def before_add_for_successors?(); end

  def before_add_for_wires(); end

  def before_add_for_wires=(before_add_for_wires); end

  def before_add_for_wires?(); end

  def before_add_for_wires_as_dest(); end

  def before_add_for_wires_as_dest=(before_add_for_wires_as_dest); end

  def before_add_for_wires_as_dest?(); end

  def before_add_for_wires_as_source(); end

  def before_add_for_wires_as_source=(before_add_for_wires_as_source); end

  def before_add_for_wires_as_source?(); end

  def before_remove_for_predecessors(); end

  def before_remove_for_predecessors=(before_remove_for_predecessors); end

  def before_remove_for_predecessors?(); end

  def before_remove_for_successors(); end

  def before_remove_for_successors=(before_remove_for_successors); end

  def before_remove_for_successors?(); end

  def before_remove_for_wires(); end

  def before_remove_for_wires=(before_remove_for_wires); end

  def before_remove_for_wires?(); end

  def before_remove_for_wires_as_dest(); end

  def before_remove_for_wires_as_dest=(before_remove_for_wires_as_dest); end

  def before_remove_for_wires_as_dest?(); end

  def before_remove_for_wires_as_source(); end

  def before_remove_for_wires_as_source=(before_remove_for_wires_as_source); end

  def before_remove_for_wires_as_source?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_predecessors(*args); end

  def validate_associated_records_for_successors(*args); end

  def validate_associated_records_for_wires(*args); end

  def validate_associated_records_for_wires_as_dest(*args); end

  def validate_associated_records_for_wires_as_source(*args); end
end

class FieldValue::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class FieldValue::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class FieldValue::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module FieldValue::GeneratedAssociationMethods
  def build_allowable_field_type(*args, &block); end

  def build_child_item(*args, &block); end

  def build_child_sample(*args, &block); end

  def build_field_type(*args, &block); end

  def create_allowable_field_type(*args, &block); end

  def create_allowable_field_type!(*args, &block); end

  def create_child_item(*args, &block); end

  def create_child_item!(*args, &block); end

  def create_child_sample(*args, &block); end

  def create_child_sample!(*args, &block); end

  def create_field_type(*args, &block); end

  def create_field_type!(*args, &block); end

  def predecessor_ids(); end

  def predecessor_ids=(ids); end

  def successor_ids(); end

  def successor_ids=(ids); end

  def wire_ids(); end

  def wire_ids=(ids); end

  def wires_as_dest_ids(); end

  def wires_as_dest_ids=(ids); end

  def wires_as_source_ids(); end

  def wires_as_source_ids=(ids); end
end

class FieldValue
  def self.after_add_for_predecessors(); end

  def self.after_add_for_predecessors=(val); end

  def self.after_add_for_predecessors?(); end

  def self.after_add_for_successors(); end

  def self.after_add_for_successors=(val); end

  def self.after_add_for_successors?(); end

  def self.after_add_for_wires(); end

  def self.after_add_for_wires=(val); end

  def self.after_add_for_wires?(); end

  def self.after_add_for_wires_as_dest(); end

  def self.after_add_for_wires_as_dest=(val); end

  def self.after_add_for_wires_as_dest?(); end

  def self.after_add_for_wires_as_source(); end

  def self.after_add_for_wires_as_source=(val); end

  def self.after_add_for_wires_as_source?(); end

  def self.after_remove_for_predecessors(); end

  def self.after_remove_for_predecessors=(val); end

  def self.after_remove_for_predecessors?(); end

  def self.after_remove_for_successors(); end

  def self.after_remove_for_successors=(val); end

  def self.after_remove_for_successors?(); end

  def self.after_remove_for_wires(); end

  def self.after_remove_for_wires=(val); end

  def self.after_remove_for_wires?(); end

  def self.after_remove_for_wires_as_dest(); end

  def self.after_remove_for_wires_as_dest=(val); end

  def self.after_remove_for_wires_as_dest?(); end

  def self.after_remove_for_wires_as_source(); end

  def self.after_remove_for_wires_as_source=(val); end

  def self.after_remove_for_wires_as_source?(); end

  def self.before_add_for_predecessors(); end

  def self.before_add_for_predecessors=(val); end

  def self.before_add_for_predecessors?(); end

  def self.before_add_for_successors(); end

  def self.before_add_for_successors=(val); end

  def self.before_add_for_successors?(); end

  def self.before_add_for_wires(); end

  def self.before_add_for_wires=(val); end

  def self.before_add_for_wires?(); end

  def self.before_add_for_wires_as_dest(); end

  def self.before_add_for_wires_as_dest=(val); end

  def self.before_add_for_wires_as_dest?(); end

  def self.before_add_for_wires_as_source(); end

  def self.before_add_for_wires_as_source=(val); end

  def self.before_add_for_wires_as_source?(); end

  def self.before_remove_for_predecessors(); end

  def self.before_remove_for_predecessors=(val); end

  def self.before_remove_for_predecessors?(); end

  def self.before_remove_for_successors(); end

  def self.before_remove_for_successors=(val); end

  def self.before_remove_for_successors?(); end

  def self.before_remove_for_wires(); end

  def self.before_remove_for_wires=(val); end

  def self.before_remove_for_wires?(); end

  def self.before_remove_for_wires_as_dest(); end

  def self.before_remove_for_wires_as_dest=(val); end

  def self.before_remove_for_wires_as_dest?(); end

  def self.before_remove_for_wires_as_source(); end

  def self.before_remove_for_wires_as_source=(val); end

  def self.before_remove_for_wires_as_source?(); end
end

module FieldValuePlanner
  extend ::ActiveSupport::Concern
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.cleanpath(path, rel_root=T.unsafe(nil)); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.open!(file, *args, &block); end

  def self.probe_stat_in(dir); end

  def self.read_binary(file); end

  def self.relative_path(from, to); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, **options, &block); end

  def safe_ln(*args, **options); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

module Find
end

module Find
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  def to_d(precision=T.unsafe(nil)); end

  def to_default_s(); end

  def to_json(options=T.unsafe(nil)); end
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def self._deprecated_default_specifications_dir(); end
end

Gem::Cache = Gem::SourceIndex

class Gem::Command
  def check_deprecated_options(options); end

  def deprecate_option(name, version: T.unsafe(nil), extra_msg: T.unsafe(nil)); end

end

class Gem::Dependency
  def identity(); end
end

class Gem::DependencyInstaller
  def _deprecated_available_set_for(dep_or_name, version); end

  def _deprecated_find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def _deprecated_find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end
end

class Gem::Installer
  def _deprecated_unpack(directory); end

  def package(); end
end

class Gem::Package
  def gem(); end
end

class Gem::Package::TarHeader
  def self.oct_or_256based(str); end
end

class Gem::Package
  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::RemoteFetcher
  include ::Gem::UriParsing
  def _deprecated_fetch_size(uri); end

  def s3_uri_signer(uri); end
end

class Gem::RemoteFetcher
  extend ::Gem::Deprecate
end

class Gem::Requirement
  DefaultPrereleaseRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement
  def self.default_prerelease(); end
end

class Gem::Resolver::ActivationRequest
  def platform(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::S3URISigner
  def initialize(uri); end

  def sign(expiration=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
  EC2_IAM_INFO = ::T.let(nil, ::T.untyped)
  EC2_IAM_SECURITY_CREDENTIALS = ::T.let(nil, ::T.untyped)
end

class Gem::S3URISigner::ConfigurationError
  def initialize(message); end
end

class Gem::S3URISigner::ConfigurationError
end

class Gem::S3URISigner::InstanceProfileError
  def initialize(message); end
end

class Gem::S3URISigner::InstanceProfileError
end

class Gem::S3URISigner::S3Config
  def access_key_id(); end

  def access_key_id=(_); end

  def region(); end

  def region=(_); end

  def secret_access_key(); end

  def secret_access_key=(_); end

  def security_token(); end

  def security_token=(_); end
end

class Gem::S3URISigner::S3Config
  def self.[](*_); end

  def self.members(); end
end

class Gem::S3URISigner
end

class Gem::Source
  include ::Gem::Text
  def typo_squatting?(host, distance_threshold=T.unsafe(nil)); end
end

class Gem::SourceIndex
  include ::Enumerable
  def ==(other); end

  def add_spec(gem_spec, name=T.unsafe(nil)); end

  def add_specs(*gem_specs); end

  def all_gems(); end

  def dump(); end

  def each(&block); end

  def find_name(gem_name, requirement=T.unsafe(nil)); end

  def gem_signature(gem_full_name); end

  def gems(); end

  def index_signature(); end

  def initialize(specifications=T.unsafe(nil)); end

  def latest_specs(include_prerelease=T.unsafe(nil)); end

  def length(); end

  def load_gems_in(*spec_dirs); end

  def outdated(); end

  def prerelease_gems(); end

  def prerelease_specs(); end

  def refresh!(); end

  def released_gems(); end

  def released_specs(); end

  def remove_spec(full_name); end

  def search(gem_pattern, platform_only=T.unsafe(nil)); end

  def size(); end

  def spec_dirs(); end

  def spec_dirs=(spec_dirs); end

  def specification(full_name); end
end

class Gem::SourceIndex
  def self.from_gems_in(*spec_dirs); end

  def self.from_installed_gems(*deprecated); end

  def self.installed_spec_directories(); end

  def self.load_specification(file_name); end
end

class Gem::Specification
  def _deprecated_rubyforge_project=(_deprecated_rubyforge_project); end
  LOAD_CACHE_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Enumerable
  def self.default_stubs(pattern=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
end

class Gem::UriParser
  def parse(uri); end

  def parse!(uri); end
end

class Gem::UriParser
end

module Gem::UriParsing
end

module Gem::UriParsing
end

module Gem::Util
  def self.correct_for_windows_path(path); end
end

module Gem
  def self.add_to_load_path(*paths); end

  def self.default_specifications_dir(); end

  def self.java_platform?(); end

  def self.source_date_epoch(); end

  def self.source_date_epoch_string(); end

  def self.source_index(); end

  def self.suffix_regexp(); end
end

class GlobalID
  def ==(other); end

  def app(*args, &block); end

  def eql?(other); end

  def find(options=T.unsafe(nil)); end

  def initialize(gid, options=T.unsafe(nil)); end

  def model_class(); end

  def model_id(*args, &block); end

  def model_name(*args, &block); end

  def params(*args, &block); end

  def to_s(*args, &block); end

  def uri(); end
end

module GlobalID::Identification
  def to_gid(options=T.unsafe(nil)); end

  def to_gid_param(options=T.unsafe(nil)); end

  def to_global_id(options=T.unsafe(nil)); end

  def to_sgid(options=T.unsafe(nil)); end

  def to_sgid_param(options=T.unsafe(nil)); end

  def to_signed_global_id(options=T.unsafe(nil)); end
end

module GlobalID::Identification
  extend ::ActiveSupport::Concern
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class GlobalID::Railtie
end

class GlobalID::Railtie
end

class GlobalID::Verifier
end

class GlobalID::Verifier
end

class GlobalID
  extend ::ActiveSupport::Autoload
  def self.app(); end

  def self.app=(app); end

  def self.create(model, options=T.unsafe(nil)); end

  def self.find(gid, options=T.unsafe(nil)); end

  def self.parse(gid, options=T.unsafe(nil)); end
end

class Group
  def after_add_for_memberships(); end

  def after_add_for_memberships=(after_add_for_memberships); end

  def after_add_for_memberships?(); end

  def after_remove_for_memberships(); end

  def after_remove_for_memberships=(after_remove_for_memberships); end

  def after_remove_for_memberships?(); end

  def autosave_associated_records_for_memberships(*args); end

  def before_add_for_memberships(); end

  def before_add_for_memberships=(before_add_for_memberships); end

  def before_add_for_memberships?(); end

  def before_remove_for_memberships(); end

  def before_remove_for_memberships=(before_remove_for_memberships); end

  def before_remove_for_memberships?(); end

  def validate_associated_records_for_memberships(*args); end
end

class Group::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Group::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Group::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Group::GeneratedAssociationMethods
  def membership_ids(); end

  def membership_ids=(ids); end
end

class Group
  def self.after_add_for_memberships(); end

  def self.after_add_for_memberships=(val); end

  def self.after_add_for_memberships?(); end

  def self.after_remove_for_memberships(); end

  def self.after_remove_for_memberships=(val); end

  def self.after_remove_for_memberships?(); end

  def self.before_add_for_memberships(); end

  def self.before_add_for_memberships=(val); end

  def self.before_add_for_memberships?(); end

  def self.before_remove_for_memberships(); end

  def self.before_remove_for_memberships=(val); end

  def self.before_remove_for_memberships?(); end
end

module HTML
end

class HTML::CDATA
end

class HTML::CDATA
end

class HTML::Document
  def find(conditions); end

  def find_all(conditions); end

  def initialize(text, strict=T.unsafe(nil), xml=T.unsafe(nil)); end

  def root(); end
end

class HTML::Document
end

class HTML::FullSanitizer
end

class HTML::FullSanitizer
end

class HTML::LinkSanitizer
  def included_tags(); end
end

class HTML::LinkSanitizer
  def self.included_tags(); end

  def self.included_tags=(obj); end
end

class HTML::Node
  def ==(node); end

  def children(); end

  def find(conditions); end

  def find_all(conditions); end

  def initialize(parent, line=T.unsafe(nil), pos=T.unsafe(nil)); end

  def line(); end

  def match(conditions); end

  def parent(); end

  def position(); end

  def tag?(); end

  def validate_conditions(conditions); end
end

class HTML::Node
  def self.parse(parent, line, pos, content, strict=T.unsafe(nil)); end
end

class HTML::Sanitizer
  def process_node(node, result, options); end

  def sanitize(text, options=T.unsafe(nil)); end

  def sanitizeable?(text); end

  def tokenize(text, options); end

  def validate_options(options); end
end

class HTML::Sanitizer
end

class HTML::Selector
  def attribute_match(equality, value); end

  def initialize(selector, *values); end

  def match(element, first_only=T.unsafe(nil)); end

  def next_element(element, name=T.unsafe(nil)); end

  def next_selector(statement, values); end

  def nth_child(a, b, of_type, reverse); end

  def only_child(of_type); end

  def select(root); end

  def select_first(root); end

  def simple_selector(statement, values, can_negate=T.unsafe(nil)); end
end

class HTML::Selector::InvalidSelectorError
end

class HTML::Selector::InvalidSelectorError
end

class HTML::Selector
  def self.for_class(cls); end

  def self.for_id(id); end
end

class HTML::Tag
  def [](attr); end

  def attributes(); end

  def childless?(xml=T.unsafe(nil)); end

  def closing(); end

  def initialize(parent, line, pos, name, attributes, closing); end

  def name(); end

  def select(selector, *values); end
end

class HTML::Tag
end

class HTML::Text
  def content(); end

  def initialize(parent, line, pos, content); end
end

class HTML::Text
end

class HTML::Tokenizer
  def initialize(text); end

  def line(); end

  def next(); end

  def position(); end
end

class HTML::Tokenizer
end

module HTML::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module HTML::Version
end

class HTML::WhiteListSanitizer
  def allowed_attributes(); end

  def allowed_attributes?(); end

  def allowed_css_keywords(); end

  def allowed_css_keywords?(); end

  def allowed_css_properties(); end

  def allowed_css_properties?(); end

  def allowed_protocols(); end

  def allowed_protocols?(); end

  def allowed_tags(); end

  def allowed_tags?(); end

  def bad_tags(); end

  def bad_tags?(); end

  def contains_bad_protocols?(attr_name, value); end

  def process_attributes_for(node, options); end

  def protocol_separator(); end

  def protocol_separator?(); end

  def sanitize_css(style); end

  def shorthand_css_properties(); end

  def shorthand_css_properties?(); end

  def uri_attributes(); end

  def uri_attributes?(); end
end

class HTML::WhiteListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(val); end

  def self.allowed_attributes?(); end

  def self.allowed_css_keywords(); end

  def self.allowed_css_keywords=(val); end

  def self.allowed_css_keywords?(); end

  def self.allowed_css_properties(); end

  def self.allowed_css_properties=(val); end

  def self.allowed_css_properties?(); end

  def self.allowed_protocols(); end

  def self.allowed_protocols=(val); end

  def self.allowed_protocols?(); end

  def self.allowed_tags(); end

  def self.allowed_tags=(val); end

  def self.allowed_tags?(); end

  def self.bad_tags(); end

  def self.bad_tags=(val); end

  def self.bad_tags?(); end

  def self.protocol_separator(); end

  def self.protocol_separator=(val); end

  def self.protocol_separator?(); end

  def self.shorthand_css_properties(); end

  def self.shorthand_css_properties=(val); end

  def self.shorthand_css_properties?(); end

  def self.uri_attributes(); end

  def self.uri_attributes=(val); end

  def self.uri_attributes?(); end
end

module HTML
  extend ::ActiveSupport::Autoload
  def self.selector(statement, *values); end
end

class HTMLSelector
  def context(); end

  def initialize(values, previous_selection=T.unsafe(nil), &root_fallback); end

  def message(); end

  def select(); end

  def selector(); end

  def tests(); end
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

class HTMLSelector
  def self.context(); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def assert_valid_keys(*valid_keys); end

  def compact(); end

  def compact!(); end

  def deep_merge(other_hash, &block); end

  def deep_merge!(other_hash, &block); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def except(*keys); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def nested_under_indifferent_access(); end

  def replace(_); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def reverse_update(other_hash); end

  def slice(*keys); end

  def slice!(*keys); end

  def to_h(); end

  def to_json(options=T.unsafe(nil)); end

  def to_options!(); end

  def to_param(namespace=T.unsafe(nil)); end

  def to_proc(); end

  def to_query(namespace=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values!(); end

  def update(*_); end

  def with_indifferent_access(); end
  MERGER = ::T.let(nil, ::T.untyped)
end

class Hash
  def self.from_trusted_xml(xml); end

  def self.from_xml(xml, disallowed_types=T.unsafe(nil)); end

  def self.try_convert(_); end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

module I18n
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class I18n::ArgumentError
end

class I18n::ArgumentError
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def exists?(locale, key); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
  USE_INSPECT_HASH = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Cache
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def exists?(locale, key); end

  def initialize(*backends); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Base
  def available_locales(); end

  def available_locales=(value); end

  def available_locales_initialized?(); end

  def backend(); end

  def backend=(value); end

  def config(); end

  def config=(value); end

  def default_locale(); end

  def default_locale=(value); end

  def default_separator(); end

  def default_separator=(value); end

  def enforce_available_locales(); end

  def enforce_available_locales!(locale); end

  def enforce_available_locales=(value); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exists?(key, locale=T.unsafe(nil)); end

  def l(object, options=T.unsafe(nil)); end

  def load_path(); end

  def load_path=(value); end

  def locale(); end

  def locale=(value); end

  def locale_available?(locale); end

  def localize(object, options=T.unsafe(nil)); end

  def normalize_keys(locale, key, scope, separator=T.unsafe(nil)); end

  def reload!(); end

  def t(*args); end

  def t!(key, options=T.unsafe(nil)); end

  def translate(*args); end

  def translate!(key, options=T.unsafe(nil)); end

  def transliterate(*args); end

  def with_locale(tmp_locale=T.unsafe(nil)); end
end

module I18n::Base
end

class I18n::Config
  def available_locales(); end

  def available_locales=(locales); end

  def available_locales_initialized?(); end

  def available_locales_set(); end

  def backend(); end

  def backend=(backend); end

  def clear_available_locales_set(); end

  def default_locale(); end

  def default_locale=(locale); end

  def default_separator(); end

  def default_separator=(separator); end

  def enforce_available_locales(); end

  def enforce_available_locales=(enforce_available_locales); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def load_path(); end

  def load_path=(load_path); end

  def locale(); end

  def locale=(locale); end

  def missing_interpolation_argument_handler(); end

  def missing_interpolation_argument_handler=(exception_handler); end
end

class I18n::Config
end

class I18n::ExceptionHandler
end

class I18n::ExceptionHandler
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

class I18n::InvalidLocale
  def initialize(locale); end

  def locale(); end
end

class I18n::InvalidLocale
end

class I18n::InvalidLocaleData
  def filename(); end

  def initialize(filename, exception_message); end
end

class I18n::InvalidLocaleData
end

class I18n::InvalidPluralizationData
  def count(); end

  def entry(); end

  def initialize(entry, count, key); end

  def key(); end
end

class I18n::InvalidPluralizationData
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

class I18n::MissingInterpolationArgument
  def initialize(key, values, string); end

  def key(); end

  def string(); end

  def values(); end
end

class I18n::MissingInterpolationArgument
end

class I18n::MissingTranslation
  include ::I18n::MissingTranslation::Base
end

module I18n::MissingTranslation::Base
  def initialize(locale, key, options=T.unsafe(nil)); end

  def key(); end

  def keys(); end

  def locale(); end

  def message(); end

  def options(); end

  def to_exception(); end

  def to_s(); end
end

module I18n::MissingTranslation::Base
end

class I18n::MissingTranslation
end

class I18n::MissingTranslationData
  include ::I18n::MissingTranslation::Base
end

class I18n::MissingTranslationData
end

class I18n::Railtie
end

class I18n::Railtie
  def self.include_fallbacks_module(); end

  def self.init_fallbacks(fallbacks); end

  def self.initialize_i18n(app); end

  def self.validate_fallbacks(fallbacks); end
end

class I18n::ReservedInterpolationKey
  def initialize(key, string); end

  def key(); end

  def string(); end
end

class I18n::ReservedInterpolationKey
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

class I18n::UnknownFileType
  def filename(); end

  def initialize(type, filename); end

  def type(); end
end

class I18n::UnknownFileType
end

module I18n
  extend ::I18n::Base
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.interpolate(string, values); end

  def self.interpolate_hash(string, values); end

  def self.new_double_nested_cache(); end

  def self.perform_caching?(); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

module IPAddress
  def ipv4?(); end

  def ipv6?(); end
  AUTHORS = ::T.let(nil, ::T.untyped)
  GEM = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
end

class IPAddress::IPv4
  include ::IPAddress
  include ::Enumerable
  include ::Comparable
  def +(oth); end

  def -(oth); end

  def /(subnets=T.unsafe(nil)); end

  def [](index); end

  def []=(index, value); end

  def a?(); end

  def address(); end

  def arpa(); end

  def b?(); end

  def bits(); end

  def broadcast(); end

  def broadcast_u32(); end

  def c?(); end

  def data(); end

  def each(&blk); end

  def each_host(); end

  def first(); end

  def hex(space=T.unsafe(nil)); end

  def hosts(); end

  def include?(oth); end

  def include_all?(*others); end

  def initialize(str); end

  def last(); end

  def loopback?(); end

  def multicast?(); end

  def netmask(); end

  def netmask=(addr); end

  def network(); end

  def network?(); end

  def network_u32(); end

  def octet(index); end

  def octet=(index, value); end

  def octets(); end

  def prefix(); end

  def prefix=(num); end

  def private?(); end

  def reverse(); end

  def size(); end

  def split(subnets=T.unsafe(nil)); end

  def subnet(subprefix); end

  def supernet(new_prefix); end

  def to(e); end

  def to_h(space=T.unsafe(nil)); end

  def to_hex(space=T.unsafe(nil)); end

  def to_i(); end

  def to_ipv6(); end

  def to_string(); end

  def to_u32(); end

  def u32(); end
  CLASSFUL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class IPAddress::IPv4
  def self.extract(str); end

  def self.parse_classful(ip); end

  def self.parse_data(str, prefix=T.unsafe(nil)); end

  def self.parse_u32(u32, prefix=T.unsafe(nil)); end

  def self.summarize(*args); end
end

class IPAddress::IPv6
  include ::IPAddress
  include ::Enumerable
  include ::Comparable
  def [](index); end

  def []=(index, value); end

  def address(); end

  def arpa(); end

  def bits(); end

  def broadcast_u128(); end

  def compressed(); end

  def data(); end

  def each(&blk); end

  def group(index); end

  def group=(index, value); end

  def groups(); end

  def hexs(); end

  def include?(oth); end

  def initialize(str); end

  def literal(); end

  def loopback?(); end

  def mapped?(); end

  def network(); end

  def network?(); end

  def network_u128(); end

  def prefix(); end

  def prefix=(num); end

  def reverse(); end

  def size(); end

  def to_hex(); end

  def to_i(); end

  def to_string(); end

  def to_string_uncompressed(); end

  def to_u128(); end

  def unspecified?(); end
  IN6FORMAT = ::T.let(nil, ::T.untyped)
end

class IPAddress::IPv6::Loopback
  def initialize(); end
end

class IPAddress::IPv6::Loopback
end

class IPAddress::IPv6::Mapped
  def ipv4(); end
end

class IPAddress::IPv6::Mapped
end

class IPAddress::IPv6::Unspecified
  def initialize(); end
end

class IPAddress::IPv6::Unspecified
end

class IPAddress::IPv6
  def self.compress(str); end

  def self.expand(str); end

  def self.groups(str); end

  def self.parse_data(str); end

  def self.parse_hex(hex, prefix=T.unsafe(nil)); end

  def self.parse_u128(u128, prefix=T.unsafe(nil)); end
end

class IPAddress::Prefix
  include ::Comparable
  def +(oth); end

  def -(oth); end

  def initialize(num); end

  def prefix(); end

  def to_i(); end
end

class IPAddress::Prefix
end

class IPAddress::Prefix128
  def bits(); end

  def host_prefix(); end

  def initialize(num=T.unsafe(nil)); end

  def to_u128(); end
end

class IPAddress::Prefix128
end

class IPAddress::Prefix32
  def [](index); end

  def bits(); end

  def host_prefix(); end

  def hostmask(); end

  def octets(); end

  def to_ip(); end

  def to_u32(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
end

class IPAddress::Prefix32
  def self.parse_netmask(netmask); end
end

module IPAddress
  def self.deprecate(message=T.unsafe(nil)); end

  def self.ntoa(uint); end

  def self.parse(str); end

  def self.valid?(addr); end

  def self.valid_ipv4?(addr); end

  def self.valid_ipv4_netmask?(addr); end

  def self.valid_ipv6?(addr); end
end

module ITypeAssert
  def get_type(); end
end

module ITypeAssert
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Insertion
  def after(val, recursive=T.unsafe(nil)); end

  def after_any(val); end

  def before(val, recursive=T.unsafe(nil)); end

  def before_any(val); end

  def initialize(list, value); end
end

class Insertion
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def multiple_of?(number); end

  def nobits?(_); end

  def ordinal(); end

  def ordinalize(); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end

  def to_default_s(*_); end

  def to_json(options=T.unsafe(nil)); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.sqrt(_); end
end

class IntegerString
end

class IntegerString
  def self.===(other); end
end

module IntegerStringImpl
  def _is_a_integer_string?(); end

  def instance_of?(type); end

  def is_a?(type); end

  def kind_of?(type); end
end

module IntegerStringImpl
end

class Invoice
  def autosave_associated_records_for_budget(*args); end

  def autosave_associated_records_for_user(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class Invoice::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Invoice::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Invoice::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Invoice::GeneratedAssociationMethods
  def build_budget(*args, &block); end

  def build_user(*args, &block); end

  def create_budget(*args, &block); end

  def create_budget!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end
end

class Item
  def after_add_for_post_associations(); end

  def after_add_for_post_associations=(after_add_for_post_associations); end

  def after_add_for_post_associations?(); end

  def after_remove_for_post_associations(); end

  def after_remove_for_post_associations=(after_remove_for_post_associations); end

  def after_remove_for_post_associations?(); end

  def autosave_associated_records_for_locator(); end

  def autosave_associated_records_for_object_type(*args); end

  def autosave_associated_records_for_part(); end

  def autosave_associated_records_for_post_associations(*args); end

  def autosave_associated_records_for_sample(*args); end

  def before_add_for_post_associations(); end

  def before_add_for_post_associations=(before_add_for_post_associations); end

  def before_add_for_post_associations?(); end

  def before_remove_for_post_associations(); end

  def before_remove_for_post_associations=(before_remove_for_post_associations); end

  def before_remove_for_post_associations?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_object_type(*args); end

  def validate_associated_records_for_post_associations(*args); end

  def validate_associated_records_for_sample(*args); end
end

class Item::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Item::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Item::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Item::GeneratedAssociationMethods
  def build_locator(*args, &block); end

  def build_object_type(*args, &block); end

  def build_part(*args, &block); end

  def build_sample(*args, &block); end

  def create_locator(*args, &block); end

  def create_locator!(*args, &block); end

  def create_object_type(*args, &block); end

  def create_object_type!(*args, &block); end

  def create_part(*args, &block); end

  def create_part!(*args, &block); end

  def create_sample(*args, &block); end

  def create_sample!(*args, &block); end

  def object_type_attributes=(attributes); end

  def post_association_ids(); end

  def post_association_ids=(ids); end

  def post_associations(*args); end

  def post_associations=(value); end

  def sample(*args); end

  def sample=(value); end

  def sample_attributes=(attributes); end
end

class Item
  def self.after_add_for_post_associations(); end

  def self.after_add_for_post_associations=(val); end

  def self.after_add_for_post_associations?(); end

  def self.after_remove_for_post_associations(); end

  def self.after_remove_for_post_associations=(val); end

  def self.after_remove_for_post_associations?(); end

  def self.before_add_for_post_associations(); end

  def self.before_add_for_post_associations=(val); end

  def self.before_add_for_post_associations?(); end

  def self.before_remove_for_post_associations(); end

  def self.before_remove_for_post_associations=(val); end

  def self.before_remove_for_post_associations?(); end
end

module JMESPath
  VERSION = ::T.let(nil, ::T.untyped)
end

class JMESPath::CachingParser
  def initialize(options=T.unsafe(nil)); end

  def parse(expression); end
end

class JMESPath::CachingParser
end

module JMESPath::Errors
end

class JMESPath::Errors::Error
end

class JMESPath::Errors::Error
end

class JMESPath::Errors::InvalidArityError
end

class JMESPath::Errors::InvalidArityError
end

class JMESPath::Errors::InvalidTypeError
end

class JMESPath::Errors::InvalidTypeError
end

class JMESPath::Errors::InvalidValueError
end

class JMESPath::Errors::InvalidValueError
end

class JMESPath::Errors::RuntimeError
end

class JMESPath::Errors::RuntimeError
end

class JMESPath::Errors::SyntaxError
end

class JMESPath::Errors::SyntaxError
end

class JMESPath::Errors::UnknownFunctionError
end

class JMESPath::Errors::UnknownFunctionError
end

module JMESPath::Errors
end

class JMESPath::Lexer
  def tokenize(expression); end
  NUMBERS = ::T.let(nil, ::T.untyped)
  SIMPLE_TOKENS = ::T.let(nil, ::T.untyped)
  STATE_AND = ::T.let(nil, ::T.untyped)
  STATE_EQ = ::T.let(nil, ::T.untyped)
  STATE_GT = ::T.let(nil, ::T.untyped)
  STATE_IDENTIFIER = ::T.let(nil, ::T.untyped)
  STATE_JSON_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_LBRACKET = ::T.let(nil, ::T.untyped)
  STATE_LT = ::T.let(nil, ::T.untyped)
  STATE_NOT = ::T.let(nil, ::T.untyped)
  STATE_NUMBER = ::T.let(nil, ::T.untyped)
  STATE_PIPE = ::T.let(nil, ::T.untyped)
  STATE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  STATE_SINGLE_CHAR = ::T.let(nil, ::T.untyped)
  STATE_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TRANSLATION_TABLE = ::T.let(nil, ::T.untyped)
  T_AND = ::T.let(nil, ::T.untyped)
  T_COLON = ::T.let(nil, ::T.untyped)
  T_COMMA = ::T.let(nil, ::T.untyped)
  T_COMPARATOR = ::T.let(nil, ::T.untyped)
  T_CURRENT = ::T.let(nil, ::T.untyped)
  T_DOT = ::T.let(nil, ::T.untyped)
  T_EOF = ::T.let(nil, ::T.untyped)
  T_EXPREF = ::T.let(nil, ::T.untyped)
  T_FILTER = ::T.let(nil, ::T.untyped)
  T_FLATTEN = ::T.let(nil, ::T.untyped)
  T_IDENTIFIER = ::T.let(nil, ::T.untyped)
  T_LBRACE = ::T.let(nil, ::T.untyped)
  T_LBRACKET = ::T.let(nil, ::T.untyped)
  T_LITERAL = ::T.let(nil, ::T.untyped)
  T_LPAREN = ::T.let(nil, ::T.untyped)
  T_NOT = ::T.let(nil, ::T.untyped)
  T_NUMBER = ::T.let(nil, ::T.untyped)
  T_OR = ::T.let(nil, ::T.untyped)
  T_PIPE = ::T.let(nil, ::T.untyped)
  T_QUOTED_IDENTIFIER = ::T.let(nil, ::T.untyped)
  T_RBRACE = ::T.let(nil, ::T.untyped)
  T_RBRACKET = ::T.let(nil, ::T.untyped)
  T_RPAREN = ::T.let(nil, ::T.untyped)
  T_STAR = ::T.let(nil, ::T.untyped)
  T_UNKNOWN = ::T.let(nil, ::T.untyped)
  VALID_IDENTIFIERS = ::T.let(nil, ::T.untyped)
end

class JMESPath::Lexer::CharacterStream
  def current(); end

  def initialize(chars); end

  def next(); end

  def position(); end
end

class JMESPath::Lexer::CharacterStream
end

class JMESPath::Lexer
  def self.requires_wrapping?(); end
end

module JMESPath::Nodes
end

class JMESPath::Nodes::AbsFunction
end

class JMESPath::Nodes::AbsFunction
end

class JMESPath::Nodes::And
  def initialize(left, right); end
end

class JMESPath::Nodes::And
end

class JMESPath::Nodes::ArrayProjection
  def extract_targets(target); end

  def fast_instance(); end
end

class JMESPath::Nodes::ArrayProjection
end

class JMESPath::Nodes::AvgFunction
end

class JMESPath::Nodes::AvgFunction
end

class JMESPath::Nodes::CeilFunction
end

class JMESPath::Nodes::CeilFunction
end

class JMESPath::Nodes::Chain
  def initialize(children); end

  def optimize(); end

  def visit(value); end
end

class JMESPath::Nodes::Chain
end

class JMESPath::Nodes::ChainedField
  def initialize(keys); end

  def visit(obj); end
end

class JMESPath::Nodes::ChainedField
end

class JMESPath::Nodes::Comparator
  def initialize(left, right); end

  def left(); end

  def right(); end
end

class JMESPath::Nodes::Comparator
  def self.create(relation, left, right); end
end

class JMESPath::Nodes::ComparatorCondition
  def initialize(left, right, child); end
  COMPARATOR_TO_CONDITION = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::ComparatorCondition
end

module JMESPath::Nodes::Comparators
end

class JMESPath::Nodes::Comparators::Eq
end

class JMESPath::Nodes::Comparators::Eq
end

class JMESPath::Nodes::Comparators::Gt
end

class JMESPath::Nodes::Comparators::Gt
end

class JMESPath::Nodes::Comparators::Gte
end

class JMESPath::Nodes::Comparators::Gte
end

class JMESPath::Nodes::Comparators::Lt
end

class JMESPath::Nodes::Comparators::Lt
end

class JMESPath::Nodes::Comparators::Lte
end

class JMESPath::Nodes::Comparators::Lte
end

class JMESPath::Nodes::Comparators::Neq
end

class JMESPath::Nodes::Comparators::Neq
end

module JMESPath::Nodes::Comparators
end

module JMESPath::Nodes::CompareBy
  include ::JMESPath::Nodes::TypeChecker
  def compare_by(mode, *args); end
end

module JMESPath::Nodes::CompareBy
end

class JMESPath::Nodes::Condition
  def initialize(test, child); end
end

class JMESPath::Nodes::Condition
end

class JMESPath::Nodes::ContainsFunction
end

class JMESPath::Nodes::ContainsFunction
end

class JMESPath::Nodes::Current
end

class JMESPath::Nodes::Current
end

class JMESPath::Nodes::EndsWithFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::EndsWithFunction
end

class JMESPath::Nodes::EqCondition
end

class JMESPath::Nodes::EqCondition
end

class JMESPath::Nodes::Expression
  def eval(value); end

  def expression(); end

  def initialize(expression); end
end

class JMESPath::Nodes::Expression
end

class JMESPath::Nodes::FastArrayProjection
  include ::JMESPath::Nodes::FastProjector
end

class JMESPath::Nodes::FastArrayProjection
end

class JMESPath::Nodes::FastObjectProjection
  include ::JMESPath::Nodes::FastProjector
end

class JMESPath::Nodes::FastObjectProjection
end

module JMESPath::Nodes::FastProjector
  def visit(value); end
end

module JMESPath::Nodes::FastProjector
end

class JMESPath::Nodes::Field
  def chain(other); end

  def initialize(key); end

  def keys(); end
end

class JMESPath::Nodes::Field
end

class JMESPath::Nodes::Flatten
  def initialize(child); end
end

class JMESPath::Nodes::Flatten
end

class JMESPath::Nodes::FloorFunction
end

class JMESPath::Nodes::FloorFunction
end

class JMESPath::Nodes::Function
  def initialize(children, options=T.unsafe(nil)); end
  FUNCTIONS = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::Function::FunctionName
  def initialize(name); end

  def name(); end
end

class JMESPath::Nodes::Function::FunctionName
end

class JMESPath::Nodes::Function
  def self.create(name, children, options=T.unsafe(nil)); end
end

class JMESPath::Nodes::GtCondition
end

class JMESPath::Nodes::GtCondition
end

class JMESPath::Nodes::GteCondition
end

class JMESPath::Nodes::GteCondition
end

JMESPath::Nodes::Index = JMESPath::Nodes::Field

class JMESPath::Nodes::JoinFunction
end

class JMESPath::Nodes::JoinFunction
end

class JMESPath::Nodes::KeysFunction
end

class JMESPath::Nodes::KeysFunction
end

class JMESPath::Nodes::LengthFunction
end

class JMESPath::Nodes::LengthFunction
end

class JMESPath::Nodes::Literal
  def initialize(value); end

  def value(); end
end

class JMESPath::Nodes::Literal
end

class JMESPath::Nodes::LiteralRightEqCondition
end

class JMESPath::Nodes::LiteralRightEqCondition
end

class JMESPath::Nodes::LiteralRightNeqCondition
end

class JMESPath::Nodes::LiteralRightNeqCondition
end

class JMESPath::Nodes::LtCondition
end

class JMESPath::Nodes::LtCondition
end

class JMESPath::Nodes::LteCondition
end

class JMESPath::Nodes::LteCondition
end

class JMESPath::Nodes::Map
end

class JMESPath::Nodes::Map
end

class JMESPath::Nodes::MaxByFunction
  include ::JMESPath::Nodes::CompareBy
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::MaxByFunction
end

class JMESPath::Nodes::MaxFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::MaxFunction
end

class JMESPath::Nodes::MergeFunction
end

class JMESPath::Nodes::MergeFunction
end

class JMESPath::Nodes::MinByFunction
  include ::JMESPath::Nodes::CompareBy
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::MinByFunction
end

class JMESPath::Nodes::MinFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::MinFunction
end

class JMESPath::Nodes::MultiSelectHash
  def initialize(kv_pairs); end
end

class JMESPath::Nodes::MultiSelectHash::KeyValuePair
  def initialize(key, value); end

  def key(); end

  def optimize(); end

  def value(); end
end

class JMESPath::Nodes::MultiSelectHash::KeyValuePair
end

class JMESPath::Nodes::MultiSelectHash
end

class JMESPath::Nodes::MultiSelectList
  def initialize(children); end
end

class JMESPath::Nodes::MultiSelectList
end

class JMESPath::Nodes::NeqCondition
end

class JMESPath::Nodes::NeqCondition
end

class JMESPath::Nodes::Node
  def chains_with?(other); end

  def hash_like?(value); end

  def optimize(); end

  def visit(value); end
end

class JMESPath::Nodes::Node
end

class JMESPath::Nodes::Not
  def initialize(expression); end
end

class JMESPath::Nodes::Not
end

class JMESPath::Nodes::NotNullFunction
end

class JMESPath::Nodes::NotNullFunction
end

class JMESPath::Nodes::ObjectProjection
  def extract_targets(target); end

  def fast_instance(); end
end

class JMESPath::Nodes::ObjectProjection
end

class JMESPath::Nodes::Or
  def initialize(left, right); end
end

class JMESPath::Nodes::Or
end

JMESPath::Nodes::Pipe = JMESPath::Nodes::Subexpression

class JMESPath::Nodes::Projection
  def initialize(target, projection); end
end

class JMESPath::Nodes::Projection
end

class JMESPath::Nodes::ReverseFunction
end

class JMESPath::Nodes::ReverseFunction
end

class JMESPath::Nodes::SimpleSlice
  def initialize(start, stop); end
end

class JMESPath::Nodes::SimpleSlice
end

class JMESPath::Nodes::Slice
  def initialize(start, stop, step); end
end

class JMESPath::Nodes::Slice
end

class JMESPath::Nodes::SortByFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::SortByFunction
end

class JMESPath::Nodes::SortFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::SortFunction
end

class JMESPath::Nodes::StartsWithFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::StartsWithFunction
end

class JMESPath::Nodes::Subexpression
  def flatten(); end

  def initialize(left, right); end

  def left(); end

  def right(); end
end

class JMESPath::Nodes::Subexpression
end

class JMESPath::Nodes::SumFunction
end

class JMESPath::Nodes::SumFunction
end

class JMESPath::Nodes::ToArrayFunction
end

class JMESPath::Nodes::ToArrayFunction
end

class JMESPath::Nodes::ToNumberFunction
end

class JMESPath::Nodes::ToNumberFunction
end

class JMESPath::Nodes::ToStringFunction
end

class JMESPath::Nodes::ToStringFunction
end

module JMESPath::Nodes::TypeChecker
  def get_type(value); end
  ARRAY_TYPE = ::T.let(nil, ::T.untyped)
  BOOLEAN_TYPE = ::T.let(nil, ::T.untyped)
  EXPRESSION_TYPE = ::T.let(nil, ::T.untyped)
  NULL_TYPE = ::T.let(nil, ::T.untyped)
  NUMBER_TYPE = ::T.let(nil, ::T.untyped)
  OBJECT_TYPE = ::T.let(nil, ::T.untyped)
  STRING_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::TypeFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::TypeFunction
end

class JMESPath::Nodes::ValuesFunction
end

class JMESPath::Nodes::ValuesFunction
end

module JMESPath::Nodes
end

class JMESPath::Parser
  def initialize(options=T.unsafe(nil)); end

  def method_missing(method_name, *args); end

  def parse(expression); end
  AFTER_DOT = ::T.let(nil, ::T.untyped)
  COLON_RBRACKET = ::T.let(nil, ::T.untyped)
  CURRENT_NODE = ::T.let(nil, ::T.untyped)
  NUM_COLON_RBRACKET = ::T.let(nil, ::T.untyped)
end

class JMESPath::Parser
end

class JMESPath::Runtime
  def initialize(options=T.unsafe(nil)); end

  def parser(); end

  def search(expression, data); end
end

JMESPath::Runtime::DEFAULT_PARSER = JMESPath::CachingParser

class JMESPath::Runtime
end

class JMESPath::Token
  def initialize(type, value, position); end
  BINDING_POWER = ::T.let(nil, ::T.untyped)
  NULL_TOKEN = ::T.let(nil, ::T.untyped)
end

class JMESPath::Token
end

class JMESPath::TokenStream
  def expression(); end

  def initialize(expression, tokens); end

  def lookahead(count); end

  def next(options=T.unsafe(nil)); end

  def position(); end

  def token(); end
end

class JMESPath::TokenStream
end

module JMESPath::Util
end

module JMESPath::Util
  def self.falsey?(value); end
end

module JMESPath
  def self.load_json(path); end

  def self.search(expression, data, runtime_options=T.unsafe(nil)); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

module JaroWinkler
  VERSION = ::T.let(nil, ::T.untyped)
end

class JaroWinkler::Error
end

class JaroWinkler::Error
end

class JaroWinkler::InvalidWeightError
end

class JaroWinkler::InvalidWeightError
end

module JaroWinkler
  def self.distance(*_); end

  def self.jaro_distance(*_); end
end

class Job
  def after_add_for_job_associations(); end

  def after_add_for_job_associations=(after_add_for_job_associations); end

  def after_add_for_job_associations?(); end

  def after_add_for_logs(); end

  def after_add_for_logs=(after_add_for_logs); end

  def after_add_for_logs?(); end

  def after_add_for_post_associations(); end

  def after_add_for_post_associations=(after_add_for_post_associations); end

  def after_add_for_post_associations?(); end

  def after_add_for_predecessors(); end

  def after_add_for_predecessors=(after_add_for_predecessors); end

  def after_add_for_predecessors?(); end

  def after_add_for_uploads(); end

  def after_add_for_uploads=(after_add_for_uploads); end

  def after_add_for_uploads?(); end

  def after_remove_for_job_associations(); end

  def after_remove_for_job_associations=(after_remove_for_job_associations); end

  def after_remove_for_job_associations?(); end

  def after_remove_for_logs(); end

  def after_remove_for_logs=(after_remove_for_logs); end

  def after_remove_for_logs?(); end

  def after_remove_for_post_associations(); end

  def after_remove_for_post_associations=(after_remove_for_post_associations); end

  def after_remove_for_post_associations?(); end

  def after_remove_for_predecessors(); end

  def after_remove_for_predecessors=(after_remove_for_predecessors); end

  def after_remove_for_predecessors?(); end

  def after_remove_for_uploads(); end

  def after_remove_for_uploads=(after_remove_for_uploads); end

  def after_remove_for_uploads?(); end

  def autosave_associated_records_for_group(*args); end

  def autosave_associated_records_for_job_associations(*args); end

  def autosave_associated_records_for_logs(*args); end

  def autosave_associated_records_for_metacol(*args); end

  def autosave_associated_records_for_post_associations(*args); end

  def autosave_associated_records_for_predecessors(*args); end

  def autosave_associated_records_for_successor(*args); end

  def autosave_associated_records_for_uploads(*args); end

  def autosave_associated_records_for_user(*args); end

  def autosave_associated_records_for_workflow_process(*args); end

  def before_add_for_job_associations(); end

  def before_add_for_job_associations=(before_add_for_job_associations); end

  def before_add_for_job_associations?(); end

  def before_add_for_logs(); end

  def before_add_for_logs=(before_add_for_logs); end

  def before_add_for_logs?(); end

  def before_add_for_post_associations(); end

  def before_add_for_post_associations=(before_add_for_post_associations); end

  def before_add_for_post_associations?(); end

  def before_add_for_predecessors(); end

  def before_add_for_predecessors=(before_add_for_predecessors); end

  def before_add_for_predecessors?(); end

  def before_add_for_uploads(); end

  def before_add_for_uploads=(before_add_for_uploads); end

  def before_add_for_uploads?(); end

  def before_remove_for_job_associations(); end

  def before_remove_for_job_associations=(before_remove_for_job_associations); end

  def before_remove_for_job_associations?(); end

  def before_remove_for_logs(); end

  def before_remove_for_logs=(before_remove_for_logs); end

  def before_remove_for_logs?(); end

  def before_remove_for_post_associations(); end

  def before_remove_for_post_associations=(before_remove_for_post_associations); end

  def before_remove_for_post_associations?(); end

  def before_remove_for_predecessors(); end

  def before_remove_for_predecessors=(before_remove_for_predecessors); end

  def before_remove_for_predecessors?(); end

  def before_remove_for_uploads(); end

  def before_remove_for_uploads=(before_remove_for_uploads); end

  def before_remove_for_uploads?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_job_associations(*args); end

  def validate_associated_records_for_logs(*args); end

  def validate_associated_records_for_post_associations(*args); end

  def validate_associated_records_for_predecessors(*args); end

  def validate_associated_records_for_uploads(*args); end
end

class Job::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Job::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Job::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Job::GeneratedAssociationMethods
  def build_group(*args, &block); end

  def build_metacol(*args, &block); end

  def build_successor(*args, &block); end

  def build_user(*args, &block); end

  def build_workflow_process(*args, &block); end

  def create_group(*args, &block); end

  def create_group!(*args, &block); end

  def create_metacol(*args, &block); end

  def create_metacol!(*args, &block); end

  def create_successor(*args, &block); end

  def create_successor!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def create_workflow_process(*args, &block); end

  def create_workflow_process!(*args, &block); end

  def job_association_ids(); end

  def job_association_ids=(ids); end

  def log_ids(); end

  def log_ids=(ids); end

  def metacol(*args); end

  def metacol=(value); end

  def post_association_ids(); end

  def post_association_ids=(ids); end

  def post_associations(*args); end

  def post_associations=(value); end

  def predecessor_ids(); end

  def predecessor_ids=(ids); end

  def predecessors(*args); end

  def predecessors=(value); end

  def successor(*args); end

  def successor=(value); end

  def upload_ids(); end

  def upload_ids=(ids); end

  def uploads(*args); end

  def uploads=(value); end

  def user(*args); end

  def user=(value); end

  def workflow_process(*args); end

  def workflow_process=(value); end
end

class Job
  def self.after_add_for_job_associations(); end

  def self.after_add_for_job_associations=(val); end

  def self.after_add_for_job_associations?(); end

  def self.after_add_for_logs(); end

  def self.after_add_for_logs=(val); end

  def self.after_add_for_logs?(); end

  def self.after_add_for_post_associations(); end

  def self.after_add_for_post_associations=(val); end

  def self.after_add_for_post_associations?(); end

  def self.after_add_for_predecessors(); end

  def self.after_add_for_predecessors=(val); end

  def self.after_add_for_predecessors?(); end

  def self.after_add_for_uploads(); end

  def self.after_add_for_uploads=(val); end

  def self.after_add_for_uploads?(); end

  def self.after_remove_for_job_associations(); end

  def self.after_remove_for_job_associations=(val); end

  def self.after_remove_for_job_associations?(); end

  def self.after_remove_for_logs(); end

  def self.after_remove_for_logs=(val); end

  def self.after_remove_for_logs?(); end

  def self.after_remove_for_post_associations(); end

  def self.after_remove_for_post_associations=(val); end

  def self.after_remove_for_post_associations?(); end

  def self.after_remove_for_predecessors(); end

  def self.after_remove_for_predecessors=(val); end

  def self.after_remove_for_predecessors?(); end

  def self.after_remove_for_uploads(); end

  def self.after_remove_for_uploads=(val); end

  def self.after_remove_for_uploads?(); end

  def self.before_add_for_job_associations(); end

  def self.before_add_for_job_associations=(val); end

  def self.before_add_for_job_associations?(); end

  def self.before_add_for_logs(); end

  def self.before_add_for_logs=(val); end

  def self.before_add_for_logs?(); end

  def self.before_add_for_post_associations(); end

  def self.before_add_for_post_associations=(val); end

  def self.before_add_for_post_associations?(); end

  def self.before_add_for_predecessors(); end

  def self.before_add_for_predecessors=(val); end

  def self.before_add_for_predecessors?(); end

  def self.before_add_for_uploads(); end

  def self.before_add_for_uploads=(val); end

  def self.before_add_for_uploads?(); end

  def self.before_remove_for_job_associations(); end

  def self.before_remove_for_job_associations=(val); end

  def self.before_remove_for_job_associations?(); end

  def self.before_remove_for_logs(); end

  def self.before_remove_for_logs=(val); end

  def self.before_remove_for_logs?(); end

  def self.before_remove_for_post_associations(); end

  def self.before_remove_for_post_associations=(val); end

  def self.before_remove_for_post_associations?(); end

  def self.before_remove_for_predecessors(); end

  def self.before_remove_for_predecessors=(val); end

  def self.before_remove_for_predecessors?(); end

  def self.before_remove_for_uploads(); end

  def self.before_remove_for_uploads=(val); end

  def self.before_remove_for_uploads?(); end
end

class JobAssociation
  def autosave_associated_records_for_job(*args); end

  def autosave_associated_records_for_operation(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class JobAssociation::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class JobAssociation::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class JobAssociation::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module JobAssociation::GeneratedAssociationMethods
  def build_job(*args, &block); end

  def build_operation(*args, &block); end

  def create_job(*args, &block); end

  def create_job!(*args, &block); end

  def create_operation(*args, &block); end

  def create_operation!(*args, &block); end
end

module Kernel
  def capture(stream); end

  def class_eval(*args, &block); end

  def concern(topic, &module_definition); end

  def enable_warnings(); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def quietly(); end

  def silence(stream); end

  def silence_stderr(); end

  def silence_stream(stream); end

  def silence_warnings(); end

  def suppress(*exception_classes); end

  def suppress_warnings(); end

  def then(); end

  def with_warnings(flag); end

  def yield_self(); end
end

module Kernel
  def self.`(_); end

  def self.at_exit(); end

  def self.fail(*_); end

  def self.load(*_); end

  def self.require(_); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

class Krill::ShowResponse
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Library
  include ::Library::GeneratedAssociationMethods
end

class Library::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Library::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Library::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Library::GeneratedAssociationMethods
end

module Library::GeneratedAssociationMethods
end

class LoadError
  def is_missing?(location); end

  def path(); end
  REGEXPS = ::T.let(nil, ::T.untyped)
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Locator
  def autosave_associated_records_for_item(); end

  def autosave_associated_records_for_wizard(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class Locator::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Locator::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Locator::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Locator::GeneratedAssociationMethods
  def build_item(*args, &block); end

  def build_wizard(*args, &block); end

  def create_item(*args, &block); end

  def create_item!(*args, &block); end

  def create_wizard(*args, &block); end

  def create_wizard!(*args, &block); end
end

class Log
  def autosave_associated_records_for_user(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class Log::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Log::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Log::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Log::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module LoggerSilence
  def silence(temporary_level=T.unsafe(nil)); end
end

module LoggerSilence
  extend ::ActiveSupport::Concern
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::DocumentDecorator
  def initialize(*args, &block); end
end

module Loofah::DocumentDecorator
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
end

module Loofah::HTML
end

class Loofah::HTML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::Document
end

class Loofah::HTML::DocumentFragment
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::DocumentFragment
end

module Loofah::HTML
end

module Loofah::HTML5
end

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::SafeList
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  def self.allowed_element?(element_name); end

  def self.force_correct_attribute_escaping!(node); end

  def self.scrub_attributes(node); end

  def self.scrub_css(style); end

  def self.scrub_css_attribute(node); end
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::HTML5
end

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

module Loofah::LibxmlWorkarounds
end

module Loofah::MetaHelpers
end

module Loofah::MetaHelpers
  def self.add_downcased_set_members_to_all_set_constants(mojule); end
end

module Loofah::ScrubBehavior
end

module Loofah::ScrubBehavior::Node
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::Node
end

module Loofah::ScrubBehavior::NodeSet
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::NodeSet
end

module Loofah::ScrubBehavior
  def self.resolve_scrubber(scrubber); end
end

class Loofah::Scrubber
  def append_attribute(node, attribute, value); end

  def block(); end

  def direction(); end

  def initialize(options=T.unsafe(nil), &block); end

  def scrub(node); end

  def traverse(node); end
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
end

class Loofah::ScrubberNotFound
end

class Loofah::ScrubberNotFound
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubbers::Escape
  def initialize(); end
end

class Loofah::Scrubbers::Escape
end

class Loofah::Scrubbers::NewlineBlockElements
  def initialize(); end
end

class Loofah::Scrubbers::NewlineBlockElements
end

class Loofah::Scrubbers::NoFollow
  def initialize(); end
end

class Loofah::Scrubbers::NoFollow
end

class Loofah::Scrubbers::NoOpener
  def initialize(); end
end

class Loofah::Scrubbers::NoOpener
end

class Loofah::Scrubbers::Prune
  def initialize(); end
end

class Loofah::Scrubbers::Prune
end

class Loofah::Scrubbers::Strip
  def initialize(); end
end

class Loofah::Scrubbers::Strip
end

class Loofah::Scrubbers::Unprintable
  def initialize(); end
end

class Loofah::Scrubbers::Unprintable
end

class Loofah::Scrubbers::Whitewash
  def initialize(); end
end

class Loofah::Scrubbers::Whitewash
end

module Loofah::Scrubbers
  def self.scrubber_symbols(); end
end

module Loofah::TextBehavior
  def inner_text(options=T.unsafe(nil)); end

  def text(options=T.unsafe(nil)); end

  def to_str(options=T.unsafe(nil)); end

  def to_text(options=T.unsafe(nil)); end
end

module Loofah::TextBehavior
end

module Loofah::XML
end

class Loofah::XML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
end

class Loofah::XML::Document
end

class Loofah::XML::DocumentFragment
end

class Loofah::XML::DocumentFragment
end

module Loofah::XML
end

module Loofah
  def self.document(*args, &block); end

  def self.fragment(*args, &block); end

  def self.remove_extraneous_whitespace(string); end

  def self.scrub_document(string_or_io, method); end

  def self.scrub_fragment(string_or_io, method); end

  def self.scrub_xml_document(string_or_io, method); end

  def self.scrub_xml_fragment(string_or_io, method); end

  def self.xml_document(*args, &block); end

  def self.xml_fragment(*args, &block); end
end

module MIME
end

class MIME::Type
  include ::Comparable
  def add_extensions(*extensions); end

  def ascii?(); end

  def binary?(); end

  def complete?(); end

  def content_type(); end

  def default_encoding(); end

  def docs(); end

  def docs=(docs); end

  def encode_with(coder); end

  def encoding(); end

  def encoding=(enc); end

  def eql?(other); end

  def extensions(); end

  def extensions=(value); end

  def friendly(lang=T.unsafe(nil)); end

  def i18n_key(); end

  def init_with(coder); end

  def initialize(content_type); end

  def like?(other); end

  def media_type(); end

  def obsolete(); end

  def obsolete=(obsolete); end

  def obsolete?(); end

  def preferred_extension(); end

  def preferred_extension=(value); end

  def priority_compare(other); end

  def raw_media_type(); end

  def raw_sub_type(); end

  def registered(); end

  def registered=(registered); end

  def registered?(); end

  def signature(); end

  def signature=(signature); end

  def signature?(); end

  def simplified(); end

  def sub_type(); end

  def to_h(); end

  def to_json(*args); end

  def to_str(); end

  def use_instead(); end

  def use_instead=(use_instead); end

  def xref_urls(); end

  def xrefs(); end

  def xrefs=(xrefs); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Type::Columnar
  def docs(*args); end

  def docs=(*args); end

  def encoding(*args); end

  def encoding=(*args); end

  def friendly(*args); end

  def initialize(container, content_type, extensions); end

  def obsolete(*args); end

  def obsolete=(*args); end

  def obsolete?(*args); end

  def preferred_extension(*args); end

  def preferred_extension=(*args); end

  def registered(*args); end

  def registered=(*args); end

  def registered?(*args); end

  def signature(*args); end

  def signature=(*args); end

  def signature?(*args); end

  def use_instead(*args); end

  def use_instead=(*args); end

  def xref_urls(*args); end

  def xrefs(*args); end

  def xrefs=(*args); end
end

class MIME::Type::Columnar
end

class MIME::Type::InvalidContentType
  def initialize(type_string); end
end

class MIME::Type::InvalidContentType
end

class MIME::Type::InvalidEncoding
  def initialize(encoding); end
end

class MIME::Type::InvalidEncoding
end

class MIME::Type
  def self.i18n_key(content_type); end

  def self.match(content_type); end

  def self.simplified(content_type, remove_x_prefix: T.unsafe(nil)); end
end

class MIME::Types
  include ::Enumerable
  def [](type_id, complete: T.unsafe(nil), registered: T.unsafe(nil)); end

  def add(*types); end

  def add_type(type, quiet=T.unsafe(nil)); end

  def count(); end

  def each(&blk); end

  def of(filename); end

  def type_for(filename); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Types::Cache
  def data(); end

  def data=(_); end

  def version(); end

  def version=(_); end
end

class MIME::Types::Cache
  def self.[](*_); end

  def self.load(cache_file=T.unsafe(nil)); end

  def self.members(); end

  def self.save(types=T.unsafe(nil), cache_file=T.unsafe(nil)); end
end

module MIME::Types::Columnar
  def load_base_data(path); end
  LOAD_MUTEX = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Columnar
  def self.extended(obj); end
end

class MIME::Types::Container
  def ==(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def container(); end

  def container=(container); end

  def count(*args, &block); end

  def each(*args, &block); end

  def each_value(*args, &block); end

  def empty?(*args, &block); end

  def encode_with(coder); end

  def flat_map(*args, &block); end

  def init_with(coder); end

  def initialize(hash=T.unsafe(nil)); end

  def keys(*args, &block); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def merge(other); end

  def merge!(other); end

  def normalize(); end

  def select(*args, &block); end

  def to_hash(); end

  def values(*args, &block); end
end

class MIME::Types::Container
  extend ::Forwardable
end

module MIME::Types::Data
  PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Data
end

class MIME::Types::Loader
  def container(); end

  def initialize(path=T.unsafe(nil), container=T.unsafe(nil)); end

  def load(options=T.unsafe(nil)); end

  def load_columnar(); end

  def load_json(); end

  def load_yaml(); end

  def path(); end
end

class MIME::Types::Loader
  def self.load(options=T.unsafe(nil)); end

  def self.load_from_json(filename); end

  def self.load_from_yaml(filename); end
end

class MIME::Types::WarnLogger
  def initialize(_one, _two=T.unsafe(nil), _three=T.unsafe(nil)); end
end

class MIME::Types::WarnLogger::WarnLogDevice
  def initialize(*_); end

  def write(m); end
end

class MIME::Types::WarnLogger::WarnLogDevice
end

class MIME::Types::WarnLogger
end

class MIME::Types
  extend ::Enumerable
  def self.[](type_id, complete: T.unsafe(nil), registered: T.unsafe(nil)); end

  def self.add(*types); end

  def self.count(); end

  def self.each(&blk); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.of(filename); end

  def self.type_for(filename); end
end

module MIME
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::Address
  include ::Mail::Utilities
  include ::Mail::Constants
  def address(output_type=T.unsafe(nil)); end

  def address=(value); end

  def comments(); end

  def decoded(); end

  def display_name(output_type=T.unsafe(nil)); end

  def display_name=(str); end

  def domain(output_type=T.unsafe(nil)); end

  def encoded(); end

  def format(output_type=T.unsafe(nil)); end

  def group(); end

  def initialize(value=T.unsafe(nil)); end

  def local(output_type=T.unsafe(nil)); end

  def name(); end

  def raw(); end
end

class Mail::Address
end

class Mail::AddressContainer
  def <<(address); end

  def initialize(field, list=T.unsafe(nil)); end
end

class Mail::AddressContainer
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::AddressList
end

class Mail::AttachmentsList
  def [](index_value); end

  def []=(name, value); end

  def guess_encoding(); end

  def initialize(parts_list); end

  def inline(); end

  def set_mime_type(filename); end
end

class Mail::AttachmentsList
end

class Mail::BccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def include_in_headers(); end

  def include_in_headers=(include_in_headers); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::BccField
end

class Mail::Body
  def <<(val); end

  def ==(other); end

  def =~(regexp); end

  def ascii_only?(); end

  def boundary(); end

  def boundary=(val); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def default_encoding(); end

  def empty?(); end

  def encoded(transfer_encoding=T.unsafe(nil)); end

  def encoding(val=T.unsafe(nil)); end

  def encoding=(val); end

  def epilogue(); end

  def epilogue=(val); end

  def include?(other); end

  def initialize(string=T.unsafe(nil)); end

  def match(regexp); end

  def multipart?(); end

  def negotiate_best_encoding(message_encoding, allowed_encodings=T.unsafe(nil)); end

  def parts(); end

  def preamble(); end

  def preamble=(val); end

  def raw_source(); end

  def set_sort_order(order); end

  def sort_parts!(); end

  def split!(boundary); end
end

class Mail::Body
end

class Mail::CcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
end

module Mail::CheckDeliveryParams
end

module Mail::CheckDeliveryParams
  def self.check(mail); end

  def self.check_addr(addr_name, addr); end

  def self.check_from(addr); end

  def self.check_message(message); end

  def self.check_to(addrs); end

  def self.validate_smtp_addr(addr); end
end

class Mail::CommentsField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
end

module Mail::CommonAddress
  def <<(val); end

  def addresses(); end

  def addrs(); end

  def charset(); end

  def decoded_group_addresses(); end

  def default(); end

  def display_names(); end

  def each(&blk); end

  def encode_if_needed(val); end

  def encoded_group_addresses(); end

  def formatted(); end

  def group_addresses(); end

  def group_names(); end

  def groups(); end

  def parse(val=T.unsafe(nil)); end

  def value=(val); end
end

module Mail::CommonAddress
end

module Mail::CommonDate
  def date_time(); end

  def default(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonDate
end

module Mail::CommonField
  include ::Mail::Constants
  def default(); end

  def field_length(); end

  def name(); end

  def name=(value); end

  def responsible_for?(val); end

  def to_s(); end

  def value(); end

  def value=(value); end
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
end

module Mail::CommonMessageId
  def default(); end

  def element(); end

  def message_id(); end

  def message_ids(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonMessageId
end

class Mail::Configuration
  include ::Singleton
  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def lookup_delivery_method(method); end

  def lookup_retriever_method(method); end

  def param_encode_language(value=T.unsafe(nil)); end

  def retriever_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end
end

class Mail::Configuration
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
end

class Mail::ContentDescriptionField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  def decoded(); end

  def disposition_type(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionField
end

class Mail::ContentIdField
  def content_id(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def location(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationField
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  def decoded(); end

  def element(); end

  def encoded(); end

  def encoding(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingField
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  def attempt_to_clean(); end

  def content_type(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def main_type(); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end

  def string(); end

  def stringify(params); end

  def sub_type(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  def self.generate_boundary(); end

  def self.with_boundary(type); end
end

class Mail::DateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
end

class Mail::DateTimeElement
  def date_string(); end

  def initialize(string); end

  def time_string(); end
end

class Mail::DateTimeElement
end

module Mail::Encodings
  include ::Mail::Constants
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
end

class Mail::Encodings::Identity
end

class Mail::Encodings::Identity
  def self.decode(str); end

  def self.encode(str); end
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  def self.can_encode?(enc); end

  def self.can_transport?(enc); end

  def self.compatible_input?(str); end

  def self.cost(str); end

  def self.lowest_cost(str, encodings); end

  def self.negotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end

  def self.renegotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  def self.decode(str); end

  def self.encode(str); end
end

module Mail::Encodings
  extend ::Mail::Utilities
  extend ::Mail::Constants
  def self.address_encode(address, charset=T.unsafe(nil)); end

  def self.b_value_decode(str); end

  def self.b_value_encode(string, encoding=T.unsafe(nil)); end

  def self.collapse_adjacent_encodings(str); end

  def self.decode_encode(str, output_type); end

  def self.defined?(name); end

  def self.each_base64_chunk_byterange(str, max_bytesize_per_base64_chunk, &block); end

  def self.each_chunk_byterange(str, max_bytesize_per_chunk); end

  def self.encode_non_usascii(address, charset); end

  def self.find_encoding(str); end

  def self.get_all(); end

  def self.get_encoding(name); end

  def self.get_name(name); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.q_value_decode(str); end

  def self.q_value_encode(encoded_str, encoding=T.unsafe(nil)); end

  def self.register(name, cls); end

  def self.transcode_charset(str, from_charset, to_charset=T.unsafe(nil)); end

  def self.unquote_and_convert_to(str, to_encoding); end

  def self.value_decode(str); end

  def self.value_encoding_from_string(str); end

  def self.with_ascii_kcode(); end
end

class Mail::Envelope
  def date(); end

  def element(); end

  def from(); end

  def initialize(*args); end
end

class Mail::Envelope
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Comparable
  def ==(other); end

  def field(); end

  def field=(value); end

  def field_order_id(); end

  def initialize(name, value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def name(); end

  def responsible_for?(val); end

  def same(other); end

  def unparsed_value(); end

  def update(name, value); end

  def value(); end

  def value=(val); end
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Field::FieldError
end

class Mail::Field::FieldError
end

class Mail::Field::IncompleteParseError
  def initialize(element, original_text, unparsed_index); end
end

class Mail::Field::IncompleteParseError
end

class Mail::Field::NilParseError
  def initialize(element); end
end

class Mail::Field::NilParseError
end

class Mail::Field::ParseError
  def element(); end

  def element=(element); end

  def initialize(element, value, reason); end

  def reason(); end

  def reason=(reason); end

  def value(); end

  def value=(value); end
end

class Mail::Field::ParseError
end

class Mail::Field::SyntaxError
end

class Mail::Field::SyntaxError
end

class Mail::Field
  def self.parse(field, charset=T.unsafe(nil)); end

  def self.split(raw_field); end
end

class Mail::FieldList
  def <<(new_field); end
end

class Mail::FieldList
end

class Mail::FileDelivery
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::FileDelivery
end

class Mail::FromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
end

class Mail::Header
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Enumerable
  def [](name); end

  def []=(name, value); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def field_summary(); end

  def fields(); end

  def fields=(unfolded_fields); end

  def has_content_id?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def initialize(header_text=T.unsafe(nil), charset=T.unsafe(nil)); end

  def raw_source(); end
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  def self.maximum_amount(); end

  def self.maximum_amount=(value); end
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::InReplyToField
end

class Mail::IndifferentHash
  def []=(key, value); end

  def convert_key(key); end

  def convert_value(value); end

  def default(key=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, *extras); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash); end

  def merge!(other_hash); end

  def regular_update(*_); end

  def regular_writer(_, _1); end

  def store(key, value); end

  def update(other_hash); end

  def values_at(*indices); end
end

class Mail::IndifferentHash
  def self.new_from_hash_copying_default(hash); end
end

class Mail::KeywordsField
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def keywords(); end

  def parse(val=T.unsafe(nil)); end

  def phrase_list(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
end

class Mail::LoggerDelivery
  include ::Mail::CheckDeliveryParams
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

module Mail::Matchers
  def an_attachment_with_filename(filename); end

  def any_attachment(); end

  def have_sent_email(); end
end

class Mail::Matchers::AnyAttachmentMatcher
  def ===(other); end
end

class Mail::Matchers::AnyAttachmentMatcher
end

class Mail::Matchers::AttachmentFilenameMatcher
  def ===(other); end

  def filename(); end

  def initialize(filename); end
end

class Mail::Matchers::AttachmentFilenameMatcher
end

class Mail::Matchers::HasSentEmailMatcher
  def bcc(recipient_or_list); end

  def cc(recipient_or_list); end

  def description(); end

  def dump_deliveries(); end

  def explain_expectations(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def filter_matched_deliveries(deliveries); end

  def from(sender); end

  def initialize(_context); end

  def matches?(subject); end

  def matches_on_attachments?(delivery); end

  def matches_on_blind_copy_recipients?(delivery); end

  def matches_on_body?(delivery); end

  def matches_on_body_matcher?(delivery); end

  def matches_on_copy_recipients?(delivery); end

  def matches_on_having_attachments?(delivery); end

  def matches_on_html_part_body?(delivery); end

  def matches_on_recipients?(delivery); end

  def matches_on_sender?(delivery); end

  def matches_on_subject?(delivery); end

  def matches_on_subject_matcher?(delivery); end

  def matches_on_text_part_body?(delivery); end

  def matching_body(body_matcher); end

  def matching_subject(subject_matcher); end

  def to(recipient_or_list); end

  def with_any_attachments(); end

  def with_attachments(attachments); end

  def with_body(body); end

  def with_html(body); end

  def with_no_attachments(); end

  def with_subject(subject); end

  def with_text(body); end
end

class Mail::Matchers::HasSentEmailMatcher
end

module Mail::Matchers
end

class Mail::Message
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def action(); end

  def add_charset(); end

  def add_content_transfer_encoding(); end

  def add_content_type(); end

  def add_date(date_val=T.unsafe(nil)); end

  def add_file(values); end

  def add_message_id(msg_id_val=T.unsafe(nil)); end

  def add_mime_version(ver_val=T.unsafe(nil)); end

  def add_part(part); end

  def add_transfer_encoding(); end

  def all_parts(); end

  def attachment(); end

  def attachment?(); end

  def attachments(); end

  def bcc(val=T.unsafe(nil)); end

  def bcc=(val); end

  def bcc_addrs(); end

  def body(value=T.unsafe(nil)); end

  def body=(value); end

  def body_encoding(value=T.unsafe(nil)); end

  def body_encoding=(value); end

  def bounced?(); end

  def boundary(); end

  def cc(val=T.unsafe(nil)); end

  def cc=(val); end

  def cc_addrs(); end

  def charset(); end

  def charset=(value); end

  def comments(val=T.unsafe(nil)); end

  def comments=(val); end

  def content_description(val=T.unsafe(nil)); end

  def content_description=(val); end

  def content_disposition(val=T.unsafe(nil)); end

  def content_disposition=(val); end

  def content_id(val=T.unsafe(nil)); end

  def content_id=(val); end

  def content_location(val=T.unsafe(nil)); end

  def content_location=(val); end

  def content_transfer_encoding(val=T.unsafe(nil)); end

  def content_transfer_encoding=(val); end

  def content_type(val=T.unsafe(nil)); end

  def content_type=(val); end

  def content_type_parameters(); end

  def convert_to_multipart(); end

  def date(val=T.unsafe(nil)); end

  def date=(val); end

  def decode_body(); end

  def decoded(); end

  def default(sym, val=T.unsafe(nil)); end

  def deliver(); end

  def deliver!(); end

  def delivery_handler(); end

  def delivery_handler=(delivery_handler); end

  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def delivery_status_part(); end

  def delivery_status_report?(); end

  def destinations(); end

  def diagnostic_code(); end

  def encode!(); end

  def encoded(); end

  def envelope_date(); end

  def envelope_from(); end

  def error_status(); end

  def errors(); end

  def filename(); end

  def final_recipient(); end

  def find_first_mime_type(mt); end

  def from(val=T.unsafe(nil)); end

  def from=(val); end

  def from_addrs(); end

  def has_attachments?(); end

  def has_charset?(); end

  def has_content_transfer_encoding?(); end

  def has_content_type?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def has_transfer_encoding?(); end

  def header(value=T.unsafe(nil)); end

  def header=(value); end

  def header_fields(); end

  def headers(hash=T.unsafe(nil)); end

  def html_part(&block); end

  def html_part=(msg); end

  def in_reply_to(val=T.unsafe(nil)); end

  def in_reply_to=(val); end

  def inform_interceptors(); end

  def inform_observers(); end

  def initialize(*args, &block); end

  def is_marked_for_delete?(); end

  def keywords(val=T.unsafe(nil)); end

  def keywords=(val); end

  def main_type(); end

  def mark_for_delete=(value=T.unsafe(nil)); end

  def message_content_type(); end

  def message_id(val=T.unsafe(nil)); end

  def message_id=(val); end

  def method_missing(name, *args, &block); end

  def mime_parameters(); end

  def mime_type(); end

  def mime_version(val=T.unsafe(nil)); end

  def mime_version=(val); end

  def multipart?(); end

  def multipart_report?(); end

  def part(params=T.unsafe(nil)); end

  def parts(); end

  def perform_deliveries(); end

  def perform_deliveries=(perform_deliveries); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(raise_delivery_errors); end

  def raw_envelope(); end

  def raw_source(); end

  def read(); end

  def ready_to_send!(); end

  def received(val=T.unsafe(nil)); end

  def received=(val); end

  def references(val=T.unsafe(nil)); end

  def references=(val); end

  def register_for_delivery_notification(observer); end

  def remote_mta(); end

  def reply(*args, &block); end

  def reply_to(val=T.unsafe(nil)); end

  def reply_to=(val); end

  def resent_bcc(val=T.unsafe(nil)); end

  def resent_bcc=(val); end

  def resent_cc(val=T.unsafe(nil)); end

  def resent_cc=(val); end

  def resent_date(val=T.unsafe(nil)); end

  def resent_date=(val); end

  def resent_from(val=T.unsafe(nil)); end

  def resent_from=(val); end

  def resent_message_id(val=T.unsafe(nil)); end

  def resent_message_id=(val); end

  def resent_sender(val=T.unsafe(nil)); end

  def resent_sender=(val); end

  def resent_to(val=T.unsafe(nil)); end

  def resent_to=(val); end

  def retryable?(); end

  def return_path(val=T.unsafe(nil)); end

  def return_path=(val); end

  def sender(val=T.unsafe(nil)); end

  def sender=(val); end

  def set_envelope(val); end

  def skip_deletion(); end

  def smtp_envelope_from(val=T.unsafe(nil)); end

  def smtp_envelope_from=(val); end

  def smtp_envelope_to(val=T.unsafe(nil)); end

  def smtp_envelope_to=(val); end

  def sub_type(); end

  def subject(val=T.unsafe(nil)); end

  def subject=(val); end

  def text?(); end

  def text_part(&block); end

  def text_part=(msg); end

  def to(val=T.unsafe(nil)); end

  def to=(val); end

  def to_addrs(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def transfer_encoding(); end

  def transport_encoding(val=T.unsafe(nil)); end

  def transport_encoding=(val); end

  def without_attachments!(); end
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  def self.default_charset(); end

  def self.default_charset=(charset); end

  def self.from_hash(hash); end

  def self.from_yaml(str); end
end

class Mail::MessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def major(); end

  def minor(); end

  def parse(val=T.unsafe(nil)); end

  def version(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MimeVersionField
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Chars
  include ::Comparable
  def =~(other); end

  def [](*args); end

  def []=(*args); end

  def acts_like_string?(); end

  def capitalize(); end

  def capitalize!(*args); end

  def chars(string); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def g_length(); end

  def initialize(string); end

  def justify(integer, way, padstr=T.unsafe(nil)); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def padding(padsize, padstr=T.unsafe(nil)); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def translate_offset(byte_offset); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class Mail::Multibyte::Chars
  def self.consumes?(string); end
end

class Mail::Multibyte::EncodingError
end

class Mail::Multibyte::EncodingError
end

module Mail::Multibyte::Unicode
  def apply_mapping(string, mapping); end

  def compose_codepoints(codepoints); end

  def decompose_codepoints(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def g_pack(unpacked); end

  def g_unpack(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def reorder_characters(codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def u_unpack(string); end
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class Mail::Multibyte::Unicode::Codepoint
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module Mail::Multibyte::Unicode
  extend ::Mail::Multibyte::Unicode
  def self.codepoints_to_pattern(array_of_codepoints); end
end

module Mail::Multibyte
  def self.clean(string); end

  def self.mb_chars(str); end

  def self.proxy_class(); end

  def self.proxy_class=(proxy_class); end

  def self.valid_character(); end

  def self.verify(string); end

  def self.verify!(string); end
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

class Mail::ParameterHash
  include ::Mail::Utilities
  include ::Mail::Constants
  def [](key_name); end

  def decoded(); end

  def encoded(); end
end

class Mail::ParameterHash
end

module Mail::Parsers
end

module Mail::Parsers::AddressListsParser
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def addresses(); end

  def addresses=(_); end

  def error(); end

  def error=(_); end

  def group_names(); end

  def group_names=(_); end
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def comments(); end

  def comments=(_); end

  def display_name(); end

  def display_name=(_); end

  def domain(); end

  def domain=(_); end

  def error(); end

  def error=(_); end

  def group(); end

  def group=(_); end

  def local(); end

  def local=(_); end

  def obs_domain_list(); end

  def obs_domain_list=(_); end

  def raw(); end

  def raw=(_); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::AddressListsParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentDispositionParser
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def disposition_type(); end

  def disposition_type=(_); end

  def error(); end

  def error=(_); end

  def parameters(); end

  def parameters=(_); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentDispositionParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentLocationParser
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def error(); end

  def error=(_); end

  def location(); end

  def location=(_); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentLocationParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTransferEncodingParser
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def encoding(); end

  def encoding=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTransferEncodingParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTypeParser
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def error(); end

  def error=(_); end

  def main_type(); end

  def main_type=(_); end

  def parameters(); end

  def parameters=(_); end

  def sub_type(); end

  def sub_type=(_); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTypeParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::DateTimeParser
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def date_string(); end

  def date_string=(_); end

  def error(); end

  def error=(_); end

  def time_string(); end

  def time_string=(_); end
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::DateTimeParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::EnvelopeFromParser
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def address(); end

  def address=(_); end

  def ctime_date(); end

  def ctime_date=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::EnvelopeFromParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MessageIdsParser
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def error(); end

  def error=(_); end

  def message_ids(); end

  def message_ids=(_); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MessageIdsParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MimeVersionParser
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def error(); end

  def error=(_); end

  def major(); end

  def major=(_); end

  def minor(); end

  def minor=(_); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MimeVersionParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::Parsers::PhraseListsParser
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def error(); end

  def error=(_); end

  def phrases(); end

  def phrases=(_); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ReceivedParser
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def date(); end

  def date=(_); end

  def error(); end

  def error=(_); end

  def info(); end

  def info=(_); end

  def time(); end

  def time=(_); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ReceivedParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers
end

class Mail::Part
  def add_content_id(content_id_val=T.unsafe(nil)); end

  def cid(); end

  def delivery_status_data(); end

  def delivery_status_report_part?(); end

  def has_content_id?(); end

  def inline?(); end

  def inline_content_id(); end

  def url(); end
end

class Mail::Part
end

class Mail::PartsList
  def attachments(); end

  def collect(); end

  def collect!(); end

  def encode_with(coder); end

  def initialize(*args); end

  def map(); end

  def map!(); end

  def parts(); end

  def sort(); end

  def sort!(order); end

  def to_yaml(options=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mail::PartsList
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  include ::Mail::Utilities
  include ::Mail::Constants
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  def date_time(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def formatted_date(); end

  def info(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReceivedField
end

class Mail::ReferencesField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
end

class Mail::ReplyToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
end

class Mail::ResentBccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
end

class Mail::ResentCcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
end

class Mail::ResentDateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
end

class Mail::ResentFromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
end

class Mail::ResentMessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
end

class Mail::ResentSenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
end

class Mail::ResentToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
end

class Mail::Retriever
  def all(options=T.unsafe(nil), &block); end

  def find_and_delete(options=T.unsafe(nil), &block); end

  def first(options=T.unsafe(nil), &block); end

  def last(options=T.unsafe(nil), &block); end
end

class Mail::Retriever
end

class Mail::ReturnPathField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
end

class Mail::Ruby19
end

class Mail::Ruby19::BestEffortCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::BestEffortCharsetEncoder
end

class Mail::Ruby19::StrictCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::StrictCharsetEncoder
end

class Mail::Ruby19
  def self.b_value_decode(str); end

  def self.b_value_encode(str, encoding=T.unsafe(nil)); end

  def self.bracket(str); end

  def self.charset_encoder(); end

  def self.charset_encoder=(charset_encoder); end

  def self.decode_base64(str); end

  def self.decode_utf7(utf7); end

  def self.encode_base64(str); end

  def self.encode_utf7(string); end

  def self.escape_bracket(str); end

  def self.escape_paren(str); end

  def self.get_constant(klass, string); end

  def self.has_constant?(klass, string); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.paren(str); end

  def self.pick_encoding(charset); end

  def self.q_value_decode(str); end

  def self.q_value_encode(str, encoding=T.unsafe(nil)); end

  def self.string_byteslice(str, *args); end

  def self.transcode_charset(str, from_encoding, to_encoding=T.unsafe(nil)); end

  def self.uri_parser(); end
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTP
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SenderField
end

class Mail::Sendmail
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  def self.call(path, arguments, destinations, encoded_message); end

  def self.popen(command, &block); end

  def self.shellquote(address); end
end

class Mail::StructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(val); end

  def errors(); end

  def initialize(name=T.unsafe(nil), value=T.unsafe(nil), charset=T.unsafe(nil)); end
end

class Mail::StructuredField
end

class Mail::SubjectField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
end

class Mail::TestMailer
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::TestMailer
  def self.deliveries(); end

  def self.deliveries=(val); end
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ToField
end

class Mail::UnknownEncodingType
end

class Mail::UnknownEncodingType
end

class Mail::UnstructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(charset); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def initialize(name, value, charset=T.unsafe(nil)); end

  def parse(); end
end

class Mail::UnstructuredField
end

module Mail::Utilities
  include ::Mail::Constants
  def atom_safe?(str); end

  def bracket(str); end

  def capitalize_field(str); end

  def constantize(str); end

  def dasherize(str); end

  def dquote(str); end

  def escape_paren(str); end

  def map_lines(str, &block); end

  def map_with_index(enum, &block); end

  def match_to_s(obj1, obj2); end

  def paren(str); end

  def quote_atom(str); end

  def quote_phrase(str); end

  def quote_token(str); end

  def token_safe?(str); end

  def unbracket(str); end

  def underscoreize(str); end

  def unparen(str); end

  def uri_escape(str); end

  def uri_parser(); end

  def uri_unescape(str); end
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  def self.binary_unsafe_to_crlf(string); end

  def self.binary_unsafe_to_lf(string); end

  def self.blank?(value); end

  def self.safe_for_line_ending_conversion?(string); end

  def self.to_crlf(string); end

  def self.to_lf(string); end

  def self.unescape(str); end

  def self.unquote(str); end
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  def self.version(); end
end

module Mail
  def self.all(*args, &block); end

  def self.connection(&block); end

  def self.defaults(&block); end

  def self.delete_all(*args, &block); end

  def self.deliver(*args, &block); end

  def self.delivery_method(); end

  def self.eager_autoload!(); end

  def self.find(*args, &block); end

  def self.find_and_delete(*args, &block); end

  def self.first(*args, &block); end

  def self.inform_interceptors(mail); end

  def self.inform_observers(mail); end

  def self.last(*args, &block); end

  def self.new(*args, &block); end

  def self.random_tag(); end

  def self.read(filename); end

  def self.read_from_string(mail_as_string); end

  def self.register_autoload(name, path); end

  def self.register_interceptor(interceptor); end

  def self.register_observer(observer); end

  def self.retriever_method(); end

  def self.something_random(); end

  def self.uniq(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_observer(observer); end
end

Markdown = RedcarpetCompat

module Marshal
  def self.load_with_autoloading(source, proc=T.unsafe(nil)); end

  def self.load_without_autoloading(*_); end

  def self.restore(*_); end
end

class Membership
  def autosave_associated_records_for_group(*args); end

  def autosave_associated_records_for_user(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class Membership::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Membership::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Membership::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Membership::GeneratedAssociationMethods
  def build_group(*args, &block); end

  def build_user(*args, &block); end

  def create_group(*args, &block); end

  def create_group!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end
end

Methods = T::Private::Methods

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  ATOM = ::T.let(nil, ::T.untyped)
  BMP = ::T.let(nil, ::T.untyped)
  CSS = ::T.let(nil, ::T.untyped)
  CSV = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  GIF = ::T.let(nil, ::T.untyped)
  HTML = ::T.let(nil, ::T.untyped)
  ICS = ::T.let(nil, ::T.untyped)
  JPEG = ::T.let(nil, ::T.untyped)
  JS = ::T.let(nil, ::T.untyped)
  JSON = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  MPEG = ::T.let(nil, ::T.untyped)
  MULTIPART_FORM = ::T.let(nil, ::T.untyped)
  PDF = ::T.let(nil, ::T.untyped)
  PNG = ::T.let(nil, ::T.untyped)
  RSS = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TIFF = ::T.let(nil, ::T.untyped)
  URL_ENCODED_FORM = ::T.let(nil, ::T.untyped)
  VCF = ::T.let(nil, ::T.untyped)
  WEB_CONSOLE_V2 = ::T.let(nil, ::T.untyped)
  XML = ::T.let(nil, ::T.untyped)
  YAML = ::T.let(nil, ::T.untyped)
  ZIP = ::T.let(nil, ::T.untyped)
end

class Mime::Mimes
  def <<(*_); end

  def clear(*_); end

  def collect!(*_); end

  def compact!(*_); end

  def delete(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def map!(*_); end

  def reject!(*_); end

  def replace(*_); end

  def reverse!(*_); end

  def sort!(*_); end

  def symbols(); end

  def uniq!(*_); end
end

class Mime::Mimes
end

class Mime::NullType
  include ::Singleton
  def ref(); end
end

class Mime::NullType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def eql?(other); end

  def html?(); end

  def html_types(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
end

class Mime::Type::AcceptItem
  def ==(item); end

  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptItem
end

class Mime::Type::AcceptList
  def assort!(); end
end

class Mime::Type::AcceptList
end

class Mime::Type
  def self.html_types(); end

  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(input); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  def self.[](type); end

  def self.fetch(type); end
end

class MimeMagic
  def ==(other); end

  def audio?(); end

  def child_of?(parent); end

  def comment(); end

  def eql?(other); end

  def extensions(); end

  def image?(); end

  def initialize(type); end

  def mediatype(); end

  def subtype(); end

  def text?(); end

  def type(); end

  def video?(); end
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  MAGIC = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MimeMagic
  def self.add(type, options); end

  def self.all_by_magic(io); end

  def self.by_extension(ext); end

  def self.by_magic(io); end

  def self.by_path(path); end

  def self.child?(child, parent); end

  def self.remove(type); end
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

module MiniMime::Configuration
end

module MiniMime::Configuration
  def self.content_type_db_path(); end

  def self.content_type_db_path=(content_type_db_path); end

  def self.ext_db_path(); end

  def self.ext_db_path=(ext_db_path); end
end

class MiniMime::Db
  def lookup_by_content_type(content_type); end

  def lookup_by_extension(extension); end
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::Cache
  def []=(key, val); end

  def fetch(key, &blk); end

  def initialize(size); end
end

class MiniMime::Db::Cache
end

class MiniMime::Db::RandomAccessDb
  def initialize(path, sort_order); end

  def lookup(val); end

  def lookup_uncached(val); end

  def resolve(row); end
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
end

class MiniMime::Db
  def self.lookup_by_content_type(content_type); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class MiniMime::Info
  def [](idx); end

  def binary?(); end

  def content_type(); end

  def content_type=(content_type); end

  def encoding(); end

  def encoding=(encoding); end

  def extension(); end

  def extension=(extension); end

  def initialize(buffer); end
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
end

module MiniMime
  def self.lookup_by_content_type(mime); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

MiniTest = Minitest

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Minitest::AbstractReporter
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
end

class Minitest::Assertion
end

module Minitest::Assertions
  def _synchronize(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

class Minitest::CompositeReporter
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

module Minitest::Parallel
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class Minitest::Parallel::Executor
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Parallel::Test::ClassMethods
end

module Minitest::Parallel::Test
end

module Minitest::Parallel
end

class Minitest::ProgressReporter
end

class Minitest::ProgressReporter
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Reporter
end

class Minitest::Result
  include ::Minitest::Reportable
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Skip
end

class Minitest::Skip
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end
end

class Minitest::StatisticsReporter
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::SummaryReporter
end

class Minitest::Test
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  def capture_exceptions(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
end

class Minitest::UnexpectedError
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit::TestCase
end

class Minitest::Unit::TestCase
end

class Minitest::Unit
  def self.after_tests(&b); end

  def self.autorun(); end
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.clock_time(); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run_one_method(klass, method_name); end
end

MissingSourceFile = LoadError

class Module
  include ::Module::Concerning
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  def alias_attribute(new_name, old_name); end

  def alias_method_chain(target, feature); end

  def anonymous?(); end

  def attr_internal(*attrs); end

  def attr_internal_accessor(*attrs); end

  def attr_internal_reader(*attrs); end

  def attr_internal_writer(*attrs); end

  def cattr_accessor(*syms, &blk); end

  def cattr_reader(*syms); end

  def cattr_writer(*syms); end

  def class_name(); end

  def context(*a, &b); end

  def delegate(*methods); end

  def deprecate(*method_names); end

  def deprecate_constant(*_); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def local_constants(); end

  def mattr_accessor(*syms, &blk); end

  def mattr_reader(*syms); end

  def mattr_writer(*syms); end

  def methods_transplantable?(); end

  def parent(); end

  def parent_name(); end

  def parents(); end

  def qualified_const_defined?(path, search_parents=T.unsafe(nil)); end

  def qualified_const_get(path); end

  def qualified_const_set(path, value); end

  def rake_extension(method); end

  def reachable?(); end

  def redefine_method(method, &block); end

  def remove_possible_method(method); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def undef_method(*_); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
  RUBY_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  def concern(topic, &module_definition); end

  def concerning(topic, &block); end
end

module Module::Concerning
end

class Module::DelegationError
end

class Module::DelegationError
end

class Module
  def self.attr_internal_naming_format(); end

  def self.attr_internal_naming_format=(attr_internal_naming_format); end

  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

module Mysql2
  VERSION = ::T.let(nil, ::T.untyped)
end

class Mysql2::Client
  def abandon_results!(); end

  def affected_rows(); end

  def async_result(); end

  def automatic_close=(automatic_close); end

  def automatic_close?(); end

  def close(); end

  def closed?(); end

  def encoding(); end

  def escape(_); end

  def info(); end

  def initialize(opts=T.unsafe(nil)); end

  def last_id(); end

  def more_results?(); end

  def next_result(); end

  def parse_connect_attrs(conn_attrs); end

  def parse_flags_array(flags, initial=T.unsafe(nil)); end

  def parse_ssl_mode(mode); end

  def ping(); end

  def prepare(_); end

  def query(sql, options=T.unsafe(nil)); end

  def query_info(); end

  def query_info_string(); end

  def query_options(); end

  def read_timeout(); end

  def reconnect=(reconnect); end

  def select_db(_); end

  def server_info(); end

  def set_server_option(_); end

  def socket(); end

  def ssl_cipher(); end

  def store_result(); end

  def thread_id(); end

  def warning_count(); end
  COMPRESS = ::T.let(nil, ::T.untyped)
  CONNECT_ATTRS = ::T.let(nil, ::T.untyped)
  CONNECT_WITH_DB = ::T.let(nil, ::T.untyped)
  FOUND_ROWS = ::T.let(nil, ::T.untyped)
  IGNORE_SIGPIPE = ::T.let(nil, ::T.untyped)
  IGNORE_SPACE = ::T.let(nil, ::T.untyped)
  INTERACTIVE = ::T.let(nil, ::T.untyped)
  LOCAL_FILES = ::T.let(nil, ::T.untyped)
  LONG_FLAG = ::T.let(nil, ::T.untyped)
  LONG_PASSWORD = ::T.let(nil, ::T.untyped)
  MULTI_STATEMENTS = ::T.let(nil, ::T.untyped)
  NO_SCHEMA = ::T.let(nil, ::T.untyped)
  ODBC = ::T.let(nil, ::T.untyped)
  OPTION_MULTI_STATEMENTS_OFF = ::T.let(nil, ::T.untyped)
  OPTION_MULTI_STATEMENTS_ON = ::T.let(nil, ::T.untyped)
  PROTOCOL_41 = ::T.let(nil, ::T.untyped)
  PS_MULTI_RESULTS = ::T.let(nil, ::T.untyped)
  REMEMBER_OPTIONS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SECURE_CONNECTION = ::T.let(nil, ::T.untyped)
  SSL = ::T.let(nil, ::T.untyped)
  SSL_MODE_DISABLED = ::T.let(nil, ::T.untyped)
  SSL_MODE_PREFERRED = ::T.let(nil, ::T.untyped)
  SSL_MODE_REQUIRED = ::T.let(nil, ::T.untyped)
  SSL_MODE_VERIFY_CA = ::T.let(nil, ::T.untyped)
  SSL_MODE_VERIFY_IDENTITY = ::T.let(nil, ::T.untyped)
  SSL_VERIFY_SERVER_CERT = ::T.let(nil, ::T.untyped)
  TRANSACTIONS = ::T.let(nil, ::T.untyped)
end

class Mysql2::Client
  def self.default_query_options(); end

  def self.escape(_); end

  def self.info(); end
end

class Mysql2::Error
  def errno(); end

  def error(); end

  def error_number(); end

  def initialize(msg, server_version=T.unsafe(nil), error_number=T.unsafe(nil), sql_state=T.unsafe(nil)); end

  def sql_state(); end
  CODES = ::T.let(nil, ::T.untyped)
  ENCODE_OPTS = ::T.let(nil, ::T.untyped)
end

class Mysql2::Error::ConnectionError
end

class Mysql2::Error::ConnectionError
end

class Mysql2::Error::TimeoutError
end

class Mysql2::Error::TimeoutError
end

class Mysql2::Error
  def self.new_with_args(msg, server_version, error_number, sql_state); end
end

class Mysql2::Field
  def name(); end

  def name=(_); end

  def type(); end

  def type=(_); end
end

class Mysql2::Field
  def self.[](*_); end

  def self.members(); end
end

class Mysql2::Result
  include ::Enumerable
  def count(); end

  def each(*_, &blk); end

  def fields(); end

  def free(); end

  def server_flags(); end

  def size(); end
end

class Mysql2::Result
end

class Mysql2::Statement
  include ::Enumerable
  def _execute(*_); end

  def affected_rows(); end

  def close(); end

  def execute(*args, **kwargs); end

  def field_count(); end

  def fields(); end

  def last_id(); end

  def param_count(); end
end

class Mysql2::Statement
end

module Mysql2::Util
end

Mysql2::Util::TIMEOUT_ERROR_CLASS = Timeout::Error

module Mysql2::Util
  def self.key_hash_as_symbols(hash); end
end

module Mysql2
end

module NIO
  ENGINE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class NIO::ByteBuffer
  include ::Enumerable
  def <<(_); end

  def [](_); end

  def capacity(); end

  def clear(); end

  def compact(); end

  def each(&blk); end

  def flip(); end

  def full?(); end

  def get(*_); end

  def initialize(_); end

  def limit(); end

  def limit=(limit); end

  def mark(); end

  def position(); end

  def position=(position); end

  def read_from(_); end

  def remaining(); end

  def reset(); end

  def rewind(); end

  def size(); end

  def write_to(_); end
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer
end

class NIO::Monitor
  def add_interest(_); end

  def close(*_); end

  def closed?(); end

  def initialize(_, _1, _2); end

  def interests(); end

  def interests=(interests); end

  def io(); end

  def readable?(); end

  def readiness(); end

  def remove_interest(_); end

  def selector(); end

  def value(); end

  def value=(value); end

  def writable?(); end

  def writeable?(); end
end

class NIO::Monitor
end

class NIO::Selector
  def backend(); end

  def close(); end

  def closed?(); end

  def deregister(_); end

  def empty?(); end

  def initialize(*_); end

  def register(_, _1); end

  def registered?(_); end

  def wakeup(); end
end

class NIO::Selector
  def self.backends(); end
end

module NIO
  def self.engine(); end
end

class NameError
  include ::DidYouMean::Correctable
  def missing_name(); end

  def missing_name?(name); end

  def name(); end

  def receiver(); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  include ::AWS::Core::Http::Patches::Ruby_2
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

class Net::HTTP
end

Net::HTTPSession::ProxyDelta = Net::HTTP::ProxyDelta

Net::HTTPSession::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP
end

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end

  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

Net::SMTPSession = Net::SMTP

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_d(); end

  def to_i(); end

  def to_json(options=T.unsafe(nil)); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS
end

class Nokogiri::CSS::Node
  def accept(visitor); end

  def find_by_type(types); end

  def initialize(type, value); end

  def to_a(); end

  def to_type(); end

  def to_xpath(prefix=T.unsafe(nil), visitor=T.unsafe(nil)); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
end

class Nokogiri::CSS::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(namespaces=T.unsafe(nil)); end

  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end

  def unescape_css_identifier(identifier); end

  def unescape_css_string(str); end

  def xpath_for(string, options=T.unsafe(nil)); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  def self.[](string); end

  def self.[]=(string, value); end

  def self.cache_on(); end

  def self.cache_on=(cache_on); end

  def self.cache_on?(); end

  def self.clear_cache(); end

  def self.parse(selector); end

  def self.set_cache(_); end

  def self.without_cache(&block); end
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::Tokenizer
  def _next_token(); end

  def action(); end

  def filename(); end

  def lineno(); end

  def load_file(filename); end

  def next_token(); end

  def scan(str); end

  def scan_file(filename); end

  def scan_setup(str); end

  def scan_str(str); end

  def state(); end

  def state=(state); end
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer
end

class Nokogiri::CSS::XPathVisitor
  def accept(node); end

  def visit_attribute_condition(node); end

  def visit_child_selector(node); end

  def visit_class_condition(node); end

  def visit_combinator(node); end

  def visit_conditional_selector(node); end

  def visit_descendant_selector(node); end

  def visit_direct_adjacent_selector(node); end

  def visit_element_name(node); end

  def visit_following_selector(node); end

  def visit_function(node); end

  def visit_id(node); end

  def visit_not(node); end

  def visit_pseudo_class(node); end
end

class Nokogiri::CSS::XPathVisitor
end

module Nokogiri::CSS
  def self.parse(selector); end

  def self.xpath_for(selector, options=T.unsafe(nil)); end
end

module Nokogiri::Decorators
end

module Nokogiri::Decorators::Slop
  def method_missing(name, *args, &block); end
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
end

module Nokogiri::Decorators
end

class Nokogiri::EncodingHandler
  def name(); end
end

class Nokogiri::EncodingHandler
  def self.[](_); end

  def self.alias(_, _1); end

  def self.clear_aliases!(); end

  def self.delete(_); end
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::Builder
  def to_html(); end
end

class Nokogiri::HTML::Builder
end

class Nokogiri::HTML::Document
  def meta_encoding(); end

  def meta_encoding=(encoding); end

  def serialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(text); end
end

class Nokogiri::HTML::Document
end

class Nokogiri::HTML::DocumentFragment
end

class Nokogiri::HTML::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::ElementDescription
  def block?(); end

  def default_sub_element(); end

  def deprecated?(); end

  def deprecated_attributes(); end

  def description(); end

  def empty?(); end

  def implied_end_tag?(); end

  def implied_start_tag?(); end

  def inline?(); end

  def name(); end

  def optional_attributes(); end

  def required_attributes(); end

  def save_end_tag?(); end

  def sub_elements(); end
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML::ElementDescription
  def self.[](_); end
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityLookup
  def [](name); end

  def get(_); end
end

class Nokogiri::HTML::EntityLookup
end

module Nokogiri::HTML::SAX
end

class Nokogiri::HTML::SAX::Parser
  def parse_file(filename, encoding=T.unsafe(nil)); end

  def parse_memory(data, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::SAX::Parser
end

class Nokogiri::HTML::SAX::ParserContext
end

class Nokogiri::HTML::SAX::ParserContext
  def self.file(_, _1); end

  def self.memory(_, _1); end
end

class Nokogiri::HTML::SAX::PushParser
end

class Nokogiri::HTML::SAX::PushParser
end

module Nokogiri::HTML::SAX
end

module Nokogiri::HTML
  def self.fragment(string, encoding=T.unsafe(nil)); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

class Nokogiri::SyntaxError
end

class Nokogiri::SyntaxError
end

class Nokogiri::VersionInfo
  def compiled_parser_version(); end

  def engine(); end

  def jruby?(); end

  def libxml2?(); end

  def libxml2_using_packaged?(); end

  def libxml2_using_system?(); end

  def loaded_parser_version(); end

  def to_hash(); end

  def to_markdown(); end

  def warnings(); end
end

class Nokogiri::VersionInfo
  def self.instance(); end
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Attr
  def content=(content); end

  def value(); end

  def value=(value); end
end

class Nokogiri::XML::Attr
end

class Nokogiri::XML::AttributeDecl
  def attribute_type(); end

  def default(); end

  def enumeration(); end
end

class Nokogiri::XML::AttributeDecl
end

class Nokogiri::XML::Builder
  def <<(string); end

  def [](ns); end

  def arity(); end

  def arity=(arity); end

  def cdata(string); end

  def comment(string); end

  def context(); end

  def context=(context); end

  def doc(); end

  def doc=(doc); end

  def initialize(options=T.unsafe(nil), root=T.unsafe(nil), &block); end

  def method_missing(method, *args, &block); end

  def parent(); end

  def parent=(parent); end

  def text(string); end

  def to_xml(*args); end
end

class Nokogiri::XML::Builder
  def self.with(root, &block); end
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CharacterData
  include ::Nokogiri::XML::PP::CharacterData
end

class Nokogiri::XML::CharacterData
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::DTD
  def entities(); end

  def external_id(); end

  def html5_dtd?(); end

  def html_dtd?(); end

  def notations(); end

  def system_id(); end

  def validate(_); end
end

class Nokogiri::XML::DTD
end

class Nokogiri::XML::Document
  def canonicalize(*_); end

  def collect_namespaces(); end

  def create_cdata(string, &block); end

  def create_comment(string, &block); end

  def create_element(name, *args, &block); end

  def create_entity(*_); end

  def create_text_node(string, &block); end

  def decorate(node); end

  def decorators(key); end

  def encoding(); end

  def encoding=(encoding); end

  def errors(); end

  def errors=(errors); end

  def fragment(tags=T.unsafe(nil)); end

  def initialize(*args); end

  def remove_namespaces!(); end

  def root(); end

  def root=(root); end

  def slop!(); end

  def to_java(); end

  def to_xml(*args, &block); end

  def url(); end

  def validate(); end

  def version(); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  def self.empty_doc?(string_or_io); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.read_io(_, _1, _2, _3); end

  def self.read_memory(_, _1, _2, _3); end

  def self.wrap(document); end
end

class Nokogiri::XML::DocumentFragment
  def dup(); end

  def errors(); end

  def errors=(things); end

  def initialize(document, tags=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def search(*rules); end

  def serialize(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end
end

class Nokogiri::XML::DocumentFragment
  def self.parse(tags); end
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  def children(); end

  def document(); end

  def name(); end

  def occur(); end

  def prefix(); end

  def type(); end
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ElementContent
end

class Nokogiri::XML::ElementDecl
  def element_type(); end

  def prefix(); end
end

class Nokogiri::XML::ElementDecl
end

class Nokogiri::XML::EntityDecl
  def entity_type(); end

  def external_id(); end

  def original_content(); end

  def system_id(); end
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  def self.new(name, doc, *args); end
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::Namespace
  include ::Nokogiri::XML::PP::Node
  def document(); end

  def href(); end

  def prefix(); end
end

class Nokogiri::XML::Namespace
end

class Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def <<(node_or_tags); end

  def ==(other); end

  def >(selector); end

  def [](name); end

  def []=(name, value); end

  def accept(visitor); end

  def add_child(node_or_tags); end

  def add_class(name); end

  def add_namespace(_, _1); end

  def add_namespace_definition(_, _1); end

  def add_next_sibling(node_or_tags); end

  def add_previous_sibling(node_or_tags); end

  def after(node_or_tags); end

  def ancestors(selector=T.unsafe(nil)); end

  def append_class(name); end

  def attr(name); end

  def attribute(_); end

  def attribute_nodes(); end

  def attribute_with_ns(_, _1); end

  def attributes(); end

  def before(node_or_tags); end

  def canonicalize(mode=T.unsafe(nil), inclusive_namespaces=T.unsafe(nil), with_comments=T.unsafe(nil)); end

  def cdata?(); end

  def child(); end

  def children(); end

  def children=(node_or_tags); end

  def classes(); end

  def comment?(); end

  def content(); end

  def content=(string); end

  def create_external_subset(_, _1, _2); end

  def create_internal_subset(_, _1, _2); end

  def css_path(); end

  def decorate!(); end

  def default_namespace=(url); end

  def delete(name); end

  def description(); end

  def do_xinclude(options=T.unsafe(nil)); end

  def document(); end

  def document?(); end

  def dup(*_); end

  def each(&blk); end

  def elem?(); end

  def element?(); end

  def element_children(); end

  def elements(); end

  def encode_special_chars(_); end

  def external_subset(); end

  def first_element_child(); end

  def fragment(tags); end

  def fragment?(); end

  def get_attribute(name); end

  def has_attribute?(_); end

  def html?(); end

  def initialize(name, document); end

  def inner_html(*args); end

  def inner_html=(node_or_tags); end

  def inner_text(); end

  def internal_subset(); end

  def key?(_); end

  def keys(); end

  def lang(); end

  def lang=(lang); end

  def last_element_child(); end

  def line(); end

  def matches?(selector); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespace=(ns); end

  def namespace_definitions(); end

  def namespace_scopes(); end

  def namespaced_key?(_, _1); end

  def namespaces(); end

  def native_content=(native_content); end

  def next(); end

  def next=(node_or_tags); end

  def next_element(); end

  def next_sibling(); end

  def node_name(); end

  def node_name=(node_name); end

  def node_type(); end

  def parent(); end

  def parent=(parent_node); end

  def parse(string_or_io, options=T.unsafe(nil)); end

  def path(); end

  def pointer_id(); end

  def prepend_child(node_or_tags); end

  def previous(); end

  def previous=(node_or_tags); end

  def previous_element(); end

  def previous_sibling(); end

  def processing_instruction?(); end

  def read_only?(); end

  def remove(); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def replace(node_or_tags); end

  def serialize(*args, &block); end

  def set_attribute(name, value); end

  def swap(node_or_tags); end

  def text(); end

  def text?(); end

  def to_html(options=T.unsafe(nil)); end

  def to_str(); end

  def to_xhtml(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def traverse(&block); end

  def type(); end

  def unlink(); end

  def values(); end

  def wrap(html); end

  def write_html_to(io, options=T.unsafe(nil)); end

  def write_to(io, *options); end

  def write_xhtml_to(io, options=T.unsafe(nil)); end

  def write_xml_to(io, options=T.unsafe(nil)); end

  def xml?(); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
end

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def &(_); end

  def +(_); end

  def -(_); end

  def <<(_); end

  def ==(other); end

  def >(selector); end

  def [](*_); end

  def add_class(name); end

  def after(datum); end

  def append_class(name); end

  def attr(key, value=T.unsafe(nil), &block); end

  def attribute(key, value=T.unsafe(nil), &block); end

  def before(datum); end

  def children(); end

  def clone(); end

  def delete(_); end

  def document(); end

  def document=(document); end

  def each(&blk); end

  def empty?(); end

  def filter(expr); end

  def first(n=T.unsafe(nil)); end

  def index(node=T.unsafe(nil)); end

  def initialize(document, list=T.unsafe(nil)); end

  def inner_html(*args); end

  def inner_text(); end

  def last(); end

  def length(); end

  def pop(); end

  def push(_); end

  def remove(); end

  def remove_attr(name); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def reverse(); end

  def set(key, value=T.unsafe(nil), &block); end

  def shift(); end

  def size(); end

  def slice(*_); end

  def text(); end

  def to_a(); end

  def to_ary(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end

  def unlink(); end

  def wrap(html); end

  def |(_); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::Notation
end

module Nokogiri::XML::PP
end

module Nokogiri::XML::PP::CharacterData
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::CharacterData
end

module Nokogiri::XML::PP::Node
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::Node
end

module Nokogiri::XML::PP
end

class Nokogiri::XML::ParseOptions
  def compact(); end

  def compact?(); end

  def default_html(); end

  def default_html?(); end

  def default_xml(); end

  def default_xml?(); end

  def dtdattr(); end

  def dtdattr?(); end

  def dtdload(); end

  def dtdload?(); end

  def dtdvalid(); end

  def dtdvalid?(); end

  def huge(); end

  def huge?(); end

  def initialize(options=T.unsafe(nil)); end

  def nobasefix(); end

  def nobasefix?(); end

  def noblanks(); end

  def noblanks?(); end

  def nocdata(); end

  def nocdata?(); end

  def nocompact(); end

  def nodefault_html(); end

  def nodefault_xml(); end

  def nodict(); end

  def nodict?(); end

  def nodtdattr(); end

  def nodtdload(); end

  def nodtdvalid(); end

  def noent(); end

  def noent?(); end

  def noerror(); end

  def noerror?(); end

  def nohuge(); end

  def nonet(); end

  def nonet?(); end

  def nonobasefix(); end

  def nonoblanks(); end

  def nonocdata(); end

  def nonodict(); end

  def nonoent(); end

  def nonoerror(); end

  def nononet(); end

  def nonowarning(); end

  def nonoxincnode(); end

  def nonsclean(); end

  def noold10(); end

  def nopedantic(); end

  def norecover(); end

  def nosax1(); end

  def nowarning(); end

  def nowarning?(); end

  def noxinclude(); end

  def noxincnode(); end

  def noxincnode?(); end

  def nsclean(); end

  def nsclean?(); end

  def old10(); end

  def old10?(); end

  def options(); end

  def options=(options); end

  def pedantic(); end

  def pedantic?(); end

  def recover(); end

  def recover?(); end

  def sax1(); end

  def sax1?(); end

  def strict(); end

  def strict?(); end

  def to_i(); end

  def xinclude(); end

  def xinclude?(); end
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
end

class Nokogiri::XML::ProcessingInstruction
  def initialize(document, name, content); end
end

class Nokogiri::XML::ProcessingInstruction
end

class Nokogiri::XML::Reader
  include ::Enumerable
  def attribute(_); end

  def attribute_at(_); end

  def attribute_count(); end

  def attribute_nodes(); end

  def attributes(); end

  def attributes?(); end

  def base_uri(); end

  def default?(); end

  def depth(); end

  def each(&blk); end

  def empty_element?(); end

  def encoding(); end

  def errors(); end

  def errors=(errors); end

  def initialize(source, url=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def inner_xml(); end

  def lang(); end

  def local_name(); end

  def name(); end

  def namespace_uri(); end

  def namespaces(); end

  def node_type(); end

  def outer_xml(); end

  def prefix(); end

  def read(); end

  def self_closing?(); end

  def source(); end

  def state(); end

  def value(); end

  def value?(); end

  def xml_version(); end
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  def self.from_io(*_); end

  def self.from_memory(*_); end
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::RelaxNG
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::SAX::Document
  def cdata_block(string); end

  def characters(string); end

  def comment(string); end

  def end_document(); end

  def end_element(name); end

  def end_element_namespace(name, prefix=T.unsafe(nil), uri=T.unsafe(nil)); end

  def error(string); end

  def processing_instruction(name, content); end

  def start_document(); end

  def start_element(name, attrs=T.unsafe(nil)); end

  def start_element_namespace(name, attrs=T.unsafe(nil), prefix=T.unsafe(nil), uri=T.unsafe(nil), ns=T.unsafe(nil)); end

  def warning(string); end

  def xmldecl(version, encoding, standalone); end
end

class Nokogiri::XML::SAX::Document
end

class Nokogiri::XML::SAX::Parser
  def document(); end

  def document=(document); end

  def encoding(); end

  def encoding=(encoding); end

  def initialize(doc=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def parse(thing, &block); end

  def parse_file(filename); end

  def parse_io(io, encoding=T.unsafe(nil)); end

  def parse_memory(data); end
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
end

class Nokogiri::XML::SAX::ParserContext
  def column(); end

  def line(); end

  def parse_with(_); end

  def recovery(); end

  def recovery=(recovery); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::SAX::ParserContext
  def self.file(_); end

  def self.io(_, _1); end

  def self.memory(_); end

  def self.new(thing, encoding=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
  def <<(chunk, last_chunk=T.unsafe(nil)); end

  def document(); end

  def document=(document); end

  def finish(); end

  def initialize(doc=T.unsafe(nil), file_name=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end

  def write(chunk, last_chunk=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::Schema
  def errors(); end

  def errors=(errors); end

  def valid?(thing); end

  def validate(thing); end
end

class Nokogiri::XML::Schema
  def self.from_document(_); end

  def self.new(string_or_io); end

  def self.read_memory(_); end
end

module Nokogiri::XML::Searchable
  def %(*args); end

  def /(*args); end

  def at(*args); end

  def at_css(*args); end

  def at_xpath(*args); end

  def css(*args); end

  def search(*args); end

  def xpath(*args); end
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
end

class Nokogiri::XML::SyntaxError
  def code(); end

  def column(); end

  def domain(); end

  def error?(); end

  def fatal?(); end

  def file(); end

  def int1(); end

  def level(); end

  def line(); end

  def none?(); end

  def str1(); end

  def str2(); end

  def str3(); end

  def warning?(); end
end

class Nokogiri::XML::SyntaxError
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::XPath
  def document(); end

  def document=(document); end
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath
end

class Nokogiri::XML::XPathContext
  def evaluate(*_); end

  def register_namespaces(namespaces); end

  def register_ns(_, _1); end

  def register_variable(_, _1); end
end

class Nokogiri::XML::XPathContext
  def self.new(_); end
end

module Nokogiri::XML
  def self.Reader(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.RelaxNG(string_or_io); end

  def self.Schema(string_or_io); end

  def self.fragment(string); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::XSLT
end

class Nokogiri::XSLT::Stylesheet
  def apply_to(document, params=T.unsafe(nil)); end

  def serialize(_); end

  def transform(*_); end
end

class Nokogiri::XSLT::Stylesheet
  def self.parse_stylesheet_doc(_); end
end

module Nokogiri::XSLT
  def self.parse(string, modules=T.unsafe(nil)); end

  def self.quote_params(params); end

  def self.register(_, _1); end
end

module Nokogiri
  def self.HTML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.Slop(*args, &block); end

  def self.XML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.XSLT(stylesheet, modules=T.unsafe(nil)); end

  def self.install_default_aliases(); end

  def self.jruby?(); end

  def self.make(input=T.unsafe(nil), opts=T.unsafe(nil), &blk); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.uses_libxml?(); end
end

module NullDB
  LEGACY_ACTIVERECORD = ::T.let(nil, ::T.untyped)
end

class NullDB::Configuration
end

class NullDB::Configuration
end

module NullDB
  def self.checkpoint(); end

  def self.configuration(); end

  def self.configure(); end

  def self.nullify(options=T.unsafe(nil)); end

  def self.restore(); end
end

class Numeric
  def to_formatted_s(format=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Dependencies::Loadable
  include ::PP::ObjectMixin
  def `(command); end

  def as_json(options=T.unsafe(nil)); end

  def dclone(); end

  def html_safe?(); end

  def presence_in(another_object); end

  def to_json(options=T.unsafe(nil)); end

  def to_json_with_active_support_encoder(options=T.unsafe(nil)); end

  def to_json_without_active_support_encoder(*_); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class ObjectType
  def after_add_for_items(); end

  def after_add_for_items=(after_add_for_items); end

  def after_add_for_items?(); end

  def after_remove_for_items(); end

  def after_remove_for_items=(after_remove_for_items); end

  def after_remove_for_items?(); end

  def autosave_associated_records_for_items(*args); end

  def autosave_associated_records_for_sample_type(*args); end

  def before_add_for_items(); end

  def before_add_for_items=(before_add_for_items); end

  def before_add_for_items?(); end

  def before_remove_for_items(); end

  def before_remove_for_items=(before_remove_for_items); end

  def before_remove_for_items?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_items(*args); end
end

class ObjectType::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class ObjectType::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class ObjectType::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module ObjectType::GeneratedAssociationMethods
  def build_sample_type(*args, &block); end

  def create_sample_type(*args, &block); end

  def create_sample_type!(*args, &block); end

  def item_ids(); end

  def item_ids=(ids); end
end

class ObjectType
  def self.after_add_for_items(); end

  def self.after_add_for_items=(val); end

  def self.after_add_for_items?(); end

  def self.after_remove_for_items(); end

  def self.after_remove_for_items=(val); end

  def self.after_remove_for_items?(); end

  def self.before_add_for_items(); end

  def self.before_add_for_items=(val); end

  def self.before_add_for_items?(); end

  def self.before_remove_for_items(); end

  def self.before_remove_for_items=(val); end

  def self.before_remove_for_items?(); end
end

module Observable
  def add_observer(observer, func=T.unsafe(nil)); end

  def changed(state=T.unsafe(nil)); end

  def changed?(); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def notify_observers(*arg); end
end

module Observable
end

module Octokit
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Octokit::AbuseDetected
end

class Octokit::AbuseDetected
end

class Octokit::AccountSuspended
end

class Octokit::AccountSuspended
end

class Octokit::ApplicationCredentialsRequired
end

class Octokit::ApplicationCredentialsRequired
end

class Octokit::Arguments
  def initialize(args); end

  def options(); end
end

class Octokit::Arguments
end

module Octokit::Authentication
  def application_authenticated?(); end

  def basic_authenticated?(); end

  def bearer_authenticated?(); end

  def token_authenticated?(); end

  def user_authenticated?(); end
end

module Octokit::Authentication
end

class Octokit::BadGateway
end

class Octokit::BadGateway
end

class Octokit::BadRequest
end

class Octokit::BadRequest
end

class Octokit::BillingIssue
end

class Octokit::BillingIssue
end

class Octokit::BranchNotProtected
end

class Octokit::BranchNotProtected
end

class Octokit::Client
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Preview
  include ::Octokit::Warnable
  include ::Octokit::Client::Authorizations
  include ::Octokit::Client::Checks
  include ::Octokit::Client::Commits
  include ::Octokit::Client::CommitComments
  include ::Octokit::Client::CommitPulls
  include ::Octokit::Client::CommitBranches
  include ::Octokit::Client::CommunityProfile
  include ::Octokit::Client::Contents
  include ::Octokit::Client::Deployments
  include ::Octokit::Client::Downloads
  include ::Octokit::Client::Emojis
  include ::Octokit::Client::Events
  include ::Octokit::Client::Feeds
  include ::Octokit::Client::Gists
  include ::Octokit::Client::Gitignore
  include ::Octokit::Client::Hooks
  include ::Octokit::Client::Apps
  include ::Octokit::Client::Issues
  include ::Octokit::Client::Labels
  include ::Octokit::Client::LegacySearch
  include ::Octokit::Client::Licenses
  include ::Octokit::Client::Meta
  include ::Octokit::Client::Markdown
  include ::Octokit::Client::Marketplace
  include ::Octokit::Client::Milestones
  include ::Octokit::Client::Notifications
  include ::Octokit::Client::OauthApplications
  include ::Octokit::Client::Objects
  include ::Octokit::Client::Organizations
  include ::Octokit::Client::Pages
  include ::Octokit::Client::Projects
  include ::Octokit::Client::PubSubHubbub
  include ::Octokit::Client::PullRequests
  include ::Octokit::Client::RateLimit
  include ::Octokit::Client::Reactions
  include ::Octokit::Client::Refs
  include ::Octokit::Client::Releases
  include ::Octokit::Client::Repositories
  include ::Octokit::Client::RepositoryInvitations
  include ::Octokit::Client::Reviews
  include ::Octokit::Client::Say
  include ::Octokit::Client::Search
  include ::Octokit::Client::ServiceStatus
  include ::Octokit::Client::SourceImport
  include ::Octokit::Client::Stats
  include ::Octokit::Client::Statuses
  include ::Octokit::Client::Traffic
  include ::Octokit::Client::Users
  def access_token=(value); end

  def as_app(key=T.unsafe(nil), secret=T.unsafe(nil), &block); end

  def bearer_token=(value); end

  def client_id=(value); end

  def client_secret=(value); end

  def client_without_redirects(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def login=(value); end

  def password=(value); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::Apps
  def add_repo_to_installation(installation, repo, options=T.unsafe(nil)); end

  def add_repository_to_app_installation(installation, repo, options=T.unsafe(nil)); end

  def add_repository_to_integration_installation(installation, repo, options=T.unsafe(nil)); end

  def create_app_installation_access_token(installation, options=T.unsafe(nil)); end

  def create_installation_access_token(installation, options=T.unsafe(nil)); end

  def create_integration_installation_access_token(installation, options=T.unsafe(nil)); end

  def delete_installation(installation, options=T.unsafe(nil)); end

  def find_app_installations(options=T.unsafe(nil)); end

  def find_installation_repositories_for_user(installation, options=T.unsafe(nil)); end

  def find_installations(options=T.unsafe(nil)); end

  def find_integration_installations(options=T.unsafe(nil)); end

  def find_organization_installation(organization, options=T.unsafe(nil)); end

  def find_repository_installation(repo, options=T.unsafe(nil)); end

  def find_user_installation(user, options=T.unsafe(nil)); end

  def find_user_installations(options=T.unsafe(nil)); end

  def installation(id, options=T.unsafe(nil)); end

  def list_app_installation_repositories(options=T.unsafe(nil)); end

  def list_installation_repos(options=T.unsafe(nil)); end

  def list_integration_installation_repositories(options=T.unsafe(nil)); end

  def remove_repo_from_installation(installation, repo, options=T.unsafe(nil)); end

  def remove_repository_from_app_installation(installation, repo, options=T.unsafe(nil)); end

  def remove_repository_from_integration_installation(installation, repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Apps
end

module Octokit::Client::Authorizations
  def authorization(number, options=T.unsafe(nil)); end

  def authorizations(options=T.unsafe(nil)); end

  def authorize_url(app_id=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_authorization(options=T.unsafe(nil)); end

  def delete_authorization(number, options=T.unsafe(nil)); end

  def revoke_all_application_authorizations(options=T.unsafe(nil)); end

  def scopes(token=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_authorization(number, options=T.unsafe(nil)); end
end

module Octokit::Client::Authorizations
end

module Octokit::Client::Checks
  def check_run(repo, id, options=T.unsafe(nil)); end

  def check_run_annotations(repo, id, options=T.unsafe(nil)); end

  def check_runs_for_check_suite(repo, id, options=T.unsafe(nil)); end

  def check_runs_for_ref(repo, ref, options=T.unsafe(nil)); end

  def check_suite(repo, id, options=T.unsafe(nil)); end

  def check_suites_for_ref(repo, ref, options=T.unsafe(nil)); end

  def create_check_run(repo, name, head_sha, options=T.unsafe(nil)); end

  def create_check_suite(repo, head_sha, options=T.unsafe(nil)); end

  def list_check_runs_for_check_suite(repo, id, options=T.unsafe(nil)); end

  def list_check_runs_for_ref(repo, ref, options=T.unsafe(nil)); end

  def list_check_suites_for_ref(repo, ref, options=T.unsafe(nil)); end

  def rerequest_check_suite(repo, id, options=T.unsafe(nil)); end

  def set_check_suite_preferences(repo, options=T.unsafe(nil)); end

  def update_check_run(repo, id, options=T.unsafe(nil)); end
end

module Octokit::Client::Checks
end

module Octokit::Client::CommitBranches
  def commit_branches(repo, sha, options=T.unsafe(nil)); end
end

module Octokit::Client::CommitBranches
end

module Octokit::Client::CommitComments
  def commit_comment(repo, id, options=T.unsafe(nil)); end

  def commit_comments(repo, sha, options=T.unsafe(nil)); end

  def create_commit_comment(repo, sha, body, path=T.unsafe(nil), line=T.unsafe(nil), position=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_commit_comment(repo, id, options=T.unsafe(nil)); end

  def list_commit_comments(repo, options=T.unsafe(nil)); end

  def update_commit_comment(repo, id, body, options=T.unsafe(nil)); end
end

module Octokit::Client::CommitComments
end

module Octokit::Client::CommitPulls
  def commit_pulls(repo, sha, options=T.unsafe(nil)); end
end

module Octokit::Client::CommitPulls
end

module Octokit::Client::Commits
  def commit(repo, sha, options=T.unsafe(nil)); end

  def commits(*args); end

  def commits_before(*args); end

  def commits_between(*args); end

  def commits_on(*args); end

  def commits_since(*args); end

  def compare(repo, start, endd, options=T.unsafe(nil)); end

  def create_commit(repo, message, tree, parents=T.unsafe(nil), options=T.unsafe(nil)); end

  def git_commit(repo, sha, options=T.unsafe(nil)); end

  def iso8601(date); end

  def list_commits(*args); end

  def merge(repo, base, head, options=T.unsafe(nil)); end

  def parse_date(date); end
end

module Octokit::Client::Commits
end

module Octokit::Client::CommunityProfile
  def community_profile(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::CommunityProfile
end

module Octokit::Client::Contents
  def add_content(*args); end

  def add_contents(*args); end

  def archive_link(repo, options=T.unsafe(nil)); end

  def content(repo, options=T.unsafe(nil)); end

  def contents(repo, options=T.unsafe(nil)); end

  def create_content(*args); end

  def create_contents(*args); end

  def delete_content(repo, path, message, sha, options=T.unsafe(nil)); end

  def delete_contents(repo, path, message, sha, options=T.unsafe(nil)); end

  def readme(repo, options=T.unsafe(nil)); end

  def remove_content(repo, path, message, sha, options=T.unsafe(nil)); end

  def remove_contents(repo, path, message, sha, options=T.unsafe(nil)); end

  def update_content(*args); end

  def update_contents(*args); end
end

module Octokit::Client::Contents
end

module Octokit::Client::Deployments
  def create_deployment(repo, ref, options=T.unsafe(nil)); end

  def create_deployment_status(deployment_url, state, options=T.unsafe(nil)); end

  def deployment(repo, deployment_id, options=T.unsafe(nil)); end

  def deployment_statuses(deployment_url, options=T.unsafe(nil)); end

  def deployments(repo, options=T.unsafe(nil)); end

  def list_deployment_statuses(deployment_url, options=T.unsafe(nil)); end

  def list_deployments(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Deployments
end

module Octokit::Client::Downloads
  def delete_download(repo, id, options=T.unsafe(nil)); end

  def download(repo, id, options=T.unsafe(nil)); end

  def downloads(repo, options=T.unsafe(nil)); end

  def list_downloads(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Downloads
end

module Octokit::Client::Emojis
  def emojis(options=T.unsafe(nil)); end
end

module Octokit::Client::Emojis
end

module Octokit::Client::Events
  def issue_event(repo, number, options=T.unsafe(nil)); end

  def issue_events(repo, number, options=T.unsafe(nil)); end

  def organization_events(org, options=T.unsafe(nil)); end

  def organization_public_events(org, options=T.unsafe(nil)); end

  def public_events(options=T.unsafe(nil)); end

  def received_events(user, options=T.unsafe(nil)); end

  def received_public_events(user, options=T.unsafe(nil)); end

  def repo_issue_events(repo, options=T.unsafe(nil)); end

  def repository_events(repo, options=T.unsafe(nil)); end

  def repository_issue_events(repo, options=T.unsafe(nil)); end

  def repository_network_events(repo, options=T.unsafe(nil)); end

  def user_events(user, options=T.unsafe(nil)); end

  def user_public_events(user, options=T.unsafe(nil)); end
end

module Octokit::Client::Events
end

module Octokit::Client::Feeds
  def feed(name, options=T.unsafe(nil)); end

  def feeds(); end
end

module Octokit::Client::Feeds
end

module Octokit::Client::Gists
  def create_gist(options=T.unsafe(nil)); end

  def create_gist_comment(gist_id, comment, options=T.unsafe(nil)); end

  def delete_gist(gist, options=T.unsafe(nil)); end

  def delete_gist_comment(gist_id, gist_comment_id, options=T.unsafe(nil)); end

  def edit_gist(gist, options=T.unsafe(nil)); end

  def fork_gist(gist, options=T.unsafe(nil)); end

  def gist(gist, options=T.unsafe(nil)); end

  def gist_comment(gist_id, gist_comment_id, options=T.unsafe(nil)); end

  def gist_comments(gist_id, options=T.unsafe(nil)); end

  def gist_commits(gist, options=T.unsafe(nil)); end

  def gist_forks(gist, options=T.unsafe(nil)); end

  def gist_starred?(gist, options=T.unsafe(nil)); end

  def gists(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_gists(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def public_gists(options=T.unsafe(nil)); end

  def star_gist(gist, options=T.unsafe(nil)); end

  def starred_gists(options=T.unsafe(nil)); end

  def unstar_gist(gist, options=T.unsafe(nil)); end

  def update_gist_comment(gist_id, gist_comment_id, comment, options=T.unsafe(nil)); end
end

module Octokit::Client::Gists
end

module Octokit::Client::Gitignore
  def gitignore_template(template_name, options=T.unsafe(nil)); end

  def gitignore_templates(options=T.unsafe(nil)); end
end

module Octokit::Client::Gitignore
end

module Octokit::Client::Hooks
  def available_hooks(options=T.unsafe(nil)); end

  def create_hook(repo, name, config, options=T.unsafe(nil)); end

  def create_org_hook(org, config, options=T.unsafe(nil)); end

  def edit_hook(repo, id, name, config, options=T.unsafe(nil)); end

  def edit_org_hook(org, id, config, options=T.unsafe(nil)); end

  def hook(repo, id, options=T.unsafe(nil)); end

  def hooks(repo, options=T.unsafe(nil)); end

  def list_org_hooks(org, options=T.unsafe(nil)); end

  def org_hook(org, id, options=T.unsafe(nil)); end

  def org_hooks(org, options=T.unsafe(nil)); end

  def parse_payload(payload_string); end

  def ping_hook(repo, id, options=T.unsafe(nil)); end

  def ping_org_hook(org, id, options=T.unsafe(nil)); end

  def remove_hook(repo, id, options=T.unsafe(nil)); end

  def remove_org_hook(org, id, options=T.unsafe(nil)); end

  def test_hook(repo, id, options=T.unsafe(nil)); end

  def update_org_hook(org, id, config, options=T.unsafe(nil)); end
end

module Octokit::Client::Hooks
end

module Octokit::Client::Issues
  def add_assignees(repo, number, assignees, options=T.unsafe(nil)); end

  def add_comment(repo, number, comment, options=T.unsafe(nil)); end

  def close_issue(repo, number, options=T.unsafe(nil)); end

  def create_issue(repo, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_comment(repo, number, options=T.unsafe(nil)); end

  def issue(repo, number, options=T.unsafe(nil)); end

  def issue_comment(repo, number, options=T.unsafe(nil)); end

  def issue_comments(repo, number, options=T.unsafe(nil)); end

  def issue_timeline(repo, number, options=T.unsafe(nil)); end

  def issues(repository=T.unsafe(nil), options=T.unsafe(nil)); end

  def issues_comments(repo, options=T.unsafe(nil)); end

  def list_assignees(repo, options=T.unsafe(nil)); end

  def list_issues(repository=T.unsafe(nil), options=T.unsafe(nil)); end

  def lock_issue(repo, number, options=T.unsafe(nil)); end

  def open_issue(repo, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def org_issues(org, options=T.unsafe(nil)); end

  def remove_assignees(repo, number, assignees, options=T.unsafe(nil)); end

  def reopen_issue(repo, number, options=T.unsafe(nil)); end

  def unlock_issue(repo, number, options=T.unsafe(nil)); end

  def update_comment(repo, number, comment, options=T.unsafe(nil)); end

  def update_issue(repo, number, *args); end

  def user_issues(options=T.unsafe(nil)); end
end

module Octokit::Client::Issues
end

module Octokit::Client::Labels
  def add_label(repo, label, color=T.unsafe(nil), options=T.unsafe(nil)); end

  def add_labels_to_an_issue(repo, number, labels); end

  def delete_label!(repo, label, options=T.unsafe(nil)); end

  def label(repo, name, options=T.unsafe(nil)); end

  def labels(repo, options=T.unsafe(nil)); end

  def labels_for_issue(repo, number, options=T.unsafe(nil)); end

  def labels_for_milestone(repo, number, options=T.unsafe(nil)); end

  def remove_all_labels(repo, number, options=T.unsafe(nil)); end

  def remove_label(repo, number, label, options=T.unsafe(nil)); end

  def replace_all_labels(repo, number, labels, options=T.unsafe(nil)); end

  def update_label(repo, label, options=T.unsafe(nil)); end
end

module Octokit::Client::Labels
end

module Octokit::Client::LegacySearch
  def legacy_search_issues(repo, search_term, state=T.unsafe(nil), options=T.unsafe(nil)); end

  def legacy_search_repositories(q, options=T.unsafe(nil)); end

  def legacy_search_users(search, options=T.unsafe(nil)); end
end

module Octokit::Client::LegacySearch
end

module Octokit::Client::Licenses
  def license(license_name, options=T.unsafe(nil)); end

  def licenses(options=T.unsafe(nil)); end

  def repository_license_contents(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Licenses
end

module Octokit::Client::Markdown
  def markdown(text, options=T.unsafe(nil)); end
end

module Octokit::Client::Markdown
end

module Octokit::Client::Marketplace
  def list_accounts_for_plan(plan_id, options=T.unsafe(nil)); end

  def list_plans(options=T.unsafe(nil)); end

  def marketplace_purchases(options=T.unsafe(nil)); end

  def plan_for_account(account_id, options=T.unsafe(nil)); end
end

module Octokit::Client::Marketplace
end

module Octokit::Client::Meta
  def github_meta(options=T.unsafe(nil)); end

  def meta(options=T.unsafe(nil)); end
end

module Octokit::Client::Meta
end

module Octokit::Client::Milestones
  def create_milestone(repository, title, options=T.unsafe(nil)); end

  def delete_milestone(repository, number, options=T.unsafe(nil)); end

  def edit_milestone(repository, number, options=T.unsafe(nil)); end

  def list_milestones(repository, options=T.unsafe(nil)); end

  def milestone(repository, number, options=T.unsafe(nil)); end

  def milestones(repository, options=T.unsafe(nil)); end

  def update_milestone(repository, number, options=T.unsafe(nil)); end
end

module Octokit::Client::Milestones
end

module Octokit::Client::Notifications
  def delete_thread_subscription(thread_id, options=T.unsafe(nil)); end

  def mark_notifications_as_read(options=T.unsafe(nil)); end

  def mark_repo_notifications_as_read(repo, options=T.unsafe(nil)); end

  def mark_repository_notifications_as_read(repo, options=T.unsafe(nil)); end

  def mark_thread_as_read(thread_id, options=T.unsafe(nil)); end

  def notifications(options=T.unsafe(nil)); end

  def repo_notifications(repo, options=T.unsafe(nil)); end

  def repository_notifications(repo, options=T.unsafe(nil)); end

  def thread_notifications(thread_id, options=T.unsafe(nil)); end

  def thread_subscription(thread_id, options=T.unsafe(nil)); end

  def update_thread_subscription(thread_id, options=T.unsafe(nil)); end
end

module Octokit::Client::Notifications
end

module Octokit::Client::OauthApplications
  def check_application_authorization(access_token, options=T.unsafe(nil)); end

  def check_token(access_token, options=T.unsafe(nil)); end

  def delete_app_authorization(access_token, options=T.unsafe(nil)); end

  def delete_app_token(access_token, options=T.unsafe(nil)); end

  def delete_application_authorization(access_token, options=T.unsafe(nil)); end

  def reset_application_authorization(access_token, options=T.unsafe(nil)); end

  def reset_token(access_token, options=T.unsafe(nil)); end

  def revoke_application_authorization(access_token, options=T.unsafe(nil)); end
end

module Octokit::Client::OauthApplications
end

module Octokit::Client::Objects
  def blob(repo, blob_sha, options=T.unsafe(nil)); end

  def create_blob(repo, content, encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_tag(repo, tag, message, object_sha, type, tagger_name, tagger_email, tagger_date, options=T.unsafe(nil)); end

  def create_tree(repo, tree, options=T.unsafe(nil)); end

  def tag(repo, tag_sha, options=T.unsafe(nil)); end

  def tree(repo, tree_sha, options=T.unsafe(nil)); end
end

module Octokit::Client::Objects
end

module Octokit::Client::Organizations
  def add_team_member(team_id, user, options=T.unsafe(nil)); end

  def add_team_membership(team_id, user, options=T.unsafe(nil)); end

  def add_team_repo(team_id, repo, options=T.unsafe(nil)); end

  def add_team_repository(team_id, repo, options=T.unsafe(nil)); end

  def all_organizations(options=T.unsafe(nil)); end

  def all_orgs(options=T.unsafe(nil)); end

  def child_teams(team_id, options=T.unsafe(nil)); end

  def conceal_membership(org, user, options=T.unsafe(nil)); end

  def convert_to_outside_collaborator(org, user, options=T.unsafe(nil)); end

  def create_team(org, options=T.unsafe(nil)); end

  def delete_migration_archive(org, id, options=T.unsafe(nil)); end

  def delete_team(team_id, options=T.unsafe(nil)); end

  def list_organizations(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_orgs(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def migration_archive_url(org, id, options=T.unsafe(nil)); end

  def migration_status(org, id, options=T.unsafe(nil)); end

  def migrations(org, options=T.unsafe(nil)); end

  def org(org, options=T.unsafe(nil)); end

  def org_invitations(org, options=T.unsafe(nil)); end

  def org_member?(org, user, options=T.unsafe(nil)); end

  def org_members(org, options=T.unsafe(nil)); end

  def org_membership(org, options=T.unsafe(nil)); end

  def org_memberships(options=T.unsafe(nil)); end

  def org_public_member?(org, user, options=T.unsafe(nil)); end

  def org_public_members(org, options=T.unsafe(nil)); end

  def org_repos(org, options=T.unsafe(nil)); end

  def org_repositories(org, options=T.unsafe(nil)); end

  def org_teams(org, options=T.unsafe(nil)); end

  def organization(org, options=T.unsafe(nil)); end

  def organization_invitations(org, options=T.unsafe(nil)); end

  def organization_member?(org, user, options=T.unsafe(nil)); end

  def organization_members(org, options=T.unsafe(nil)); end

  def organization_membership(org, options=T.unsafe(nil)); end

  def organization_memberships(options=T.unsafe(nil)); end

  def organization_public_member?(org, user, options=T.unsafe(nil)); end

  def organization_public_members(org, options=T.unsafe(nil)); end

  def organization_repositories(org, options=T.unsafe(nil)); end

  def organization_teams(org, options=T.unsafe(nil)); end

  def organizations(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def orgs(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def outside_collaborators(org, options=T.unsafe(nil)); end

  def publicize_membership(org, user, options=T.unsafe(nil)); end

  def remove_org_member(org, user, options=T.unsafe(nil)); end

  def remove_org_membership(org, options=T.unsafe(nil)); end

  def remove_organization_member(org, user, options=T.unsafe(nil)); end

  def remove_organization_membership(org, options=T.unsafe(nil)); end

  def remove_outside_collaborator(org, user, options=T.unsafe(nil)); end

  def remove_team_member(team_id, user, options=T.unsafe(nil)); end

  def remove_team_membership(team_id, user, options=T.unsafe(nil)); end

  def remove_team_repo(team_id, repo, options=T.unsafe(nil)); end

  def remove_team_repository(team_id, repo, options=T.unsafe(nil)); end

  def start_migration(org, repositories, options=T.unsafe(nil)); end

  def team(team_id, options=T.unsafe(nil)); end

  def team_by_name(org, team_slug, options=T.unsafe(nil)); end

  def team_invitations(team_id, options=T.unsafe(nil)); end

  def team_member?(team_id, user, options=T.unsafe(nil)); end

  def team_members(team_id, options=T.unsafe(nil)); end

  def team_membership(team_id, user, options=T.unsafe(nil)); end

  def team_repo?(team_id, repo, options=T.unsafe(nil)); end

  def team_repos(team_id, options=T.unsafe(nil)); end

  def team_repositories(team_id, options=T.unsafe(nil)); end

  def team_repository?(team_id, repo, options=T.unsafe(nil)); end

  def unlock_repository(org, id, repo, options=T.unsafe(nil)); end

  def unpublicize_membership(org, user, options=T.unsafe(nil)); end

  def update_org(org, values, options=T.unsafe(nil)); end

  def update_org_membership(org, options=T.unsafe(nil)); end

  def update_organization(org, values, options=T.unsafe(nil)); end

  def update_organization_membership(org, options=T.unsafe(nil)); end

  def update_team(team_id, options=T.unsafe(nil)); end

  def user_teams(options=T.unsafe(nil)); end
end

module Octokit::Client::Organizations
end

module Octokit::Client::Pages
  def latest_pages_build(repo, options=T.unsafe(nil)); end

  def list_pages_builds(repo, options=T.unsafe(nil)); end

  def pages(repo, options=T.unsafe(nil)); end

  def pages_build(repo, id, options=T.unsafe(nil)); end

  def pages_builds(repo, options=T.unsafe(nil)); end

  def request_page_build(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Pages
end

module Octokit::Client::Projects
  def column_cards(id, options=T.unsafe(nil)); end

  def create_org_project(org, name, options=T.unsafe(nil)); end

  def create_organization_project(org, name, options=T.unsafe(nil)); end

  def create_project(repo, name, options=T.unsafe(nil)); end

  def create_project_card(id, options=T.unsafe(nil)); end

  def create_project_column(id, name, options=T.unsafe(nil)); end

  def delete_project(id, options=T.unsafe(nil)); end

  def delete_project_card(id, options=T.unsafe(nil)); end

  def delete_project_column(id, options=T.unsafe(nil)); end

  def move_project_card(id, position, options=T.unsafe(nil)); end

  def move_project_column(id, position, options=T.unsafe(nil)); end

  def org_projects(org, options=T.unsafe(nil)); end

  def organization_projects(org, options=T.unsafe(nil)); end

  def project(id, options=T.unsafe(nil)); end

  def project_card(id, options=T.unsafe(nil)); end

  def project_column(id, options=T.unsafe(nil)); end

  def project_columns(id, options=T.unsafe(nil)); end

  def projects(repo, options=T.unsafe(nil)); end

  def update_project(id, options=T.unsafe(nil)); end

  def update_project_card(id, options=T.unsafe(nil)); end

  def update_project_column(id, name, options=T.unsafe(nil)); end
end

module Octokit::Client::Projects
end

module Octokit::Client::PubSubHubbub
  def subscribe(topic, callback, secret=T.unsafe(nil)); end

  def subscribe_service_hook(repo, service_name, service_arguments=T.unsafe(nil), secret=T.unsafe(nil)); end

  def unsubscribe(topic, callback); end

  def unsubscribe_service_hook(repo, service_name); end
end

module Octokit::Client::PubSubHubbub
end

module Octokit::Client::PullRequests
  def close_pull_request(repo, number, options=T.unsafe(nil)); end

  def create_pull_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def create_pull_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_pull_request(repo, base, head, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_pull_request_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def create_pull_request_comment_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_pull_request_for_issue(repo, base, head, issue, options=T.unsafe(nil)); end

  def create_review_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_view_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def delete_pull_comment(repo, comment_id, options=T.unsafe(nil)); end

  def delete_pull_request_comment(repo, comment_id, options=T.unsafe(nil)); end

  def delete_review_comment(repo, comment_id, options=T.unsafe(nil)); end

  def merge_pull_request(repo, number, commit_message=T.unsafe(nil), options=T.unsafe(nil)); end

  def pull(repo, number, options=T.unsafe(nil)); end

  def pull_comment(repo, comment_id, options=T.unsafe(nil)); end

  def pull_comments(repo, number, options=T.unsafe(nil)); end

  def pull_commits(repo, number, options=T.unsafe(nil)); end

  def pull_files(repo, number, options=T.unsafe(nil)); end

  def pull_merged?(repo, number, options=T.unsafe(nil)); end

  def pull_request(repo, number, options=T.unsafe(nil)); end

  def pull_request_comment(repo, comment_id, options=T.unsafe(nil)); end

  def pull_request_comments(repo, number, options=T.unsafe(nil)); end

  def pull_request_commits(repo, number, options=T.unsafe(nil)); end

  def pull_request_files(repo, number, options=T.unsafe(nil)); end

  def pull_request_merged?(repo, number, options=T.unsafe(nil)); end

  def pull_requests(repo, options=T.unsafe(nil)); end

  def pull_requests_comments(repo, options=T.unsafe(nil)); end

  def pulls(repo, options=T.unsafe(nil)); end

  def pulls_comments(repo, options=T.unsafe(nil)); end

  def review_comment(repo, comment_id, options=T.unsafe(nil)); end

  def review_comments(repo, number, options=T.unsafe(nil)); end

  def reviews_comments(repo, options=T.unsafe(nil)); end

  def update_pull_comment(repo, comment_id, body, options=T.unsafe(nil)); end

  def update_pull_request(*args); end

  def update_pull_request_comment(repo, comment_id, body, options=T.unsafe(nil)); end

  def update_review_comment(repo, comment_id, body, options=T.unsafe(nil)); end
end

module Octokit::Client::PullRequests
end

module Octokit::Client::RateLimit
  def rate_limit(options=T.unsafe(nil)); end

  def rate_limit!(options=T.unsafe(nil)); end

  def rate_limit_remaining(options=T.unsafe(nil)); end

  def rate_limit_remaining!(options=T.unsafe(nil)); end

  def ratelimit(options=T.unsafe(nil)); end

  def ratelimit!(options=T.unsafe(nil)); end

  def ratelimit_remaining(options=T.unsafe(nil)); end

  def ratelimit_remaining!(options=T.unsafe(nil)); end
end

module Octokit::Client::RateLimit
end

module Octokit::Client::Reactions
  def commit_comment_reactions(repo, id, options=T.unsafe(nil)); end

  def create_commit_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def create_issue_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def create_issue_reaction(repo, number, reaction, options=T.unsafe(nil)); end

  def create_pull_request_review_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def delete_reaction(id, options=T.unsafe(nil)); end

  def issue_comment_reactions(repo, id, options=T.unsafe(nil)); end

  def issue_reactions(repo, number, options=T.unsafe(nil)); end

  def pull_request_review_comment_reactions(repo, id, options=T.unsafe(nil)); end
end

module Octokit::Client::Reactions
end

module Octokit::Client::Refs
  def create_ref(repo, ref, sha, options=T.unsafe(nil)); end

  def create_reference(repo, ref, sha, options=T.unsafe(nil)); end

  def delete_branch(repo, branch, options=T.unsafe(nil)); end

  def delete_ref(repo, ref, options=T.unsafe(nil)); end

  def delete_reference(repo, ref, options=T.unsafe(nil)); end

  def list_references(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_refs(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def ref(repo, ref, options=T.unsafe(nil)); end

  def reference(repo, ref, options=T.unsafe(nil)); end

  def references(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def refs(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_branch(repo, branch, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_ref(repo, ref, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_reference(repo, ref, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Refs
end

module Octokit::Client::Releases
  def create_release(repo, tag_name, options=T.unsafe(nil)); end

  def delete_release(url, options=T.unsafe(nil)); end

  def delete_release_asset(asset_url, options=T.unsafe(nil)); end

  def edit_release(url, options=T.unsafe(nil)); end

  def edit_release_asset(asset_url, options=T.unsafe(nil)); end

  def latest_release(repo, options=T.unsafe(nil)); end

  def list_releases(repo, options=T.unsafe(nil)); end

  def release(url, options=T.unsafe(nil)); end

  def release_asset(asset_url, options=T.unsafe(nil)); end

  def release_assets(release_url, options=T.unsafe(nil)); end

  def release_for_tag(repo, tag_name, options=T.unsafe(nil)); end

  def releases(repo, options=T.unsafe(nil)); end

  def update_release(url, options=T.unsafe(nil)); end

  def update_release_asset(asset_url, options=T.unsafe(nil)); end

  def upload_asset(release_url, path_or_file, options=T.unsafe(nil)); end
end

module Octokit::Client::Releases
end

module Octokit::Client::Repositories
  def add_collab(repo, collaborator, options=T.unsafe(nil)); end

  def add_collaborator(repo, collaborator, options=T.unsafe(nil)); end

  def add_deploy_key(repo, title, key, options=T.unsafe(nil)); end

  def all_repositories(options=T.unsafe(nil)); end

  def branch(repo, branch, options=T.unsafe(nil)); end

  def branch_protection(repo, branch, options=T.unsafe(nil)); end

  def branches(repo, options=T.unsafe(nil)); end

  def check_assignee(repo, assignee, options=T.unsafe(nil)); end

  def collaborator?(repo, collaborator, options=T.unsafe(nil)); end

  def collaborators(repo, options=T.unsafe(nil)); end

  def collabs(repo, options=T.unsafe(nil)); end

  def contribs(repo, anon=T.unsafe(nil), options=T.unsafe(nil)); end

  def contributors(repo, anon=T.unsafe(nil), options=T.unsafe(nil)); end

  def create(name, options=T.unsafe(nil)); end

  def create_repo(name, options=T.unsafe(nil)); end

  def create_repo_from_template(repo, name, options=T.unsafe(nil)); end

  def create_repository(name, options=T.unsafe(nil)); end

  def create_repository_from_template(repo, name, options=T.unsafe(nil)); end

  def delete_repo(repo, options=T.unsafe(nil)); end

  def delete_repository(repo, options=T.unsafe(nil)); end

  def delete_subscription(repo, options=T.unsafe(nil)); end

  def deploy_key(repo, id, options=T.unsafe(nil)); end

  def deploy_keys(repo, options=T.unsafe(nil)); end

  def edit(repo, options=T.unsafe(nil)); end

  def edit_deploy_key(repo, id, options); end

  def edit_repository(repo, options=T.unsafe(nil)); end

  def fork(repo, options=T.unsafe(nil)); end

  def forks(repo, options=T.unsafe(nil)); end

  def get_branch(repo, branch, options=T.unsafe(nil)); end

  def languages(repo, options=T.unsafe(nil)); end

  def list_deploy_keys(repo, options=T.unsafe(nil)); end

  def list_repos(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_repositories(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def network(repo, options=T.unsafe(nil)); end

  def permission_level(repo, collaborator, options=T.unsafe(nil)); end

  def protect_branch(repo, branch, options=T.unsafe(nil)); end

  def remove_collab(repo, collaborator, options=T.unsafe(nil)); end

  def remove_collaborator(repo, collaborator, options=T.unsafe(nil)); end

  def remove_deploy_key(repo, id, options=T.unsafe(nil)); end

  def replace_all_topics(repo, names, options=T.unsafe(nil)); end

  def repo(repo, options=T.unsafe(nil)); end

  def repo_assignees(repo, options=T.unsafe(nil)); end

  def repo_teams(repo, options=T.unsafe(nil)); end

  def repos(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def repositories(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def repository(repo, options=T.unsafe(nil)); end

  def repository?(repo, options=T.unsafe(nil)); end

  def repository_assignees(repo, options=T.unsafe(nil)); end

  def repository_teams(repo, options=T.unsafe(nil)); end

  def set_private(repo, options=T.unsafe(nil)); end

  def set_public(repo, options=T.unsafe(nil)); end

  def star(repo, options=T.unsafe(nil)); end

  def stargazers(repo, options=T.unsafe(nil)); end

  def subscribers(repo, options=T.unsafe(nil)); end

  def subscription(repo, options=T.unsafe(nil)); end

  def tags(repo, options=T.unsafe(nil)); end

  def teams(repo, options=T.unsafe(nil)); end

  def topics(repo, options=T.unsafe(nil)); end

  def transfer_repo(repo, new_owner, options=T.unsafe(nil)); end

  def transfer_repository(repo, new_owner, options=T.unsafe(nil)); end

  def unprotect_branch(repo, branch, options=T.unsafe(nil)); end

  def unstar(repo, options=T.unsafe(nil)); end

  def unwatch(repo, options=T.unsafe(nil)); end

  def update(repo, options=T.unsafe(nil)); end

  def update_deploy_key(repo, id, options); end

  def update_repository(repo, options=T.unsafe(nil)); end

  def update_subscription(repo, options=T.unsafe(nil)); end

  def watch(repo, options=T.unsafe(nil)); end

  def watchers(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Repositories
end

module Octokit::Client::RepositoryInvitations
  def accept_repo_invitation(invitation_id, options=T.unsafe(nil)); end

  def accept_repository_invitation(invitation_id, options=T.unsafe(nil)); end

  def decline_invitation(invitation_id, options=T.unsafe(nil)); end

  def decline_repository_invitation(invitation_id, options=T.unsafe(nil)); end

  def delete_repo_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def delete_repository_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def invite_user_to_repo(repo, user, options=T.unsafe(nil)); end

  def invite_user_to_repository(repo, user, options=T.unsafe(nil)); end

  def repo_invitations(repo, options=T.unsafe(nil)); end

  def repository_invitations(repo, options=T.unsafe(nil)); end

  def update_repo_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def update_repository_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def user_repo_invitations(options=T.unsafe(nil)); end

  def user_repository_invitations(options=T.unsafe(nil)); end
end

module Octokit::Client::RepositoryInvitations
end

module Octokit::Client::Reviews
  def create_pull_request_review(repo, number, options=T.unsafe(nil)); end

  def delete_pull_request_review(repo, number, review, options=T.unsafe(nil)); end

  def delete_pull_request_review_request(repo, id, reviewers=T.unsafe(nil), options=T.unsafe(nil)); end

  def dismiss_pull_request_review(repo, number, review, message, options=T.unsafe(nil)); end

  def pull_request_review(repo, number, review, options=T.unsafe(nil)); end

  def pull_request_review_comments(repo, number, review, options=T.unsafe(nil)); end

  def pull_request_review_requests(repo, number, options=T.unsafe(nil)); end

  def pull_request_reviews(repo, number, options=T.unsafe(nil)); end

  def request_pull_request_review(repo, number, reviewers=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_pull_request_review(repo, number, review, event, options=T.unsafe(nil)); end

  def update_pull_request_review(repo, number, review, body, options=T.unsafe(nil)); end
end

module Octokit::Client::Reviews
end

module Octokit::Client::Say
  def octocat(text=T.unsafe(nil), options=T.unsafe(nil)); end

  def say(text=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Say
end

module Octokit::Client::Search
  def search_code(query, options=T.unsafe(nil)); end

  def search_commits(query, options=T.unsafe(nil)); end

  def search_issues(query, options=T.unsafe(nil)); end

  def search_repos(query, options=T.unsafe(nil)); end

  def search_repositories(query, options=T.unsafe(nil)); end

  def search_users(query, options=T.unsafe(nil)); end
end

module Octokit::Client::Search
end

module Octokit::Client::ServiceStatus
  def github_status(); end

  def github_status_last_message(); end

  def github_status_messages(); end
  STATUS_ROOT = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::ServiceStatus
end

module Octokit::Client::SourceImport
  def cancel_source_import(repo, options=T.unsafe(nil)); end

  def map_source_import_commit_author(author_url, values, options=T.unsafe(nil)); end

  def set_source_import_lfs_preference(repo, use_lfs, options=T.unsafe(nil)); end

  def source_import_commit_authors(repo, options=T.unsafe(nil)); end

  def source_import_large_files(repo, options=T.unsafe(nil)); end

  def source_import_progress(repo, options=T.unsafe(nil)); end

  def start_source_import(*args); end

  def update_source_import(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::SourceImport
end

module Octokit::Client::Stats
  def code_frequency_stats(repo, options=T.unsafe(nil)); end

  def commit_activity_stats(repo, options=T.unsafe(nil)); end

  def contributor_stats(repo, options=T.unsafe(nil)); end

  def contributors_stats(repo, options=T.unsafe(nil)); end

  def participation_stats(repo, options=T.unsafe(nil)); end

  def punch_card(repo, options=T.unsafe(nil)); end

  def punch_card_stats(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Stats
end

module Octokit::Client::Statuses
  def combined_status(repo, ref, options=T.unsafe(nil)); end

  def create_status(repo, sha, state, options=T.unsafe(nil)); end

  def list_statuses(repo, sha, options=T.unsafe(nil)); end

  def status(repo, ref, options=T.unsafe(nil)); end

  def statuses(repo, sha, options=T.unsafe(nil)); end
end

module Octokit::Client::Statuses
end

module Octokit::Client::Traffic
  def clones(repo, options=T.unsafe(nil)); end

  def top_paths(repo, options=T.unsafe(nil)); end

  def top_referrers(repo, options=T.unsafe(nil)); end

  def views(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Traffic
end

module Octokit::Client::Users
  def add_email(email, options=T.unsafe(nil)); end

  def add_key(title, key, options=T.unsafe(nil)); end

  def all_users(options=T.unsafe(nil)); end

  def emails(options=T.unsafe(nil)); end

  def exchange_code_for_token(code, app_id=T.unsafe(nil), app_secret=T.unsafe(nil), options=T.unsafe(nil)); end

  def follow(user, options=T.unsafe(nil)); end

  def followers(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def following(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def follows?(*args); end

  def key(key_id, options=T.unsafe(nil)); end

  def keys(options=T.unsafe(nil)); end

  def remove_email(email); end

  def remove_key(id, options=T.unsafe(nil)); end

  def starred(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def starred?(repo, options=T.unsafe(nil)); end

  def subscriptions(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def unfollow(user, options=T.unsafe(nil)); end

  def update_key(key_id, options=T.unsafe(nil)); end

  def update_user(options); end

  def user(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def user_keys(user, options=T.unsafe(nil)); end

  def validate_credentials(options=T.unsafe(nil)); end

  def watched(user=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Users
end

class Octokit::Client
end

class Octokit::ClientError
end

class Octokit::ClientError
end

module Octokit::Configurable
  def access_token(); end

  def access_token=(access_token); end

  def api_endpoint(); end

  def api_endpoint=(api_endpoint); end

  def auto_paginate(); end

  def auto_paginate=(auto_paginate); end

  def bearer_token(); end

  def bearer_token=(bearer_token); end

  def client_id(); end

  def client_id=(client_id); end

  def client_secret(); end

  def client_secret=(client_secret); end

  def configure(); end

  def connection_options(); end

  def connection_options=(connection_options); end

  def default_media_type(); end

  def default_media_type=(default_media_type); end

  def login(); end

  def login=(login); end

  def management_console_endpoint(); end

  def management_console_endpoint=(management_console_endpoint); end

  def management_console_password=(management_console_password); end

  def middleware(); end

  def middleware=(middleware); end

  def netrc(); end

  def netrc=(netrc); end

  def netrc?(); end

  def netrc_file(); end

  def netrc_file=(netrc_file); end

  def password=(password); end

  def per_page(); end

  def per_page=(per_page); end

  def proxy(); end

  def proxy=(proxy); end

  def reset!(); end

  def same_options?(opts); end

  def setup(); end

  def ssl_verify_mode(); end

  def ssl_verify_mode=(ssl_verify_mode); end

  def user_agent(); end

  def user_agent=(user_agent); end

  def web_endpoint(); end

  def web_endpoint=(web_endpoint); end
end

module Octokit::Configurable
  def self.keys(); end
end

class Octokit::Conflict
end

class Octokit::Conflict
end

module Octokit::Connection
  include ::Octokit::Authentication
  def agent(); end

  def delete(url, options=T.unsafe(nil)); end

  def endpoint(); end

  def get(url, options=T.unsafe(nil)); end

  def head(url, options=T.unsafe(nil)); end

  def last_response(); end

  def paginate(url, options=T.unsafe(nil), &block); end

  def patch(url, options=T.unsafe(nil)); end

  def post(url, options=T.unsafe(nil)); end

  def put(url, options=T.unsafe(nil)); end

  def root(); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Connection
end

module Octokit::Default
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
  MEDIA_TYPE = ::T.let(nil, ::T.untyped)
  MIDDLEWARE = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  WEB_ENDPOINT = ::T.let(nil, ::T.untyped)
end

Octokit::Default::RACK_BUILDER_CLASS = Faraday::RackBuilder

module Octokit::Default
  def self.access_token(); end

  def self.api_endpoint(); end

  def self.auto_paginate(); end

  def self.bearer_token(); end

  def self.client_id(); end

  def self.client_secret(); end

  def self.connection_options(); end

  def self.default_media_type(); end

  def self.login(); end

  def self.management_console_endpoint(); end

  def self.management_console_password(); end

  def self.middleware(); end

  def self.netrc(); end

  def self.netrc_file(); end

  def self.options(); end

  def self.password(); end

  def self.per_page(); end

  def self.proxy(); end

  def self.ssl_verify_mode(); end

  def self.user_agent(); end

  def self.web_endpoint(); end
end

class Octokit::EnterpriseAdminClient
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Warnable
  include ::Octokit::EnterpriseAdminClient::AdminStats
  include ::Octokit::EnterpriseAdminClient::License
  include ::Octokit::EnterpriseAdminClient::Orgs
  include ::Octokit::EnterpriseAdminClient::SearchIndexing
  include ::Octokit::EnterpriseAdminClient::Users
  def initialize(options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::AdminStats
  def admin_comments_stats(); end

  def admin_gists_stats(); end

  def admin_hooks_stats(); end

  def admin_issues_stats(); end

  def admin_milestones_stats(); end

  def admin_organization_stats(); end

  def admin_pages_stats(); end

  def admin_pull_requests_stats(); end

  def admin_repository_stats(); end

  def admin_stats(); end

  def admin_users_stats(); end
end

module Octokit::EnterpriseAdminClient::AdminStats
end

module Octokit::EnterpriseAdminClient::License
  def license_info(); end
end

module Octokit::EnterpriseAdminClient::License
end

module Octokit::EnterpriseAdminClient::Orgs
  def create_organization(login, admin, options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::Orgs
end

module Octokit::EnterpriseAdminClient::SearchIndexing
  def index_organization(user); end

  def index_organizations_repositories(user); end

  def index_organizations_repositories_code(user); end

  def index_organizations_repositories_issues(user); end

  def index_repository(repo); end

  def index_repository_code(repo); end

  def index_repository_issues(repo); end

  def index_user(user); end

  def index_users_repositories(user); end

  def index_users_repositories_code(user); end

  def index_users_repositories_issues(user); end
end

module Octokit::EnterpriseAdminClient::SearchIndexing
end

module Octokit::EnterpriseAdminClient::Users
  def create_impersonation_token(login, options=T.unsafe(nil)); end

  def create_user(login, email, options=T.unsafe(nil)); end

  def delete_impersonation_token(login, options=T.unsafe(nil)); end

  def delete_key(id, options=T.unsafe(nil)); end

  def delete_user(username, options=T.unsafe(nil)); end

  def demote(user, options=T.unsafe(nil)); end

  def list_all_keys(options=T.unsafe(nil)); end

  def promote(user, options=T.unsafe(nil)); end

  def rename_user(old_login, new_login, options=T.unsafe(nil)); end

  def suspend(user, options=T.unsafe(nil)); end

  def unsuspend(user, options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::Users
end

class Octokit::EnterpriseAdminClient
end

class Octokit::EnterpriseManagementConsoleClient
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Warnable
  include ::Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  def initialize(options=T.unsafe(nil)); end

  def management_console_endpoint=(value); end

  def management_console_password=(value); end
end

module Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  def add_authorized_key(key); end

  def authorized_keys(); end

  def config_check(); end

  def config_status(); end

  def delete_authorized_key(key); end

  def edit_maintenance_status(maintenance); end

  def edit_settings(settings); end

  def get_authorized_keys(); end

  def get_maintenance_status(); end

  def get_settings(); end

  def maintenance_status(); end

  def remove_authorized_key(key); end

  def set_maintenance_status(maintenance); end

  def settings(); end

  def start_configuration(); end

  def upgrade(license); end

  def upload_license(license, settings=T.unsafe(nil)); end
end

module Octokit::EnterpriseManagementConsoleClient::ManagementConsole
end

class Octokit::EnterpriseManagementConsoleClient
end

class Octokit::Error
  def documentation_url(); end

  def errors(); end

  def initialize(response=T.unsafe(nil)); end

  def response_body(); end

  def response_headers(); end

  def response_status(); end
end

class Octokit::Error
  def self.error_for_401(headers); end

  def self.error_for_403(body); end

  def self.error_for_404(body); end

  def self.from_response(response); end
end

class Octokit::Forbidden
end

class Octokit::Forbidden
end

class Octokit::Gist
  def id(); end

  def id=(id); end

  def initialize(gist); end

  def url(); end
end

class Octokit::Gist
  def self.from_url(url); end
end

class Octokit::InternalServerError
end

class Octokit::InternalServerError
end

class Octokit::InvalidRepository
end

class Octokit::InvalidRepository
end

class Octokit::MethodNotAllowed
end

class Octokit::MethodNotAllowed
end

module Octokit::Middleware
end

class Octokit::Middleware::FollowRedirects
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  ENV_TO_CLEAR = ::T.let(nil, ::T.untyped)
  FOLLOW_LIMIT = ::T.let(nil, ::T.untyped)
  REDIRECT_CODES = ::T.let(nil, ::T.untyped)
  URI_UNSAFE = ::T.let(nil, ::T.untyped)
end

class Octokit::Middleware::FollowRedirects
end

class Octokit::Middleware::RedirectLimitReached
  def initialize(response); end
end

class Octokit::Middleware::RedirectLimitReached
end

module Octokit::Middleware
end

class Octokit::MissingContentType
end

class Octokit::MissingContentType
end

class Octokit::NotAcceptable
end

class Octokit::NotAcceptable
end

class Octokit::NotFound
end

class Octokit::NotFound
end

class Octokit::NotImplemented
end

class Octokit::NotImplemented
end

class Octokit::OneTimePasswordRequired
  def password_delivery(); end
  OTP_DELIVERY_PATTERN = ::T.let(nil, ::T.untyped)
end

class Octokit::OneTimePasswordRequired
  def self.required_header(headers); end
end

class Octokit::Organization
end

class Octokit::Organization
  def self.path(org); end
end

module Octokit::Preview
  def ensure_api_media_type(type, options); end

  def warn_preview(type); end
  PREVIEW_TYPES = ::T.let(nil, ::T.untyped)
end

module Octokit::Preview
end

class Octokit::RateLimit
end

class Octokit::RateLimit
  def self.from_response(response); end
end

class Octokit::RepoArguments
  def repo(); end
end

class Octokit::RepoArguments
end

class Octokit::Repository
  def id(); end

  def id=(id); end

  def id_api_path(); end

  def initialize(repo); end

  def name(); end

  def name=(name); end

  def named_api_path(); end

  def owner(); end

  def owner=(owner); end

  def path(); end

  def repo(); end

  def slug(); end

  def url(); end

  def user(); end

  def username(); end
  NAME_WITH_OWNER_PATTERN = ::T.let(nil, ::T.untyped)
end

class Octokit::Repository
  def self.from_url(url); end

  def self.path(repo); end
end

class Octokit::RepositoryUnavailable
end

class Octokit::RepositoryUnavailable
end

module Octokit::Response
end

class Octokit::Response::FeedParser
end

class Octokit::Response::FeedParser
end

class Octokit::Response::RaiseError
end

class Octokit::Response::RaiseError
end

module Octokit::Response
end

class Octokit::SAMLProtected
end

class Octokit::SAMLProtected
end

class Octokit::ServerError
end

class Octokit::ServerError
end

class Octokit::ServiceUnavailable
end

class Octokit::ServiceUnavailable
end

class Octokit::TooLargeContent
end

class Octokit::TooLargeContent
end

class Octokit::TooManyLoginAttempts
end

class Octokit::TooManyLoginAttempts
end

class Octokit::TooManyRequests
end

class Octokit::TooManyRequests
end

class Octokit::Unauthorized
end

class Octokit::Unauthorized
end

class Octokit::UnavailableForLegalReasons
end

class Octokit::UnavailableForLegalReasons
end

class Octokit::UnprocessableEntity
end

class Octokit::UnprocessableEntity
end

class Octokit::UnsupportedMediaType
end

class Octokit::UnsupportedMediaType
end

class Octokit::UnverifiedEmail
end

class Octokit::UnverifiedEmail
end

class Octokit::User
end

class Octokit::User
  def self.path(user); end
end

module Octokit::Warnable
  def octokit_warn(*message); end
end

module Octokit::Warnable
end

module Octokit
  extend ::Octokit::Configurable
  def self.client(); end

  def self.enterprise_admin_client(); end

  def self.enterprise_management_console_client(); end
end

module Oj
  VERSION = ::T.let(nil, ::T.untyped)
end

class Oj::Bag
  def ==(other); end

  def eql?(other); end

  def initialize(args=T.unsafe(nil)); end

  def method_missing(m, *args, &block); end

  def respond_to?(m); end
end

class Oj::Bag
  def self.define_class(classname); end
end

class Oj::CStack
end

class Oj::CStack
end

class Oj::DepthError
end

class Oj::DepthError
end

class Oj::Doc
  def clone(); end

  def close(); end

  def dump(*_); end

  def each_child(*_); end

  def each_leaf(*_); end

  def each_value(*_); end

  def fetch(*_); end

  def home(); end

  def local_key(); end

  def move(_); end

  def size(); end

  def type(*_); end

  def where?(); end
end

class Oj::Doc
  def self.open(_); end

  def self.open_file(_); end

  def self.parse(_); end
end

class Oj::EasyHash
  def [](key); end

  def initialize(); end

  def method_missing(m, *args, &block); end

  def respond_to?(m); end
end

class Oj::EasyHash
end

class Oj::Error
end

class Oj::Error
end

class Oj::LoadError
end

class Oj::LoadError
end

class Oj::MimicDumpOption
  def []=(key, value); end

  def initialize(); end
end

class Oj::MimicDumpOption
end

class Oj::MimicError
end

class Oj::MimicError
end

class Oj::ParseError
end

class Oj::ParseError
end

module Oj::Rails
end

class Oj::Rails::Encoder
  def deoptimize(*_); end

  def encode(_); end

  def optimize(*_); end

  def optimized?(_); end
end

class Oj::Rails::Encoder
end

module Oj::Rails
  def self.deoptimize(*_); end

  def self.encode(*_); end

  def self.mimic_JSON(); end

  def self.optimize(*_); end

  def self.optimized?(_); end

  def self.set_decoder(); end

  def self.set_encoder(); end
end

class Oj::Saj
end

class Oj::Saj
end

class Oj::ScHandler
end

class Oj::ScHandler
end

class Oj::StreamWriter
  def flush(); end

  def pop(); end

  def pop_all(); end

  def push_array(*_); end

  def push_json(*_); end

  def push_key(_); end

  def push_object(*_); end

  def push_value(*_); end
end

class Oj::StreamWriter
end

class Oj::StringWriter
  def as_json(); end

  def pop(); end

  def pop_all(); end

  def push_array(*_); end

  def push_json(*_); end

  def push_key(_); end

  def push_object(*_); end

  def push_value(*_); end

  def raw_json(); end

  def reset(); end
end

class Oj::StringWriter
end

module Oj
  def self.add_to_json(*_); end

  def self.compat_load(*_); end

  def self.default_options(); end

  def self.default_options=(default_options); end

  def self.dump(*_); end

  def self.fast_generate(*_); end

  def self.generate(*_); end

  def self.load(*_); end

  def self.load_file(*_); end

  def self.mimic_JSON(*_); end

  def self.mimic_loaded(mimic_paths=T.unsafe(nil)); end

  def self.object_load(*_); end

  def self.optimize_rails(); end

  def self.register_odd(*_); end

  def self.register_odd_raw(*_); end

  def self.remove_to_json(*_); end

  def self.safe_load(_); end

  def self.saj_parse(*_); end

  def self.sc_parse(*_); end

  def self.strict_load(*_); end

  def self.to_file(*_); end

  def self.to_json(*_); end

  def self.to_stream(*_); end

  def self.wab_load(*_); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module OpenURI
  Options = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end

  def io(); end
end

class OpenURI::HTTPError
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end

  def uri(); end
end

class OpenURI::HTTPRedirect
end

module OpenURI::Meta
  def base_uri(); end

  def base_uri=(base_uri); end

  def charset(); end

  def content_encoding(); end

  def content_type(); end

  def content_type_parse(); end

  def last_modified(); end

  def meta(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end

  def metas(); end

  def status(); end

  def status=(status); end
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
end

module OpenURI::Meta
  def self.init(obj, src=T.unsafe(nil)); end
end

module OpenURI::OpenRead
  def open(*rest, &block); end

  def read(options=T.unsafe(nil)); end
end

module OpenURI::OpenRead
end

module OpenURI
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

class Operation
  def after_add_for_job_associations(); end

  def after_add_for_job_associations=(after_add_for_job_associations); end

  def after_add_for_job_associations?(); end

  def after_add_for_jobs(); end

  def after_add_for_jobs=(after_add_for_jobs); end

  def after_add_for_jobs?(); end

  def after_add_for_plan_associations(); end

  def after_add_for_plan_associations=(after_add_for_plan_associations); end

  def after_add_for_plan_associations?(); end

  def after_add_for_plans(); end

  def after_add_for_plans=(after_add_for_plans); end

  def after_add_for_plans?(); end

  def after_remove_for_job_associations(); end

  def after_remove_for_job_associations=(after_remove_for_job_associations); end

  def after_remove_for_job_associations?(); end

  def after_remove_for_jobs(); end

  def after_remove_for_jobs=(after_remove_for_jobs); end

  def after_remove_for_jobs?(); end

  def after_remove_for_plan_associations(); end

  def after_remove_for_plan_associations=(after_remove_for_plan_associations); end

  def after_remove_for_plan_associations?(); end

  def after_remove_for_plans(); end

  def after_remove_for_plans=(after_remove_for_plans); end

  def after_remove_for_plans?(); end

  def autosave_associated_records_for_job_associations(*args); end

  def autosave_associated_records_for_jobs(*args); end

  def autosave_associated_records_for_operation_type(*args); end

  def autosave_associated_records_for_plan_associations(*args); end

  def autosave_associated_records_for_plans(*args); end

  def autosave_associated_records_for_user(*args); end

  def before_add_for_job_associations(); end

  def before_add_for_job_associations=(before_add_for_job_associations); end

  def before_add_for_job_associations?(); end

  def before_add_for_jobs(); end

  def before_add_for_jobs=(before_add_for_jobs); end

  def before_add_for_jobs?(); end

  def before_add_for_plan_associations(); end

  def before_add_for_plan_associations=(before_add_for_plan_associations); end

  def before_add_for_plan_associations?(); end

  def before_add_for_plans(); end

  def before_add_for_plans=(before_add_for_plans); end

  def before_add_for_plans?(); end

  def before_remove_for_job_associations(); end

  def before_remove_for_job_associations=(before_remove_for_job_associations); end

  def before_remove_for_job_associations?(); end

  def before_remove_for_jobs(); end

  def before_remove_for_jobs=(before_remove_for_jobs); end

  def before_remove_for_jobs?(); end

  def before_remove_for_plan_associations(); end

  def before_remove_for_plan_associations=(before_remove_for_plan_associations); end

  def before_remove_for_plan_associations?(); end

  def before_remove_for_plans(); end

  def before_remove_for_plans=(before_remove_for_plans); end

  def before_remove_for_plans?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_job_associations(*args); end

  def validate_associated_records_for_jobs(*args); end

  def validate_associated_records_for_plan_associations(*args); end

  def validate_associated_records_for_plans(*args); end
end

class Operation::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Operation::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Operation::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Operation::GeneratedAssociationMethods
  def build_operation_type(*args, &block); end

  def build_user(*args, &block); end

  def create_operation_type(*args, &block); end

  def create_operation_type!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def job_association_ids(); end

  def job_association_ids=(ids); end

  def job_ids(); end

  def job_ids=(ids); end

  def plan_association_ids(); end

  def plan_association_ids=(ids); end

  def plan_ids(); end

  def plan_ids=(ids); end
end

class Operation
  def self.after_add_for_job_associations(); end

  def self.after_add_for_job_associations=(val); end

  def self.after_add_for_job_associations?(); end

  def self.after_add_for_jobs(); end

  def self.after_add_for_jobs=(val); end

  def self.after_add_for_jobs?(); end

  def self.after_add_for_plan_associations(); end

  def self.after_add_for_plan_associations=(val); end

  def self.after_add_for_plan_associations?(); end

  def self.after_add_for_plans(); end

  def self.after_add_for_plans=(val); end

  def self.after_add_for_plans?(); end

  def self.after_remove_for_job_associations(); end

  def self.after_remove_for_job_associations=(val); end

  def self.after_remove_for_job_associations?(); end

  def self.after_remove_for_jobs(); end

  def self.after_remove_for_jobs=(val); end

  def self.after_remove_for_jobs?(); end

  def self.after_remove_for_plan_associations(); end

  def self.after_remove_for_plan_associations=(val); end

  def self.after_remove_for_plan_associations?(); end

  def self.after_remove_for_plans(); end

  def self.after_remove_for_plans=(val); end

  def self.after_remove_for_plans?(); end

  def self.before_add_for_job_associations(); end

  def self.before_add_for_job_associations=(val); end

  def self.before_add_for_job_associations?(); end

  def self.before_add_for_jobs(); end

  def self.before_add_for_jobs=(val); end

  def self.before_add_for_jobs?(); end

  def self.before_add_for_plan_associations(); end

  def self.before_add_for_plan_associations=(val); end

  def self.before_add_for_plan_associations?(); end

  def self.before_add_for_plans(); end

  def self.before_add_for_plans=(val); end

  def self.before_add_for_plans?(); end

  def self.before_remove_for_job_associations(); end

  def self.before_remove_for_job_associations=(val); end

  def self.before_remove_for_job_associations?(); end

  def self.before_remove_for_jobs(); end

  def self.before_remove_for_jobs=(val); end

  def self.before_remove_for_jobs?(); end

  def self.before_remove_for_plan_associations(); end

  def self.before_remove_for_plan_associations=(val); end

  def self.before_remove_for_plan_associations?(); end

  def self.before_remove_for_plans(); end

  def self.before_remove_for_plans=(val); end

  def self.before_remove_for_plans?(); end
end

class OperationType
  def after_add_for_operations(); end

  def after_add_for_operations=(after_add_for_operations); end

  def after_add_for_operations?(); end

  def after_remove_for_operations(); end

  def after_remove_for_operations=(after_remove_for_operations); end

  def after_remove_for_operations?(); end

  def autosave_associated_records_for_operations(*args); end

  def before_add_for_operations(); end

  def before_add_for_operations=(before_add_for_operations); end

  def before_add_for_operations?(); end

  def before_remove_for_operations(); end

  def before_remove_for_operations=(before_remove_for_operations); end

  def before_remove_for_operations?(); end

  def validate_associated_records_for_operations(*args); end
end

class OperationType::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class OperationType::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class OperationType::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module OperationType::GeneratedAssociationMethods
  def operation_ids(); end

  def operation_ids=(ids); end
end

class OperationType
  extend ::OperationTypeExport::ClassMethods
  def self.after_add_for_operations(); end

  def self.after_add_for_operations=(val); end

  def self.after_add_for_operations?(); end

  def self.after_remove_for_operations(); end

  def self.after_remove_for_operations=(val); end

  def self.after_remove_for_operations?(); end

  def self.before_add_for_operations(); end

  def self.before_add_for_operations=(val); end

  def self.before_add_for_operations?(); end

  def self.before_remove_for_operations(); end

  def self.before_remove_for_operations=(val); end

  def self.before_remove_for_operations?(); end
end

module Paperclip
  REQUIRED_VALIDATORS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Paperclip::AbstractAdapter
  def tempfile(); end
  OS_RESTRICTED_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Paperclip::ContentTypeDetector
  EMPTY_TYPE = ::T.let(nil, ::T.untyped)
  SENSIBLE_DEFAULT = ::T.let(nil, ::T.untyped)
end

class Paperclip::DataUriAdapter
  REGEXP = ::T.let(nil, ::T.untyped)
end

class Paperclip::FileCommandContentTypeDetector
  SENSIBLE_DEFAULT = ::T.let(nil, ::T.untyped)
end

class Paperclip::Geometry
  EXIF_ROTATED_ORIENTATION_VALUES = ::T.let(nil, ::T.untyped)
end

class Paperclip::GeometryParser
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Paperclip::HttpUrlProxyAdapter
  REGEXP = ::T.let(nil, ::T.untyped)
end

module Paperclip::Interpolations
  ID_PARTITION_LIMIT = ::T.let(nil, ::T.untyped)
  RIGHT_HERE = ::T.let(nil, ::T.untyped)
end

class Paperclip::Railtie
end

module Paperclip::Schema
  COLUMNS = ::T.let(nil, ::T.untyped)
end

module Paperclip::Storage::Fog
  AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX = ::T.let(nil, ::T.untyped)
end

class Paperclip::Tempfile
  def make_tmpname(prefix_suffix, n); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Paperclip::Tempfile
end

class Paperclip::Thumbnail
  ANIMATED_FORMATS = ::T.let(nil, ::T.untyped)
  MULTI_FRAME_FORMATS = ::T.let(nil, ::T.untyped)
end

module Paperclip::Validators
  extend ::ActiveSupport::Concern
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

class Parameter
  def autosave_associated_records_for_user(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class Parameter::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Parameter::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Parameter::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Parameter::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end
end

module Parlour
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parlour::ConflictResolver
  def resolve_conflicts(*args, &blk); end
end

class Parlour::ConflictResolver
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::Debugging
end

module Parlour::Debugging::Tree
  INDENT_SPACES = ::T.let(nil, ::T.untyped)
end

module Parlour::Debugging::Tree
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.begin(*args, &blk); end

  def self.end(*args, &blk); end

  def self.here(*args, &blk); end

  def self.line_prefix(); end

  def self.text_prefix(); end
end

module Parlour::Debugging
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.debug_mode=(*args, &blk); end

  def self.debug_mode?(*args, &blk); end

  def self.debug_puts(*args, &blk); end

  def self.name_for_debug_caller(*args, &blk); end
end

class Parlour::Plugin
  def generate(*args, &blk); end

  def initialize(*args, &blk); end

  def strictness(*args, &blk); end

  def strictness=(strictness); end
end

class Parlour::Plugin
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.inherited(*args, &blk); end

  def self.registered_plugins(*args, &blk); end

  def self.run_plugins(*args, &blk); end
end

class Parlour::RbiGenerator
  def current_plugin(*args, &blk); end

  def current_plugin=(current_plugin); end

  def initialize(*args, &blk); end

  def options(*args, &blk); end

  def rbi(*args, &blk); end

  def root(*args, &blk); end
end

class Parlour::RbiGenerator::Arbitrary
  def ==(*args, &blk); end

  def code(*args, &blk); end

  def code=(code); end
end

class Parlour::RbiGenerator::Arbitrary
end

class Parlour::RbiGenerator::Attribute
  def class_attribute(*args, &blk); end

  def kind(*args, &blk); end
end

class Parlour::RbiGenerator::Attribute
end

class Parlour::RbiGenerator::ClassNamespace
  def abstract(*args, &blk); end

  def superclass(*args, &blk); end
end

class Parlour::RbiGenerator::ClassNamespace
end

class Parlour::RbiGenerator::Constant
  def ==(*args, &blk); end

  def value(*args, &blk); end
end

class Parlour::RbiGenerator::Constant
end

class Parlour::RbiGenerator::Extend
  def ==(*args, &blk); end
end

class Parlour::RbiGenerator::Extend
end

class Parlour::RbiGenerator::Include
  def ==(*args, &blk); end
end

class Parlour::RbiGenerator::Include
end

class Parlour::RbiGenerator::Method
  def ==(*args, &blk); end

  def abstract(*args, &blk); end

  def class_method(*args, &blk); end

  def implementation(*args, &blk); end

  def overridable(*args, &blk); end

  def override(*args, &blk); end

  def parameters(*args, &blk); end

  def return_type(*args, &blk); end

  def type_parameters(*args, &blk); end
end

class Parlour::RbiGenerator::Method
end

class Parlour::RbiGenerator::ModuleNamespace
  def interface(*args, &blk); end
end

class Parlour::RbiGenerator::ModuleNamespace
end

class Parlour::RbiGenerator::Namespace
  def add_comment_to_next_child(*args, &blk); end

  def children(*args, &blk); end

  def constants(*args, &blk); end

  def create_arbitrary(code:, &block); end

  def create_attr(*args, &blk); end

  def create_attr_accessor(*args, &blk); end

  def create_attr_reader(*args, &blk); end

  def create_attr_writer(*args, &blk); end

  def create_attribute(*args, &blk); end

  def create_class(*args, &blk); end

  def create_constant(*args, &blk); end

  def create_extend(*args, &blk); end

  def create_extends(*args, &blk); end

  def create_include(*args, &blk); end

  def create_includes(*args, &blk); end

  def create_method(*args, &blk); end

  def create_module(*args, &blk); end

  def extends(*args, &blk); end

  def includes(*args, &blk); end

  def path(*args, &blk); end
end

class Parlour::RbiGenerator::Namespace
end

class Parlour::RbiGenerator::Options
  def break_params(*args, &blk); end

  def indented(*args, &blk); end

  def initialize(*args, &blk); end

  def tab_size(*args, &blk); end
end

class Parlour::RbiGenerator::Options
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::Parameter
  def ==(*args, &blk); end

  def default(*args, &blk); end

  def initialize(*args, &blk); end

  def kind(*args, &blk); end

  def name(*args, &blk); end

  def name_without_kind(*args, &blk); end

  def to_def_param(*args, &blk); end

  def to_sig_param(*args, &blk); end

  def type(*args, &blk); end
  PREFIXES = ::T.let(nil, ::T.untyped)
end

class Parlour::RbiGenerator::Parameter
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::RbiObject
  def add_comment(*args, &blk); end

  def add_comments(*args, &blk); end

  def comments(*args, &blk); end

  def describe(*args, &blk); end

  def generate_rbi(*args, &blk); end

  def generated_by(*args, &blk); end

  def generator(*args, &blk); end

  def initialize(*args, &blk); end

  def merge_into_self(*args, &blk); end

  def mergeable?(*args, &blk); end

  def name(*args, &blk); end
end

class Parlour::RbiGenerator::RbiObject
  extend ::T::Helpers
  extend ::T::Sig
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_def_e(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_defs_e(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_for(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def in_block?(); end

  def in_class?(); end

  def in_dynamic_block?(); end

  def in_lambda?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

class Parser::CurrentArgStack
  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(); end

  def register(numparam); end

  def stack(); end

  def top(); end
end

class Parser::MaxNumparamStack
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*_); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::EndlessDefinition
  def assignment(); end

  def initialize(keyword_l, operator_l, name_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::EndlessDefinition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def diagnostics(); end

  def empty?(); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_forward_args?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

module Parser
end

class PartAssociation
  def autosave_associated_records_for_collection(*args); end

  def autosave_associated_records_for_part(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class PartAssociation::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class PartAssociation::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class PartAssociation::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module PartAssociation::GeneratedAssociationMethods
  def build_collection(*args, &block); end

  def build_part(*args, &block); end

  def create_collection(*args, &block); end

  def create_collection!(*args, &block); end

  def create_part(*args, &block); end

  def create_part!(*args, &block); end
end

module Parts
end

class Parts::EpiloguePart
  include ::Parts::Part
  def initialize(boundary); end
end

class Parts::EpiloguePart
end

class Parts::FilePart
  include ::Parts::Part
  def build_head(boundary, name, filename, type, content_len, opts=T.unsafe(nil)); end

  def initialize(boundary, name, io, headers=T.unsafe(nil)); end
end

class Parts::FilePart
end

class Parts::ParamPart
  include ::Parts::Part
  def build_part(boundary, name, value, headers=T.unsafe(nil)); end

  def initialize(boundary, name, value, headers=T.unsafe(nil)); end
end

class Parts::ParamPart
end

module Parts::Part
  def length(); end

  def to_io(); end
end

module Parts::Part
  def self.file?(value); end

  def self.new(boundary, name, value, headers=T.unsafe(nil)); end
end

module Parts
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Plan
  def after_add_for_operations(); end

  def after_add_for_operations=(after_add_for_operations); end

  def after_add_for_operations?(); end

  def after_add_for_plan_associations(); end

  def after_add_for_plan_associations=(after_add_for_plan_associations); end

  def after_add_for_plan_associations?(); end

  def after_remove_for_operations(); end

  def after_remove_for_operations=(after_remove_for_operations); end

  def after_remove_for_operations?(); end

  def after_remove_for_plan_associations(); end

  def after_remove_for_plan_associations=(after_remove_for_plan_associations); end

  def after_remove_for_plan_associations?(); end

  def autosave_associated_records_for_budget(*args); end

  def autosave_associated_records_for_operations(*args); end

  def autosave_associated_records_for_plan_associations(*args); end

  def autosave_associated_records_for_user(*args); end

  def before_add_for_operations(); end

  def before_add_for_operations=(before_add_for_operations); end

  def before_add_for_operations?(); end

  def before_add_for_plan_associations(); end

  def before_add_for_plan_associations=(before_add_for_plan_associations); end

  def before_add_for_plan_associations?(); end

  def before_remove_for_operations(); end

  def before_remove_for_operations=(before_remove_for_operations); end

  def before_remove_for_operations?(); end

  def before_remove_for_plan_associations(); end

  def before_remove_for_plan_associations=(before_remove_for_plan_associations); end

  def before_remove_for_plan_associations?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_operations(*args); end

  def validate_associated_records_for_plan_associations(*args); end
end

class Plan::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Plan::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Plan::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Plan::GeneratedAssociationMethods
  def build_budget(*args, &block); end

  def build_user(*args, &block); end

  def create_budget(*args, &block); end

  def create_budget!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def operation_ids(); end

  def operation_ids=(ids); end

  def plan_association_ids(); end

  def plan_association_ids=(ids); end
end

class Plan
  def self.after_add_for_operations(); end

  def self.after_add_for_operations=(val); end

  def self.after_add_for_operations?(); end

  def self.after_add_for_plan_associations(); end

  def self.after_add_for_plan_associations=(val); end

  def self.after_add_for_plan_associations?(); end

  def self.after_remove_for_operations(); end

  def self.after_remove_for_operations=(val); end

  def self.after_remove_for_operations?(); end

  def self.after_remove_for_plan_associations(); end

  def self.after_remove_for_plan_associations=(val); end

  def self.after_remove_for_plan_associations?(); end

  def self.before_add_for_operations(); end

  def self.before_add_for_operations=(val); end

  def self.before_add_for_operations?(); end

  def self.before_add_for_plan_associations(); end

  def self.before_add_for_plan_associations=(val); end

  def self.before_add_for_plan_associations?(); end

  def self.before_remove_for_operations(); end

  def self.before_remove_for_operations=(val); end

  def self.before_remove_for_operations?(); end

  def self.before_remove_for_plan_associations(); end

  def self.before_remove_for_plan_associations=(val); end

  def self.before_remove_for_plan_associations?(); end
end

class PlanAssociation
  def autosave_associated_records_for_operation(*args); end

  def autosave_associated_records_for_plan(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class PlanAssociation::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class PlanAssociation::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class PlanAssociation::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module PlanAssociation::GeneratedAssociationMethods
  def build_operation(*args, &block); end

  def build_plan(*args, &block); end

  def create_operation(*args, &block); end

  def create_operation!(*args, &block); end

  def create_plan(*args, &block); end

  def create_plan!(*args, &block); end
end

class Proc
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def yield(*_); end
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

module ProtectedAttributes
  VERSION = ::T.let(nil, ::T.untyped)
end

class ProtectedAttributes::Railtie
end

class ProtectedAttributes::Railtie
end

module ProtectedAttributes
end

class ProtocolTestBase
  include ::Minitest::Assertions
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::Domain
  def domain(); end

  def domain?(); end

  def initialize(*args); end

  def name(); end

  def sld(); end

  def subdomain(); end

  def subdomain?(); end

  def tld(); end

  def to_a(); end

  def trd(); end
end

class PublicSuffix::Domain
  def self.name_to_labels(name); end
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::Error
end

class PublicSuffix::Error
end

class PublicSuffix::List
  def <<(rule); end

  def ==(other); end

  def add(rule); end

  def clear(); end

  def default_rule(); end

  def each(&block); end

  def empty?(); end

  def eql?(other); end

  def find(name, default: T.unsafe(nil), **options); end

  def rules(); end

  def size(); end
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  def self.default(**options); end

  def self.default=(value); end

  def self.parse(input, private_domains: T.unsafe(nil)); end
end

module PublicSuffix::Rule
end

class PublicSuffix::Rule::Base
  def ==(other); end

  def decompose(*_); end

  def eql?(other); end

  def initialize(value:, length: T.unsafe(nil), private: T.unsafe(nil)); end

  def length(); end

  def match?(name); end

  def parts(); end

  def private(); end

  def value(); end
end

class PublicSuffix::Rule::Base
  def self.build(content, private: T.unsafe(nil)); end
end

class PublicSuffix::Rule::Entry
  def length=(_); end

  def private(); end

  def private=(_); end

  def type(); end

  def type=(_); end
end

class PublicSuffix::Rule::Entry
  def self.[](*_); end

  def self.members(); end
end

class PublicSuffix::Rule::Exception
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Exception
end

class PublicSuffix::Rule::Normal
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Normal
end

class PublicSuffix::Rule::Wildcard
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Wildcard
end

module PublicSuffix::Rule
  def self.default(); end

  def self.factory(content, private: T.unsafe(nil)); end
end

module PublicSuffix
  def self.decompose(name, rule); end

  def self.domain(name, **options); end

  def self.normalize(name); end

  def self.parse(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end

  def self.valid?(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end
end

module Puma
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  include ::Puma::Const
  def add_ssl_listener(host, port, ctx, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_tcp_listener(host, port, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_unix_listener(path, umask=T.unsafe(nil), mode=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def close(); end

  def close_listeners(); end

  def close_unix_paths(); end

  def connected_port(); end

  def env(sock); end

  def import_from_env(); end

  def inherit_ssl_listener(fd, ctx); end

  def inherit_tcp_listener(host, port, fd); end

  def inherit_unix_listener(path, fd); end

  def initialize(events); end

  def ios(); end

  def loopback_addresses(); end

  def parse(binds, logger); end

  def redirects_for_restart(); end
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
end

class Puma::Client
  include ::Puma::Const
  def body(); end

  def call(); end

  def close(); end

  def closed?(*args, &block); end

  def eagerly_finish(); end

  def env(); end

  def finish(); end

  def hijacked(); end

  def in_data_phase(); end

  def initialize(io, env=T.unsafe(nil)); end

  def io(); end

  def peerip(); end

  def peerip=(peerip); end

  def ready(); end

  def remote_addr_header(); end

  def remote_addr_header=(remote_addr_header); end

  def reset(fast_check=T.unsafe(nil)); end

  def set_timeout(val); end

  def tempfile(); end

  def timeout_at(); end

  def to_io(); end

  def try_to_finish(); end

  def write_error(status_code); end
  EmptyBody = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  extend ::Forwardable
end

class Puma::Cluster
  def all_workers_booted?(); end

  def check_workers(force=T.unsafe(nil)); end

  def cull_workers(); end

  def halt(); end

  def next_worker_index(); end

  def phased_restart(); end

  def preload?(); end

  def reload_worker_directory(); end

  def restart(); end

  def run(); end

  def setup_signals(); end

  def spawn_workers(); end

  def start_phased_restart(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end

  def stop_workers(); end

  def wakeup!(); end

  def worker(index, master); end
end

class Puma::Cluster::Worker
  def boot!(); end

  def booted?(); end

  def hup(); end

  def index(); end

  def initialize(idx, pid, phase, options); end

  def kill(); end

  def last_checkin(); end

  def last_status(); end

  def phase(); end

  def pid(); end

  def ping!(status); end

  def ping_timeout?(which); end

  def signal(); end

  def started_at(); end

  def term(); end

  def term?(); end
end

class Puma::Cluster::Worker
end

class Puma::Cluster
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

module Puma::ConfigDefault
end

class Puma::Configuration
  include ::Puma::ConfigDefault
  def app(); end

  def app_configured?(); end

  def clamp(); end

  def config_files(); end

  def configure(); end

  def environment(); end

  def environment_str(); end

  def flatten(); end

  def flatten!(); end

  def initialize(user_options=T.unsafe(nil), default_options=T.unsafe(nil), &block); end

  def load(); end

  def load_plugin(name); end

  def options(); end

  def plugins(); end

  def puma_default_options(); end

  def rackup(); end

  def run_hooks(key, arg); end
end

class Puma::Configuration::ConfigMiddleware
  def call(env); end

  def initialize(config, app); end
end

class Puma::Configuration::ConfigMiddleware
end

class Puma::Configuration
  def self.random_token(); end

  def self.temp_path(); end
end

class Puma::ConnectionError
end

class Puma::ConnectionError
end

module Puma::Const
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  FIRST_DATA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_INJECTION_REGEX = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_ADDR = ::T.let(nil, ::T.untyped)
  LOCALHOST_IP = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_FAST_INLINE = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PERSISTENT_TIMEOUT = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WORKER_CHECK_INTERVAL = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Puma::Const
end

class Puma::DSL
  include ::Puma::ConfigDefault
  def _load_from(path); end

  def _offer_plugins(); end

  def activate_control_app(url=T.unsafe(nil), opts=T.unsafe(nil)); end

  def after_worker_boot(&block); end

  def after_worker_fork(&block); end

  def app(obj=T.unsafe(nil), &block); end

  def before_fork(&block); end

  def bind(url); end

  def clean_thread_locals(which=T.unsafe(nil)); end

  def clear_binds!(); end

  def daemonize(which=T.unsafe(nil)); end

  def debug(); end

  def default_host(); end

  def directory(dir); end

  def drain_on_shutdown(which=T.unsafe(nil)); end

  def early_hints(answer=T.unsafe(nil)); end

  def environment(environment); end

  def extra_runtime_dependencies(answer=T.unsafe(nil)); end

  def first_data_timeout(seconds); end

  def force_shutdown_after(val=T.unsafe(nil)); end

  def get(key, default=T.unsafe(nil)); end

  def initialize(options, config); end

  def inject(&blk); end

  def load(file); end

  def log_formatter(&block); end

  def log_requests(which=T.unsafe(nil)); end

  def lowlevel_error_handler(obj=T.unsafe(nil), &block); end

  def on_restart(&block); end

  def on_worker_boot(&block); end

  def on_worker_fork(&block); end

  def on_worker_shutdown(&block); end

  def out_of_band(&block); end

  def persistent_timeout(seconds); end

  def pidfile(path); end

  def plugin(name); end

  def port(port, host=T.unsafe(nil)); end

  def preload_app!(answer=T.unsafe(nil)); end

  def prune_bundler(answer=T.unsafe(nil)); end

  def queue_requests(answer=T.unsafe(nil)); end

  def quiet(which=T.unsafe(nil)); end

  def rackup(path); end

  def raise_exception_on_sigterm(answer=T.unsafe(nil)); end

  def restart_command(cmd); end

  def set_default_host(host); end

  def set_remote_address(val=T.unsafe(nil)); end

  def shutdown_debug(val=T.unsafe(nil)); end

  def ssl_bind(host, port, opts); end

  def state_path(path); end

  def stdout_redirect(stdout=T.unsafe(nil), stderr=T.unsafe(nil), append=T.unsafe(nil)); end

  def tag(string); end

  def tcp_mode(); end

  def tcp_mode!(); end

  def threads(min, max); end

  def worker_boot_timeout(timeout); end

  def worker_directory(dir); end

  def worker_shutdown_timeout(timeout); end

  def worker_timeout(timeout); end

  def workers(count); end
end

class Puma::DSL
end

class Puma::Events
  include ::Puma::Const
  def debug(str); end

  def error(str); end

  def fire(hook, *args); end

  def fire_on_booted!(); end

  def format(str); end

  def formatter(); end

  def formatter=(formatter); end

  def initialize(stdout, stderr); end

  def log(str); end

  def on_booted(&block); end

  def parse_error(server, env, error); end

  def register(hook, obj=T.unsafe(nil), &blk); end

  def ssl_error(server, peeraddr, peercert, error); end

  def stderr(); end

  def stdout(); end

  def unknown_error(server, error, kind=T.unsafe(nil), env=T.unsafe(nil)); end

  def write(str); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puma::Events::DefaultFormatter
  def call(str); end
end

class Puma::Events::DefaultFormatter
end

class Puma::Events::PidFormatter
  def call(str); end
end

class Puma::Events::PidFormatter
end

class Puma::Events
  def self.null(); end

  def self.stdio(); end

  def self.strings(); end
end

class Puma::HttpParser
  def body(); end

  def error?(); end

  def execute(_, _1, _2); end

  def finish(); end

  def finished?(); end

  def nread(); end

  def reset(); end
end

class Puma::HttpParser
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::IOBuffer
  def <<(_); end

  def append(*_); end

  def capacity(); end

  def reset(); end

  def to_str(); end

  def used(); end
end

class Puma::IOBuffer
end

class Puma::Launcher
  def binder(); end

  def close_binder_listeners(); end

  def config(); end

  def connected_port(); end

  def delete_pidfile(); end

  def events(); end

  def halt(); end

  def initialize(conf, launcher_args=T.unsafe(nil)); end

  def options(); end

  def phased_restart(); end

  def restart(); end

  def restart_args(); end

  def restart_dir(); end

  def run(); end

  def stats(); end

  def stop(); end

  def write_state(); end
  KEYS_NOT_TO_PERSIST_IN_STATE = ::T.let(nil, ::T.untyped)
end

class Puma::Launcher
end

module Puma::MiniSSL
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_SSL3 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1_1 = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::Context
  def ca(); end

  def ca=(ca); end

  def cert(); end

  def cert=(cert); end

  def check(); end

  def key(); end

  def key=(key); end

  def no_tlsv1(); end

  def no_tlsv1=(tlsv1); end

  def no_tlsv1_1(); end

  def no_tlsv1_1=(tlsv1_1); end

  def ssl_cipher_filter(); end

  def ssl_cipher_filter=(ssl_cipher_filter); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end
end

class Puma::MiniSSL::Context
end

class Puma::MiniSSL::ContextBuilder
  def context(); end

  def initialize(params, events); end
end

class Puma::MiniSSL::ContextBuilder
end

class Puma::MiniSSL::Engine
  def extract(); end

  def init?(); end

  def inject(_); end

  def peercert(); end

  def read(); end

  def shutdown(); end

  def write(_); end
end

class Puma::MiniSSL::Engine
  def self.client(); end

  def self.server(_); end
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::Server
  def accept(); end

  def accept_nonblock(); end

  def close(); end

  def initialize(socket, ctx); end

  def to_io(); end
end

class Puma::MiniSSL::Server
end

class Puma::MiniSSL::Socket
  def <<(data); end

  def close(); end

  def closed?(); end

  def engine_read_all(); end

  def flush(); end

  def initialize(socket, engine); end

  def peeraddr(); end

  def peercert(); end

  def read_and_drop(timeout=T.unsafe(nil)); end

  def read_nonblock(size, *_); end

  def readpartial(size); end

  def should_drop_bytes?(); end

  def syswrite(data); end

  def to_io(); end

  def write(data); end

  def write_nonblock(data, *_); end
end

class Puma::MiniSSL::Socket
end

module Puma::MiniSSL
  def self.check(); end
end

class Puma::NullIO
  def close(); end

  def each(&blk); end

  def eof?(); end

  def gets(); end

  def puts(*ary); end

  def read(count=T.unsafe(nil), _buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def sync=(v); end

  def write(*ary); end
end

class Puma::NullIO
end

class Puma::Plugin
  def in_background(&blk); end

  def initialize(loader); end

  def workers_supported?(); end
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Plugin
  def self.create(&blk); end

  def self.extract_name(ary); end
end

class Puma::PluginLoader
  def create(name); end

  def fire_starts(launcher); end
end

class Puma::PluginLoader
end

class Puma::PluginRegistry
  def add_background(blk); end

  def find(name); end

  def fire_background(); end

  def register(name, cls); end
end

class Puma::PluginRegistry
end

module Puma::Rack
end

class Puma::Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Puma::Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Puma::Rack::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Puma::Rack::Options
end

module Puma::Rack
end

class Puma::Reactor
  def add(c); end

  def calculate_sleep(); end

  def clear!(); end

  def initialize(server, app_pool); end

  def run(); end

  def run_in_thread(); end

  def shutdown(); end
  DefaultSleepFor = ::T.let(nil, ::T.untyped)
end

class Puma::Reactor
end

class Puma::Runner
  def app(); end

  def before_restart(); end

  def daemon?(); end

  def debug(str); end

  def development?(); end

  def error(str); end

  def initialize(cli, events); end

  def load_and_bind(); end

  def log(str); end

  def output_header(mode); end

  def redirect_io(); end

  def redirected_io?(); end

  def ruby_engine(); end

  def start_control(); end

  def start_server(); end

  def test?(); end
end

class Puma::Runner
end

class Puma::Server
  include ::Puma::Const
  def add_ssl_listener(*args, &block); end

  def add_tcp_listener(*args, &block); end

  def add_unix_listener(*args, &block); end

  def app(); end

  def app=(app); end

  def auto_trim_time(); end

  def auto_trim_time=(auto_trim_time); end

  def backlog(); end

  def begin_restart(); end

  def binder(); end

  def binder=(binder); end

  def closed_socket?(socket); end

  def connected_port(*args, &block); end

  def cork_socket(socket); end

  def default_server_port(env); end

  def early_hints(); end

  def early_hints=(early_hints); end

  def events(); end

  def first_data_timeout(); end

  def first_data_timeout=(first_data_timeout); end

  def graceful_shutdown(); end

  def halt(sync=T.unsafe(nil)); end

  def handle_check(); end

  def handle_request(req, lines); end

  def handle_servers(); end

  def handle_servers_lopez_mode(); end

  def inherit_binder(bind); end

  def initialize(app, events=T.unsafe(nil), options=T.unsafe(nil)); end

  def leak_stack_on_error(); end

  def leak_stack_on_error=(leak_stack_on_error); end

  def lowlevel_error(e, env); end

  def max_threads(); end

  def max_threads=(max_threads); end

  def min_threads(); end

  def min_threads=(min_threads); end

  def normalize_env(env, client); end

  def persistent_timeout(); end

  def persistent_timeout=(persistent_timeout); end

  def pool_capacity(); end

  def process_client(client, buffer); end

  def read_body(env, client, body, cl); end

  def reaping_time(); end

  def reaping_time=(reaping_time); end

  def run(background=T.unsafe(nil)); end

  def run_lopez_mode(background=T.unsafe(nil)); end

  def running(); end

  def shutting_down?(); end

  def stop(sync=T.unsafe(nil)); end

  def tcp_mode!(); end

  def thread(); end

  def uncork_socket(socket); end
  ThreadLocalKey = ::T.let(nil, ::T.untyped)
  UNPACK_TCP_STATE_FROM_TCP_INFO = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  extend ::Forwardable
  def self.current(); end
end

class Puma::Single
  def halt(); end

  def jruby_daemon?(); end

  def jruby_daemon_start(); end

  def restart(); end

  def run(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end
end

class Puma::Single
end

class Puma::ThreadPool
  def <<(work); end

  def auto_reap!(timeout=T.unsafe(nil)); end

  def auto_trim!(timeout=T.unsafe(nil)); end

  def backlog(); end

  def clean_thread_locals(); end

  def clean_thread_locals=(clean_thread_locals); end

  def initialize(min, max, *extra, &block); end

  def pool_capacity(); end

  def reap(); end

  def shutdown(timeout=T.unsafe(nil)); end

  def spawned(); end

  def trim(force=T.unsafe(nil)); end

  def trim_requested(); end

  def wait_until_not_full(); end

  def waiting(); end
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool::Automaton
  def initialize(pool, timeout, thread_name, message); end

  def start!(); end

  def stop(); end
end

class Puma::ThreadPool::Automaton
end

class Puma::ThreadPool::ForceShutdown
end

class Puma::ThreadPool::ForceShutdown
end

class Puma::ThreadPool
  def self.clean_thread_locals(); end
end

class Puma::UnknownPlugin
end

class Puma::UnknownPlugin
end

class Puma::UnsupportedOption
end

class Puma::UnsupportedOption
end

class Puma::UserFileDefaultOptions
  def [](key); end

  def []=(key, value); end

  def all_of(key); end

  def default_options(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def file_options(); end

  def finalize_values(); end

  def initialize(user_options, default_options); end

  def user_options(); end
end

class Puma::UserFileDefaultOptions
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Puma::Util::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def replace(other); end
end

class Puma::Util::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

module Puma::Util
  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.pipe(); end

  def self.unescape(s, encoding=T.unsafe(nil)); end
end

module Puma
  def self.jruby?(); end

  def self.set_thread_name(name); end

  def self.stats(); end

  def self.stats_object=(val); end

  def self.windows?(); end
end

module QualifiedConstUtils
end

module QualifiedConstUtils
  def self.names(path); end

  def self.raise_if_absolute(path); end
end

module RDoc::Text
  def expand_tabs(text); end

  def flush_left(text); end

  def markup(text); end

  def normalize_comment(text); end

  def parse(text, format=T.unsafe(nil)); end

  def snippet(text, limit=T.unsafe(nil)); end

  def strip_hashes(text); end

  def strip_newlines(text); end

  def strip_stars(text); end

  def to_html(text); end

  def wrap(txt, line_len=T.unsafe(nil)); end
  MARKUP_FORMAT = ::T.let(nil, ::T.untyped)
  TO_HTML_CHARACTERS = ::T.let(nil, ::T.untyped)
end

module RDoc::Text
  def self.encode_fallback(character, encoding, fallback); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def clone(); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def clone(); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def clone(); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def [](name_or_index); end

  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def clone(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil), &blk); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def clone(); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
end

module REXML::Security
end

module REXML::Security
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

module REXML::StreamListener
  def attlistdecl(element_name, attributes, raw_content); end

  def cdata(content); end

  def comment(comment); end

  def doctype(name, pub_sys, long_name, uri); end

  def doctype_end(); end

  def elementdecl(content); end

  def entity(content); end

  def entitydecl(content); end

  def instruction(name, instruction); end

  def notationdecl(content); end

  def tag_end(name); end

  def tag_start(name, attrs); end

  def text(text); end

  def xmldecl(version, encoding, standalone); end
end

module REXML::StreamListener
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def clone(); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def clone(); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def initialize(strict: T.unsafe(nil)); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  DEBUG = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

module RSpec::Core
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::BacktraceFormatter
end

module RSpec::Core::Bisect
end

class RSpec::Core::Bisect::BisectFailedError
end

class RSpec::Core::Bisect::BisectFailedError
  def self.for_failed_spec_run(spec_output); end
end

class RSpec::Core::Bisect::Channel
  def close(); end

  def receive(); end

  def send(message); end
end

class RSpec::Core::Bisect::Channel
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def all_example_ids(); end

  def all_example_ids=(_); end

  def failed_example_ids(); end

  def failed_example_ids=(_); end
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Bisect::Notifier
  def initialize(formatter); end

  def publish(event, *args); end
end

class RSpec::Core::Bisect::Notifier
end

module RSpec::Core::Bisect
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks
  include ::RSpec::Core::Configuration::Readers
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(value); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def profile_examples(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

module RSpec::Core::Configuration::Readers
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_aliases(name, alias_name); end

  def self.define_predicate_for(*names); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
end

module RSpec::Core::DSL
end

module RSpec::Core::DSL
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::DidYouMean
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example::Procsy
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MemoizedHelpers
  include ::RSpec::Core::Pending
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup
  extend ::RSpec::Core::Hooks
  extend ::RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::RSpec::Core::SharedExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusDumper
  def dump(); end

  def initialize(examples); end
end

class RSpec::Core::ExampleStatusDumper
  def self.dump(examples); end
end

class RSpec::Core::ExampleStatusMerger
  def initialize(this_run, from_previous_runs); end

  def merge(); end
end

class RSpec::Core::ExampleStatusMerger
  def self.merge(this_run, from_previous_runs); end
end

class RSpec::Core::ExampleStatusParser
  def initialize(string); end

  def parse(); end
end

class RSpec::Core::ExampleStatusParser
  def self.parse(string); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterManager
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

module RSpec::Core::FilterableItemRepository
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
end

module RSpec::Core::FilterableItemRepository
end

module RSpec::Core::FlatMap
end

module RSpec::Core::FlatMap
  def self.flat_map(array, &block); end
end

module RSpec::Core::Formatters
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*_); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
end

class RSpec::Core::Formatters::ExceptionPresenter
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FailureListFormatter
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::HtmlPrinter
  include ::ERB::Util
  def flush(); end

  def initialize(output); end

  def make_example_group_header_red(group_id); end

  def make_example_group_header_yellow(group_id); end

  def make_header_red(); end

  def make_header_yellow(); end

  def move_progress(percent_done); end

  def print_example_failed(pending_fixed, description, run_time, failure_id, exception, extra_content); end

  def print_example_group_end(); end

  def print_example_group_start(group_id, description, number_of_parents); end

  def print_example_passed(description, run_time); end

  def print_example_pending(description, pending_message); end

  def print_html_start(); end

  def print_summary(duration, example_count, failure_count, pending_count); end
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  def self.highlight_syntax(lines); end
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assert_valid_keys(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deep_merge(*args, &block); end

  def deep_merge!(*args, &block); end

  def deep_stringify_keys(*args, &block); end

  def deep_stringify_keys!(*args, &block); end

  def deep_symbolize_keys(*args, &block); end

  def deep_symbolize_keys!(*args, &block); end

  def deep_transform_keys(*args, &block); end

  def deep_transform_keys!(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def except(*args, &block); end

  def except!(*args, &block); end

  def exclude?(*args, &block); end

  def extract!(*args, &block); end

  def extractable_options?(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def nested_under_indifferent_access(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def reverse_merge(*args, &block); end

  def reverse_merge!(*args, &block); end

  def reverse_update(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def stringify_keys(*args, &block); end

  def stringify_keys!(*args, &block); end

  def sum(*args, &block); end

  def symbolize_keys(*args, &block); end

  def symbolize_keys!(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_options(*args, &block); end

  def to_options!(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def with_indifferent_access(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::HashImitatable
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterContextHook
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::AroundHook
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::BeforeHook
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Hooks::HookCollections
end

module RSpec::Core::Hooks
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::InclusionRules
end

module RSpec::Core::Invocations
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::Bisect
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::InitializeProject
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::Invocations::PrintVersion
end

module RSpec::Core::Invocations
end

class RSpec::Core::LegacyExampleGroupHash
  include ::RSpec::Core::HashImitatable
  def initialize(metadata); end
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MemoizedHelpers
  def initialize(*_); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
end

module RSpec::Core::MemoizedHelpers
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

class RSpec::Core::Metadata::HashPopulator
end

module RSpec::Core::Metadata
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
end

module RSpec::Core::MetadataFilter
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

module RSpec::Core::MockingAdapters
end

module RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def self.configuration(); end

  def self.framework_name(); end
end

module RSpec::Core::MockingAdapters
end

class RSpec::Core::MultipleExceptionError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::MultipleExceptionError
end

module RSpec::Core::Notifications
end

class RSpec::Core::Notifications::CustomNotification
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.from_hash(data); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.for(example); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::ExamplesNotification
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
end

module RSpec::Core::Notifications::NullColorizer
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::ProfileNotification
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  include ::RSpec::Core::ShellEscape
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications
end

class RSpec::Core::NullReporter
end

class RSpec::Core::NullReporter
end

module RSpec::Core::Ordering
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::ConfigurationManager
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Custom
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Identity
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::Ordering::Registry
end

module RSpec::Core::Ordering
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def beep(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def cooked(*args, &block); end

  def cooked!(*args, &block); end

  def cursor(*args, &block); end

  def cursor=(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def echo=(*args, &block); end

  def echo?(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def getch(*args, &block); end

  def getpass(*args, &block); end

  def gets(*args, &block); end

  def goto(*args, &block); end

  def iflush(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def ioflush(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def method_missing(name, *args, &block); end

  def noecho(*args, &block); end

  def nonblock(*args, &block); end

  def nonblock=(*args, &block); end

  def nonblock?(*args, &block); end

  def nread(*args, &block); end

  def oflush(*args, &block); end

  def output(); end

  def output=(output); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def pressed?(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def raw(*args, &block); end

  def raw!(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def winsize(*args, &block); end

  def winsize=(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::OutputWrapper
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

class RSpec::Core::Pending::SkipDeclaredInExample
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def exit_early(exit_code); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
end

module RSpec::Core::RubyProject
end

module RSpec::Core::RubyProject
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  include ::Enumerable
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

class RSpec::Core::Set
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

class RSpec::Core::SharedExampleGroup::Registry
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

module RSpec::Core::SharedExampleGroup
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

class RSpec::Core::SharedExampleGroupModule
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  def self.conditionally_quote(id); end

  def self.escape(shell_command); end

  def self.quote(argument); end

  def self.shell_allows_unquoted_ids?(); end
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::SuiteHookContext
end

class RSpec::Core::Time
end

class RSpec::Core::Time
  def self.now(); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

module RSpec::Core::Warnings
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_group_counts_by_spec_file(); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
end

module RSpec::Core::World::Null
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(); end
end

class RSpec::Core::World
end

module RSpec::Core
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
end

module RSpec::ExampleGroups
  extend ::RSpec::Support::RecursiveConstMethods
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

module RSpec::Expectations
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockExpectationTarget
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

module RSpec::Expectations::ExpectationHelper
end

module RSpec::Expectations::ExpectationHelper
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
end

class RSpec::Expectations::NegativeExpectationHandler
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
end

module RSpec::Expectations::Syntax
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
end

module RSpec::Expectations
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, &block); end

  def cover(*values); end

  def covering(*args, &block); end

  def end_with(*expected); end

  def ending_with(*args, &block); end

  def eq(expected); end

  def eq_to(*args, &block); end

  def eql(expected); end

  def eql_to(*args, &block); end

  def equal(expected); end

  def equal_to(*args, &block); end

  def exist(*args); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, &block); end

  def include(*expected); end

  def including(*args, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, &block); end

  def respond_to(*names); end

  def responding_to(*args, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, &block); end

  def start_with(*expected); end

  def starting_with(*args, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*_); end
end

class RSpec::Matchers::AliasedMatcher
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::AliasedNegatedMatcher
end

module RSpec::Matchers::BuiltIn
end

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(*args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

module RSpec::Matchers::BuiltIn::CaptureStderr
end

module RSpec::Matchers::BuiltIn::CaptureStderr
  def self.capture(block); end
end

module RSpec::Matchers::BuiltIn::CaptureStdout
end

module RSpec::Matchers::BuiltIn::CaptureStdout
  def self.capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
  def capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::ChangeDetails
  def actual_after(); end

  def actual_delta(); end

  def changed?(); end

  def initialize(matcher_name, receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def perform_change(event_proc); end

  def value_representation(); end
end

class RSpec::Matchers::BuiltIn::ChangeDetails
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
  def does_not_match?(event_proc); end

  def initialize(change_details, expected_before); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
  def does_not_match?(_event_proc); end

  def initialize(change_details, expected_delta, relativity, &comparer); end

  def matches?(event_proc); end
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
end

class RSpec::Matchers::BuiltIn::ChangeToValue
  def does_not_match?(_event_proc); end

  def from(value); end

  def initialize(change_details, expected_after); end
end

class RSpec::Matchers::BuiltIn::ChangeToValue
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

module RSpec::Matchers::BuiltIn::NullCapture
end

module RSpec::Matchers::BuiltIn::NullCapture
  def self.capture(_block); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message=T.unsafe(nil), expected_message=T.unsafe(nil), &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def with_message(expected_message); end
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
  def captures(); end

  def initialize(match_data); end

  def match_data(); end

  def names(); end
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def ignoring_method_signature_failure!(); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, from, to); end

  def matches?(event_proc); end
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

class RSpec::Matchers::BuiltIn::SpecificValuesChange
end

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  def at_least(number); end

  def at_most(number); end

  def does_not_match?(block); end

  def exactly(number); end

  def initialize(); end

  def matches?(block); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def assert_used!(); end

  def assert_valid_expect_block!(); end

  def has_block?(); end

  def initialize(block, &callback); end

  def num_yields(); end

  def num_yields=(num_yields); end

  def probe(); end

  def single_yield_args(); end

  def to_proc(); end

  def yielded_args(); end

  def yielded_args=(yielded_args); end

  def yielded_once?(matcher_name); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def self.probe(block, &callback); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::BuiltIn
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end
end

module RSpec::Matchers::DSL::DefaultImplementations
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(options=T.unsafe(nil), &match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL::Macros
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Composable
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

class RSpec::Matchers::DSL::Matcher
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL
end

module RSpec::Matchers::EnglishPhrasing
end

module RSpec::Matchers::EnglishPhrasing
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def initialize(expected_list); end

  def message_with_diff(message, differ, actual); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def self.for_many_matchers(matchers); end

  def self.from(expected); end
end

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MatcherDelegator
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AllowanceTarget
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndReturnImplementation
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AndYieldImplementation
end

module RSpec::Mocks::AnyInstance
end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::Chain
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::MessageChains
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Proxy
end

class RSpec::Mocks::AnyInstance::Recorder
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::Recorder
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::StubChainChain
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
end

class RSpec::Mocks::ArgumentListMatcher
  def args_match?(*args); end

  def expected_args(); end

  def initialize(*expected_args); end

  def resolve_expected_args_based_on(actual_args); end
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
end

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end

  def an_instance_of(klass); end

  def any_args(); end

  def anything(); end

  def array_including(*args); end

  def boolean(); end

  def duck_type(*args); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def hash_not_including(*args); end

  def instance_of(klass); end

  def kind_of(klass); end

  def no_args(); end
end

module RSpec::Mocks::ArgumentMatchers
  def self.anythingize_lonely_keys(*args); end
end

class RSpec::Mocks::CallbackInvocationStrategy
  def call(doubled_module); end
end

class RSpec::Mocks::CallbackInvocationStrategy
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::ClassNewMethodReference
end

class RSpec::Mocks::ClassNewMethodReference
  def self.applies_to?(method_name); end
end

class RSpec::Mocks::ClassVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ClassVerifyingDouble
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Configuration
end

class RSpec::Mocks::Constant
  def hidden=(hidden); end

  def hidden?(); end

  def initialize(name); end

  def mutated?(); end

  def name(); end

  def original_value(); end

  def original_value=(original_value); end

  def previously_defined=(previously_defined); end

  def previously_defined?(); end

  def stubbed=(stubbed); end

  def stubbed?(); end

  def valid_name=(valid_name); end

  def valid_name?(); end
end

class RSpec::Mocks::Constant
  extend ::RSpec::Support::RecursiveConstMethods
  def self.original(name); end

  def self.unmutated(name); end
end

class RSpec::Mocks::ConstantMutator
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  include ::RSpec::Support::RecursiveConstMethods
  def full_constant_name(); end

  def idempotently_reset(); end

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def original_value(); end

  def to_constant(); end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
end

class RSpec::Mocks::ConstantMutator::ConstantHider
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::ConstantHider
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
  def initialize(*args); end

  def mutate(); end

  def reset(); end

  def should_transfer_nested_constants?(); end

  def transfer_nested_constants(); end

  def verify_constants_to_transfer!(); end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
end

class RSpec::Mocks::ConstantMutator
  extend ::RSpec::Support::RecursiveConstMethods
  def self.hide(constant_name); end

  def self.mutate(mutator); end

  def self.raise_on_invalid_const(); end

  def self.stub(constant_name, value, options=T.unsafe(nil)); end
end

class RSpec::Mocks::DirectObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(object); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::DirectObjectReference
end

class RSpec::Mocks::Double
  include ::RSpec::Mocks::TestDouble
end

class RSpec::Mocks::Double
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

class RSpec::Mocks::ErrorGenerator
end

module RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  def allow(target); end

  def allow_any_instance_of(klass); end

  def allow_message_expectations_on_nil(); end

  def class_double(doubled_class, *args); end

  def class_spy(*args); end

  def double(*args); end

  def expect_any_instance_of(klass); end

  def have_received(method_name, &block); end

  def hide_const(constant_name); end

  def instance_double(doubled_class, *args); end

  def instance_spy(*args); end

  def object_double(object_or_name, *args); end

  def object_spy(*args); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end

  def spy(*args); end

  def stub_const(constant_name, value, options=T.unsafe(nil)); end

  def without_partial_double_verification(); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
end

module RSpec::Mocks::ExampleMethods
  def self.declare_double(type, *args); end

  def self.declare_verifying_double(type, ref, *args); end

  def self.extended(object); end

  def self.included(klass); end
end

class RSpec::Mocks::ExpectChain
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

class RSpec::Mocks::ExpectationTarget
  include ::RSpec::Mocks::ExpectationTargetMethods
end

class RSpec::Mocks::ExpectationTarget
end

module RSpec::Mocks::ExpectationTargetMethods
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

module RSpec::Mocks::ExpectationTargetMethods
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::Implementation
  def call(*args, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::Implementation
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodStasher
  def handle_restoration_failures(); end

  def initialize(object, method); end

  def method_is_stashed?(); end

  def original_method(); end

  def restore(); end

  def stash(); end
end

class RSpec::Mocks::InstanceMethodStasher
end

class RSpec::Mocks::InstanceVerifyingDouble
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::InstanceVerifyingDouble
end

class RSpec::Mocks::MarshalExtension
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::Matchers::ExpectationCustomization
  def block(); end

  def block=(block); end

  def initialize(method_name, args, block); end

  def playback_onto(expectation); end
end

class RSpec::Mocks::Matchers::ExpectationCustomization
end

class RSpec::Mocks::Matchers::HaveReceived
  include ::RSpec::Mocks::Matchers::Matcher
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matches?(subject, &block); end

  def name(); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
end

module RSpec::Mocks::Matchers::Matcher
end

module RSpec::Mocks::Matchers::Matcher
end

class RSpec::Mocks::Matchers::Receive
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, &block); end

  def initialize(message, block); end

  def matches?(subject, &block); end

  def name(); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
end

class RSpec::Mocks::Matchers::Receive
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matches?(subject, &block); end

  def name(); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
end

class RSpec::Mocks::Matchers::ReceiveMessages
  include ::RSpec::Mocks::Matchers::Matcher
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matches?(subject); end

  def name(); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageChain
end

class RSpec::Mocks::MessageExpectation
  include ::RSpec::Mocks::MessageExpectation::ImplementationDetails
  def and_call_original(); end

  def and_raise(*args); end

  def and_return(first_value, *values); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def time(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, &block); end

  def matches?(message, *args); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
end

class RSpec::Mocks::MessageExpectation
end

class RSpec::Mocks::MethodDouble
  def add_default_stub(*args, &implementation); end

  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end

  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end

  def add_simple_stub(method_name, response); end

  def add_stub(error_generator, expectation_ordering, expected_from, opts=T.unsafe(nil), &implementation); end

  def build_expectation(error_generator, expectation_ordering); end

  def clear(); end

  def configure_method(); end

  def define_proxy_method(); end

  def expectations(); end

  def initialize(object, method_name, proxy); end

  def message_expectation_class(); end

  def method_name(); end

  def method_stasher(); end

  def object(); end

  def object_singleton_class(); end

  def original_implementation_callable(); end

  def original_method(); end

  def proxy_method_invoked(_obj, *args, &block); end

  def raise_method_not_stubbed_error(); end

  def remove_stub(); end

  def remove_stub_if_present(); end

  def reset(); end

  def restore_original_method(); end

  def restore_original_visibility(); end

  def save_original_implementation_callable!(); end

  def setup_simple_method_double(method_name, response, collection, error_generator=T.unsafe(nil), backtrace_line=T.unsafe(nil)); end

  def show_frozen_warning(); end

  def stubs(); end

  def verify(); end

  def visibility(); end
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble
end

class RSpec::Mocks::MethodReference
  def defined?(); end

  def implemented?(); end

  def initialize(object_reference, method_name); end

  def unimplemented?(); end

  def visibility(); end

  def with_signature(); end
end

class RSpec::Mocks::MethodReference
  def self.for(object_reference, method_name); end

  def self.instance_method_visibility_for(klass, method_name); end

  def self.method_defined_at_any_visibility?(klass, method_name); end

  def self.method_visibility_for(object, method_name); end
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::NamedObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(const_name); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::NamedObjectReference
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NestedSpace
  def initialize(parent); end
end

class RSpec::Mocks::NestedSpace
end

class RSpec::Mocks::NoCallbackInvocationStrategy
  def call(_doubled_module); end
end

class RSpec::Mocks::NoCallbackInvocationStrategy
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  def self.for(object_module_or_name, allow_direct_object_refs=T.unsafe(nil)); end
end

class RSpec::Mocks::ObjectVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ObjectVerifyingDouble
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
  def as_stubbed_const(options=T.unsafe(nil)); end
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
end

class RSpec::Mocks::OrderGroup
  def clear(); end

  def consume(); end

  def empty?(); end

  def handle_order_constraint(expectation); end

  def invoked(message); end

  def ready_for?(expectation); end

  def register(expectation); end

  def verify_invocation_order(expectation); end
end

class RSpec::Mocks::OrderGroup
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::PartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialClassDoubleProxy
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def method_double_from_ancestor_for(message); end

  def original_method_handle_for(message); end

  def original_unbound_method_handle_from_ancestor_for(message); end

  def superclass_proxy(); end
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialDoubleProxy
  def original_method_handle_for(message); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::PartialDoubleProxy
end

class RSpec::Mocks::Proxy
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_expectation(method_name, response, location); end

  def add_simple_stub(method_name, response); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def build_expectation(method_name); end

  def check_for_unexpected_arguments(expectation); end

  def ensure_implemented(*_args); end

  def has_negative_expectation?(message); end

  def initialize(object, order_group, options=T.unsafe(nil)); end

  def message_received(message, *args, &block); end

  def messages_arg_list(); end

  def method_double_if_exists_for_message(message); end

  def object(); end

  def original_method_handle_for(_message); end

  def prepended_modules_of_singleton_class(); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_unexpected_message_error(method_name, args); end

  def received_message?(method_name, *args, &block); end

  def record_message_received(message, *args, &block); end

  def remove_stub(method_name); end

  def remove_stub_if_present(method_name); end

  def replay_received_message_on(expectation, &block); end

  def reset(); end

  def verify(); end

  def visibility_for(_method_name); end
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy::SpecificMessage
  def ==(expectation); end

  def args(); end

  def args=(_); end

  def message(); end

  def message=(_); end

  def object(); end

  def object=(_); end
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Mocks::Proxy
  def self.prepended_modules_of(klass); end
end

class RSpec::Mocks::ProxyForNil
  def disallow_expectations(); end

  def disallow_expectations=(disallow_expectations); end

  def initialize(order_group); end

  def warn_about_expectations(); end

  def warn_about_expectations=(warn_about_expectations); end
end

class RSpec::Mocks::ProxyForNil
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end

  def any_instance_recorder_for(*_args); end

  def any_instance_recorders_from_ancestry_of(_object); end

  def new_scope(); end

  def proxy_for(*_args); end

  def register_constant_mutator(_mutator); end

  def registered?(_object); end

  def reset_all(); end

  def superclass_proxy_for(*_args); end

  def verify_all(); end
end

class RSpec::Mocks::RootSpace
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::SimpleMessageExpectation
end

class RSpec::Mocks::Space
  def any_instance_mutex(); end

  def any_instance_proxy_for(klass); end

  def any_instance_recorder_for(klass, only_return_existing=T.unsafe(nil)); end

  def any_instance_recorders(); end

  def any_instance_recorders_from_ancestry_of(object); end

  def constant_mutator_for(name); end

  def ensure_registered(object); end

  def new_scope(); end

  def proxies(); end

  def proxies_of(klass); end

  def proxy_for(object); end

  def proxy_mutex(); end

  def register_constant_mutator(mutator); end

  def registered?(object); end

  def reset_all(); end

  def superclass_proxy_for(klass); end

  def verify_all(); end
end

class RSpec::Mocks::Space
end

class RSpec::Mocks::StubChain
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
end

module RSpec::Mocks::Syntax
  def self.default_should_syntax_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_unless_should_configured(method_name, replacement=T.unsafe(nil)); end
end

class RSpec::Mocks::TargetBase
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def initialize(target); end
end

class RSpec::Mocks::TargetBase
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationClassMethods
  def delegate_not_to(matcher_method, options=T.unsafe(nil)); end

  def delegate_to(matcher_method); end

  def disallow_negation(method_name); end
end

module RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  def target(); end
end

module RSpec::Mocks::TargetDelegationInstanceMethods
end

module RSpec::Mocks::TestDouble
  def ==(other); end

  def __build_mock_proxy_unless_expired(order_group); end

  def __disallow_further_usage!(); end

  def as_null_object(); end

  def freeze(); end

  def initialize(name=T.unsafe(nil), stubs=T.unsafe(nil)); end

  def inspect(); end

  def null_object?(); end

  def respond_to?(message, incl_private=T.unsafe(nil)); end

  def to_s(); end
end

module RSpec::Mocks::TestDouble
end

module RSpec::Mocks::TestDoubleFormatter
end

module RSpec::Mocks::TestDoubleFormatter
  def self.format(dbl, unwrap=T.unsafe(nil)); end
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::UnsupportedMatcherError
end

class RSpec::Mocks::UnsupportedMatcherError
end

module RSpec::Mocks::VerifyingDouble
  def __send__(name, *args, &block); end

  def initialize(doubled_module, *args); end

  def method_missing(message, *args, &block); end

  def respond_to?(message, include_private=T.unsafe(nil)); end

  def send(name, *args, &block); end
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?(); end

  def with_signature(); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def self.for(object, method_name, proxy); end
end

class RSpec::Mocks::VerifyingMessageExpectation
  def initialize(*args); end

  def method_reference(); end

  def method_reference=(method_reference); end
end

class RSpec::Mocks::VerifyingMessageExpectation
end

class RSpec::Mocks::VerifyingMethodDouble
  def add_expectation(*args, &block); end

  def add_stub(*args, &block); end

  def initialize(object, method_name, proxy, method_reference); end

  def proxy_method_invoked(obj, *args, &block); end

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingMethodDouble
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def ensure_implemented(_method_name); end

  def initialize(object, expectation_ordering, optional_callback_invocation_strategy=T.unsafe(nil)); end

  def method_reference(); end
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
end

class RSpec::Mocks::VerifyingProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def initialize(object, order_group, doubled_module, method_reference_class); end

  def method_reference(); end

  def validate_arguments!(method_name, args); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::VerifyingProxy
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_stub(method_name, *args); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def ensure_implemented(method_name); end

  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::VerifyingProxyMethods
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
end

module RSpec::Mocks
  def self.allow_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.configuration(); end

  def self.error_generator(); end

  def self.expect_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.setup(); end

  def self.space(); end

  def self.teardown(); end

  def self.verify(); end

  def self.with_temporary_scope(); end
end

module RSpec::Rails
end

module RSpec::Rails::FeatureCheck
end

module RSpec::Rails::FeatureCheck
  def self.has_action_cable_testing?(); end

  def self.has_action_mailbox?(); end

  def self.has_action_mailer?(); end

  def self.has_action_mailer_parameterized?(); end

  def self.has_action_mailer_preview?(); end

  def self.has_action_mailer_unified_delivery?(); end

  def self.has_active_job?(); end

  def self.has_active_record?(); end

  def self.has_active_record_migration?(); end

  def self.type_metatag(type); end
end

class RSpec::Rails::Railtie
end

class RSpec::Rails::Railtie
end

module RSpec::Rails
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::ComparableVersion
  include ::Comparable
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::ComparableVersion
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::DirectoryMaker
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
end

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

class RSpec::Support::HunkGenerator
  def hunks(); end

  def initialize(actual, expected); end
end

class RSpec::Support::HunkGenerator
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureExpectation
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::MethodSignatureVerifier
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  def self.new(); end
end

module RSpec::Support::OS
end

module RSpec::Support::OS
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.can_inspect?(_object); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

module RSpec::Support::RecursiveConstMethods
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

class RSpec::Support::ReentrantMutex
end

module RSpec::Support::Ruby
end

module RSpec::Support::Ruby
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end

  def self.truffleruby?(); end
end

module RSpec::Support::RubyFeatures
end

module RSpec::Support::RubyFeatures
  def self.caller_locations_supported?(); end

  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_taint?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Version
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::Warnings
end

module RSpec::Support::WithKeywordsWhenNeeded
end

module RSpec::Support::WithKeywordsWhenNeeded
  def self.class_exec(klass, *args, &block); end
end

module RSpec::Support
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.reset(); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
end

module Rack::Auth
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def each(*args, &block); end

  def initialize(body, &block); end

  def method_missing(*args, &block); end

  def respond_to?(*args); end
end

class Rack::BodyProxy
end

class Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, catch=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  include ::Rack::Utils
  def close(); end

  def each(&blk); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Cors
  def all_resources(); end

  def allow(&block); end

  def call(env); end

  def debug(env, message=T.unsafe(nil), &block); end

  def debug?(); end

  def evaluate_path(env); end

  def initialize(app, opts=T.unsafe(nil), &block); end

  def match_resource(path, env); end

  def process_cors(env, path); end

  def process_preflight(env, path); end

  def resource_for_path(path_info); end

  def select_logger(env); end
  CORS_SIMPLE_HEADERS = ::T.let(nil, ::T.untyped)
  DEFAULT_VARY_HEADERS = ::T.let(nil, ::T.untyped)
  ENV_KEY = ::T.let(nil, ::T.untyped)
  HTTP_ACCESS_CONTROL_REQUEST_HEADERS = ::T.let(nil, ::T.untyped)
  HTTP_ACCESS_CONTROL_REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  HTTP_ORIGIN = ::T.let(nil, ::T.untyped)
  HTTP_X_ORIGIN = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  RACK_CORS = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  VARY = ::T.let(nil, ::T.untyped)
end

class Rack::Cors::Resource
  def allow_headers?(request_headers); end

  def compile(path); end

  def credentials(); end

  def credentials=(credentials); end

  def ensure_enum(v); end

  def expose(); end

  def expose=(expose); end

  def headers(); end

  def headers=(headers); end

  def if_proc(); end

  def if_proc=(if_proc); end

  def initialize(public_resource, path, opts=T.unsafe(nil)); end

  def match?(path, env); end

  def matches_path?(path); end

  def max_age(); end

  def max_age=(max_age); end

  def methods(); end

  def methods=(methods); end

  def origin_for_response_header(origin); end

  def path(); end

  def path=(path); end

  def pattern(); end

  def pattern=(pattern); end

  def process_preflight(env, result); end

  def public_resource?(); end

  def to_headers(env); end

  def to_preflight_headers(env); end

  def vary_headers(); end

  def vary_headers=(vary_headers); end
end

class Rack::Cors::Resource::CorsMisconfigurationError
end

class Rack::Cors::Resource::CorsMisconfigurationError
end

class Rack::Cors::Resource
end

class Rack::Cors::Resources
  def allow_origin?(source, env=T.unsafe(nil)); end

  def match_resource(path, env); end

  def origins(*args, &blk); end

  def public_resources?(); end

  def resource(path, opts=T.unsafe(nil)); end

  def resource_for_path(path); end

  def resources(); end
end

class Rack::Cors::Resources
end

class Rack::Cors::Result
  def append_header(headers); end

  def hit(); end

  def hit=(hit); end

  def hit?(); end

  def miss(reason); end

  def miss_reason(); end

  def miss_reason=(miss_reason); end

  def preflight(); end

  def preflight=(preflight); end

  def preflight?(); end
  HEADER_KEY = ::T.let(nil, ::T.untyped)
  MISS_DENY_HEADER = ::T.let(nil, ::T.untyped)
  MISS_DENY_METHOD = ::T.let(nil, ::T.untyped)
  MISS_NO_METHOD = ::T.let(nil, ::T.untyped)
  MISS_NO_ORIGIN = ::T.let(nil, ::T.untyped)
  MISS_NO_PATH = ::T.let(nil, ::T.untyped)
end

class Rack::Cors::Result
  def self.hit(env); end

  def self.miss(env, reason); end

  def self.preflight(env); end
end

class Rack::Cors
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::DeflateStream
  def close(); end

  def each(&blk); end

  def initialize(body); end
  DEFLATE_ARGS = ::T.let(nil, ::T.untyped)
end

class Rack::Deflater::DeflateStream
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def _call(env); end

  def call(env); end

  def check_forbidden(); end

  def each(&blk); end

  def entity_not_found(); end

  def files(); end

  def filesize_format(int); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(); end

  def list_path(); end

  def path(); end

  def path=(path); end

  def root(); end

  def root=(root); end

  def stat(node, max=T.unsafe(nil)); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

Rack::Directory::F = File

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::File
  def _call(env); end

  def cache_control(); end

  def cache_control=(cache_control); end

  def call(env); end

  def each(&blk); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def path(); end

  def path=(path); end

  def root(); end

  def root=(root); end

  def serving(env); end

  def to_path(); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
end

Rack::File::F = File

class Rack::File
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, options=T.unsafe(nil)); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, options=T.unsafe(nil)); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self._const_get(str, inherit=T.unsafe(nil)); end

  def self.default(options=T.unsafe(nil)); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message, &block); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
  FLAG = ::T.let(nil, ::T.untyped)
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.env_with_encoding(env, opts, uri); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end
end

class Rack::MockResponse
end

class Rack::MockSession
  def after_request(&block); end

  def clear_cookies(); end

  def cookie_jar(); end

  def cookie_jar=(cookie_jar); end

  def default_host(); end

  def initialize(app, default_host=T.unsafe(nil)); end

  def last_request(); end

  def last_response(); end

  def request(uri, env); end

  def set_cookie(cookie, uri=T.unsafe(nil)); end
end

class Rack::MockSession
end

module Rack::Multipart
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::Parser
  def initialize(boundary, io, content_length, env, tempfile, bufsize); end

  def parse(); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  DUMMY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser
  def self.create(env); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(path, content_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.parse_multipart(env); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def env(); end

  def form_data?(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_with_port(); end

  def initialize(env); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def options?(); end

  def params(); end

  def parse_http_accept_header(header); end

  def parse_multipart(env); end

  def parse_query(qs); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def reject_trusted_ip_addresses(ip_addresses); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def session(); end

  def session_options(); end

  def split_ip_addresses(ip_addresses); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

class Rack::Request
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, value); end

  def body(); end

  def body=(body); end

  def close(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def header(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), header=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_cookie(key, value); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def to_ary(&block); end

  def write(str); end
  CHUNKED = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def bad_request?(); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def created?(); end

  def forbidden?(); end

  def headers(); end

  def i_m_a_teapot?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def method_not_allowed?(); end

  def not_found?(); end

  def ok?(); end

  def original_headers(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

Rack::Sendfile::F = File

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&blk); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session
end

module Rack::Session::Abstract
  ENV_SESSION_KEY = ::T.let(nil, ::T.untyped)
  ENV_SESSION_OPTIONS_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::ID
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*_); end

  def generate_sid(*_); end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash
end

class Rack::Session::Abstract::PersistedSecure
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, env); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
end

class Rack::Session::Abstract::SessionHash
  def self.find(env); end

  def self.set(env, session); end

  def self.set_options(env, options); end
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def destroy_session(env, session_id, options); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def set_session(env, session_id, new_session, options); end

  def with_lock(env); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
end

module Rack::Session
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Cookie
  include ::Rack::Utils
  def default_uri(); end

  def domain(); end

  def empty?(); end

  def expired?(); end

  def expires(); end

  def initialize(raw, uri=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def matches?(uri); end

  def name(); end

  def path(); end

  def raw(); end

  def replaces?(other); end

  def secure?(); end

  def valid?(uri); end

  def value(); end
end

class Rack::Test::Cookie
end

class Rack::Test::CookieJar
  def <<(new_cookie); end

  def [](name); end

  def []=(name, value); end

  def delete(name); end

  def for(uri); end

  def hash_for(uri=T.unsafe(nil)); end

  def initialize(cookies=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def merge(raw_cookies, uri=T.unsafe(nil)); end

  def to_hash(); end
end

class Rack::Test::CookieJar
end

class Rack::Test::Error
end

class Rack::Test::Error
end

module Rack::Test::Methods
  def _current_session_names(); end

  def authorize(*args, &block); end

  def basic_authorize(*args, &block); end

  def build_rack_mock_session(); end

  def build_rack_test_session(name); end

  def clear_cookies(*args, &block); end

  def current_session(); end

  def delete(*args, &block); end

  def digest_authorize(*args, &block); end

  def env(*args, &block); end

  def follow_redirect!(*args, &block); end

  def get(*args, &block); end

  def head(*args, &block); end

  def header(*args, &block); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end

  def rack_mock_session(name=T.unsafe(nil)); end

  def rack_test_session(name=T.unsafe(nil)); end

  def request(*args, &block); end

  def set_cookie(*args, &block); end

  def with_session(name); end
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  extend ::Forwardable
end

class Rack::Test::MockDigestRequest
  def initialize(params); end

  def method(); end

  def method_missing(sym); end

  def response(password); end
end

class Rack::Test::MockDigestRequest
end

class Rack::Test::Session
  include ::Rack::Test::Utils
  include ::Rack::Utils
  def authorize(username, password); end

  def basic_authorize(username, password); end

  def clear_cookies(*args, &block); end

  def delete(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def digest_authorize(username, password); end

  def env(name, value); end

  def follow_redirect!(); end

  def get(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def head(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def header(name, value); end

  def initialize(mock_session); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def patch(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def post(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def put(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def request(uri, env=T.unsafe(nil), &block); end

  def set_cookie(*args, &block); end
end

class Rack::Test::Session
  extend ::Forwardable
end

class Rack::Test::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(path, content_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(method_name, include_private=T.unsafe(nil)); end

  def tempfile(); end
end

class Rack::Test::UploadedFile
end

module Rack::Test::Utils
  include ::Rack::Utils
end

module Rack::Test::Utils
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end
end

module Rack::Test
  def self.encoding_aware_strings?(); end
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
  INFINITY = ::T.let(nil, ::T.untyped)
  NEGATIVE_INFINITY = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
end

module Rack::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::Context
  def app(); end

  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def for(); end

  def initialize(app_f, app_r); end

  def recontext(app); end
end

class Rack::Utils::Context
end

class Rack::Utils::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def replace(other); end
end

class Rack::Utils::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

class Rack::Utils::InvalidParameterError
end

class Rack::Utils::InvalidParameterError
end

class Rack::Utils::KeySpaceConstrainedParams
  def [](key); end

  def []=(key, value); end

  def initialize(limit=T.unsafe(nil)); end

  def key?(key); end

  def to_params_hash(); end
end

class Rack::Utils::KeySpaceConstrainedParams
end

Rack::Utils::Multipart = Rack::Multipart

module Rack::Utils::OkJson
  def decode(s); end

  def encode(x); end

  def valenc(x); end
  Spc = ::T.let(nil, ::T.untyped)
  Uchar1max = ::T.let(nil, ::T.untyped)
  Uchar2max = ::T.let(nil, ::T.untyped)
  Uchar3max = ::T.let(nil, ::T.untyped)
  Ucharerr = ::T.let(nil, ::T.untyped)
  Umask2 = ::T.let(nil, ::T.untyped)
  Umask3 = ::T.let(nil, ::T.untyped)
  Umask4 = ::T.let(nil, ::T.untyped)
  Umaskx = ::T.let(nil, ::T.untyped)
  Unesc = ::T.let(nil, ::T.untyped)
  Upstream = ::T.let(nil, ::T.untyped)
  Ustrerr = ::T.let(nil, ::T.untyped)
  Usurr1 = ::T.let(nil, ::T.untyped)
  Usurr2 = ::T.let(nil, ::T.untyped)
  Usurr3 = ::T.let(nil, ::T.untyped)
  Usurrself = ::T.let(nil, ::T.untyped)
  Utag2 = ::T.let(nil, ::T.untyped)
  Utag3 = ::T.let(nil, ::T.untyped)
  Utag4 = ::T.let(nil, ::T.untyped)
  Utag5 = ::T.let(nil, ::T.untyped)
  Utagx = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::OkJson::Error
end

class Rack::Utils::OkJson::Error
end

class Rack::Utils::OkJson::Utf8Error
end

class Rack::Utils::OkJson::Utf8Error
end

module Rack::Utils::OkJson
  extend ::Rack::Utils::OkJson
end

class Rack::Utils::ParameterTypeError
end

class Rack::Utils::ParameterTypeError
end

module Rack::Utils
  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.bytesize(string); end

  def self.clean_path_info(path_info); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.key_space_limit(); end

  def self.key_space_limit=(key_space_limit); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.normalize_params(params, name, v=T.unsafe(nil), depth=T.unsafe(nil)); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(param_depth_limit); end

  def self.params_hash_type?(obj); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end
end

module Rack
  def self.release(); end

  def self.version(); end
end

class Rails::Application
  def asset_precompiled?(logical_path); end

  def assets(); end

  def assets=(assets); end

  def assets_manifest(); end

  def assets_manifest=(assets_manifest); end

  def build_middleware_stack(); end

  def build_original_fullpath(env); end

  def config=(configuration); end

  def config_for(name); end

  def console(&blk); end

  def default_url_options(*args, &block); end

  def default_url_options=(arg); end

  def generators(&blk); end

  def initialize(initial_variable_values=T.unsafe(nil), &block); end

  def initialize!(group=T.unsafe(nil)); end

  def initialized?(); end

  def initializer(name, opts=T.unsafe(nil), &block); end

  def isolate_namespace(mod); end

  def key_generator(); end

  def message_verifier(verifier_name); end

  def migration_railties(); end

  def ordered_railties(); end

  def precompiled_assets(clear_cache=T.unsafe(nil)); end

  def railties_initializers(current); end

  def rake_tasks(&block); end

  def reload_routes!(); end

  def reloaders(); end

  def require_environment!(); end

  def routes_reloader(); end

  def run_load_hooks!(); end

  def run_tasks_blocks(app); end

  def runner(&blk); end

  def sandbox(); end

  def sandbox=(sandbox); end

  def sandbox?(); end

  def secrets(); end

  def secrets=(secrets); end

  def to_app(); end

  def validate_secret_key_config!(); end

  def watchable_args(); end
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

class Rails::Application
  def self.add_lib_to_load_path!(root); end

  def self.create(initial_variable_values=T.unsafe(nil), &block); end
end

class Rails::ApplicationController
  def local_request?(); end

  def require_local!(); end
end

class Rails::ApplicationController
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  DOT_SLASH = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Rails::BacktraceCleaner
end

module Rails::Configuration
end

class Rails::Configuration::Generators
  def aliases(); end

  def aliases=(aliases); end

  def colorize_logging(); end

  def colorize_logging=(colorize_logging); end

  def fallbacks(); end

  def fallbacks=(fallbacks); end

  def hidden_namespaces(); end

  def hide_namespace(namespace); end

  def method_missing(method, *args); end

  def options(); end

  def options=(options); end

  def templates(); end

  def templates=(templates); end
end

class Rails::Configuration::Generators
end

class Rails::Configuration::MiddlewareStackProxy
  def delete(*args, &block); end

  def insert(*args, &block); end

  def insert_after(*args, &block); end

  def insert_before(*args, &block); end

  def merge_into(other); end

  def swap(*args, &block); end

  def unshift(*args, &block); end

  def use(*args, &block); end
end

class Rails::Configuration::MiddlewareStackProxy
end

module Rails::Configuration
end

module Rails::Dom
end

module Rails::Dom::Testing
end

module Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::TagAssertions
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil)); end

  def compare_doms(expected, actual); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_children?(child, other_child); end
end

module Rails::Dom::Testing::Assertions::DomAssertions
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  def assert_select(*args, &block); end

  def assert_select_email(&block); end

  def assert_select_encoded(element=T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
end

module Rails::Dom::Testing::Assertions::TagAssertions
  def assert_no_tag(*opts); end

  def assert_tag(*opts); end

  def find_all_tag(conditions); end

  def find_tag(conditions); end
end

module Rails::Dom::Testing::Assertions::TagAssertions
end

module Rails::Dom::Testing::Assertions
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing
end

module Rails::Dom
end

class Rails::Engine
  def _all_autoload_once_paths(); end

  def _all_autoload_paths(); end

  def _all_load_paths(); end

  def app(); end

  def call(env); end

  def default_middleware_stack(); end

  def eager_load!(); end

  def endpoint(); end

  def engine_name(*args, &block); end

  def env_config(); end

  def has_migrations?(); end

  def helpers(); end

  def helpers_paths(); end

  def isolated?(*args, &block); end

  def load_config_initializer(initializer); end

  def load_console(app=T.unsafe(nil)); end

  def load_generators(app=T.unsafe(nil)); end

  def load_runner(app=T.unsafe(nil)); end

  def load_seed(); end

  def load_tasks(app=T.unsafe(nil)); end

  def middleware(*args, &block); end

  def paths(*args, &block); end

  def railties(); end

  def root(*args, &block); end

  def routes(); end

  def routes?(); end

  def run_tasks_blocks(*_); end
end

class Rails::Engine
  def self.called_from(); end

  def self.called_from=(called_from); end

  def self.eager_load!(*args, &block); end

  def self.endpoint(endpoint=T.unsafe(nil)); end

  def self.engine_name(name=T.unsafe(nil)); end

  def self.find(path); end

  def self.find_root(from); end

  def self.find_root_with_flag(flag, root_path, default=T.unsafe(nil)); end

  def self.isolate_namespace(mod); end

  def self.isolated(); end

  def self.isolated=(isolated); end

  def self.isolated?(); end
end

module Rails::Generators
  def namespace(); end

  def namespace=(obj); end
  DEFAULT_ALIASES = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Actions
  def add_source(source, options=T.unsafe(nil)); end

  def after_bundle(&block); end

  def application(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def capify!(); end

  def environment(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def extify(name); end

  def gem(*args); end

  def gem_group(*names, &block); end

  def generate(what, *args); end

  def git(commands=T.unsafe(nil)); end

  def initialize(*_); end

  def initializer(filename, data=T.unsafe(nil), &block); end

  def lib(filename, data=T.unsafe(nil), &block); end

  def log(*args); end

  def quote(value); end

  def rake(command, options=T.unsafe(nil)); end

  def rakefile(filename, data=T.unsafe(nil), &block); end

  def readme(path); end

  def route(routing_code); end

  def vendor(filename, data=T.unsafe(nil), &block); end
end

class Rails::Generators::Actions::CreateMigration
  def existing_migration(); end

  def migration_dir(); end

  def migration_file_name(); end

  def on_conflict_behavior(); end

  def relative_existing_migration(); end

  def say_status(status, color, message=T.unsafe(nil)); end
end

class Rails::Generators::Actions::CreateMigration
end

module Rails::Generators::Actions
end

class Rails::Generators::ActiveModel
  def destroy(); end

  def errors(); end

  def initialize(name); end

  def name(); end

  def save(); end

  def update(params=T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def self.all(klass); end

  def self.build(klass, params=T.unsafe(nil)); end

  def self.find(klass, params=T.unsafe(nil)); end
end

class Rails::Generators::Base
  include ::Thor::Actions
  include ::Rails::Generators::Actions
  def class_collisions(*class_names); end

  def extract_last_module(nesting); end
end

class Rails::Generators::Base
  def self.add_shebang_option!(); end

  def self.base_name(); end

  def self.base_root(); end

  def self.default_aliases_for_option(name, options); end

  def self.default_for_option(config, name, options, default); end

  def self.default_generator_root(); end

  def self.default_source_root(); end

  def self.default_value_for_option(name, options); end

  def self.generator_name(); end

  def self.hide!(); end

  def self.hook_for(*names, &block); end

  def self.hooks(); end

  def self.inherited(base); end

  def self.prepare_for_invocation(name, value); end

  def self.remove_hook_for(*names); end

  def self.usage_path(); end
end

module Rails::Generators::Migration
  def create_migration(destination, data, config=T.unsafe(nil), &block); end

  def migration_class_name(); end

  def migration_file_name(); end

  def migration_number(); end

  def migration_template(source, destination, config=T.unsafe(nil)); end

  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration::ClassMethods
  def current_migration_number(dirname); end

  def migration_exists?(dirname, file_name); end

  def migration_lookup_at(dirname); end

  def next_migration_number(dirname); end
end

module Rails::Generators::Migration::ClassMethods
end

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern
end

class Rails::Generators::NamedBase
  def application_name(); end

  def assign_names!(name); end

  def attributes_names(); end

  def class_name(); end

  def class_path(); end

  def file_name(); end

  def file_path(); end

  def human_name(); end

  def i18n_scope(); end

  def indent(content, multiplier=T.unsafe(nil)); end

  def index_helper(); end

  def initialize(args, *options); end

  def inside_template(); end

  def inside_template?(); end

  def module_namespacing(&block); end

  def mountable_engine?(); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespaced?(); end

  def namespaced_class_path(); end

  def namespaced_file_path(); end

  def namespaced_path(); end

  def parse_attributes!(); end

  def plural_file_name(); end

  def plural_name(); end

  def plural_table_name(); end

  def pluralize_table_names?(); end

  def regular_class_path(); end

  def route_url(); end

  def singular_name(); end

  def singular_table_name(); end

  def table_name(); end

  def uncountable?(); end

  def wrap_with_namespace(content); end
end

class Rails::Generators::NamedBase
  def self.check_class_collision(options=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def assign_controller_names!(name); end

  def controller_class_name(); end

  def controller_class_path(); end

  def controller_file_name(); end

  def controller_file_path(); end

  def controller_i18n_scope(); end

  def controller_name(); end

  def initialize(*args); end

  def orm_class(); end

  def orm_instance(name=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def self.included(base); end
end

class Rails::Generators::TestCase
  include ::Rails::Generators::Testing::Behaviour
  include ::Rails::Generators::Testing::SetupAndTeardown
  include ::Rails::Generators::Testing::Assertions
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def current_path(); end

  def current_path=(current_path); end

  def current_path?(); end

  def default_arguments(); end

  def default_arguments=(default_arguments); end

  def default_arguments?(); end

  def destination_root(); end

  def destination_root=(destination_root); end

  def destination_root?(); end

  def generator_class(); end

  def generator_class=(generator_class); end

  def generator_class?(); end
end

class Rails::Generators::TestCase
  def self.current_path(); end

  def self.current_path=(val); end

  def self.current_path?(); end

  def self.default_arguments(); end

  def self.default_arguments=(val); end

  def self.default_arguments?(); end

  def self.destination_root(); end

  def self.destination_root=(val); end

  def self.destination_root?(); end

  def self.generator_class(); end

  def self.generator_class=(val); end

  def self.generator_class?(); end
end

module Rails::Generators::Testing
end

module Rails::Generators::Testing::Assertions
  def assert_class_method(method, content, &block); end

  def assert_directory(relative, *contents); end

  def assert_field_default_value(attribute_type, value); end

  def assert_field_type(attribute_type, field_type); end

  def assert_file(relative, *contents); end

  def assert_instance_method(method, content); end

  def assert_method(method, content); end

  def assert_migration(relative, *contents, &block); end

  def assert_no_directory(relative); end

  def assert_no_file(relative); end

  def assert_no_migration(relative); end
end

module Rails::Generators::Testing::Assertions
end

module Rails::Generators::Testing::Behaviour
  def capture(stream); end

  def create_generated_attribute(attribute_type, name=T.unsafe(nil), index=T.unsafe(nil)); end

  def destination_root_is_set?(); end

  def ensure_current_path(); end

  def generator(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def migration_file_name(relative); end

  def prepare_destination(); end

  def run_generator(args=T.unsafe(nil), config=T.unsafe(nil)); end
end

module Rails::Generators::Testing::Behaviour
  extend ::ActiveSupport::Concern
end

module Rails::Generators::Testing::SetupAndTeardown
  def setup(); end

  def teardown(); end
end

module Rails::Generators::Testing::SetupAndTeardown
end

module Rails::Generators::Testing
end

module Rails::Generators
  def self.aliases(); end

  def self.configure!(config); end

  def self.fallbacks(); end

  def self.find_by_namespace(name, base=T.unsafe(nil), context=T.unsafe(nil)); end

  def self.help(command=T.unsafe(nil)); end

  def self.hidden_namespaces(); end

  def self.hide_namespace(*namespaces); end

  def self.hide_namespaces(*namespaces); end

  def self.invoke(namespace, args=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.invoke_fallbacks_for(name, base); end

  def self.levenshtein_distance(str1, str2); end

  def self.lookup(namespaces); end

  def self.lookup!(); end

  def self.namespace(); end

  def self.namespace=(obj); end

  def self.namespaces_to_paths(namespaces); end

  def self.no_color!(); end

  def self.options(); end

  def self.print_generators(); end

  def self.print_list(base, namespaces); end

  def self.public_namespaces(); end

  def self.sorted_groups(); end

  def self.subclasses(); end

  def self.templates_path(); end
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::FullSanitizer
end

class Rails::Html::FullSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::PermitScrubber
  def allowed_node?(node); end

  def attributes(); end

  def attributes=(attributes); end

  def initialize(); end

  def keep_node?(node); end

  def scrub_attribute(node, attr_node); end

  def scrub_attribute?(name); end

  def scrub_attributes(node); end

  def scrub_css_attribute(node); end

  def scrub_node(node); end

  def skip_node?(node); end

  def tags(); end

  def tags=(tags); end

  def validate!(var, name); end
end

class Rails::Html::PermitScrubber
end

class Rails::Html::SafeListSanitizer
  def sanitize_css(style_string); end
end

class Rails::Html::SafeListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

class Rails::Html::Sanitizer
  def sanitize(html, options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  def self.full_sanitizer(); end

  def self.link_sanitizer(); end

  def self.safe_list_sanitizer(); end

  def self.white_list_sanitizer(); end
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TextOnlyScrubber
  def initialize(); end
end

class Rails::Html::TextOnlyScrubber
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

module Rails::Html
end

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def _layout_from_proc(); end

  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

module Rails::Initializable
  def initializers(); end

  def run_initializers(group=T.unsafe(nil), *args); end
end

module Rails::Initializable
  def self.included(base); end
end

class Rails::MailersController
  def find_part(format); end

  def find_preferred_part(*formats); end

  def find_preview(); end

  def index(); end

  def preview(); end

  def show_previews?(); end
end

class Rails::MailersController
end

module Rails::Paths
end

class Rails::Paths::Path
  include ::Enumerable
  def <<(path); end

  def autoload!(); end

  def autoload?(); end

  def autoload_once!(); end

  def autoload_once?(); end

  def children(); end

  def concat(paths); end

  def each(&block); end

  def eager_load!(); end

  def eager_load?(); end

  def existent(); end

  def existent_directories(); end

  def expanded(); end

  def first(); end

  def glob(); end

  def glob=(glob); end

  def initialize(root, current, paths, options=T.unsafe(nil)); end

  def last(); end

  def load_path!(); end

  def load_path?(); end

  def push(path); end

  def skip_autoload!(); end

  def skip_autoload_once!(); end

  def skip_eager_load!(); end

  def skip_load_path!(); end

  def to_a(); end

  def to_ary(); end

  def unshift(*paths); end
end

class Rails::Paths::Path
end

class Rails::Paths::Root
  def [](path); end

  def []=(path, value); end

  def add(path, options=T.unsafe(nil)); end

  def all_paths(); end

  def autoload_once(); end

  def autoload_paths(); end

  def eager_load(); end

  def initialize(path); end

  def keys(); end

  def load_paths(); end

  def path(); end

  def path=(path); end

  def values(); end

  def values_at(*list); end
end

class Rails::Paths::Root
end

module Rails::Paths
end

module Rails::Rack
end

class Rails::Rack::LogTailer
  def call(env); end

  def initialize(app, log=T.unsafe(nil)); end

  def tail!(); end
end

class Rails::Rack::LogTailer
end

class Rails::Rack::Logger
  def call(env); end

  def call_app(request, env); end

  def compute_tags(request); end

  def initialize(app, taggers=T.unsafe(nil)); end

  def started_request_message(request); end
end

class Rails::Rack::Logger
end

module Rails::Rack
end

class Rails::Railtie
  include ::Rails::Initializable
  def config(); end

  def configure(&block); end

  def railtie_name(*args, &block); end

  def railtie_namespace(); end

  def run_console_blocks(app); end

  def run_generators_blocks(app); end

  def run_runner_blocks(app); end

  def run_tasks_blocks(app); end
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

class Rails::Railtie
  def self.abstract_railtie?(); end

  def self.config(*args, &block); end

  def self.configure(&block); end

  def self.console(&blk); end

  def self.generate_railtie_name(string); end

  def self.generators(&blk); end

  def self.inherited(base); end

  def self.instance(); end

  def self.method_missing(name, *args, &block); end

  def self.railtie_name(name=T.unsafe(nil)); end

  def self.rake_tasks(&blk); end

  def self.respond_to_missing?(*args); end

  def self.runner(&blk); end
end

class Rails::TestUnitRailtie
end

class Rails::TestUnitRailtie
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Rails
  extend ::ActiveSupport::Autoload
  def self.app_class(); end

  def self.app_class=(app_class); end

  def self.application=(application); end

  def self.backtrace_cleaner(); end

  def self.cache(); end

  def self.cache=(cache); end

  def self.configuration(); end

  def self.env(); end

  def self.env=(environment); end

  def self.gem_version(); end

  def self.groups(*groups); end

  def self.initialize!(*args, &block); end

  def self.initialized?(*args, &block); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.public_path(); end

  def self.version(); end
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

module Rainbow
  def self.new(); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, **options, &block); end

  def chdir(*args, **options, &block); end

  def chmod(*args, **options, &block); end

  def chmod_R(*args, **options, &block); end

  def chown(*args, **options, &block); end

  def chown_R(*args, **options, &block); end

  def copy(*args, **options, &block); end

  def cp(*args, **options, &block); end

  def cp_lr(*args, **options, &block); end

  def cp_r(*args, **options, &block); end

  def install(*args, **options, &block); end

  def link(*args, **options, &block); end

  def ln(*args, **options, &block); end

  def ln_s(*args, **options, &block); end

  def ln_sf(*args, **options, &block); end

  def makedirs(*args, **options, &block); end

  def mkdir(*args, **options, &block); end

  def mkdir_p(*args, **options, &block); end

  def mkpath(*args, **options, &block); end

  def move(*args, **options, &block); end

  def mv(*args, **options, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_output_message(message); end

  def remove(*args, **options, &block); end

  def rm(*args, **options, &block); end

  def rm_f(*args, **options, &block); end

  def rm_r(*args, **options, &block); end

  def rm_rf(*args, **options, &block); end

  def rmdir(*args, **options, &block); end

  def rmtree(*args, **options, &block); end

  def safe_unlink(*args, **options, &block); end

  def symlink(*args, **options, &block); end

  def touch(*args, **options, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::TaskLib
  include ::Rake::Cloneable
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

class Rake::TaskLib
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  def %(_); end

  def each_with_time_with_zone(&block); end

  def each_without_time_with_zone(); end

  def entries(); end

  def include_with_range?(value); end

  def include_without_range?(_); end

  def overlaps?(other); end

  def step_with_time_with_zone(n=T.unsafe(nil), &block); end

  def step_without_time_with_zone(*_); end

  def sum(identity=T.unsafe(nil)); end

  def to_a(); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Rational
  def to_d(precision); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Redcarpet
  VERSION = ::T.let(nil, ::T.untyped)
end

class Redcarpet::Markdown
  def render(_); end

  def renderer(); end
end

class Redcarpet::Markdown
end

module Redcarpet::Render
end

class Redcarpet::Render::Base
end

class Redcarpet::Render::Base
end

class Redcarpet::Render::HTML
  def initialize(*_); end
end

class Redcarpet::Render::HTML
end

class Redcarpet::Render::HTML_TOC
  def initialize(*_); end
end

class Redcarpet::Render::HTML_TOC
end

class Redcarpet::Render::Safe
  def block_code(code, lang); end

  def initialize(extensions=T.unsafe(nil)); end
end

class Redcarpet::Render::Safe
end

class Redcarpet::Render::SmartyHTML
  include ::Redcarpet::Render::SmartyPants
end

class Redcarpet::Render::SmartyHTML
end

module Redcarpet::Render::SmartyPants
  def postprocess(_); end
end

module Redcarpet::Render::SmartyPants
  extend ::Redcarpet::Render::SmartyPants
  def self.render(text); end
end

class Redcarpet::Render::StripDown
  def autolink(*args); end

  def block_code(*args); end

  def block_html(*args); end

  def block_quote(*args); end

  def codespan(*args); end

  def double_emphasis(*args); end

  def emphasis(*args); end

  def entity(*args); end

  def footnote_def(*args); end

  def footnote_ref(*args); end

  def footnotes(*args); end

  def header(text, header_level); end

  def highlight(*args); end

  def image(link, title, content); end

  def link(link, title, content); end

  def list(*args); end

  def list_item(*args); end

  def normal_text(*args); end

  def paragraph(text); end

  def quote(*args); end

  def raw_html(*args); end

  def strikethrough(*args); end

  def superscript(*args); end

  def table(header, body); end

  def table_cell(content, alignment); end

  def table_row(content); end

  def triple_emphasis(*args); end

  def underline(*args); end
end

class Redcarpet::Render::StripDown
end

class Redcarpet::Render::XHTML
  def initialize(extensions=T.unsafe(nil)); end
end

class Redcarpet::Render::XHTML
end

module Redcarpet::Render
end

module Redcarpet
end

class RedcarpetCompat
  def initialize(text, *exts); end

  def text(); end

  def text=(text); end

  def to_html(*_dummy); end
  EXTENSION_MAP = ::T.let(nil, ::T.untyped)
  RENDERER_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RedcarpetCompat
end

class Regexp
  def multiline?(); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

class Ripper
  def column(); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EVENTS = ::T.let(nil, ::T.untyped)
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENTS = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENTS = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def column(); end

  def filename(); end

  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(init=T.unsafe(nil)); end

  def state(); end
end

class Ripper::Filter
end

class Ripper::Lexer
  def lex(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.lex_state_name(_); end

  def self.parse(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.token_match(src, pattern); end
end

module RuboCop
end

module RuboCop::AST
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AliasNode
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def each_value(&block); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
  VOID_CONTEXT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::BreakNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::BreakNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseMatchNode
  include ::RuboCop::AST::ConditionalNode
  def each_in_pattern(); end

  def else?(); end

  def else_branch(); end

  def in_pattern_branches(); end

  def keyword(); end
end

class RuboCop::AST::CaseMatchNode
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def each_when(); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

class RuboCop::AST::ClassNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def alpha_paginate(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude?(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def split(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def to(*args, &block); end

  def to_ary(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::DefinedNode
end

class RuboCop::AST::EnsureNode
  def body(); end
end

class RuboCop::AST::EnsureNode
end

class RuboCop::AST::FloatNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::FloatNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

class RuboCop::AST::ForwardArgsNode
  include ::RuboCop::AST::CollectionNode
end

class RuboCop::AST::ForwardArgsNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def branches(); end

  def each_branch(); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::IntNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::IntNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
  DOUBLE_SPLAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::KeywordSplatNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(node=T.unsafe(nil)); end

  def arguments(); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def macro_scope?(node=T.unsafe(nil)); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def receiver(); end

  def safe_navigation?(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
  ARITHMETIC_OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIAL_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
  ENUMERATOR_METHODS = ::T.let(nil, ::T.untyped)
  OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodIdentifierPredicates
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::ModuleNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(node=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def child_nodes(); end

  def class_constructor?(node=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_e_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_e_type?(); end

  def defs_type?(); end

  def descendants(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def guard_clause?(); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_or_proc?(node=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def line_count(); end

  def literal?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_guard_clause?(node=T.unsafe(nil)); end

  def match_nil_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(node=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(node=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rational_type?(); end

  def receiver(node=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def root_type?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(node=T.unsafe(nil)); end

  def str_type?(); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def visit_descendants(types, &block); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::NumericNode
  def sign?(); end
  SIGN_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NumericNode
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(with_spacing=T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(with_spacing=T.unsafe(nil)); end

  def value_on_new_line?(); end
  COLON = ::T.let(nil, ::T.untyped)
  HASH_ROCKET = ::T.let(nil, ::T.untyped)
  SPACED_COLON = ::T.let(nil, ::T.untyped)
  SPACED_HASH_ROCKET = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
  LOGICAL_AND = ::T.let(nil, ::T.untyped)
  LOGICAL_OR = ::T.let(nil, ::T.untyped)
  SEMANTIC_AND = ::T.let(nil, ::T.untyped)
  SEMANTIC_OR = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RangeNode
end

class RuboCop::AST::RegexpNode
  def content(); end

  def regopt(); end

  def to_regexp(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def exception_variable(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::RetryNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::RetryNode
end

class RuboCop::AST::ReturnNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::ReturnNode
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SelfClassNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

module RuboCop::AST::Traversal
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  MANY_CHILD_NODES = ::T.let(nil, ::T.untyped)
  NO_CHILD_NODES = ::T.let(nil, ::T.untyped)
  ONE_CHILD_NODE = ::T.let(nil, ::T.untyped)
  SECOND_CHILD_ONLY = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

module RuboCop::CLI::Command
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  include ::RuboCop::Formatter::TextUtil
  def run(); end
end

class RuboCop::CLI::Command::ExecuteRunner
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
end

class RuboCop::CLI::Command::Version
  def run(); end
end

class RuboCop::CLI::Command::Version
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CLI::Environment
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  REDUNDANT_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::CommentConfig
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](*args, &block); end

  def []=(*args, &block); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def delete(*args, &block); end

  def deprecation_check(); end

  def disabled_new_cops?(); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def enabled_new_cops?(); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_cop(cop); end

  def for_department(department_name); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*args, &block); end

  def merge(*args, &block); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def pending_cops(); end

  def possibly_include_hidden?(); end

  def signature(); end

  def smart_loaded_path(); end

  def target_rails_version(); end

  def target_ruby_version(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def transform_values(*args, &block); end

  def validate(*args, &block); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config::CopConfig
  def metadata(); end

  def metadata=(_); end

  def name(); end

  def name=(_); end
end

class RuboCop::Config::CopConfig
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Config
  extend ::Forwardable
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_inheritance_from_auto_generated_file(); end

  def self.add_missing_namespaces(path, hash); end

  def self.auto_gen_config(); end

  def self.auto_gen_config=(auto_gen_config); end

  def self.auto_gen_config?(); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.options_config(); end

  def self.options_config=(options_config); end

  def self.possible_new_cops?(config); end

  def self.warn_on_pending_cops(pending_cops); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete_cops_and_parameters(); end
  MOVED_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_ENFORCED_STYLES = ::T.let(nil, ::T.untyped)
  OBSOLETE_PARAMETERS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS_WITH_REASON = ::T.let(nil, ::T.untyped)
  RENAMED_COPS = ::T.let(nil, ::T.untyped)
  SPLIT_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

class RuboCop::ConfigValidator
  def for_all_cops(*args, &block); end

  def initialize(config); end

  def smart_loaded_path(*args, &block); end

  def target_ruby_version(); end

  def validate(); end

  def validate_section_presence(name); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  extend ::Forwardable
end

module RuboCop::Cop
end

module RuboCop::Cop::ActiveRecordHelper
  def external_dependency_checksum(); end

  def find_belongs_to(node0); end

  def find_set_table_name(node0); end

  def foreign_key_of(belongs_to); end

  def resolve_relation_into_column(name:, class_node:, table:); end

  def schema(); end

  def table_name(class_node); end
end

module RuboCop::Cop::ActiveRecordHelper
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def correctable?(); end

  def disable_offense(node); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end

  def support_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(department, cop_name); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge::InvalidBadge
  def initialize(token); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Badge::InvalidBadge
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

module RuboCop::Cop::Bundler
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  def gem_declaration?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def insecure_protocol_source?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
end

module RuboCop::Cop::Bundler
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CheckLineBreakable
end

module RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ClassishLength
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::CodeLength
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_configured?(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
end

class RuboCop::Cop::Cop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def correct(node); end

  def corrections(); end

  def disable_uncorrectable(node); end

  def duplicate_location?(location); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def find_location(node, loc); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def join_force?(_force_class); end

  def message(_node=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def parse(source, path=T.unsafe(nil)); end

  def processed_source(); end

  def processed_source=(processed_source); end

  def reason_to_not_correct(node); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros
  def self.all(); end

  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.inherited(subclass); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def corrections(); end

  def diagnostics(); end

  def initialize(source_buffer, corrections=T.unsafe(nil)); end

  def insert_after(node_or_range, content); end

  def insert_before(node_or_range, content); end

  def remove(node_or_range); end

  def remove_leading(node_or_range, size); end

  def remove_preceding(node_or_range, size); end

  def remove_trailing(node_or_range, size); end

  def replace(node_or_range, content); end

  def rewrite(); end

  def wrap(node_or_range, before, after); end
end

class RuboCop::Cop::Corrector
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(node=T.unsafe(nil)); end
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(node); end

  def self.insert_before(node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
  CORRECTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  def assignment_method_declarations(node0); end

  def gem_specification(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def investigate(processed_source); end

  def required_ruby_version(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def gem_specification?(node0); end

  def on_const(node); end

  def ruby_version?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Generator
  def initialize(name, github_user, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added:); end

  def inject(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
end

class RuboCop::Cop::Generator
end

module RuboCop::Cop::HashAlignmentStyles
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
end

module RuboCop::Cop::HashAlignmentStyles
end

module RuboCop::Cop::HashTransformMethod
  def autocorrect(node); end

  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def self.[](*_); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.members(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def noop_transformation?(); end

  def transformation_uses_both_args?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end

  def unchanged_body_expr(); end

  def unchanged_body_expr=(_); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::HashTransformMethod
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IndexMethod
  def autocorrect(node); end

  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::IndexMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::IndexMethod::Autocorrection
  def self.[](*_); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.members(); end
end

class RuboCop::Cop::IndexMethod::Captures
  def noop_transformation?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end
end

class RuboCop::Cop::IndexMethod::Captures
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::IndexMethod
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::Interpolation
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
end

class RuboCop::Cop::Layout::ArgumentAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
end

class RuboCop::Cop::Layout::ArrayAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
end

class RuboCop::Cop::Layout::AssignmentIndentation
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def leftmost_multiple_assignment(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def block_end_align_target?(node=T.unsafe(nil), param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
end

class RuboCop::Cop::Layout::ClassStructure
  def autocorrect(node); end

  def on_class(class_node); end

  def visibility_block?(node=T.unsafe(nil)); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def autocorrect(node); end

  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
end

class RuboCop::Cop::Layout::ConditionPosition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(node=T.unsafe(nil)); end

  def empty_line_required?(node=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end

  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def eligible_method_call?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
end

class RuboCop::Cop::Layout::HashAlignment
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offences_by(); end

  def offences_by=(offences_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
end

class RuboCop::Cop::Layout::HeredocIndentation
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_heredoc(node); end
  LIBRARY_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_TYPE_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_WIDTH_MSG = ::T.let(nil, ::T.untyped)
  STRIP_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
end

class RuboCop::Cop::Layout::IndentationStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  def access_modifier?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(_processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
end

class RuboCop::Cop::Layout::LineLength
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def investigate_post_walk(processed_source); end

  def on_array(node); end

  def on_block(node); end

  def on_hash(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::ParameterAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end

  def on_ensure(node); end

  def on_resbody(node); end
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RUBY_2_5_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def autocorrect(range); end

  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(comma); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(pos_before_left_paren); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def whitespace_after_operator?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(semicolon); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(target); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def autocorrect(range); end

  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  def autocorrect(range); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(lambda_node); end

  def on_send(node); end
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def autocorrect(node); end

  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  BRACKET_METHODS = ::T.let(nil, ::T.untyped)
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(begin_node); end

  def on_interpolation(begin_node); end
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::TrailingEmptyLines
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::Lint
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
end

class RuboCop::Cop::Lint::AmbiguousOperator
  include ::RuboCop::Cop::ParserDiagnostic
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
end

class RuboCop::Cop::Lint::BigDecimalNew
  def autocorrect(node); end

  def big_decimal_new(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
end

class RuboCop::Cop::Lint::BooleanSymbol
  def autocorrect(node); end

  def boolean_symbol?(node=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(node=T.unsafe(nil)); end

  def debugger_call?(node=T.unsafe(nil)); end

  def kernel?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def autocorrect(node); end

  def on_send(node); end
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(deprecated:, replacement:, class_constant: T.unsafe(nil)); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
end

class RuboCop::Cop::Lint::DuplicateHashKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(node=T.unsafe(nil)); end

  def attr?(node=T.unsafe(nil)); end

  def method_alias?(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
end

class RuboCop::Cop::Lint::EmptyEnsure
  def autocorrect(node); end

  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
end

class RuboCop::Cop::Lint::EmptyInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end

  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
end

class RuboCop::Cop::Lint::ErbNewArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def erb_new_with_non_keyword_arguments(node=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(node=T.unsafe(nil)); end

  def on_send(node); end
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(node0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_new_call?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
end

class RuboCop::Cop::Lint::InterpolationCheck
  def heredoc?(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
end

class RuboCop::Cop::Lint::LiteralAsCondition
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_interpolation(begin_node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
end

class RuboCop::Cop::Lint::MultipleComparison
  def autocorrect(node); end

  def multiple_compare?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def eval_call?(node=T.unsafe(nil)); end

  def exec_call?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def autocorrect(node); end

  def loop_variable(node=T.unsafe(nil)); end

  def on_block(node); end

  def unsorted_dir_block?(node=T.unsafe(nil)); end

  def unsorted_dir_each?(node=T.unsafe(nil)); end

  def var_is_required?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
end

class RuboCop::Cop::Lint::NumberConversion
  def autocorrect(node); end

  def datetime?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_method(node=T.unsafe(nil)); end
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(_node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
end

class RuboCop::Cop::Lint::RaiseException
  def exception?(node=T.unsafe(nil)); end

  def exception_new_with_message?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  include ::RuboCop::NameSimilarity
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(args); end

  def check(offenses, cop_disabled_line_ranges, comments); end
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment_and_name); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def unnecessary_require_statement?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def literal_expansion(node=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end

  def on_interpolation(begin_node); end

  def to_s_without_args?(node=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_index?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_object?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
end

class RuboCop::Cop::Lint::RescueType
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  def bad_method?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  def autocorrect(node); end

  def check(node); end

  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
end

class RuboCop::Cop::Lint::ScriptPermission
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def send_with_mixin_argument?(node=T.unsafe(nil)); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end

  def uses_var?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
end

class RuboCop::Cop::Lint::StructNewOverride
  def on_send(node); end

  def struct_new(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
end

class RuboCop::Cop::Lint::Syntax
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  def add_offense_from_error(error); end
  ERROR_SOURCE_RANGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def begin_pos(); end

  def begin_pos=(_); end

  def column(); end

  def column=(_); end

  def end_pos(); end

  def end_pos=(_); end

  def line(); end

  def line=(_); end

  def source_line(); end

  def source_line=(_); end
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Lint::Syntax
  def self.offenses_from_processed_source(processed_source, config, options); end
end

class RuboCop::Cop::Lint::ToJSON
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
end

class RuboCop::Cop::Lint::UnifiedInteger
  def autocorrect(node); end

  def fixnum_or_bignum_const(node=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(node=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedBlockArgument
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end

  def not_implemented?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(node=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
end

class RuboCop::Cop::Lint::UriRegexp
  def autocorrect(node); end

  def on_send(node); end

  def uri_regexp_with_argument?(node=T.unsafe(nil)); end

  def uri_regexp_without_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(node=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def dynamic_method_definition?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
end

class RuboCop::Cop::Lint::UselessAssignment
  include ::RuboCop::NameSimilarity
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def join_force?(force_class); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
end

class RuboCop::Cop::Lint::UselessComparison
  def on_send(node); end

  def useless_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessComparison
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(node=T.unsafe(nil)); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessSetterCall
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
end

module RuboCop::Cop::Lint
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  def define_method?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::Metrics
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
  def investigate(processed_source); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def class_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def module_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(node=T.unsafe(nil)); end

  def on_args(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
end

module RuboCop::Cop::Metrics::Utils
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def calculate(); end

  def else_branch?(node); end

  def evaluate_branch_nodes(node); end

  def evaluate_condition_node(node); end

  def initialize(node); end
  BRANCH_NODES = ::T.let(nil, ::T.untyped)
  CONDITION_NODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node); end
end

module RuboCop::Cop::Metrics::Utils
end

module RuboCop::Cop::Metrics
end

module RuboCop::Cop::Migration
end

class RuboCop::Cop::Migration::DepartmentName
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
end

module RuboCop::Cop::Migration
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def call(corrector); end

  def initialize(node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

module RuboCop::Cop::Naming
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(node=T.unsafe(nil)); end
  BLACKLISTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
end

class RuboCop::Cop::Naming::BlockParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::BlockParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(node=T.unsafe(nil)); end

  def literal_receiver?(node=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
end

class RuboCop::Cop::Naming::FileName
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def memoized?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  def attr?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def str_name(node=T.unsafe(nil)); end

  def sym_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
end

class RuboCop::Cop::Naming::MethodParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodParameterName
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
end

module RuboCop::Cop::Naming
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(node=T.unsafe(nil)); end

  def single_negative?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::NilMethods
end

module RuboCop::Cop::NilMethods
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(node); end
end

module RuboCop::Cop::ParserDiagnostic
  def investigate(processed_source); end
end

module RuboCop::Cop::ParserDiagnostic
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def config(); end

  def correct(node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(token); end

  def self.remove_space(space_before); end

  def self.swap_comma(range); end
end

module RuboCop::Cop::Rails
end

class RuboCop::Cop::Rails::ActionFilter
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  ACTION_METHODS = ::T.let(nil, ::T.untyped)
  FILTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActionFilter
end

class RuboCop::Cop::Rails::ActiveRecordAliases
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  ALIASES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveRecordAliases
end

class RuboCop::Cop::Rails::ActiveRecordOverride
  def on_def(node); end
  ACTIVE_RECORD_CLASSES = ::T.let(nil, ::T.untyped)
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveRecordOverride
end

class RuboCop::Cop::Rails::ActiveSupportAliases
  def append(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def ends_with?(node=T.unsafe(nil)); end

  def on_send(node); end

  def prepend(node=T.unsafe(nil)); end

  def starts_with?(node=T.unsafe(nil)); end
  ALIASES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveSupportAliases
end

class RuboCop::Cop::Rails::ApplicationController
  include ::RuboCop::Cop::EnforceSuperclass
  def autocorrect(node); end

  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
  BASE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPERCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ApplicationController
end

class RuboCop::Cop::Rails::ApplicationJob
  include ::RuboCop::Cop::EnforceSuperclass
  def autocorrect(node); end

  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
  BASE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPERCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ApplicationJob
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::ApplicationMailer
  include ::RuboCop::Cop::EnforceSuperclass
  def autocorrect(node); end

  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
  BASE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPERCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ApplicationMailer
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::ApplicationRecord
  include ::RuboCop::Cop::EnforceSuperclass
  def autocorrect(node); end

  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
  BASE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPERCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ApplicationRecord
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::AssertNot
  def autocorrect(node); end

  def offensive?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::AssertNot
end

class RuboCop::Cop::Rails::BelongsTo
  def autocorrect(node); end

  def match_belongs_to_with_options(node=T.unsafe(nil)); end

  def on_send(node); end
  SUPERFLOUS_REQUIRE_FALSE_MSG = ::T.let(nil, ::T.untyped)
  SUPERFLOUS_REQUIRE_TRUE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::BelongsTo
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::Blank
  def autocorrect(node); end

  def defining_blank?(node=T.unsafe(nil)); end

  def nil_or_empty?(node=T.unsafe(nil)); end

  def not_present?(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def unless_present?(node=T.unsafe(nil)); end
  MSG_NIL_OR_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NOT_PRESENT = ::T.let(nil, ::T.untyped)
  MSG_UNLESS_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Blank
end

class RuboCop::Cop::Rails::BulkChangeTable
  def on_def(node); end

  def on_send(node); end
  COMBINABLE_ALTER_METHODS = ::T.let(nil, ::T.untyped)
  COMBINABLE_TRANSFORMATIONS = ::T.let(nil, ::T.untyped)
  MIGRATION_METHODS = ::T.let(nil, ::T.untyped)
  MSG_FOR_ALTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG_FOR_CHANGE_TABLE = ::T.let(nil, ::T.untyped)
  MYSQL = ::T.let(nil, ::T.untyped)
  MYSQL_COMBINABLE_ALTER_METHODS = ::T.let(nil, ::T.untyped)
  MYSQL_COMBINABLE_TRANSFORMATIONS = ::T.let(nil, ::T.untyped)
  POSTGRESQL = ::T.let(nil, ::T.untyped)
  POSTGRESQL_COMBINABLE_ALTER_METHODS = ::T.let(nil, ::T.untyped)
  POSTGRESQL_COMBINABLE_TRANSFORMATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
  def flush(); end

  def offensive_nodes(); end

  def process(new_node); end
end

class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
end

class RuboCop::Cop::Rails::BulkChangeTable
end

class RuboCop::Cop::Rails::CreateTableWithTimestamps
  def create_table_with_block?(node=T.unsafe(nil)); end

  def create_table_with_timestamps_proc?(node=T.unsafe(nil)); end

  def created_at_or_updated_at_included?(node0); end

  def on_send(node); end

  def timestamps_included?(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::CreateTableWithTimestamps
end

class RuboCop::Cop::Rails::Date
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  BAD_DAYS = ::T.let(nil, ::T.untyped)
  DEPRECATED_METHODS = ::T.let(nil, ::T.untyped)
  DEPRECATED_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Date
end

class RuboCop::Cop::Rails::Delegate
  def autocorrect(node); end

  def delegate?(node=T.unsafe(nil)); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Delegate
end

class RuboCop::Cop::Rails::DelegateAllowBlank
  def allow_blank_option(node=T.unsafe(nil)); end

  def autocorrect(pair_node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DelegateAllowBlank
end

class RuboCop::Cop::Rails::DynamicFindBy
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  METHOD_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DynamicFindBy
end

class RuboCop::Cop::Rails::EnumHash
  def array_pair?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def enum?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnumHash
end

class RuboCop::Cop::Rails::EnumUniqueness
  include ::RuboCop::Cop::Duplication
  def enum?(node=T.unsafe(nil)); end

  def enum_values(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnumUniqueness
end

class RuboCop::Cop::Rails::EnvironmentComparison
  def autocorrect(node); end

  def comparing_str_env_with_rails_env_on_lhs?(node=T.unsafe(nil)); end

  def comparing_str_env_with_rails_env_on_rhs?(node=T.unsafe(nil)); end

  def comparing_sym_env_with_rails_env_on_lhs?(node=T.unsafe(nil)); end

  def comparing_sym_env_with_rails_env_on_rhs?(node=T.unsafe(nil)); end

  def content(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SYM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnvironmentComparison
end

class RuboCop::Cop::Rails::Exit
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  EXPLICIT_RECEIVERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Exit
end

class RuboCop::Cop::Rails::FilePath
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def file_join_nodes?(node=T.unsafe(nil)); end

  def on_dstr(node); end

  def on_send(node); end

  def rails_root_join_nodes?(node=T.unsafe(nil)); end

  def rails_root_nodes?(node0); end
  MSG_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FilePath
end

class RuboCop::Cop::Rails::FindBy
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end

  def where_first?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindBy
end

class RuboCop::Cop::Rails::FindEach
  def autocorrect(node); end

  def on_send(node); end
  IGNORED_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SCOPE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindEach
end

class RuboCop::Cop::Rails::HasAndBelongsToMany
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HasAndBelongsToMany
end

class RuboCop::Cop::Rails::HasManyOrHasOneDependent
  def active_resource_class?(node0); end

  def association_with_options?(node=T.unsafe(nil)); end

  def association_without_options?(node=T.unsafe(nil)); end

  def dependent_option?(node=T.unsafe(nil)); end

  def on_send(node); end

  def present_option?(node=T.unsafe(nil)); end

  def with_options_block(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HasManyOrHasOneDependent
end

class RuboCop::Cop::Rails::HelperInstanceVariable
  def on_ivar(node); end

  def on_ivasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HelperInstanceVariable
end

class RuboCop::Cop::Rails::HttpPositionalArguments
  def autocorrect(node); end

  def http_request?(node=T.unsafe(nil)); end

  def on_send(node); end
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORD_ARGS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpPositionalArguments
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::HttpStatus
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def http_status(node=T.unsafe(nil)); end

  def on_send(node); end

  def status_code(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
  def initialize(node); end

  def message(); end

  def node(); end

  def offensive?(); end

  def preferred_style(); end
  DEFAULT_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERMITTED_STATUS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
end

class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
  def initialize(node); end

  def message(); end

  def node(); end

  def offensive?(); end

  def preferred_style(); end
  DEFAULT_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
end

class RuboCop::Cop::Rails::HttpStatus
end

class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption
  def filter_options(node=T.unsafe(nil)); end

  def on_send(node); end
  FILTERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption
end

class RuboCop::Cop::Rails::IndexBy
  include ::RuboCop::Cop::IndexMethod
  def on_bad_each_with_object(node=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(node=T.unsafe(nil)); end

  def on_bad_map_to_h(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::IndexBy
end

class RuboCop::Cop::Rails::IndexWith
  include ::RuboCop::Cop::IndexMethod
  def on_bad_each_with_object(node=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(node=T.unsafe(nil)); end

  def on_bad_map_to_h(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::IndexWith
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::InverseOf
  def as_option?(node=T.unsafe(nil)); end

  def association_recv_arguments(node=T.unsafe(nil)); end

  def conditions_option?(node=T.unsafe(nil)); end

  def foreign_key_option?(node=T.unsafe(nil)); end

  def inverse_of_nil_option?(node=T.unsafe(nil)); end

  def inverse_of_option?(node=T.unsafe(nil)); end

  def on_send(node); end

  def options_contain_inverse_of?(options); end

  def options_from_argument(node=T.unsafe(nil)); end

  def options_ignoring_inverse_of?(options); end

  def options_requiring_inverse_of?(options); end

  def polymorphic_option?(node=T.unsafe(nil)); end

  def same_context_in_with_options?(arg, recv); end

  def scope?(arguments); end

  def through_option?(node=T.unsafe(nil)); end

  def with_options_arguments(recv, node); end
  NIL_MSG = ::T.let(nil, ::T.untyped)
  SPECIFY_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::InverseOf
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::LexicallyScopedActionFilter
  def on_send(node); end

  def only_or_except_filter_methods(node=T.unsafe(nil)); end
  FILTERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::LexicallyScopedActionFilter
end

class RuboCop::Cop::Rails::LinkToBlank
  def autocorrect(node); end

  def blank_target?(node=T.unsafe(nil)); end

  def includes_noopener?(node=T.unsafe(nil)); end

  def on_send(node); end

  def rel_node?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::LinkToBlank
end

class RuboCop::Cop::Rails::NotNullColumn
  def add_not_null_column?(node=T.unsafe(nil)); end

  def add_not_null_reference?(node=T.unsafe(nil)); end

  def default_option?(node=T.unsafe(nil)); end

  def null_false?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::NotNullColumn
end

class RuboCop::Cop::Rails::Output
  def io_output?(node=T.unsafe(nil)); end

  def on_send(node); end

  def output?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Output
end

class RuboCop::Cop::Rails::OutputSafety
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::OutputSafety
end

class RuboCop::Cop::Rails::PluralizationGrammar
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PLURAL_DURATION_METHODS = ::T.let(nil, ::T.untyped)
  SINGULAR_DURATION_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::PluralizationGrammar
end

class RuboCop::Cop::Rails::Presence
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end

  def redundant_negative_receiver_and_other(node=T.unsafe(nil)); end

  def redundant_receiver_and_other(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Presence
end

class RuboCop::Cop::Rails::Present
  def autocorrect(node); end

  def exists_and_not_empty?(node=T.unsafe(nil)); end

  def not_blank?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def unless_blank?(node=T.unsafe(nil)); end
  MSG_EXISTS_AND_NOT_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NOT_BLANK = ::T.let(nil, ::T.untyped)
  MSG_UNLESS_BLANK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Present
end

class RuboCop::Cop::Rails::RakeEnvironment
  def on_block(node); end

  def task_definition?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RakeEnvironment
end

class RuboCop::Cop::Rails::ReadWriteAttribute
  def autocorrect(node); end

  def on_send(node); end

  def read_write_attribute?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReadWriteAttribute
end

class RuboCop::Cop::Rails::RedundantAllowNil
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG_ALLOW_NIL_FALSE = ::T.let(nil, ::T.untyped)
  MSG_SAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantAllowNil
end

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions
  include ::RuboCop::Cop::RangeHelp
  def all_block_nodes_in(node0); end

  def all_send_nodes_in(node0); end

  def autocorrect(node); end

  def on_block(node); end

  def with_options?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::ReflectionClassName
  def association_with_reflection(node=T.unsafe(nil)); end

  def on_send(node); end

  def reflection_class_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReflectionClassName
end

class RuboCop::Cop::Rails::RefuteMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def offensive?(node=T.unsafe(nil)); end

  def on_send(node); end
  ASSERT_NOT_METHODS = ::T.let(nil, ::T.untyped)
  CORRECTIONS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REFUTE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RefuteMethods
end

class RuboCop::Cop::Rails::RelativeDateConstant
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_casgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end

  def relative_date?(node=T.unsafe(nil)); end

  def relative_date_assignment?(node=T.unsafe(nil)); end

  def relative_date_or_assignment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RelativeDateConstant
end

class RuboCop::Cop::Rails::RequestReferer
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end

  def referer?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RequestReferer
end

class RuboCop::Cop::Rails::ReversibleMigration
  def change_table_call(node=T.unsafe(nil)); end

  def drop_table_call(node=T.unsafe(nil)); end

  def irreversible_schema_statement_call(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end

  def remove_column_call(node=T.unsafe(nil)); end

  def remove_foreign_key_call(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReversibleMigration
end

class RuboCop::Cop::Rails::SafeNavigation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def try_call(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SafeNavigation
end

class RuboCop::Cop::Rails::SafeNavigationWithBlank
  def autocorrect(node); end

  def on_if(node); end

  def safe_navigation_blank_in_conditional?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SafeNavigationWithBlank
end

class RuboCop::Cop::Rails::SaveBang
  include ::RuboCop::Cop::NegativeConditional
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(node); end

  def check_assignment(assignment); end

  def join_force?(force_class); end

  def on_csend(node); end

  def on_send(node); end
  CREATE_CONDITIONAL_MSG = ::T.let(nil, ::T.untyped)
  CREATE_MSG = ::T.let(nil, ::T.untyped)
  CREATE_PERSIST_METHODS = ::T.let(nil, ::T.untyped)
  MODIFY_PERSIST_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERSIST_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SaveBang
end

class RuboCop::Cop::Rails::ScopeArgs
  def on_send(node); end

  def scope?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ScopeArgs
end

class RuboCop::Cop::Rails::SkipsModelValidations
  def good_touch?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  METHODS_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SkipsModelValidations
end

class RuboCop::Cop::Rails::TimeZone
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_const(node); end
  ACCEPTED_METHODS = ::T.let(nil, ::T.untyped)
  DANGEROUS_METHODS = ::T.let(nil, ::T.untyped)
  GOOD_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ACCEPTABLE = ::T.let(nil, ::T.untyped)
  MSG_LOCALTIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::TimeZone
end

class RuboCop::Cop::Rails::UniqBeforePluck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def aggressive_node_match(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def conservative_node_match(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UniqBeforePluck
end

class RuboCop::Cop::Rails::UniqueValidationWithoutIndex
  include ::RuboCop::Cop::ActiveRecordHelper
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UniqueValidationWithoutIndex
end

class RuboCop::Cop::Rails::UnknownEnv
  include ::RuboCop::NameSimilarity
  def on_send(node); end

  def rails_env?(node=T.unsafe(nil)); end

  def unknown_environment_equal?(node=T.unsafe(nil)); end

  def unknown_environment_predicate?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SIMILAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UnknownEnv
end

class RuboCop::Cop::Rails::Validation
  def autocorrect(node); end

  def on_send(node); end
  ALLOWLIST = ::T.let(nil, ::T.untyped)
  DENYLIST = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Validation
end

module RuboCop::Cop::Rails
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Registry
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def department_missing?(badge, name); end

  def departments(); end

  def each(&block); end

  def enabled(config, only, only_safe=T.unsafe(nil)); end

  def enabled?(cop, config, only_safe); end

  def enabled_pending_cop?(cop_cfg, config); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def initialize(cops=T.unsafe(nil), options=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, shall_warn=T.unsafe(nil)); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
end

module RuboCop::Cop::RescueNode
  def investigate(processed_source); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(node=T.unsafe(nil)); end

  def safe_assignment?(node=T.unsafe(nil)); end

  def setter_method?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Security::Eval
  def eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
end

class RuboCop::Cop::Security::JSONLoad
  def autocorrect(node); end

  def json_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
end

class RuboCop::Cop::Security::YAMLLoad
  def autocorrect(node); end

  def on_send(node); end

  def yaml_load(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

module RuboCop::Cop::Style
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def access_modifier_with_symbol?(node=T.unsafe(nil)); end

  def on_send(node); end
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def identifier(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
end

class RuboCop::Cop::Style::ArrayJoin
  def autocorrect(node); end

  def join_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def class_eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
end

class RuboCop::Cop::Style::CaseCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_check?(node=T.unsafe(nil)); end

  def message(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
end

class RuboCop::Cop::Style::ClassMethods
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
end

class RuboCop::Cop::Style::ClassVars
  def message(node); end

  def on_cvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
end

class RuboCop::Cop::Style::ColonMethodCall
  def autocorrect(node); end

  def java_type_node?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def autocorrect(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
end

class RuboCop::Cop::Style::CommentedKeyword
  def investigate(processed_source); end
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def candidate_condition?(node=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(node=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(processed_source); end
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
end

class RuboCop::Cop::Style::DateTime
  def date_time?(node=T.unsafe(nil)); end

  def historic_date?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_datetime?(node=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
end

class RuboCop::Cop::Style::DefWithParentheses
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
end

class RuboCop::Cop::Style::Dir
  def autocorrect(node); end

  def dir_replacement?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(node=T.unsafe(nil)); end

  def constant_visibility_declaration?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def module_function_node?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def autocorrect(node); end

  def offending_each_range(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def each_with_object_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(case_node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def array_node(node=T.unsafe(nil)); end

  def array_with_block(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def hash_node(node=T.unsafe(nil)); end

  def hash_with_block(node=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(node=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
end

class RuboCop::Cop::Style::EndBlock
  def autocorrect(node); end

  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(node=T.unsafe(nil)); end

  def line_with_offset?(node=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
end

class RuboCop::Cop::Style::EvenOdd
  def autocorrect(node); end

  def even_odd_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def file_expand_path(node=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(node=T.unsafe(nil)); end

  def pathname_parent_expand_path(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
end

class RuboCop::Cop::Style::ExponentialNotation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_float(node); end
end

class RuboCop::Cop::Style::ExponentialNotation
end

class RuboCop::Cop::Style::FloatDivision
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def any_coerce?(node=T.unsafe(nil)); end

  def both_coerce?(node=T.unsafe(nil)); end

  def left_coerce?(node=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::FloatDivision
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_for(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def formatter(node=T.unsafe(nil)); end

  def message(detected_style); end

  def method_name(style_name); end

  def on_send(node); end

  def variable_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def format_string_in_typical_context?(node=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
end

class RuboCop::Cop::Style::HashEachMethods
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end

  def kv_each(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
end

class RuboCop::Cop::Style::HashTransformKeys
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(node=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(node=T.unsafe(nil)); end

  def on_bad_map_to_h(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformKeys
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::HashTransformValues
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(node=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(node=T.unsafe(nil)); end

  def on_bad_map_to_h(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformValues
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
end

class RuboCop::Cop::Style::IfCorrector
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfInsideElse
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::IgnoredPattern
  def autocorrect(node); end

  def on_if(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(node); end

  def join_force?(force_class); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
end

class RuboCop::Cop::Style::InlineComment
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
end

class RuboCop::Cop::Style::InverseMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def correct_inverse_block(node); end

  def correct_inverse_method(node); end

  def correct_inverse_selector(block, corrector); end

  def inverse_block?(node=T.unsafe(nil)); end

  def inverse_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def on_numblock(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::LambdaCall
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(operator_range); end

  def investigate(processed_source); end
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::IgnoredPattern
  def autocorrect(_node); end

  def initialize(*_); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  def autocorrect(node); end

  def message(_node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  def autocorrect(node); end

  def message(_node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
end

class RuboCop::Cop::Style::MethodMissingSuper
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodMissingSuper
end

class RuboCop::Cop::Style::MinMax
  def autocorrect(node); end

  def min_max_candidate(node=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
end

class RuboCop::Cop::Style::MixinUsage
  def include_statement(node=T.unsafe(nil)); end

  def on_send(node); end

  def wrapped_macro_scope?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def extend_self_node?(node=T.unsafe(nil)); end

  def module_function_node?(node=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(node=T.unsafe(nil)); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
end

class RuboCop::Cop::Style::MultilineWhenThen
  include ::RuboCop::Cop::RangeHelp
  def accept_node_type?(node); end

  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison?(node=T.unsafe(nil)); end

  def simple_double_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_casgn(node); end

  def on_or_asgn(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(node=T.unsafe(nil)); end

  def splat_value(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
end

class RuboCop::Cop::Style::NegatedUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedUnless
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def add_parentheses_to_method_arguments(send_node); end

  def autocorrect(node); end

  def check(node); end

  def left_hand_operand(node, operator); end

  def modifier?(node); end

  def new_expression(inner_node); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end

  def replacement_operator(keyword); end

  def requires_parens?(node); end

  def right_hand_operand(node, left_hand_keyword); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(nested); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(_processed_source); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def nil_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
end

class RuboCop::Cop::Style::NonNilCheck
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def not_and_nil_check?(node=T.unsafe(nil)); end

  def not_equal_to_nil?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NonNilCheck
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_float(node); end

  def on_int(node); end
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def comparison(node=T.unsafe(nil)); end

  def inverted_comparison(node=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::OnNormalIfUnless
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
end

class RuboCop::Cop::Style::OrAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(node=T.unsafe(nil)); end

  def unless_assignment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def implicit_self_getter?(node=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(node0, param1, param2); end

  def tsort_each_child(assignment); end

  def uses_var?(node0, param1); end

  def var_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def autocorrect(node); end

  def control_op_condition(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def message(node); end

  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
end

class RuboCop::Cop::Style::PerlBackrefs
  def autocorrect(node); end

  def on_nth_ref(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
end

class RuboCop::Cop::Style::Proc
  def autocorrect(node); end

  def on_block(node); end

  def proc_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
end

class RuboCop::Cop::Style::RandomWithOffset
  def autocorrect(node); end

  def integer_op_rand?(node=T.unsafe(nil)); end

  def namespace(node=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(node=T.unsafe(nil)); end

  def rand_op_integer?(node=T.unsafe(nil)); end

  def random_call(node=T.unsafe(nil)); end

  def to_int(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
end

class RuboCop::Cop::Style::RedundantBegin
  def autocorrect(node); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
end

class RuboCop::Cop::Style::RedundantCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
end

class RuboCop::Cop::Style::RedundantCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end

  def redundant_condition?(node=T.unsafe(nil)); end

  def redundant_condition_inverted?(node=T.unsafe(nil)); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
end

class RuboCop::Cop::Style::RedundantException
  def autocorrect(node); end

  def compact?(node=T.unsafe(nil)); end

  def exploded?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def on_send(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
end

class RuboCop::Cop::Style::RedundantInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def first_send_argument?(node=T.unsafe(nil)); end

  def first_super_argument?(node=T.unsafe(nil)); end

  def method_node_and_args(node=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(node=T.unsafe(nil)); end

  def rescue?(node=T.unsafe(nil)); end

  def square_brackets?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantParentheses
end

class RuboCop::Cop::Style::RedundantPercentQ
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
end

class RuboCop::Cop::Style::RedundantSelf
  def autocorrect(node); end

  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
end

class RuboCop::Cop::Style::RedundantSort
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def redundant_sort?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
end

class RuboCop::Cop::Style::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_sort_by(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_resbody(node); end

  def rescue_standard_error?(node=T.unsafe(nil)); end

  def rescue_without_error_class?(node=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(node=T.unsafe(nil)); end

  def return_node?(node=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_node(node); end

  def modifier_if_safe_navigation_candidate(node=T.unsafe(nil)); end

  def not_nil_check?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def use_var_only_in_unless_modifier?(node, variable); end
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
end

class RuboCop::Cop::Style::Sample
  def autocorrect(node); end

  def on_send(node); end

  def sample_candidate?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
end

class RuboCop::Cop::Style::SelfAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end

  def sending?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def custom_fail_methods(node0); end

  def investigate(processed_source); end

  def kernel_call?(node=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def message(node); end

  def on_gvar(node); end
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def stderr_puts?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
end

class RuboCop::Cop::Style::StringHashKeys
  def autocorrect(node); end

  def on_pair(node); end

  def receive_environments_method?(node=T.unsafe(nil)); end

  def string_hash_key?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
end

class RuboCop::Cop::Style::Strip
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def lstrip_rstrip(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
end

class RuboCop::Cop::Style::StructInheritance
  def on_class(node); end

  def struct_constructor?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def autocorrect(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def proc_node?(node=T.unsafe(nil)); end

  def symbol_proc?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
end

class RuboCop::Cop::Style::TernaryCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def method_name(node=T.unsafe(nil)); end

  def on_if(node); end

  def only_closing_parenthesis_is_last_line?(condition); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryParentheses
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
end

class RuboCop::Cop::Style::TrivialAccessors
  def autocorrect(node); end

  def looks_like_trivial_writer?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
end

class RuboCop::Cop::Style::UnlessElse
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
end

class RuboCop::Cop::Style::UnpackFirst
  def autocorrect(node); end

  def on_send(node); end

  def unpack_and_first_element?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
end

class RuboCop::Cop::Style::VariableInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
end

class RuboCop::Cop::Style::WhenThen
  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
end

class RuboCop::Cop::Style::WhileUntilDo
  def autocorrect(node); end

  def handle(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def file_constant_equal_program_name?(node=T.unsafe(nil)); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def autocorrect(node); end

  def non_polymorphic_collection?(node=T.unsafe(nil)); end

  def nonzero_length_predicate(node=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(node=T.unsafe(nil)); end

  def zero_length_predicate(node=T.unsafe(nil)); end

  def zero_length_receiver(node=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
end

module RuboCop::Cop::Style
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
end

module RuboCop::Cop::TargetRailsVersion
  def minimum_target_rails_version(version); end

  def support_target_rails_version?(version); end
end

module RuboCop::Cop::TargetRailsVersion
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect(buffer, cops); end

  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def forces_for(cops); end

  def initialize(cop_classes, config, options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Team::Investigation
  def errors(); end

  def errors=(_); end

  def offenses(); end

  def offenses=(_); end
end

class RuboCop::Cop::Team::Investigation
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Team
end

module RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TooManyLines
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(processed_source, node); end

  def self.correct_for_blockarg_type(node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.tokens(node); end

  def self.trim_string_interporation_escape_character(str); end
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def width(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
end

class RuboCop::Cop::Utils::FormatString
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_if?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

class RuboCop::Cop::VariableForce
end

module RuboCop::Cop
end

class RuboCop::Error
end

class RuboCop::Error
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir); end

  def find_files_upwards(filename, start_dir); end
end

module RuboCop::FileFinder
  def self.root_level=(level); end

  def self.root_level?(path); end
end

module RuboCop::Formatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
end

class RuboCop::Formatter::HTMLFormatter
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::JUnitFormatter
  def classname_attribute_value(file); end

  def finished(_inspected_files); end
end

class RuboCop::Formatter::JUnitFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::PacmanFormatter
  include ::RuboCop::Formatter::TextUtil
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, rainbow); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::SimpleTextFormatter
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

module RuboCop::Formatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def valid_literal_value?(); end
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
  def find_similar_name(target_name, scope); end
  MINIMUM_SIMILARITY_TO_SUGGEST = ::T.let(nil, ::T.untyped)
end

module RuboCop::NameSimilarity
end

class RuboCop::NodePattern
  def ==(other); end

  def eql?(other); end

  def initialize(str); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args); end

  def pattern(); end
end

class RuboCop::NodePattern::Invalid
end

class RuboCop::NodePattern::Invalid
end

module RuboCop::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str); end

  def def_node_search(method_name, pattern_str); end

  def node_search(method_name, compiler, on_match, prelude, called_from); end

  def node_search_all(method_name, compiler, called_from); end

  def node_search_body(method_name, trailing_params, prelude, match_code, on_match); end

  def node_search_first(method_name, compiler, called_from); end
end

module RuboCop::NodePattern::Macros
end

class RuboCop::NodePattern
  def self.descend(element, &block); end
end

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Options
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def display_only_fail_level_offenses_with_autocorrect?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def only_includes_redundant_disable?(); end

  def validate_auto_correct(); end

  def validate_auto_gen_config(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_exclude_limit_option(); end

  def validate_parallel(); end

  def validate_parallel_with_combo_option(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.chdir(dir, &block); end

  def self.hidden_dir?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.pwd(); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.reset_pwd(); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

class RuboCop::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def buffer(); end

  def checksum(); end

  def comment_config(); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def current_line(token); end

  def diagnostics(); end

  def disabled_line_ranges(); end

  def each_comment(); end

  def each_token(); end

  def file_path(); end

  def find_comment(); end

  def find_token(); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def line_indentation(line_number); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def start_with?(string); end

  def tokens(); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ProcessedSource
  def self.from_file(path, ruby_version); end
end

module RuboCop::Rails
  CONFIG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Rails::Inject
end

module RuboCop::Rails::Inject
  def self.defaults!(); end
end

module RuboCop::Rails::SchemaLoader
  def db_schema_path(); end

  def load(target_ruby_version); end

  def reset!(); end
end

class RuboCop::Rails::SchemaLoader::AddIndex
  def table_name(); end
end

class RuboCop::Rails::SchemaLoader::AddIndex
end

class RuboCop::Rails::SchemaLoader::Column
  def initialize(node); end

  def name(); end

  def not_null(); end

  def type(); end
end

class RuboCop::Rails::SchemaLoader::Column
end

class RuboCop::Rails::SchemaLoader::Index
  def columns(); end

  def expression(); end

  def initialize(node); end

  def name(); end

  def unique(); end
end

class RuboCop::Rails::SchemaLoader::Index
end

class RuboCop::Rails::SchemaLoader::Schema
  def add_indicies(); end

  def add_indicies_by(table_name:); end

  def initialize(ast); end

  def table_by(name:); end

  def tables(); end
end

class RuboCop::Rails::SchemaLoader::Schema
end

class RuboCop::Rails::SchemaLoader::Table
  def columns(); end

  def indices(); end

  def initialize(node); end

  def name(); end

  def with_column?(name:); end
end

class RuboCop::Rails::SchemaLoader::Table
end

module RuboCop::Rails::SchemaLoader
  extend ::RuboCop::Rails::SchemaLoader
end

module RuboCop::Rails::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Rails::Version
end

module RuboCop::Rails
end

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
end

class RuboCop::ResultCache
  def initialize(file, team, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def save(offenses); end

  def valid?(); end
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::Runner
end

class RuboCop::StringInterpreter
  STRING_ESCAPES = ::T.let(nil, ::T.untyped)
  STRING_ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

module RuboCop::StringUtil
end

module RuboCop::StringUtil
  def self.similarity(string_a, string_b); end
end

class RuboCop::TargetFinder
  def all_cops_include(); end

  def configured_include?(file); end

  def debug?(); end

  def excluded_dirs(base_dir); end

  def fail_fast?(); end

  def find(args); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def included_file?(file); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_extensions(); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def ruby_filenames(); end

  def ruby_interpreters(file); end

  def stdin?(); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def toplevel_dirs(base_dir, flags); end
end

class RuboCop::TargetFinder
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RubyVersionFile
  FILENAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::Source
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

class RuboCop::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::Token
  def self.from_parser_token(parser_token); end
end

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.version(debug=T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop::YAMLDuplicationChecker
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

module RuboCop
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::DebugInspector
  def backtrace_locations(); end

  def frame_binding(_); end

  def frame_class(_); end

  def frame_iseq(_); end

  def frame_self(_); end
end

class RubyVM::DebugInspector
  def self.open(); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

class Sample
  include ::ActionView::Helpers::DateHelper
  def after_add_for_items(); end

  def after_add_for_items=(after_add_for_items); end

  def after_add_for_items?(); end

  def after_add_for_post_associations(); end

  def after_add_for_post_associations=(after_add_for_post_associations); end

  def after_add_for_post_associations?(); end

  def after_remove_for_items(); end

  def after_remove_for_items=(after_remove_for_items); end

  def after_remove_for_items?(); end

  def after_remove_for_post_associations(); end

  def after_remove_for_post_associations=(after_remove_for_post_associations); end

  def after_remove_for_post_associations?(); end

  def autosave_associated_records_for_items(*args); end

  def autosave_associated_records_for_post_associations(*args); end

  def autosave_associated_records_for_sample_type(*args); end

  def autosave_associated_records_for_user(*args); end

  def before_add_for_items(); end

  def before_add_for_items=(before_add_for_items); end

  def before_add_for_items?(); end

  def before_add_for_post_associations(); end

  def before_add_for_post_associations=(before_add_for_post_associations); end

  def before_add_for_post_associations?(); end

  def before_remove_for_items(); end

  def before_remove_for_items=(before_remove_for_items); end

  def before_remove_for_items?(); end

  def before_remove_for_post_associations(); end

  def before_remove_for_post_associations=(before_remove_for_post_associations); end

  def before_remove_for_post_associations?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def validate_associated_records_for_items(*args); end

  def validate_associated_records_for_post_associations(*args); end
end

class Sample::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Sample::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Sample::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Sample::GeneratedAssociationMethods
  def build_sample_type(*args, &block); end

  def build_user(*args, &block); end

  def create_sample_type(*args, &block); end

  def create_sample_type!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def item_ids(); end

  def item_ids=(ids); end

  def post_association_ids(); end

  def post_association_ids=(ids); end

  def post_associations(*args); end

  def post_associations=(value); end

  def sample_type(*args); end

  def sample_type=(value); end

  def user(*args); end

  def user=(value); end
end

class Sample
  def self.after_add_for_items(); end

  def self.after_add_for_items=(val); end

  def self.after_add_for_items?(); end

  def self.after_add_for_post_associations(); end

  def self.after_add_for_post_associations=(val); end

  def self.after_add_for_post_associations?(); end

  def self.after_remove_for_items(); end

  def self.after_remove_for_items=(val); end

  def self.after_remove_for_items?(); end

  def self.after_remove_for_post_associations(); end

  def self.after_remove_for_post_associations=(val); end

  def self.after_remove_for_post_associations?(); end

  def self.before_add_for_items(); end

  def self.before_add_for_items=(val); end

  def self.before_add_for_items?(); end

  def self.before_add_for_post_associations(); end

  def self.before_add_for_post_associations=(val); end

  def self.before_add_for_post_associations?(); end

  def self.before_remove_for_items(); end

  def self.before_remove_for_items=(val); end

  def self.before_remove_for_items?(); end

  def self.before_remove_for_post_associations(); end

  def self.before_remove_for_post_associations=(val); end

  def self.before_remove_for_post_associations?(); end
end

class SampleType
  def after_add_for_object_types(); end

  def after_add_for_object_types=(after_add_for_object_types); end

  def after_add_for_object_types?(); end

  def after_add_for_samples(); end

  def after_add_for_samples=(after_add_for_samples); end

  def after_add_for_samples?(); end

  def after_remove_for_object_types(); end

  def after_remove_for_object_types=(after_remove_for_object_types); end

  def after_remove_for_object_types?(); end

  def after_remove_for_samples(); end

  def after_remove_for_samples=(after_remove_for_samples); end

  def after_remove_for_samples?(); end

  def autosave_associated_records_for_object_types(*args); end

  def autosave_associated_records_for_samples(*args); end

  def before_add_for_object_types(); end

  def before_add_for_object_types=(before_add_for_object_types); end

  def before_add_for_object_types?(); end

  def before_add_for_samples(); end

  def before_add_for_samples=(before_add_for_samples); end

  def before_add_for_samples?(); end

  def before_remove_for_object_types(); end

  def before_remove_for_object_types=(before_remove_for_object_types); end

  def before_remove_for_object_types?(); end

  def before_remove_for_samples(); end

  def before_remove_for_samples=(before_remove_for_samples); end

  def before_remove_for_samples?(); end

  def validate_associated_records_for_object_types(*args); end

  def validate_associated_records_for_samples(*args); end
end

class SampleType::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class SampleType::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class SampleType::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module SampleType::GeneratedAssociationMethods
  def object_type_ids(); end

  def object_type_ids=(ids); end

  def sample_ids(); end

  def sample_ids=(ids); end
end

class SampleType
  def self.after_add_for_object_types(); end

  def self.after_add_for_object_types=(val); end

  def self.after_add_for_object_types?(); end

  def self.after_add_for_samples(); end

  def self.after_add_for_samples=(val); end

  def self.after_add_for_samples?(); end

  def self.after_remove_for_object_types(); end

  def self.after_remove_for_object_types=(val); end

  def self.after_remove_for_object_types?(); end

  def self.after_remove_for_samples(); end

  def self.after_remove_for_samples=(val); end

  def self.after_remove_for_samples?(); end

  def self.before_add_for_object_types(); end

  def self.before_add_for_object_types=(val); end

  def self.before_add_for_object_types?(); end

  def self.before_add_for_samples(); end

  def self.before_add_for_samples=(val); end

  def self.before_add_for_samples?(); end

  def self.before_remove_for_object_types(); end

  def self.before_remove_for_object_types=(val); end

  def self.before_remove_for_object_types?(); end

  def self.before_remove_for_samples(); end

  def self.before_remove_for_samples=(val); end

  def self.before_remove_for_samples?(); end
end

module SassC
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::BaseError
end

class SassC::BaseError
end

class SassC::Dependency
  def filename(); end

  def initialize(filename); end

  def options(); end
end

class SassC::Dependency
  def self.from_filenames(filenames); end
end

class SassC::Engine
  def dependencies(); end

  def filename(); end

  def initialize(template, options=T.unsafe(nil)); end

  def options(); end

  def render(); end

  def source_map(); end

  def template(); end
  OUTPUT_STYLES = ::T.let(nil, ::T.untyped)
end

class SassC::Engine
end

class SassC::FunctionsHandler
  def initialize(options); end

  def setup(native_options, functions: T.unsafe(nil)); end
end

class SassC::FunctionsHandler
end

class SassC::ImportHandler
  def initialize(options); end

  def setup(native_options); end
end

class SassC::ImportHandler
end

class SassC::Importer
  def imports(path, parent_path); end

  def initialize(options); end

  def options(); end
end

class SassC::Importer::Import
  def initialize(path, source: T.unsafe(nil), source_map_path: T.unsafe(nil)); end

  def path(); end

  def path=(path); end

  def source(); end

  def source=(source); end

  def source_map_path(); end

  def source_map_path=(source_map_path); end
end

class SassC::Importer::Import
end

class SassC::Importer
end

class SassC::InvalidStyleError
end

class SassC::InvalidStyleError
end

module SassC::Native
  def _context_get_included_files(*_); end

  def _make_data_context(*_); end

  def boolean_get_value(*_); end

  def color_get_a(*_); end

  def color_get_b(*_); end

  def color_get_g(*_); end

  def color_get_r(*_); end

  def color_set_a(*_); end

  def color_set_b(*_); end

  def color_set_g(*_); end

  def color_set_r(*_); end

  def compile_data_context(*_); end

  def compile_file_context(*_); end

  def compiler_get_last_import(*_); end

  def context_get_error_column(*_); end

  def context_get_error_file(*_); end

  def context_get_error_json(*_); end

  def context_get_error_line(*_); end

  def context_get_error_message(*_); end

  def context_get_error_status(*_); end

  def context_get_options(*_); end

  def context_get_output_string(*_); end

  def context_get_source_map_string(*_); end

  def data_context_get_context(*_); end

  def data_context_get_options(*_); end

  def data_context_set_options(*_); end

  def delete_data_context(*_); end

  def delete_file_context(*_); end

  def error_get_message(*_); end

  def error_set_message(*_); end

  def file_context_get_context(*_); end

  def file_context_get_options(*_); end

  def file_context_set_options(*_); end

  def function_get_cookie(*_); end

  def function_get_function(*_); end

  def function_get_list_entry(*_); end

  def function_get_signature(*_); end

  def function_set_list_entry(*_); end

  def import_get_abs_path(*_); end

  def import_get_imp_path(*_); end

  def import_get_source(*_); end

  def import_set_list_entry(*_); end

  def list_get_length(*_); end

  def list_get_value(*_); end

  def list_set_value(*_); end

  def make_boolean(*_); end

  def make_color(*_); end

  def make_error(*_); end

  def make_file_context(*_); end

  def make_function(*_); end

  def make_function_list(*_); end

  def make_import_entry(*_); end

  def make_import_list(*_); end

  def make_importer(*_); end

  def make_list(*_); end

  def make_map(*_); end

  def make_number(*_); end

  def make_options(*_); end

  def make_qstring(*_); end

  def make_string(*_); end

  def map_get_key(*_); end

  def map_get_length(*_); end

  def map_get_value(*_); end

  def map_set_key(*_); end

  def map_set_value(*_); end

  def number_get_unit(*_); end

  def number_get_value(*_); end

  def option_get_c_functions(*_); end

  def option_get_include_path(*_); end

  def option_get_input_path(*_); end

  def option_get_is_indented_syntax_src(*_); end

  def option_get_omit_source_map_url(*_); end

  def option_get_output_path(*_); end

  def option_get_output_style(*_); end

  def option_get_precision(*_); end

  def option_get_source_comments(*_); end

  def option_get_source_map_contents(*_); end

  def option_get_source_map_embed(*_); end

  def option_get_source_map_file(*_); end

  def option_set_c_functions(*_); end

  def option_set_c_importers(*_); end

  def option_set_include_path(*_); end

  def option_set_input_path(*_); end

  def option_set_is_indented_syntax_src(*_); end

  def option_set_omit_source_map_url(*_); end

  def option_set_output_path(*_); end

  def option_set_output_style(*_); end

  def option_set_precision(*_); end

  def option_set_source_comments(*_); end

  def option_set_source_map_contents(*_); end

  def option_set_source_map_embed(*_); end

  def option_set_source_map_file(*_); end

  def sass2scss(*_); end

  def string_get_value(*_); end

  def string_is_quoted(*_); end

  def value_get_tag(*_); end

  def value_is_null(*_); end

  def version(*_); end
  SassInputStyle = ::T.let(nil, ::T.untyped)
  SassOutputStyle = ::T.let(nil, ::T.untyped)
  SassSeparator = ::T.let(nil, ::T.untyped)
  SassTag = ::T.let(nil, ::T.untyped)
end

module SassC::Native::LibC
  def malloc(*_); end
end

module SassC::Native::LibC
  extend ::FFI::Library
  def self.malloc(*_); end
end

class SassC::Native::SassBoolean
end

class SassC::Native::SassBoolean
end

class SassC::Native::SassColor
end

class SassC::Native::SassColor
end

class SassC::Native::SassError
end

class SassC::Native::SassError
end

class SassC::Native::SassList
end

class SassC::Native::SassList
end

class SassC::Native::SassMap
end

class SassC::Native::SassMap
end

class SassC::Native::SassMapPair
end

class SassC::Native::SassMapPair
end

class SassC::Native::SassNull
end

class SassC::Native::SassNull
end

class SassC::Native::SassNumber
end

class SassC::Native::SassNumber
end

class SassC::Native::SassString
end

class SassC::Native::SassString
end

class SassC::Native::SassUnknown
end

class SassC::Native::SassUnknown
end

class SassC::Native::SassValue
end

class SassC::Native::SassValue
end

class SassC::Native::SassWarning
end

class SassC::Native::SassWarning
end

class SassC::Native::StringList
end

class SassC::Native::StringList
end

module SassC::Native
  extend ::FFI::Library
  def self._context_get_included_files(*_); end

  def self._make_data_context(*_); end

  def self.attach_function(*args); end

  def self.boolean_get_value(*_); end

  def self.color_get_a(*_); end

  def self.color_get_b(*_); end

  def self.color_get_g(*_); end

  def self.color_get_r(*_); end

  def self.color_set_a(*_); end

  def self.color_set_b(*_); end

  def self.color_set_g(*_); end

  def self.color_set_r(*_); end

  def self.compile_data_context(*_); end

  def self.compile_file_context(*_); end

  def self.compiler_get_last_import(*_); end

  def self.context_get_error_column(*_); end

  def self.context_get_error_file(*_); end

  def self.context_get_error_json(*_); end

  def self.context_get_error_line(*_); end

  def self.context_get_error_message(*_); end

  def self.context_get_error_status(*_); end

  def self.context_get_included_files(*args); end

  def self.context_get_options(*_); end

  def self.context_get_output_string(*_); end

  def self.context_get_source_map_string(*_); end

  def self.data_context_get_context(*_); end

  def self.data_context_get_options(*_); end

  def self.data_context_set_options(*_); end

  def self.delete_data_context(*_); end

  def self.delete_file_context(*_); end

  def self.error_get_message(*_); end

  def self.error_set_message(*_); end

  def self.file_context_get_context(*_); end

  def self.file_context_get_options(*_); end

  def self.file_context_set_options(*_); end

  def self.function_get_cookie(*_); end

  def self.function_get_function(*_); end

  def self.function_get_list_entry(*_); end

  def self.function_get_signature(*_); end

  def self.function_set_list_entry(*_); end

  def self.import_get_abs_path(*_); end

  def self.import_get_imp_path(*_); end

  def self.import_get_source(*_); end

  def self.import_set_list_entry(*_); end

  def self.list_get_length(*_); end

  def self.list_get_value(*_); end

  def self.list_set_value(*_); end

  def self.make_boolean(*_); end

  def self.make_color(*_); end

  def self.make_data_context(data); end

  def self.make_error(*_); end

  def self.make_file_context(*_); end

  def self.make_function(*_); end

  def self.make_function_list(*_); end

  def self.make_import_entry(*_); end

  def self.make_import_list(*_); end

  def self.make_importer(*_); end

  def self.make_list(*_); end

  def self.make_map(*_); end

  def self.make_number(*_); end

  def self.make_options(*_); end

  def self.make_qstring(*_); end

  def self.make_string(*_); end

  def self.map_get_key(*_); end

  def self.map_get_length(*_); end

  def self.map_get_value(*_); end

  def self.map_set_key(*_); end

  def self.map_set_value(*_); end

  def self.native_string(string); end

  def self.number_get_unit(*_); end

  def self.number_get_value(*_); end

  def self.option_get_c_functions(*_); end

  def self.option_get_include_path(*_); end

  def self.option_get_input_path(*_); end

  def self.option_get_is_indented_syntax_src(*_); end

  def self.option_get_omit_source_map_url(*_); end

  def self.option_get_output_path(*_); end

  def self.option_get_output_style(*_); end

  def self.option_get_precision(*_); end

  def self.option_get_source_comments(*_); end

  def self.option_get_source_map_contents(*_); end

  def self.option_get_source_map_embed(*_); end

  def self.option_get_source_map_file(*_); end

  def self.option_set_c_functions(*_); end

  def self.option_set_c_importers(*_); end

  def self.option_set_include_path(*_); end

  def self.option_set_input_path(*_); end

  def self.option_set_is_indented_syntax_src(*_); end

  def self.option_set_omit_source_map_url(*_); end

  def self.option_set_output_path(*_); end

  def self.option_set_output_style(*_); end

  def self.option_set_precision(*_); end

  def self.option_set_source_comments(*_); end

  def self.option_set_source_map_contents(*_); end

  def self.option_set_source_map_embed(*_); end

  def self.option_set_source_map_file(*_); end

  def self.return_string_array(ptr); end

  def self.sass2scss(*_); end

  def self.string_get_type(native_value); end

  def self.string_get_value(*_); end

  def self.string_is_quoted(*_); end

  def self.value_get_tag(*_); end

  def self.value_is_null(*_); end

  def self.version(*_); end
end

class SassC::NotRenderedError
end

class SassC::NotRenderedError
end

module SassC::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::Rails::Importer
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  GLOB = ::T.let(nil, ::T.untyped)
  PREFIXS = ::T.let(nil, ::T.untyped)
end

class SassC::Rails::Importer::CSSExtension
  def import_for(full_path, parent_dir, options); end

  def postfix(); end
end

class SassC::Rails::Importer::CSSExtension
end

class SassC::Rails::Importer::CssSassExtension
end

class SassC::Rails::Importer::CssSassExtension
end

class SassC::Rails::Importer::CssScssExtension
end

class SassC::Rails::Importer::CssScssExtension
end

class SassC::Rails::Importer::ERBExtension
end

class SassC::Rails::Importer::ERBExtension
end

class SassC::Rails::Importer::Extension
  def import_for(full_path, parent_dir, options); end

  def initialize(postfix=T.unsafe(nil)); end

  def postfix(); end
end

class SassC::Rails::Importer::Extension
end

class SassC::Rails::Importer::SassERBExtension
end

class SassC::Rails::Importer::SassERBExtension
end

class SassC::Rails::Importer
end

class SassC::Rails::Railtie
end

class SassC::Rails::Railtie
end

class SassC::Rails::SassTemplate
  def config_options(); end

  def line_comments?(); end

  def load_paths(); end

  def safe_merge(_key, left, right); end

  def sass_style(); end
end

module SassC::Rails::SassTemplate::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end
end

module SassC::Rails::SassTemplate::Functions
end

class SassC::Rails::SassTemplate
end

class SassC::Rails::ScssTemplate
end

class SassC::Rails::ScssTemplate
end

module SassC::Rails
end

class SassC::Sass2Scss
end

class SassC::Sass2Scss
  def self.convert(sass); end
end

module SassC::Script
end

module SassC::Script::Functions
  include ::Sprockets::SassProcessor::Functions
end

module SassC::Script::Functions
end

class SassC::Script::Value
  def ==(other); end

  def _perform(environment); end

  def assert_int!(); end

  def bracketed(); end

  def eql?(other); end

  def initialize(value=T.unsafe(nil)); end

  def null?(); end

  def options(); end

  def options=(options); end

  def separator(); end

  def source_range(); end

  def source_range=(source_range); end

  def to_a(); end

  def to_bool(); end

  def to_h(); end

  def to_i(); end

  def to_s(opts=T.unsafe(nil)); end

  def to_sass(opts=T.unsafe(nil)); end

  def value(); end

  def with_contents(contents, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end
end

class SassC::Script::Value::Bool
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Bool
  def self.new(value); end
end

class SassC::Script::Value::Color
  def ==(other_color); end

  def alpha(); end

  def alpha_string(); end

  def blue(); end

  def eql?(other_color); end

  def green(); end

  def hlsa?(); end

  def hue(); end

  def initialize(red: T.unsafe(nil), green: T.unsafe(nil), blue: T.unsafe(nil), hue: T.unsafe(nil), saturation: T.unsafe(nil), lightness: T.unsafe(nil), alpha: T.unsafe(nil)); end

  def lightness(); end

  def red(); end

  def rgba?(); end

  def saturation(); end

  def to_s(); end
end

class SassC::Script::Value::Color
end

class SassC::Script::Value::List
  def eq(other); end

  def initialize(value, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def options=(options); end
end

class SassC::Script::Value::List
  def self.assert_valid_index(list, n); end
end

class SassC::Script::Value::Map
  def eq(other); end

  def initialize(hash); end

  def inspect(opts=T.unsafe(nil)); end

  def options=(options); end
end

class SassC::Script::Value::Map
end

class SassC::Script::Value::Number
  def coerce(num_units, den_units); end

  def comparable_to?(other); end

  def denominator_units(); end

  def initialize(value, numerator_units=T.unsafe(nil), denominator_units=T.unsafe(nil)); end

  def inspect(opts=T.unsafe(nil)); end

  def int?(); end

  def is_unit?(unit); end

  def legal_units?(); end

  def numerator_units(); end

  def original(); end

  def original=(original); end

  def unit_str(); end

  def unitless?(); end
  CONVERSION_TABLE = ::T.let(nil, ::T.untyped)
  MUTUALLY_CONVERTIBLE = ::T.let(nil, ::T.untyped)
  NO_UNITS = ::T.let(nil, ::T.untyped)
  OPERATIONS = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Number
  def self.basically_equal?(num1, num2); end

  def self.epsilon(); end

  def self.precision(); end

  def self.precision=(digits); end

  def self.precision_factor(); end

  def self.round(num); end
end

class SassC::Script::Value::String
  def initialize(value, type=T.unsafe(nil)); end

  def plus(other); end

  def type(); end
end

class SassC::Script::Value::String
  def self.quote(contents, opts=T.unsafe(nil)); end
end

class SassC::Script::Value
end

module SassC::Script::ValueConversion
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class SassC::Script::ValueConversion::Base
  def initialize(value); end
end

class SassC::Script::ValueConversion::Base
end

class SassC::Script::ValueConversion::Bool
  def to_native(); end
end

class SassC::Script::ValueConversion::Bool
end

class SassC::Script::ValueConversion::Color
  def to_native(); end
end

class SassC::Script::ValueConversion::Color
end

class SassC::Script::ValueConversion::List
  def to_native(); end
end

class SassC::Script::ValueConversion::List
end

class SassC::Script::ValueConversion::Map
  def to_native(); end
end

class SassC::Script::ValueConversion::Map
end

class SassC::Script::ValueConversion::Number
  def to_native(); end
end

class SassC::Script::ValueConversion::Number
end

class SassC::Script::ValueConversion::String
  def to_native(opts=T.unsafe(nil)); end
end

class SassC::Script::ValueConversion::String
end

module SassC::Script::ValueConversion
  def self.from_native(native_value, options); end

  def self.to_native(value); end
end

module SassC::Script
  def self.custom_functions(functions: T.unsafe(nil)); end

  def self.formatted_function_name(function_name, functions: T.unsafe(nil)); end
end

class SassC::SyntaxError
  def initialize(message, filename: T.unsafe(nil), line: T.unsafe(nil)); end

  def sass_backtrace(); end
end

class SassC::SyntaxError
end

class SassC::UnsupportedValue
end

class SassC::UnsupportedValue
end

module SassC::Util
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class SassC::Util::NormalizedMap
  def [](k); end

  def []=(k, v); end

  def as_stored(); end

  def delete(k); end

  def denormalize(key); end

  def each(&blk); end

  def empty?(); end

  def has_key?(k); end

  def initialize(map=T.unsafe(nil)); end

  def keys(); end

  def map(); end

  def method_missing(method, *args, &block); end

  def normalize(key); end

  def size(); end

  def sort_by(); end

  def to_a(); end

  def to_hash(); end

  def update(map); end

  def values(); end
end

class SassC::Util::NormalizedMap
end

module SassC::Util
  extend ::SassC::Util
end

module SassC
  def self.load_paths(); end
end

module Sawyer
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  def allow_undefined_methods(); end

  def allow_undefined_methods=(allow_undefined_methods); end

  def allow_undefined_methods?(); end

  def call(method, url, data=T.unsafe(nil), options=T.unsafe(nil)); end

  def decode_body(str); end

  def encode_body(data); end

  def expand_url(url, options=T.unsafe(nil)); end

  def initialize(endpoint, options=T.unsafe(nil)); end

  def links_parser(); end

  def links_parser=(links_parser); end

  def marshal_dump(); end

  def marshal_load(dumped); end

  def parse_links(data); end

  def rels(); end

  def root(); end

  def start(); end

  def to_yaml_properties(); end
  NO_BODY = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  def self.decode(data); end

  def self.encode(data); end

  def self.serializer(); end

  def self.serializer=(serializer); end
end

class Sawyer::Error
end

class Sawyer::Error
end

module Sawyer::LinkParsers
end

class Sawyer::LinkParsers::Hal
  def parse(data); end
end

class Sawyer::LinkParsers::Hal
end

class Sawyer::LinkParsers::Simple
  def parse(data); end
  LINK_REGEX = ::T.let(nil, ::T.untyped)
end

class Sawyer::LinkParsers::Simple
end

module Sawyer::LinkParsers
end

class Sawyer::Relation
  def agent(); end

  def available_methods(); end

  def call(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def get(options=T.unsafe(nil)); end

  def head(options=T.unsafe(nil)); end

  def href_template(); end

  def initialize(agent, name, href, method=T.unsafe(nil)); end

  def method(); end

  def name(); end

  def options(data=T.unsafe(nil), opt=T.unsafe(nil)); end

  def patch(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def post(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def put(data=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Sawyer::Relation::Map
  def <<(rel); end

  def [](key); end

  def keys(); end

  def size(); end

  def to_h(); end

  def to_hash(); end
end

class Sawyer::Relation::Map
end

class Sawyer::Relation
  def self.from_link(agent, name, options); end

  def self.from_links(agent, index, rels=T.unsafe(nil)); end
end

class Sawyer::Resource
  include ::Enumerable
  def [](method); end

  def []=(method, value); end

  def _agent(); end

  def _fields(); end

  def _rels(); end

  def attrs(); end

  def each(&block); end

  def initialize(agent, data=T.unsafe(nil)); end

  def key?(key); end

  def marshal_dump(); end

  def marshal_load(dumped); end

  def method_missing(method, *args); end

  def process_value(value); end

  def to_attrs(); end

  def to_h(); end

  def to_hash(); end

  def to_yaml_properties(); end
  ATTR_PREDICATE = ::T.let(nil, ::T.untyped)
  ATTR_SETTER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHODS = ::T.let(nil, ::T.untyped)
end

class Sawyer::Resource
  def self.attr_accessor(*attrs); end
end

class Sawyer::Response
  def agent(); end

  def body(); end

  def data(); end

  def env(); end

  def headers(); end

  def initialize(agent, res, options=T.unsafe(nil)); end

  def process_data(data); end

  def process_rels(); end

  def rels(); end

  def status(); end

  def time(); end

  def timing(); end
end

class Sawyer::Response
end

class Sawyer::Serializer
  def decode(data); end

  def decode_hash(hash); end

  def decode_hash_value(key, value); end

  def decode_object(data); end

  def dump(data); end

  def encode(data); end

  def encode_hash(hash); end

  def encode_object(data); end

  def initialize(format, dump_method_name=T.unsafe(nil), load_method_name=T.unsafe(nil)); end

  def load(data); end

  def time_field?(key, value); end
end

class Sawyer::Serializer
  def self.any_json(); end

  def self.json(); end

  def self.message_pack(); end

  def self.multi_json(); end

  def self.yajl(); end
end

module Sawyer
end

ScanError = StringScanner::Error

module Seahorse
end

module Seahorse::Client
end

class Seahorse::Client::AsyncBase
  def close_connection(); end

  def connection(); end

  def connection_errors(); end

  def new_connection(); end
end

class Seahorse::Client::AsyncBase
end

class Seahorse::Client::AsyncResponse
  def context(); end

  def error(); end

  def initialize(options=T.unsafe(nil)); end

  def join!(); end

  def on(range, &block); end

  def on_complete(&block); end

  def wait(); end
end

class Seahorse::Client::AsyncResponse
end

class Seahorse::Client::Base
  include ::Seahorse::Client::HandlerBuilder
  def build_request(operation_name, params=T.unsafe(nil)); end

  def config(); end

  def handlers(); end

  def initialize(plugins, options); end

  def operation_names(); end
end

class Seahorse::Client::Base
  def self.add_plugin(plugin); end

  def self.api(); end

  def self.clear_plugins(); end

  def self.define(options=T.unsafe(nil)); end

  def self.extend(options=T.unsafe(nil)); end

  def self.new(options=T.unsafe(nil)); end

  def self.plugins(); end

  def self.remove_plugin(plugin); end

  def self.set_api(api); end

  def self.set_plugins(plugins); end
end

class Seahorse::Client::BlockIO
  def initialize(&block); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def size(); end

  def write(chunk); end
end

class Seahorse::Client::BlockIO
end

class Seahorse::Client::Configuration
  def add_option(name, default=T.unsafe(nil), &block); end

  def build!(options=T.unsafe(nil)); end
end

class Seahorse::Client::Configuration::DefaultResolver
  def initialize(struct); end

  def resolve(); end

  def respond_to?(method_name, *args); end
end

class Seahorse::Client::Configuration::DefaultResolver
end

class Seahorse::Client::Configuration::Defaults
  def each(&block); end
end

class Seahorse::Client::Configuration::Defaults
end

class Seahorse::Client::Configuration::DynamicDefault
  def block(); end

  def block=(block); end

  def call(*args); end

  def initialize(block=T.unsafe(nil)); end
end

class Seahorse::Client::Configuration::DynamicDefault
end

class Seahorse::Client::Configuration
end

module Seahorse::Client::H2
  DNS_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::H2::Connection
  def close!(); end

  def closed?(); end

  def connect(endpoint); end

  def connection_read_timeout(); end

  def connection_timeout(); end

  def debug_output(msg, type=T.unsafe(nil)); end

  def enable_alpn(); end

  def errors(); end

  def http_wire_trace(); end

  def initialize(options=T.unsafe(nil)); end

  def input_signal_thread(); end

  def input_signal_thread=(input_signal_thread); end

  def logger(); end

  def max_concurrent_streams(); end

  def new_stream(); end

  def ssl_ca_bundle(); end

  def ssl_ca_directory(); end

  def ssl_ca_store(); end

  def ssl_verify_peer(); end

  def ssl_verify_peer?(); end

  def start(stream); end
  CHUNKSIZE = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  SOCKET_FAMILY = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::H2::Connection
end

class Seahorse::Client::H2::Handler
end

class Seahorse::Client::H2::Handler
end

module Seahorse::Client::H2
end

class Seahorse::Client::Handler
  def call(context); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end
end

class Seahorse::Client::Handler
end

module Seahorse::Client::HandlerBuilder
  def handle(*args, &block); end

  def handle_request(*args, &block); end

  def handle_response(*args, &block); end

  def handler(*args, &block); end

  def handler_for(name=T.unsafe(nil), &block); end

  def new_handler(block); end
end

module Seahorse::Client::HandlerBuilder
end

class Seahorse::Client::HandlerList
  include ::Enumerable
  def add(handler_class, options=T.unsafe(nil)); end

  def copy_from(source_list, &block); end

  def each(&block); end

  def entries(); end

  def for(operation); end

  def initialize(options=T.unsafe(nil)); end

  def remove(handler_class); end

  def to_stack(); end
end

class Seahorse::Client::HandlerList
end

class Seahorse::Client::HandlerListEntry
  def copy(options=T.unsafe(nil)); end

  def handler_class(); end

  def initialize(options); end

  def inserted(); end

  def operations(); end

  def priority(); end

  def step(); end

  def weight(); end
  STEPS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::HandlerListEntry
end

module Seahorse::Client::Http
end

class Seahorse::Client::Http::AsyncResponse
  def signal_headers(headers); end
end

class Seahorse::Client::Http::AsyncResponse
end

class Seahorse::Client::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def each_pair(&block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(headers=T.unsafe(nil)); end

  def key?(key); end

  def keys(); end

  def to_h(); end

  def to_hash(); end

  def update(headers); end

  def values(); end

  def values_at(*keys); end
end

class Seahorse::Client::Http::Headers
end

class Seahorse::Client::Http::Request
  def body(); end

  def body=(io); end

  def body_contents(); end

  def endpoint(); end

  def endpoint=(endpoint); end

  def headers(); end

  def headers=(headers); end

  def http_method(); end

  def http_method=(http_method); end

  def initialize(options=T.unsafe(nil)); end
end

class Seahorse::Client::Http::Request
end

class Seahorse::Client::Http::Response
  def body(); end

  def body=(io); end

  def body_contents(); end

  def error(); end

  def headers(); end

  def headers=(headers); end

  def initialize(options=T.unsafe(nil)); end

  def on_data(&callback); end

  def on_done(status_code_range=T.unsafe(nil), &callback); end

  def on_error(&callback); end

  def on_headers(status_code_range=T.unsafe(nil), &block); end

  def on_success(status_code_range=T.unsafe(nil), &callback); end

  def reset(); end

  def signal_data(chunk); end

  def signal_done(options=T.unsafe(nil)); end

  def signal_error(networking_error); end

  def signal_headers(status_code, headers); end

  def status_code(); end

  def status_code=(status_code); end
end

class Seahorse::Client::Http::Response
end

module Seahorse::Client::Http
end

class Seahorse::Client::Http2ConnectionClosedError
end

class Seahorse::Client::Http2ConnectionClosedError
end

class Seahorse::Client::Http2InitialRequestError
  def initialize(error); end

  def original_error(); end
end

class Seahorse::Client::Http2InitialRequestError
end

class Seahorse::Client::Http2StreamInitializeError
  def initialize(error); end

  def original_error(); end
end

class Seahorse::Client::Http2StreamInitializeError
end

module Seahorse::Client::Logging
end

class Seahorse::Client::Logging::Formatter
  def ==(other); end

  def eql?(other); end

  def format(response); end

  def initialize(pattern, options=T.unsafe(nil)); end

  def max_string_size(); end

  def pattern(); end
end

class Seahorse::Client::Logging::Formatter
  def self.colored(); end

  def self.default(); end

  def self.short(); end
end

class Seahorse::Client::Logging::Handler
end

class Seahorse::Client::Logging::Handler
end

module Seahorse::Client::Logging
end

class Seahorse::Client::ManagedFile
  def open?(); end
end

class Seahorse::Client::ManagedFile
end

module Seahorse::Client::NetHttp
end

class Seahorse::Client::NetHttp::ConnectionPool
  def clean!(); end

  def empty!(); end

  def http_continue_timeout(); end

  def http_idle_timeout(); end

  def http_open_timeout(); end

  def http_proxy(); end

  def http_read_timeout(); end

  def http_wire_trace(); end

  def http_wire_trace?(); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def request(endpoint, request, &block); end

  def session_for(endpoint, &block); end

  def size(); end

  def ssl_ca_bundle(); end

  def ssl_ca_directory(); end

  def ssl_ca_store(); end

  def ssl_verify_peer(); end

  def ssl_verify_peer?(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession
  def finish(); end

  def initialize(http); end

  def last_used(); end

  def request(*args, &block); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession
end

class Seahorse::Client::NetHttp::ConnectionPool
  def self.for(options=T.unsafe(nil)); end

  def self.pools(); end
end

class Seahorse::Client::NetHttp::Handler
  def pool_for(config); end
  DNS_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::Handler::InvalidHttpVerbError
end

class Seahorse::Client::NetHttp::Handler::InvalidHttpVerbError
end

class Seahorse::Client::NetHttp::Handler::TruncatedBodyError
  def initialize(bytes_expected, bytes_received); end
end

class Seahorse::Client::NetHttp::Handler::TruncatedBodyError
end

class Seahorse::Client::NetHttp::Handler
end

module Seahorse::Client::NetHttp::Patches
end

module Seahorse::Client::NetHttp::Patches::Ruby_1_9_3
  def new_transport_request(req); end
end

module Seahorse::Client::NetHttp::Patches::Ruby_1_9_3
end

module Seahorse::Client::NetHttp::Patches::Ruby_2
  def new_transport_request(req); end
end

module Seahorse::Client::NetHttp::Patches::Ruby_2
end

module Seahorse::Client::NetHttp::Patches
  def self.apply!(); end
end

module Seahorse::Client::NetHttp
end

class Seahorse::Client::NetworkingError
  def initialize(error, msg=T.unsafe(nil)); end

  def original_error(); end
end

class Seahorse::Client::NetworkingError
end

class Seahorse::Client::Plugin
  def add_handlers(handlers, config); end

  def add_options(config); end

  def after_initialize(client); end

  def before_initialize(client_class, options); end
end

class Seahorse::Client::Plugin
  extend ::Seahorse::Client::HandlerBuilder
  def self.after_initialize(&block); end

  def self.after_initialize_hooks(); end

  def self.before_initialize(&block); end

  def self.before_initialize_hooks(); end

  def self.handlers(); end

  def self.literal(string); end

  def self.option(name, default=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.options(); end
end

class Seahorse::Client::PluginList
  include ::Enumerable
  def add(plugin); end

  def each(&block); end

  def initialize(plugins=T.unsafe(nil), options=T.unsafe(nil)); end

  def remove(plugin); end

  def set(plugins); end
end

class Seahorse::Client::PluginList::PluginWrapper
  def canonical_name(); end

  def eql?(other); end

  def initialize(plugin); end

  def plugin(); end
end

class Seahorse::Client::PluginList::PluginWrapper
  def self.new(plugin); end
end

class Seahorse::Client::PluginList
end

module Seahorse::Client::Plugins
end

class Seahorse::Client::Plugins::ContentLength
end

class Seahorse::Client::Plugins::ContentLength::Handler
end

class Seahorse::Client::Plugins::ContentLength::Handler
end

class Seahorse::Client::Plugins::ContentLength
end

class Seahorse::Client::Plugins::Endpoint
end

class Seahorse::Client::Plugins::Endpoint::Handler
end

class Seahorse::Client::Plugins::Endpoint::Handler
end

class Seahorse::Client::Plugins::Endpoint
end

class Seahorse::Client::Plugins::H2
end

class Seahorse::Client::Plugins::H2
end

class Seahorse::Client::Plugins::Logging
end

class Seahorse::Client::Plugins::Logging
end

class Seahorse::Client::Plugins::NetHttp
end

class Seahorse::Client::Plugins::NetHttp
end

class Seahorse::Client::Plugins::RaiseResponseErrors
end

class Seahorse::Client::Plugins::RaiseResponseErrors::Handler
end

class Seahorse::Client::Plugins::RaiseResponseErrors::Handler
end

class Seahorse::Client::Plugins::RaiseResponseErrors
end

class Seahorse::Client::Plugins::ResponseTarget
end

class Seahorse::Client::Plugins::ResponseTarget::Handler
end

class Seahorse::Client::Plugins::ResponseTarget::Handler
end

class Seahorse::Client::Plugins::ResponseTarget
end

module Seahorse::Client::Plugins
end

class Seahorse::Client::Request
  include ::Seahorse::Client::HandlerBuilder
  def context(); end

  def handlers(); end

  def initialize(handlers, context); end

  def send_request(options=T.unsafe(nil), &block); end
end

class Seahorse::Client::Request
end

class Seahorse::Client::RequestContext
  def [](key); end

  def []=(key, value); end

  def authorizer(); end

  def authorizer=(authorizer); end

  def client(); end

  def client=(client); end

  def config(); end

  def config=(config); end

  def http_request(); end

  def http_request=(http_request); end

  def http_response(); end

  def http_response=(http_response); end

  def initialize(options=T.unsafe(nil)); end

  def metadata(); end

  def operation(); end

  def operation=(operation); end

  def operation_name(); end

  def operation_name=(operation_name); end

  def params(); end

  def params=(params); end

  def retries(); end

  def retries=(retries); end
end

class Seahorse::Client::RequestContext
end

class Seahorse::Client::Response
  def context(); end

  def data(); end

  def data=(data); end

  def error(); end

  def error=(error); end

  def initialize(options=T.unsafe(nil)); end

  def on(range, &_block); end

  def on_complete(&block); end

  def on_success(&block); end

  def successful?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::Response
end

module Seahorse::Client
end

module Seahorse::Model
end

module Seahorse::Model::Shapes
end

module Seahorse::Model::Shapes
end

module Seahorse::Model
end

module Seahorse::Util
end

module Seahorse::Util
  def self.uri_escape(string); end

  def self.uri_path_escape(path); end
end

module Seahorse
end

module SecureRandom
  def self.bytes(n); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

class SignedGlobalID
  def expires_at(); end

  def purpose(); end

  def to_h(); end

  def to_s(); end

  def verifier(); end
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID
  def self.expires_in(); end

  def self.expires_in=(expires_in); end

  def self.parse(sgid, options=T.unsafe(nil)); end

  def self.pick_purpose(options); end

  def self.pick_verifier(options); end

  def self.verifier(); end

  def self.verifier=(verifier); end
end

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ArrayFilter
  def matches?(source_files_list); end
end

class SimpleCov::ArrayFilter
end

class SimpleCov::BlockFilter
  def matches?(source_file); end
end

class SimpleCov::BlockFilter
end

module SimpleCov::Combine
end

module SimpleCov::Combine::BranchesCombiner
end

module SimpleCov::Combine::BranchesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::FilesCombiner
end

module SimpleCov::Combine::FilesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::LinesCombiner
end

module SimpleCov::Combine::LinesCombiner
  def self.combine(coverage_a, coverage_b); end

  def self.merge_line_coverage(first_val, second_val); end
end

module SimpleCov::Combine::ResultsCombiner
end

module SimpleCov::Combine::ResultsCombiner
  def self.combine(*results); end

  def self.combine_file_coverage(coverage_a, coverage_b); end

  def self.combine_result_sets(combined_results, result); end
end

module SimpleCov::Combine
  def self.combine(combiner_module, coverage_a, coverage_b); end

  def self.empty_coverage?(coverage_a, coverage_b); end

  def self.existing_coverage(coverage_a, coverage_b); end
end

module SimpleCov::CommandGuesser
end

module SimpleCov::CommandGuesser
  def self.guess(); end

  def self.original_run_command(); end

  def self.original_run_command=(original_run_command); end
end

module SimpleCov::Configuration
  def adapters(); end

  def add_filter(filter_argument=T.unsafe(nil), &filter_proc); end

  def add_group(group_name, filter_argument=T.unsafe(nil), &filter_proc); end

  def at_exit(&block); end

  def branch_coverage?(); end

  def branch_coverage_supported?(); end

  def clear_coverage_criteria(); end

  def command_name(name=T.unsafe(nil)); end

  def configure(&block); end

  def coverage_criteria(); end

  def coverage_criterion(criterion=T.unsafe(nil)); end

  def coverage_criterion_enabled?(criterion); end

  def coverage_dir(dir=T.unsafe(nil)); end

  def coverage_path(); end

  def coverage_start_arguments_supported?(); end

  def enable_coverage(criterion); end

  def filters(); end

  def filters=(filters); end

  def formatter(formatter=T.unsafe(nil)); end

  def formatter=(formatter); end

  def formatters(); end

  def formatters=(formatters); end

  def groups(); end

  def groups=(groups); end

  def maximum_coverage_drop(coverage_drop=T.unsafe(nil)); end

  def merge_timeout(seconds=T.unsafe(nil)); end

  def minimum_coverage(coverage=T.unsafe(nil)); end

  def minimum_coverage_by_file(coverage=T.unsafe(nil)); end

  def nocov_token(nocov_token=T.unsafe(nil)); end

  def print_error_status(); end

  def print_error_status=(print_error_status); end

  def profiles(); end

  def project_name(new_name=T.unsafe(nil)); end

  def refuse_coverage_drop(); end

  def root(root=T.unsafe(nil)); end

  def skip_token(nocov_token=T.unsafe(nil)); end

  def track_files(glob); end

  def tracked_files(); end

  def use_merging(use=T.unsafe(nil)); end
  DEFAULT_COVERAGE_CRITERION = ::T.let(nil, ::T.untyped)
  SUPPORTED_COVERAGE_CRITERIA = ::T.let(nil, ::T.untyped)
end

module SimpleCov::Configuration
end

class SimpleCov::CoverageStatistics
  def covered(); end

  def initialize(covered:, missed:, total_strength: T.unsafe(nil)); end

  def missed(); end

  def percent(); end

  def strength(); end

  def total(); end
end

class SimpleCov::CoverageStatistics
  def self.from(coverage_statistics); end
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes
end

class SimpleCov::FileList
  include ::Enumerable
  def branch_covered_percent(); end

  def count(*args, &block); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_percentages(); end

  def covered_strength(); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def initialize(files); end

  def least_covered_file(); end

  def length(*args, &block); end

  def lines_of_code(); end

  def map(*args, &block); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def size(*args, &block); end

  def skipped_lines(); end

  def to_a(*args, &block); end

  def to_ary(*args, &block); end

  def total_branches(); end
end

class SimpleCov::FileList
  extend ::Forwardable
end

class SimpleCov::Filter
  def filter_argument(); end

  def initialize(filter_argument); end

  def matches?(_source_file); end

  def passes?(source_file); end
end

class SimpleCov::Filter
  def self.build_filter(filter_argument); end

  def self.class_for_argument(filter_argument); end
end

module SimpleCov::Formatter
end

class SimpleCov::Formatter::HTMLFormatter
  def branchable_result?(); end

  def format(result); end

  def line_status?(source_file, line); end

  def output_message(result); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::Formatter::HTMLFormatter
end

class SimpleCov::Formatter::MultiFormatter
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  def format(result); end
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
end

class SimpleCov::Formatter::MultiFormatter
  def self.[](*args); end

  def self.new(formatters=T.unsafe(nil)); end
end

class SimpleCov::Formatter::SimpleFormatter
  def format(result); end
end

class SimpleCov::Formatter::SimpleFormatter
end

module SimpleCov::Formatter
end

module SimpleCov::LastRun
end

module SimpleCov::LastRun
  def self.last_run_path(); end

  def self.read(); end

  def self.write(json); end
end

class SimpleCov::LinesClassifier
  def classify(lines); end
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

class SimpleCov::LinesClassifier
  def self.no_cov_line(); end

  def self.no_cov_line?(line); end

  def self.whitespace_line?(line); end
end

class SimpleCov::Profiles
  def define(name, &blk); end

  def load(name); end
end

class SimpleCov::Profiles
end

class SimpleCov::RegexFilter
  def matches?(source_file); end
end

class SimpleCov::RegexFilter
end

class SimpleCov::Result
  def command_name(); end

  def command_name=(command_name); end

  def coverage_statistics(*args, &block); end

  def covered_branches(*args, &block); end

  def covered_lines(*args, &block); end

  def covered_percent(*args, &block); end

  def covered_percentages(*args, &block); end

  def covered_strength(*args, &block); end

  def created_at(); end

  def created_at=(created_at); end

  def filenames(); end

  def files(); end

  def format!(); end

  def groups(); end

  def initialize(original_result); end

  def least_covered_file(*args, &block); end

  def missed_branches(*args, &block); end

  def missed_lines(*args, &block); end

  def original_result(); end

  def source_files(); end

  def to_hash(); end

  def total_branches(*args, &block); end

  def total_lines(*args, &block); end
end

class SimpleCov::Result
  extend ::Forwardable
  def self.from_hash(hash); end
end

class SimpleCov::ResultAdapter
  def adapt(); end

  def initialize(result); end

  def result(); end
end

class SimpleCov::ResultAdapter
  def self.call(*args); end
end

module SimpleCov::ResultMerger
end

module SimpleCov::ResultMerger
  def self.clear_resultset(); end

  def self.merge_and_store(*results); end

  def self.merge_results(*results); end

  def self.merged_result(); end

  def self.results(); end

  def self.resultset(); end

  def self.resultset_path(); end

  def self.resultset_writelock(); end

  def self.store_result(result); end

  def self.stored_data(); end

  def self.synchronize_resultset(); end
end

module SimpleCov::SimulateCoverage
end

module SimpleCov::SimulateCoverage
  def self.call(absolute_path); end
end

class SimpleCov::SourceFile
  def branches(); end

  def branches_coverage_percent(); end

  def branches_for_line(line_number); end

  def branches_report(); end

  def coverage_data(); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_strength(); end

  def filename(); end

  def initialize(filename, coverage_data); end

  def line(number); end

  def line_with_missed_branch?(line_number); end

  def lines(); end

  def lines_of_code(); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def no_branches?(); end

  def no_lines?(); end

  def project_filename(); end

  def relevant_lines(); end

  def skipped_lines(); end

  def source(); end

  def source_lines(); end

  def src(); end

  def total_branches(); end
  RUBY_FILE_ENCODING_MAGIC_COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SHEBANG_REGEX = ::T.let(nil, ::T.untyped)
end

class SimpleCov::SourceFile::Branch
  def coverage(); end

  def covered?(); end

  def end_line(); end

  def initialize(start_line:, end_line:, coverage:, inline:, type:); end

  def inline?(); end

  def missed?(); end

  def overlaps_with?(line_range); end

  def report(); end

  def report_line(); end

  def skipped!(); end

  def skipped?(); end

  def start_line(); end

  def type(); end
end

class SimpleCov::SourceFile::Branch
end

class SimpleCov::SourceFile::Line
  def coverage(); end

  def covered?(); end

  def initialize(src, line_number, coverage); end

  def line(); end

  def line_number(); end

  def missed?(); end

  def never?(); end

  def number(); end

  def skipped(); end

  def skipped!(); end

  def skipped?(); end

  def source(); end

  def src(); end

  def status(); end
end

class SimpleCov::SourceFile::Line
end

class SimpleCov::SourceFile
end

class SimpleCov::StringFilter
  def matches?(source_file); end
end

class SimpleCov::StringFilter
end

module SimpleCov::UselessResultsRemover
  ROOT_REGX = ::T.let(nil, ::T.untyped)
end

module SimpleCov::UselessResultsRemover
  def self.call(coverage_result); end
end

module SimpleCov
  extend ::SimpleCov::Configuration
  def self.at_exit_behavior(); end

  def self.clear_result(); end

  def self.collate(result_filenames, profile=T.unsafe(nil), &block); end

  def self.exit_exception(); end

  def self.exit_status_from_exception(); end

  def self.external_at_exit(); end

  def self.external_at_exit=(external_at_exit); end

  def self.external_at_exit?(); end

  def self.filtered(files); end

  def self.final_result_process?(); end

  def self.grouped(files); end

  def self.load_adapter(name); end

  def self.load_profile(name); end

  def self.pid(); end

  def self.pid=(pid); end

  def self.process_result(result, exit_status); end

  def self.result(); end

  def self.result?(); end

  def self.result_exit_status(result, covered_percent); end

  def self.run_exit_tasks!(); end

  def self.running(); end

  def self.running=(running); end

  def self.set_exit_exception(); end

  def self.start(profile=T.unsafe(nil), &block); end

  def self.wait_for_other_processes(); end

  def self.write_last_run(covered_percent); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  IFF_DORMANT = ::T.let(nil, ::T.untyped)
  IFF_ECHO = ::T.let(nil, ::T.untyped)
  IFF_LOWER_UP = ::T.let(nil, ::T.untyped)
  IFF_VOLATILE = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  IFF_DORMANT = ::T.let(nil, ::T.untyped)
  IFF_ECHO = ::T.let(nil, ::T.untyped)
  IFF_LOWER_UP = ::T.let(nil, ::T.untyped)
  IFF_VOLATILE = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class SorbetRails::Config
  def enabled_gem_plugins(*args, &blk); end

  def enabled_gem_plugins=(enabled_gem_plugins); end

  def enabled_model_plugins(*args, &blk); end

  def enabled_model_plugins=(enabled_model_plugins); end

  def enabled_plugins(*args, &blk); end

  def extra_helper_includes(*args, &blk); end

  def extra_helper_includes=(extra_helper_includes); end

  def initialize(&blk); end
end

class SorbetRails::Config
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::CustomFinderMethods
  def find_by_id(id); end

  def find_by_id!(id); end

  def find_n(*ids); end

  def first_n(n); end

  def last_n(n); end
end

module SorbetRails::CustomFinderMethods
end

module SorbetRails::CustomParamsMethods
  include ::Kernel
end

module SorbetRails::CustomParamsMethods
  extend ::T::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::ModelPlugins
  include ::Kernel
  def get_plugin_by_name(*args, &blk); end

  def get_plugins(*args, &blk); end

  def register_plugin(*args, &blk); end

  def register_plugin_by_name(arg0, &blk); end

  def set_plugins(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordAssoc
  def assoc_should_be_untyped?(*args, &blk); end

  def polymorphic_assoc?(*args, &blk); end

  def populate_collection_assoc_getter_setter(*args, &blk); end

  def populate_single_assoc_getter_setter(*args, &blk); end

  def relation_should_be_untyped?(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordAssoc
end

class SorbetRails::ModelPlugins::ActiveRecordAttribute
  def active_record_type_to_sorbet_type(*args, &blk); end

  def time_zone_aware_column?(*args, &blk); end

  def type_for_column_def(*args, &blk); end

  def value_type_for_attr_writer(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordAttribute
end

class SorbetRails::ModelPlugins::ActiveRecordEnum
end

class SorbetRails::ModelPlugins::ActiveRecordEnum
end

class SorbetRails::ModelPlugins::ActiveRecordFactoryMethods
  def add_factory_method(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordFactoryMethods
end

class SorbetRails::ModelPlugins::ActiveRecordFinderMethods
  def create_finder_method_pair(*args, &blk); end

  def create_finder_methods_for(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordFinderMethods
end

class SorbetRails::ModelPlugins::ActiveRecordNamedScope
end

class SorbetRails::ModelPlugins::ActiveRecordNamedScope
end

class SorbetRails::ModelPlugins::ActiveRecordQuerying
end

class SorbetRails::ModelPlugins::ActiveRecordQuerying
end

class SorbetRails::ModelPlugins::ActiveRelationWhereNot
end

class SorbetRails::ModelPlugins::ActiveRelationWhereNot
end

class SorbetRails::ModelPlugins::ActiveStorageMethods
  def create_has_many_methods(*args, &blk); end

  def create_has_one_methods(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveStorageMethods
end

class SorbetRails::ModelPlugins::Base
  include ::SorbetRails::ModelUtils
  def available_classes(*args, &blk); end
end

SorbetRails::ModelPlugins::Base::Parameter = Parlour::RbiGenerator::Parameter

class SorbetRails::ModelPlugins::Base
end

class SorbetRails::ModelPlugins::CustomFinderMethods
end

class SorbetRails::ModelPlugins::CustomFinderMethods
end

class SorbetRails::ModelPlugins::EnumerableCollections
  def create_enumerable_methods_for(*args, &blk); end
end

class SorbetRails::ModelPlugins::EnumerableCollections
end

class SorbetRails::ModelPlugins::UnrecognizedPluginName
end

class SorbetRails::ModelPlugins::UnrecognizedPluginName
end

module SorbetRails::ModelPlugins
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::ModelRbiFormatter
  include ::SorbetRails::ModelUtils
  def available_classes(*args, &blk); end

  def generate_base_rbi(*args, &blk); end

  def generate_rbi(*args, &blk); end

  def initialize(*args, &blk); end

  def run_plugins(*args, &blk); end
end

class SorbetRails::ModelRbiFormatter
  extend ::T::Sig
  extend ::SorbetRails::ModelPlugins
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::ModelUtils
  def add_relation_query_method(*args, &blk); end

  def exists_class_method?(*args, &blk); end

  def exists_instance_method?(*args, &blk); end

  def model_assoc_proxy_class_name(*args, &blk); end

  def model_assoc_relation_class_name(*args, &blk); end

  def model_class(*args, &blk); end

  def model_class_name(*args, &blk); end

  def model_module_name(*args, &blk); end

  def model_relation_class_name(*args, &blk); end
end

module SorbetRails::ModelUtils
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::Railtie
end

class SorbetRails::Railtie
end

module SorbetRails::Utils
end

module SorbetRails::Utils
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.rails_eager_load_all!(*args, &blk); end

  def self.valid_method_name?(*args, &blk); end
end

module SorbetRails
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.config(&blk); end

  def self.configure(*args, &blk); end

  def self.register_configured_plugins(&blk); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class SourceAnnotationExtractor
  def display(results, options=T.unsafe(nil)); end

  def extract_annotations_from(file, pattern); end

  def find(dirs); end

  def find_in(dir); end

  def initialize(tag); end

  def tag(); end
end

class SourceAnnotationExtractor::Annotation
  def to_s(options=T.unsafe(nil)); end
end

class SourceAnnotationExtractor::Annotation
  def self.directories(); end

  def self.extensions(); end

  def self.register_extensions(*exts, &block); end
end

class SourceAnnotationExtractor
  def self.enumerate(tag, options=T.unsafe(nil)); end
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::AddSourceMapCommentToAssetProcessor
end

class Sprockets::AddSourceMapCommentToAssetProcessor
  def self.call(input); end
end

class Sprockets::ArgumentError
end

class Sprockets::ArgumentError
end

class Sprockets::Asset
  def ==(other); end

  def base64digest(); end

  def bytesize(); end

  def charset(); end

  def content_type(); end

  def digest(); end

  def digest_path(); end

  def each(&blk); end

  def eql?(other); end

  def etag(); end

  def filename(); end

  def full_digest_path(); end

  def hexdigest(); end

  def id(); end

  def initialize(attributes=T.unsafe(nil)); end

  def integrity(); end

  def length(); end

  def links(); end

  def logical_path(); end

  def metadata(); end

  def source(); end

  def to_hash(); end

  def uri(); end

  def write_to(filename); end
end

class Sprockets::Asset
end

module Sprockets::Autoload
end

Sprockets::Autoload::Closure = Closure

Sprockets::Autoload::SassC = SassC

module Sprockets::Autoload
end

class Sprockets::BabelProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::BabelProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::Base
  include ::Sprockets::SourceMapUtils
  include ::Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Server
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::Bower
  include ::Sprockets::Npm
  def [](*args); end

  def cache(); end

  def cache=(cache); end

  def cached(); end

  def compress_from_root(uri); end

  def expand_from_root(uri); end

  def find_all_linked_assets(*args); end

  def find_asset(*args, **options); end

  def find_asset!(*args); end

  def index(); end
end

class Sprockets::Base
end

module Sprockets::Bower
  def read_bower_main(dirname, filename); end

  def resolve_alternates(load_path, logical_path); end
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Bower
end

class Sprockets::Bundle
end

class Sprockets::Bundle
  def self.call(input); end

  def self.dedup(required); end

  def self.process_bundle_reducers(input, assets, reducers); end
end

class Sprockets::Cache
  def clear(options=T.unsafe(nil)); end

  def fetch(key); end

  def get(key, local=T.unsafe(nil)); end

  def initialize(cache=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value, local=T.unsafe(nil)); end
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def initialize(root, max_size=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def self.default_logger(); end
end

class Sprockets::Cache::GetWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::GetWrapper
end

class Sprockets::Cache::HashWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::HashWrapper
end

class Sprockets::Cache::MemoryStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def initialize(max_size=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::MemoryStore
end

class Sprockets::Cache::NullStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::Cache::ReadWriteWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::ReadWriteWrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache
  def self.default_logger(); end
end

class Sprockets::CachedEnvironment
  def initialize(environment); end

  def processor_cache_key(str); end
end

class Sprockets::CachedEnvironment
end

class Sprockets::ClosureCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ClosureCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::Compressing
  include ::Sprockets::Utils
  def compressors(); end

  def css_compressor(); end

  def css_compressor=(compressor); end

  def gzip=(gzip); end

  def gzip?(); end

  def js_compressor(); end

  def js_compressor=(compressor); end

  def register_compressor(mime_type, sym, klass); end

  def skip_gzip?(); end
end

module Sprockets::Compressing
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Mime
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def config(); end

  def config=(config); end

  def context_class(); end

  def digest_class(); end

  def digest_class=(klass); end

  def initialize_configuration(parent); end

  def logger(); end

  def logger=(logger); end

  def version(); end

  def version=(version); end
end

module Sprockets::Configuration
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::Context
  def asset_data_uri(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def base64_asset_data_uri(asset); end

  def content_type(); end

  def depend_on(path); end

  def depend_on_asset(path); end

  def depend_on_env(key); end

  def env_proxy(); end

  def environment(); end

  def filename(); end

  def font_path(path); end

  def image_path(path); end

  def initialize(input); end

  def javascript_path(path); end

  def link_asset(path); end

  def load(uri); end

  def load_path(); end

  def logical_path(); end

  def metadata(); end

  def optimize_quoted_uri_escapes!(escaped); end

  def optimize_svg_for_uri_escaping!(svg); end

  def require_asset(path); end

  def resolve(path, **kargs); end

  def root_path(); end

  def stub_asset(path); end

  def stylesheet_path(path); end

  def svg_asset_data_uri(asset); end

  def video_path(path); end
end

class Sprockets::Context::ENVProxy
  def [](key); end

  def fetch(key, *_); end

  def initialize(context); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sprockets::Context::ENVProxy
end

class Sprockets::Context
end

class Sprockets::ConversionError
end

class Sprockets::ConversionError
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def add_dependency(uri); end

  def depend_on(uri); end

  def dependencies(); end

  def dependency_resolvers(); end

  def register_dependency_resolver(scheme, &block); end

  def resolve_dependency(str); end
end

module Sprockets::Dependencies
end

module Sprockets::DigestUtils
  def detect_digest_class(bytes); end

  def digest(obj); end

  def digest_class(); end

  def hexdigest(obj); end

  def hexdigest_integrity_uri(hexdigest); end

  def integrity_uri(digest); end

  def pack_base64digest(bin); end

  def pack_hexdigest(bin); end

  def pack_urlsafe_base64digest(bin); end

  def unpack_hexdigest(hex); end
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

module Sprockets::DigestUtils
  extend ::Sprockets::DigestUtils
end

class Sprockets::DirectiveProcessor
  def _call(input); end

  def call(input); end

  def compile_header_pattern(comments); end

  def extract_directives(header); end

  def initialize(comments: T.unsafe(nil)); end

  def process_depend_on_asset_directive(path); end

  def process_depend_on_directive(path); end

  def process_directives(directives); end

  def process_link_directive(path); end

  def process_link_directory_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_link_tree_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_require_directive(path); end

  def process_require_directory_directive(path=T.unsafe(nil)); end

  def process_require_self_directive(); end

  def process_require_tree_directive(path=T.unsafe(nil)); end

  def process_source(source); end

  def process_stub_directive(path); end
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::DoubleLinkError
  def initialize(parent_filename:, logical_path:, last_filename:, filename:); end
end

class Sprockets::DoubleLinkError
end

class Sprockets::ERBProcessor
  def call(input); end

  def initialize(&block); end
end

class Sprockets::ERBProcessor
  def self.call(input); end

  def self.instance(); end
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EncodingUtils
  def base64(str); end

  def charlock_detect(str); end

  def deflate(str); end

  def detect(str); end

  def detect_css(str); end

  def detect_html(str); end

  def detect_unicode(str); end

  def detect_unicode_bom(str); end

  def gzip(str); end

  def scan_css_charset(str); end

  def unmarshaled_deflated(str, window_bits=T.unsafe(nil)); end
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

module Sprockets::EncodingUtils
  extend ::Sprockets::EncodingUtils
end

class Sprockets::Environment
  def find_all_linked_assets(*args, &block); end

  def initialize(root=T.unsafe(nil)); end

  def load(*args); end
end

class Sprockets::Environment
end

class Sprockets::Error
end

class Sprockets::Error
end

module Sprockets::Exporters
end

class Sprockets::Exporters::Base
  def asset(); end

  def call(); end

  def directory(); end

  def environment(); end

  def initialize(asset: T.unsafe(nil), environment: T.unsafe(nil), directory: T.unsafe(nil)); end

  def setup(); end

  def skip?(logger); end

  def target(); end

  def write(filename=T.unsafe(nil)); end
end

class Sprockets::Exporters::Base
end

class Sprockets::Exporters::FileExporter
end

class Sprockets::Exporters::FileExporter
end

class Sprockets::Exporters::ZlibExporter
end

class Sprockets::Exporters::ZlibExporter
end

class Sprockets::Exporters::ZopfliExporter
end

class Sprockets::Exporters::ZopfliExporter
end

module Sprockets::Exporters
end

module Sprockets::Exporting
  def export_concurrent(); end

  def export_concurrent=(export_concurrent); end

  def exporters(); end

  def register_exporter(mime_types, klass=T.unsafe(nil)); end

  def unregister_exporter(mime_types, exporter=T.unsafe(nil)); end
end

module Sprockets::Exporting
end

class Sprockets::FileNotFound
end

class Sprockets::FileNotFound
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileReader
end

class Sprockets::FileReader
  def self.call(input); end
end

module Sprockets::HTTPUtils
  def find_best_mime_type_match(q_value_header, available); end

  def find_best_q_match(q_values, available, &matcher); end

  def find_mime_type_matches(q_value_header, available); end

  def find_q_matches(q_values, available, &matcher); end

  def match_mime_type?(value, matcher); end

  def match_mime_type_keys(hash, mime_type); end

  def parse_q_values(values); end
end

module Sprockets::HTTPUtils
  extend ::Sprockets::HTTPUtils
end

class Sprockets::JSMincCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::JSMincCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::JstProcessor
  def call(input); end

  def initialize(namespace: T.unsafe(nil)); end
end

class Sprockets::JstProcessor
  def self.call(input); end

  def self.default_namespace(); end

  def self.instance(); end
end

module Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def load(uri); end
end

module Sprockets::Loader
end

class Sprockets::Manifest
  include ::Sprockets::ManifestUtils
  def assets(); end

  def clean(count=T.unsafe(nil), age=T.unsafe(nil)); end

  def clobber(); end

  def compile(*args); end

  def dir(); end

  def directory(); end

  def environment(); end

  def filename(); end

  def files(); end

  def find(*args); end

  def find_sources(*args); end

  def initialize(*args); end

  def path(); end

  def remove(filename); end

  def save(); end
end

class Sprockets::Manifest
end

module Sprockets::ManifestUtils
  def find_directory_manifest(dirname, logger=T.unsafe(nil)); end

  def generate_manifest_path(); end
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::ManifestUtils
  extend ::Sprockets::ManifestUtils
end

module Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::HTTPUtils
  def mime_exts(); end

  def mime_type_charset_detecter(mime_type); end

  def mime_types(); end

  def read_file(filename, content_type=T.unsafe(nil)); end

  def register_mime_type(mime_type, extensions: T.unsafe(nil), charset: T.unsafe(nil)); end
end

module Sprockets::Mime
end

class Sprockets::NotFound
end

class Sprockets::NotFound
end

class Sprockets::NotImplementedError
end

class Sprockets::NotImplementedError
end

module Sprockets::Npm
  def read_package_directives(dirname, filename); end

  def resolve_alternates(load_path, logical_path); end
end

module Sprockets::Npm
end

module Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  def entries_with_dependencies(path); end

  def stat_directory_with_dependencies(dir); end

  def stat_sorted_tree_with_dependencies(dir); end
end

module Sprockets::PathDependencyUtils
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def file_digest(path); end

  def files_digest(paths); end

  def stat_digest(path, stat); end
end

module Sprockets::PathDigestUtils
end

module Sprockets::PathUtils
  def absolute_path?(path); end

  def atomic_write(filename); end

  def directory?(path); end

  def entries(path); end

  def file?(path); end

  def find_matching_path_for_extensions(path, basename, extensions); end

  def find_upwards(basename, path, root=T.unsafe(nil)); end

  def join(base, path); end

  def match_path_extname(path, extensions); end

  def path_extnames(path); end

  def path_parents(path, root=T.unsafe(nil)); end

  def paths_split(paths, filename); end

  def relative_path?(path); end

  def relative_path_from(start, dest); end

  def set_pipeline(path, mime_exts, pipeline_exts, pipeline); end

  def split_subpath(path, subpath); end

  def stat(path); end

  def stat_directory(dir); end

  def stat_sorted_tree(dir, &block); end

  def stat_tree(dir, &block); end
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::PathUtils
  extend ::Sprockets::PathUtils
end

module Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::PathUtils
  def append_path(path); end

  def clear_paths(); end

  def each_file(); end

  def paths(); end

  def prepend_path(path); end

  def root(); end
end

module Sprockets::Paths
end

module Sprockets::Preprocessors
end

class Sprockets::Preprocessors::DefaultSourceMap
  def call(input); end
end

class Sprockets::Preprocessors::DefaultSourceMap
end

module Sprockets::Preprocessors
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  def build_processors_uri(type, file_type, pipeline); end

  def bundle_processors(); end

  def default_processors_for(type, file_type); end

  def pipelines(); end

  def postprocessors(); end

  def preprocessors(); end

  def processors(); end

  def processors_for(type, file_type, pipeline); end

  def register_bundle_metadata_reducer(mime_type, key, *args, &block); end

  def register_bundle_processor(*args, &block); end

  def register_pipeline(name, proc=T.unsafe(nil), &block); end

  def register_postprocessor(*args, &block); end

  def register_preprocessor(*args, &block); end

  def register_processor(*args, &block); end

  def resolve_processors_cache_key_uri(uri); end

  def self_processors_for(type, file_type); end

  def unregister_bundle_processor(*args); end

  def unregister_postprocessor(*args); end

  def unregister_preprocessor(*args); end

  def unregister_processor(*args); end
end

module Sprockets::Processing
end

module Sprockets::ProcessorUtils
  def call_processor(processor, input); end

  def call_processors(processors, input); end

  def compose_processors(*processors); end

  def processor_cache_key(processor); end

  def processors_cache_keys(processors); end

  def validate_processor_result!(result); end
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  def cache_key(); end

  def call(input); end
  PLURAL = ::T.let(nil, ::T.untyped)
  SINGULAR = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  def self.create(processors); end
end

module Sprockets::ProcessorUtils
  extend ::Sprockets::ProcessorUtils
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Context
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def compute_asset_path(path, options=T.unsafe(nil)); end
end

module Sprockets::Rails::Context
  def self.included(klass); end
end

module Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::Sprockets::Rails::Utils
  def asset_digest_path(path, options=T.unsafe(nil)); end

  def asset_integrity(path, options=T.unsafe(nil)); end

  def asset_resolver_strategies(); end

  def compute_asset_path(path, options=T.unsafe(nil)); end

  def compute_integrity?(options); end

  def javascript_include_tag(*sources); end

  def legacy_debug_path(path, debug); end

  def lookup_debug_asset(path, options=T.unsafe(nil)); end

  def path_with_extname(path, options); end

  def request_debug_assets?(); end

  def resolve_asset(); end

  def resolve_asset_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def secure_subresource_integrity_context?(); end

  def stylesheet_link_tag(*sources); end
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Helper
  def self.extended(obj); end

  def self.included(klass); end
end

module Sprockets::Rails::HelperAssetResolvers
end

class Sprockets::Rails::HelperAssetResolvers::Environment
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Environment
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
end

module Sprockets::Rails::HelperAssetResolvers
  def self.[](name); end
end

class Sprockets::Rails::QuietAssets
  def call(env); end

  def initialize(app); end
end

class Sprockets::Rails::QuietAssets
end

module Sprockets::Rails::RouteWrapper
  def internal?(); end

  def internal_assets_path?(); end
end

module Sprockets::Rails::RouteWrapper
  def self.included(klass); end
end

module Sprockets::Rails::Utils
  def using_sprockets4?(); end
end

module Sprockets::Rails::Utils
end

module Sprockets::Rails
end

class Sprockets::Railtie
  include ::Sprockets::Rails::Utils
  def build_environment(app, initialized=T.unsafe(nil)); end
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Railtie::ManifestNeededError
  def initialize(); end
end

class Sprockets::Railtie::ManifestNeededError
end

class Sprockets::Railtie::OrderedOptions
  def configure(&block); end
end

class Sprockets::Railtie::OrderedOptions
end

class Sprockets::Railtie
  def self.build_manifest(app); end
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  include ::Sprockets::HTTPUtils
  def parse_accept_options(mime_type, explicit_type); end

  def resolve(path, load_paths: T.unsafe(nil), accept: T.unsafe(nil), pipeline: T.unsafe(nil), base_path: T.unsafe(nil)); end

  def resolve!(path, **kargs); end

  def resolve_absolute_path(paths, filename, accept); end

  def resolve_alternates(load_path, logical_name); end

  def resolve_alts_under_path(load_path, logical_name, mime_exts); end

  def resolve_asset_uri(uri); end

  def resolve_index_under_path(load_path, logical_name, mime_exts); end

  def resolve_logical_path(paths, logical_path, accept); end

  def resolve_main_under_path(load_path, logical_name, mime_exts); end

  def resolve_relative_path(paths, path, dirname, accept); end

  def resolve_under_paths(paths, logical_name, accepts); end
end

module Sprockets::Resolve
end

class Sprockets::SassCompressor
  def cache_key(); end

  def call(*args); end

  def evaluate(*args); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

Sprockets::SassFunctions = Sprockets::SassProcessor::Functions

class Sprockets::SassProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil), &block); end
end

module Sprockets::SassProcessor::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def audio_url(path); end

  def font_path(path); end

  def font_url(path); end

  def image_path(path); end

  def image_url(path); end

  def javascript_path(path); end

  def javascript_url(path); end

  def sprockets_context(); end

  def sprockets_dependencies(); end

  def sprockets_environment(); end

  def stylesheet_path(path); end

  def stylesheet_url(path); end

  def video_path(path); end

  def video_url(path); end
end

module Sprockets::SassProcessor::Functions
end

class Sprockets::SassProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end

  def self.syntax(); end
end

class Sprockets::SasscCompressor
  def call(input); end

  def initialize(options=T.unsafe(nil)); end
end

class Sprockets::SasscCompressor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::SasscProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil), &block); end
end

module Sprockets::SasscProcessor::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def audio_url(path); end

  def font_path(path); end

  def font_url(path); end

  def image_path(path); end

  def image_url(path); end

  def javascript_path(path); end

  def javascript_url(path); end

  def sprockets_context(); end

  def sprockets_dependencies(); end

  def sprockets_environment(); end

  def stylesheet_path(path); end

  def stylesheet_url(path); end

  def video_path(path); end

  def video_url(path); end
end

module Sprockets::SasscProcessor::Functions
end

class Sprockets::SasscProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end

  def self.syntax(); end
end

class Sprockets::ScssProcessor
end

class Sprockets::ScssProcessor
end

class Sprockets::ScsscProcessor
end

class Sprockets::ScsscProcessor
end

module Sprockets::Server
  def call(env); end
  ALLOWED_REQUEST_METHODS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Server
end

class Sprockets::SourceMapProcessor
end

class Sprockets::SourceMapProcessor
  def self.call(input); end

  def self.original_content_type(source_map_content_type, error_when_not_found: T.unsafe(nil)); end
end

module Sprockets::SourceMapUtils
  def bsearch_mappings(mappings, offset, from=T.unsafe(nil), to=T.unsafe(nil)); end

  def combine_source_maps(first, second); end

  def compare_source_offsets(a, b); end

  def concat_source_maps(a, b); end

  def decode_source_map(map); end

  def decode_vlq_mappings(str, sources: T.unsafe(nil), names: T.unsafe(nil)); end

  def encode_source_map(map); end

  def encode_vlq_mappings(mappings, sources: T.unsafe(nil), names: T.unsafe(nil)); end

  def format_source_map(map, input); end

  def make_index_map(map); end

  def vlq_decode(str); end

  def vlq_decode_mappings(str); end

  def vlq_encode(ary); end

  def vlq_encode_mappings(ary); end
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_VALUES = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

module Sprockets::SourceMapUtils
  extend ::Sprockets::SourceMapUtils
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def compose_transformers(transformers, types, preprocessors, postprocessors); end

  def expand_transform_accepts(parsed_accepts); end

  def register_transformer(from, to, proc); end

  def register_transformer_suffix(types, type_format, extname, processor); end

  def resolve_transform_type(type, accept); end

  def transformers(); end
end

class Sprockets::Transformers::Transformer
  def from(); end

  def from=(_); end

  def proc=(_); end

  def to(); end

  def to=(_); end
end

class Sprockets::Transformers::Transformer
  def self.[](*_); end

  def self.members(); end
end

module Sprockets::Transformers
end

class Sprockets::URITar
  def absolute_path?(); end

  def compress(); end

  def compressed_path(); end

  def expand(); end

  def initialize(uri, env); end

  def path(); end

  def root(); end

  def scheme(); end
end

class Sprockets::URITar
end

module Sprockets::URIUtils
  def build_asset_uri(path, params=T.unsafe(nil)); end

  def build_file_digest_uri(path); end

  def encode_uri_query_params(params); end

  def join_file_uri(scheme, host, path, query); end

  def join_uri(scheme, userinfo, host, port, registry, path, opaque, query, fragment); end

  def parse_asset_uri(uri); end

  def parse_file_digest_uri(uri); end

  def parse_uri_query_params(query); end

  def split_file_uri(uri); end

  def split_uri(uri); end

  def valid_asset_uri?(str); end
end

module Sprockets::URIUtils
  extend ::Sprockets::URIUtils
end

class Sprockets::UglifierCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::UglifierCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::UnloadedAsset
  def asset_key(); end

  def compressed_path(); end

  def dependency_history_key(); end

  def digest_key(digest); end

  def file_digest_key(stat); end

  def filename(); end

  def initialize(uri, env); end

  def params(); end

  def uri(); end
end

class Sprockets::UnloadedAsset
end

module Sprockets::Utils
  def concat_javascript_sources(buf, source); end

  def dfs(initial); end

  def dfs_paths(path); end

  def duplicable?(obj); end

  def hash_reassoc(hash, key_a, key_b=T.unsafe(nil), &block); end

  def hash_reassoc1(hash, key); end

  def module_include(base, mod); end

  def string_end_with_semicolon?(str); end
end

class Sprockets::Utils::Gzip
  def archiver(); end

  def can_compress?(); end

  def cannot_compress?(); end

  def charset(); end

  def compress(file, target); end

  def content_type(); end

  def initialize(asset, archiver: T.unsafe(nil)); end

  def source(); end
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Sprockets::Utils::Gzip::ZlibArchiver
end

module Sprockets::Utils::Gzip::ZlibArchiver
  def self.call(file, source, mtime); end
end

module Sprockets::Utils::Gzip::ZopfliArchiver
end

module Sprockets::Utils::Gzip::ZopfliArchiver
  def self.call(file, source, mtime); end
end

class Sprockets::Utils::Gzip
end

module Sprockets::Utils
  extend ::Sprockets::Utils
end

class Sprockets::YUICompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets
  extend ::Sprockets::Configuration
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Exporting
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Mime
  extend ::Sprockets::Paths
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::ProcessorUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::PathUtils
  extend ::Sprockets::DigestUtils
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::IntegerStringImpl
  include ::BooleanStringImpl
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def ext(newext=T.unsafe(nil)); end

  def grapheme_clusters(); end

  def parse_csv(**options); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def reverse!(); end

  def shell_split(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def to_d(); end

  def to_json(options=T.unsafe(nil)); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
end

class String
  def self.json_create(obj); end
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

class Struct::AwsEmptyStructure
end

class Struct::AwsEmptyStructure
  def self.[](*_); end

  def self.members(); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SubstitutionContext
  def match(matches, attribute, matcher); end

  def substitute!(selector, values); end
end

class SubstitutionContext
end

class SymbolHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def initialize(symbolize_value=T.unsafe(nil)); end

  def key?(key); end

  def merge(hash); end

  def merge!(hash); end

  def update(hash); end
end

class SymbolHash
  def self.[](*hsh); end
end

class SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class SynchronizedDelegator
end

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class TA
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module TZInfo
end

class TZInfo::AmbiguousTime
end

class TZInfo::AmbiguousTime
end

class TZInfo::Country
  include ::Comparable
  def _dump(limit); end

  def code(); end

  def eql?(c); end

  def name(); end

  def zone_identifiers(); end

  def zone_info(); end

  def zone_names(); end

  def zones(); end
end

class TZInfo::Country
  def self._load(data); end

  def self.all(); end

  def self.all_codes(); end

  def self.data_source(); end

  def self.get(identifier); end

  def self.init_countries(); end

  def self.new(identifier); end
end

module TZInfo::CountryIndexDefinition
end

module TZInfo::CountryIndexDefinition::ClassMethods
  def countries(); end

  def country(code, name, &block); end
end

module TZInfo::CountryIndexDefinition::ClassMethods
end

module TZInfo::CountryIndexDefinition
  def self.append_features(base); end
end

class TZInfo::CountryInfo
  def code(); end

  def initialize(code, name); end

  def name(); end

  def zone_identifiers(); end

  def zones(); end
end

class TZInfo::CountryInfo
end

class TZInfo::CountryTimezone
  def ==(ct); end

  def description(); end

  def description_or_friendly_identifier(); end

  def eql?(ct); end

  def identifier(); end

  def initialize(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end

  def latitude(); end

  def longitude(); end

  def timezone(); end
end

class TZInfo::CountryTimezone
  def self.new(identifier, latitude, longitude, description=T.unsafe(nil)); end

  def self.new!(*_); end
end

module TZInfo::Data
  VERSION = ::T.let(nil, ::T.untyped)
end

module TZInfo::Data::Definitions
end

module TZInfo::Data::Definitions::Africa
end

module TZInfo::Data::Definitions::Africa::Abidjan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Abidjan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Accra
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Accra
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Addis_Ababa
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Addis_Ababa
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Algiers
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Algiers
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Asmara
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Asmara
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Asmera
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Asmera
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Bamako
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Bamako
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Bangui
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Bangui
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Banjul
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Banjul
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Bissau
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Bissau
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Blantyre
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Blantyre
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Brazzaville
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Brazzaville
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Bujumbura
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Bujumbura
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Cairo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Cairo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Casablanca
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Casablanca
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Ceuta
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Ceuta
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Conakry
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Conakry
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Dakar
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Dakar
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Dar_es_Salaam
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Dar_es_Salaam
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Djibouti
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Djibouti
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Douala
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Douala
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::El_Aaiun
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::El_Aaiun
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Freetown
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Freetown
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Gaborone
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Gaborone
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Harare
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Harare
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Johannesburg
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Johannesburg
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Juba
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Juba
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Kampala
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Kampala
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Khartoum
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Khartoum
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Kigali
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Kigali
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Kinshasa
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Kinshasa
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Lagos
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Lagos
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Libreville
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Libreville
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Lome
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Lome
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Luanda
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Luanda
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Lubumbashi
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Lubumbashi
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Lusaka
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Lusaka
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Malabo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Malabo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Maputo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Maputo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Maseru
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Maseru
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Mbabane
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Mbabane
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Mogadishu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Mogadishu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Monrovia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Monrovia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Nairobi
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Nairobi
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Ndjamena
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Ndjamena
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Niamey
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Niamey
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Nouakchott
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Nouakchott
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Ouagadougou
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Ouagadougou
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Porto__m__Novo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Porto__m__Novo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Sao_Tome
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Sao_Tome
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Timbuktu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Timbuktu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Tripoli
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Tripoli
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Tunis
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Tunis
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa::Windhoek
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Africa::Windhoek
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Africa
end

module TZInfo::Data::Definitions::America
end

module TZInfo::Data::Definitions::America::Adak
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Adak
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Anchorage
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Anchorage
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Anguilla
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Anguilla
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Antigua
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Antigua
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Araguaina
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Araguaina
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina
end

module TZInfo::Data::Definitions::America::Argentina::Buenos_Aires
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Buenos_Aires
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::Catamarca
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Catamarca
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::ComodRivadavia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::ComodRivadavia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::Cordoba
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Cordoba
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::Jujuy
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Jujuy
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::La_Rioja
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::La_Rioja
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::Mendoza
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Mendoza
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::Rio_Gallegos
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Rio_Gallegos
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::Salta
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Salta
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::San_Juan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::San_Juan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::San_Luis
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::San_Luis
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::Tucuman
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Tucuman
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina::Ushuaia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Argentina::Ushuaia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Argentina
end

module TZInfo::Data::Definitions::America::Aruba
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Aruba
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Asuncion
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Asuncion
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Atikokan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Atikokan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Atka
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Atka
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Bahia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Bahia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Bahia_Banderas
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Bahia_Banderas
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Barbados
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Barbados
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Belem
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Belem
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Belize
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Belize
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Blanc__m__Sablon
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Blanc__m__Sablon
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Boa_Vista
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Boa_Vista
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Bogota
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Bogota
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Boise
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Boise
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Buenos_Aires
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Buenos_Aires
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Cambridge_Bay
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Cambridge_Bay
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Campo_Grande
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Campo_Grande
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Cancun
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Cancun
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Caracas
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Caracas
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Catamarca
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Catamarca
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Cayenne
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Cayenne
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Cayman
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Cayman
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Chicago
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Chicago
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Chihuahua
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Chihuahua
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Coral_Harbour
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Coral_Harbour
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Cordoba
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Cordoba
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Costa_Rica
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Costa_Rica
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Creston
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Creston
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Cuiaba
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Cuiaba
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Curacao
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Curacao
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Danmarkshavn
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Danmarkshavn
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Dawson
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Dawson
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Dawson_Creek
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Dawson_Creek
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Denver
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Denver
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Detroit
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Detroit
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Dominica
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Dominica
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Edmonton
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Edmonton
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Eirunepe
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Eirunepe
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::El_Salvador
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::El_Salvador
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Ensenada
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Ensenada
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Fort_Nelson
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Fort_Nelson
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Fort_Wayne
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Fort_Wayne
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Fortaleza
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Fortaleza
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Glace_Bay
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Glace_Bay
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Godthab
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Godthab
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Goose_Bay
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Goose_Bay
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Grand_Turk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Grand_Turk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Grenada
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Grenada
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Guadeloupe
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Guadeloupe
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Guatemala
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Guatemala
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Guayaquil
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Guayaquil
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Guyana
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Guyana
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Halifax
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Halifax
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Havana
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Havana
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Hermosillo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Hermosillo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana
end

module TZInfo::Data::Definitions::America::Indiana::Indianapolis
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indiana::Indianapolis
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana::Knox
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indiana::Knox
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana::Marengo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indiana::Marengo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana::Petersburg
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indiana::Petersburg
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana::Tell_City
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indiana::Tell_City
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana::Vevay
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indiana::Vevay
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana::Vincennes
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indiana::Vincennes
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana::Winamac
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indiana::Winamac
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Indiana
end

module TZInfo::Data::Definitions::America::Indianapolis
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Indianapolis
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Inuvik
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Inuvik
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Iqaluit
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Iqaluit
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Jamaica
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Jamaica
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Jujuy
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Jujuy
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Juneau
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Juneau
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Kentucky
end

module TZInfo::Data::Definitions::America::Kentucky::Louisville
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Kentucky::Louisville
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Kentucky::Monticello
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Kentucky::Monticello
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Kentucky
end

module TZInfo::Data::Definitions::America::Knox_IN
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Knox_IN
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Kralendijk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Kralendijk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::La_Paz
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::La_Paz
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Lima
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Lima
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Los_Angeles
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Los_Angeles
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Louisville
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Louisville
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Lower_Princes
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Lower_Princes
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Maceio
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Maceio
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Managua
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Managua
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Manaus
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Manaus
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Marigot
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Marigot
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Martinique
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Martinique
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Matamoros
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Matamoros
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Mazatlan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Mazatlan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Mendoza
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Mendoza
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Menominee
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Menominee
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Merida
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Merida
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Metlakatla
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Metlakatla
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Mexico_City
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Mexico_City
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Miquelon
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Miquelon
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Moncton
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Moncton
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Monterrey
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Monterrey
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Montevideo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Montevideo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Montreal
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Montreal
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Montserrat
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Montserrat
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Nassau
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Nassau
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::New_York
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::New_York
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Nipigon
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Nipigon
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Nome
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Nome
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Noronha
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Noronha
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::North_Dakota
end

module TZInfo::Data::Definitions::America::North_Dakota::Beulah
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::North_Dakota::Beulah
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::North_Dakota::Center
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::North_Dakota::Center
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::North_Dakota::New_Salem
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::North_Dakota::New_Salem
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::North_Dakota
end

module TZInfo::Data::Definitions::America::Nuuk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Nuuk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Ojinaga
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Ojinaga
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Panama
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Panama
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Pangnirtung
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Pangnirtung
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Paramaribo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Paramaribo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Phoenix
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Phoenix
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Port__m__au__m__Prince
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Port__m__au__m__Prince
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Port_of_Spain
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Port_of_Spain
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Porto_Acre
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Porto_Acre
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Porto_Velho
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Porto_Velho
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Puerto_Rico
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Puerto_Rico
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Punta_Arenas
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Punta_Arenas
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Rainy_River
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Rainy_River
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Rankin_Inlet
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Rankin_Inlet
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Recife
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Recife
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Regina
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Regina
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Resolute
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Resolute
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Rio_Branco
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Rio_Branco
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Rosario
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Rosario
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Santa_Isabel
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Santa_Isabel
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Santarem
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Santarem
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Santiago
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Santiago
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Santo_Domingo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Santo_Domingo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Sao_Paulo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Sao_Paulo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Scoresbysund
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Scoresbysund
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Shiprock
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Shiprock
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Sitka
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Sitka
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::St_Barthelemy
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::St_Barthelemy
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::St_Johns
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::St_Johns
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::St_Kitts
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::St_Kitts
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::St_Lucia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::St_Lucia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::St_Thomas
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::St_Thomas
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::St_Vincent
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::St_Vincent
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Swift_Current
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Swift_Current
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Tegucigalpa
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Tegucigalpa
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Thule
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Thule
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Thunder_Bay
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Thunder_Bay
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Tijuana
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Tijuana
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Toronto
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Toronto
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Tortola
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Tortola
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Vancouver
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Vancouver
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Virgin
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Virgin
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Whitehorse
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Whitehorse
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Winnipeg
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Winnipeg
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Yakutat
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Yakutat
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America::Yellowknife
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::America::Yellowknife
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::America
end

module TZInfo::Data::Definitions::Antarctica
end

module TZInfo::Data::Definitions::Antarctica::Casey
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Casey
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::Davis
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Davis
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::DumontDUrville
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::DumontDUrville
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::Macquarie
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Macquarie
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::Mawson
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Mawson
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::McMurdo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::McMurdo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::Palmer
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Palmer
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::Rothera
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Rothera
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::South_Pole
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::South_Pole
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::Syowa
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Syowa
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::Troll
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Troll
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica::Vostok
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Antarctica::Vostok
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Antarctica
end

module TZInfo::Data::Definitions::Arctic
end

module TZInfo::Data::Definitions::Arctic::Longyearbyen
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Arctic::Longyearbyen
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Arctic
end

module TZInfo::Data::Definitions::Asia
end

module TZInfo::Data::Definitions::Asia::Aden
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Aden
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Almaty
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Almaty
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Amman
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Amman
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Anadyr
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Anadyr
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Aqtau
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Aqtau
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Aqtobe
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Aqtobe
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Ashgabat
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Ashgabat
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Ashkhabad
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Ashkhabad
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Atyrau
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Atyrau
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Baghdad
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Baghdad
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Bahrain
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Bahrain
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Baku
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Baku
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Bangkok
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Bangkok
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Barnaul
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Barnaul
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Beirut
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Beirut
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Bishkek
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Bishkek
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Brunei
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Brunei
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Calcutta
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Calcutta
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Chita
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Chita
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Choibalsan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Choibalsan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Chongqing
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Chongqing
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Chungking
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Chungking
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Colombo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Colombo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Dacca
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Dacca
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Damascus
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Damascus
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Dhaka
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Dhaka
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Dili
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Dili
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Dubai
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Dubai
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Dushanbe
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Dushanbe
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Famagusta
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Famagusta
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Gaza
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Gaza
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Harbin
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Harbin
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Hebron
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Hebron
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Ho_Chi_Minh
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Ho_Chi_Minh
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Hong_Kong
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Hong_Kong
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Hovd
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Hovd
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Irkutsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Irkutsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Istanbul
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Istanbul
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Jakarta
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Jakarta
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Jayapura
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Jayapura
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Jerusalem
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Jerusalem
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Kabul
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Kabul
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Kamchatka
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Kamchatka
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Karachi
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Karachi
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Kashgar
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Kashgar
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Kathmandu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Kathmandu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Katmandu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Katmandu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Khandyga
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Khandyga
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Kolkata
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Kolkata
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Krasnoyarsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Krasnoyarsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Kuala_Lumpur
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Kuala_Lumpur
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Kuching
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Kuching
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Kuwait
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Kuwait
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Macao
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Macao
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Macau
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Macau
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Magadan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Magadan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Makassar
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Makassar
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Manila
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Manila
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Muscat
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Muscat
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Nicosia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Nicosia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Novokuznetsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Novokuznetsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Novosibirsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Novosibirsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Omsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Omsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Oral
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Oral
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Phnom_Penh
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Phnom_Penh
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Pontianak
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Pontianak
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Pyongyang
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Pyongyang
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Qatar
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Qatar
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Qostanay
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Qostanay
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Qyzylorda
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Qyzylorda
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Rangoon
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Rangoon
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Riyadh
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Riyadh
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Saigon
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Saigon
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Sakhalin
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Sakhalin
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Samarkand
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Samarkand
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Seoul
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Seoul
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Shanghai
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Shanghai
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Singapore
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Singapore
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Srednekolymsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Srednekolymsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Taipei
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Taipei
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Tashkent
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Tashkent
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Tbilisi
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Tbilisi
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Tehran
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Tehran
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Tel_Aviv
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Tel_Aviv
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Thimbu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Thimbu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Thimphu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Thimphu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Tokyo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Tokyo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Tomsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Tomsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Ujung_Pandang
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Ujung_Pandang
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Ulaanbaatar
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Ulaanbaatar
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Ulan_Bator
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Ulan_Bator
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Urumqi
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Urumqi
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Ust__m__Nera
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Ust__m__Nera
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Vientiane
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Vientiane
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Vladivostok
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Vladivostok
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Yakutsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Yakutsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Yangon
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Yangon
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Yekaterinburg
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Yekaterinburg
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia::Yerevan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Asia::Yerevan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Asia
end

module TZInfo::Data::Definitions::Atlantic
end

module TZInfo::Data::Definitions::Atlantic::Azores
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Azores
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Bermuda
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Bermuda
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Canary
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Canary
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Cape_Verde
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Cape_Verde
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Faeroe
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Faeroe
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Faroe
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Faroe
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Jan_Mayen
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Jan_Mayen
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Madeira
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Madeira
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Reykjavik
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Reykjavik
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::South_Georgia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::South_Georgia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::St_Helena
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::St_Helena
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic::Stanley
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Atlantic::Stanley
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Atlantic
end

module TZInfo::Data::Definitions::Australia
end

module TZInfo::Data::Definitions::Australia::ACT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::ACT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Adelaide
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Adelaide
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Brisbane
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Brisbane
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Broken_Hill
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Broken_Hill
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Canberra
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Canberra
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Currie
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Currie
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Darwin
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Darwin
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Eucla
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Eucla
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Hobart
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Hobart
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::LHI
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::LHI
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Lindeman
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Lindeman
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Lord_Howe
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Lord_Howe
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Melbourne
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Melbourne
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::NSW
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::NSW
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::North
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::North
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Perth
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Perth
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Queensland
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Queensland
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::South
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::South
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Sydney
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Sydney
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Tasmania
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Tasmania
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Victoria
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Victoria
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::West
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::West
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia::Yancowinna
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Australia::Yancowinna
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Australia
end

module TZInfo::Data::Definitions::Brazil
end

module TZInfo::Data::Definitions::Brazil::Acre
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Brazil::Acre
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Brazil::DeNoronha
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Brazil::DeNoronha
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Brazil::East
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Brazil::East
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Brazil::West
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Brazil::West
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Brazil
end

module TZInfo::Data::Definitions::CET
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::CET
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::CST6CDT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::CST6CDT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada
end

module TZInfo::Data::Definitions::Canada::Atlantic
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Canada::Atlantic
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada::Central
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Canada::Central
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada::Eastern
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Canada::Eastern
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada::Mountain
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Canada::Mountain
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada::Newfoundland
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Canada::Newfoundland
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada::Pacific
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Canada::Pacific
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada::Saskatchewan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Canada::Saskatchewan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada::Yukon
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Canada::Yukon
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Canada
end

module TZInfo::Data::Definitions::Chile
end

module TZInfo::Data::Definitions::Chile::Continental
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Chile::Continental
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Chile::EasterIsland
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Chile::EasterIsland
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Chile
end

module TZInfo::Data::Definitions::Cuba
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Cuba
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::EET
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::EET
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::EST
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::EST
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::EST5EDT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::EST5EDT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Egypt
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Egypt
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Eire
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Eire
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc
end

module TZInfo::Data::Definitions::Etc::GMT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT0
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT0
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__0
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__0
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__1
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__1
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__10
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__10
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__11
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__11
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__12
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__12
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__13
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__13
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__14
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__14
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__2
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__2
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__3
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__3
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__4
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__4
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__5
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__5
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__6
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__6
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__7
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__7
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__8
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__8
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__m__9
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__m__9
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__0
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__0
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__1
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__1
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__10
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__10
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__11
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__11
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__12
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__12
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__2
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__2
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__3
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__3
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__4
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__4
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__5
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__5
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__6
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__6
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__7
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__7
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__8
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__8
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::GMT__p__9
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::GMT__p__9
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::Greenwich
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::Greenwich
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::UCT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::UCT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::UTC
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::UTC
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::Universal
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::Universal
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc::Zulu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Etc::Zulu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Etc
end

module TZInfo::Data::Definitions::Europe
end

module TZInfo::Data::Definitions::Europe::Amsterdam
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Amsterdam
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Andorra
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Andorra
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Astrakhan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Astrakhan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Athens
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Athens
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Belfast
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Belfast
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Belgrade
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Belgrade
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Berlin
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Berlin
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Bratislava
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Bratislava
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Brussels
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Brussels
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Bucharest
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Bucharest
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Budapest
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Budapest
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Busingen
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Busingen
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Chisinau
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Chisinau
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Copenhagen
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Copenhagen
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Dublin
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Dublin
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Gibraltar
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Gibraltar
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Guernsey
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Guernsey
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Helsinki
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Helsinki
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Isle_of_Man
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Isle_of_Man
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Istanbul
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Istanbul
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Jersey
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Jersey
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Kaliningrad
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Kaliningrad
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Kiev
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Kiev
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Kirov
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Kirov
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Lisbon
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Lisbon
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Ljubljana
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Ljubljana
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::London
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::London
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Luxembourg
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Luxembourg
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Madrid
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Madrid
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Malta
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Malta
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Mariehamn
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Mariehamn
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Minsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Minsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Monaco
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Monaco
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Moscow
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Moscow
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Nicosia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Nicosia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Oslo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Oslo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Paris
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Paris
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Podgorica
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Podgorica
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Prague
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Prague
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Riga
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Riga
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Rome
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Rome
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Samara
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Samara
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::San_Marino
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::San_Marino
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Sarajevo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Sarajevo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Saratov
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Saratov
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Simferopol
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Simferopol
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Skopje
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Skopje
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Sofia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Sofia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Stockholm
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Stockholm
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Tallinn
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Tallinn
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Tirane
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Tirane
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Tiraspol
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Tiraspol
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Ulyanovsk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Ulyanovsk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Uzhgorod
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Uzhgorod
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Vaduz
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Vaduz
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Vatican
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Vatican
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Vienna
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Vienna
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Vilnius
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Vilnius
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Volgograd
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Volgograd
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Warsaw
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Warsaw
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Zagreb
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Zagreb
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Zaporozhye
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Zaporozhye
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe::Zurich
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Europe::Zurich
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Europe
end

module TZInfo::Data::Definitions::Factory
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Factory
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::GB
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::GB
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::GB__m__Eire
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::GB__m__Eire
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::GMT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::GMT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::GMT0
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::GMT0
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::GMT__m__0
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::GMT__m__0
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::GMT__p__0
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::GMT__p__0
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Greenwich
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Greenwich
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::HST
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::HST
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Hongkong
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Hongkong
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Iceland
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Iceland
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian
end

module TZInfo::Data::Definitions::Indian::Antananarivo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Antananarivo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Chagos
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Chagos
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Christmas
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Christmas
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Cocos
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Cocos
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Comoro
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Comoro
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Kerguelen
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Kerguelen
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Mahe
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Mahe
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Maldives
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Maldives
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Mauritius
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Mauritius
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Mayotte
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Mayotte
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian::Reunion
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Indian::Reunion
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Indian
end

module TZInfo::Data::Definitions::Iran
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Iran
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Israel
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Israel
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Jamaica
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Jamaica
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Japan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Japan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Kwajalein
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Kwajalein
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Libya
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Libya
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::MET
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::MET
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::MST
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::MST
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::MST7MDT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::MST7MDT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Mexico
end

module TZInfo::Data::Definitions::Mexico::BajaNorte
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Mexico::BajaNorte
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Mexico::BajaSur
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Mexico::BajaSur
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Mexico::General
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Mexico::General
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Mexico
end

module TZInfo::Data::Definitions::NZ
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::NZ
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::NZ__m__CHAT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::NZ__m__CHAT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Navajo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Navajo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::PRC
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::PRC
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::PST8PDT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::PST8PDT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific
end

module TZInfo::Data::Definitions::Pacific::Apia
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Apia
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Auckland
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Auckland
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Bougainville
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Bougainville
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Chatham
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Chatham
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Chuuk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Chuuk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Easter
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Easter
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Efate
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Efate
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Enderbury
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Enderbury
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Fakaofo
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Fakaofo
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Fiji
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Fiji
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Funafuti
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Funafuti
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Galapagos
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Galapagos
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Gambier
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Gambier
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Guadalcanal
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Guadalcanal
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Guam
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Guam
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Honolulu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Honolulu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Johnston
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Johnston
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Kiritimati
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Kiritimati
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Kosrae
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Kosrae
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Kwajalein
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Kwajalein
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Majuro
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Majuro
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Marquesas
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Marquesas
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Midway
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Midway
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Nauru
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Nauru
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Niue
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Niue
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Norfolk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Norfolk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Noumea
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Noumea
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Pago_Pago
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Pago_Pago
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Palau
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Palau
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Pitcairn
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Pitcairn
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Pohnpei
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Pohnpei
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Ponape
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Ponape
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Port_Moresby
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Port_Moresby
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Rarotonga
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Rarotonga
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Saipan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Saipan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Samoa
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Samoa
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Tahiti
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Tahiti
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Tarawa
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Tarawa
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Tongatapu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Tongatapu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Truk
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Truk
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Wake
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Wake
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Wallis
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Wallis
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific::Yap
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Pacific::Yap
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Pacific
end

module TZInfo::Data::Definitions::Poland
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Poland
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Portugal
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Portugal
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::ROC
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::ROC
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::ROK
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::ROK
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Singapore
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Singapore
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Turkey
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Turkey
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::UCT
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::UCT
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US
end

module TZInfo::Data::Definitions::US::Alaska
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Alaska
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Aleutian
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Aleutian
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Arizona
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Arizona
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Central
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Central
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::East__m__Indiana
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::East__m__Indiana
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Eastern
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Eastern
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Hawaii
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Hawaii
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Indiana__m__Starke
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Indiana__m__Starke
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Michigan
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Michigan
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Mountain
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Mountain
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Pacific
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Pacific
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Pacific__m__New
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Pacific__m__New
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US::Samoa
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::US::Samoa
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::US
end

module TZInfo::Data::Definitions::UTC
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::UTC
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Universal
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Universal
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::WET
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::WET
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::W__m__SU
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::W__m__SU
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions::Zulu
  include ::TZInfo::TimezoneDefinition
end

module TZInfo::Data::Definitions::Zulu
  extend ::TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::Data::Definitions
end

module TZInfo::Data::Indexes
end

module TZInfo::Data::Indexes::Timezones
  include ::TZInfo::TimezoneIndexDefinition
end

module TZInfo::Data::Indexes::Timezones
  extend ::TZInfo::TimezoneIndexDefinition::ClassMethods
end

module TZInfo::Data::Indexes
end

module TZInfo::Data::Version
  FORMAT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TZDATA = ::T.let(nil, ::T.untyped)
end

module TZInfo::Data::Version
end

module TZInfo::Data
end

class TZInfo::DataSource
  def country_codes(); end

  def data_timezone_identifiers(); end

  def linked_timezone_identifiers(); end

  def load_country_info(code); end

  def load_timezone_info(identifier); end

  def timezone_identifiers(); end
end

class TZInfo::DataSource
  def self.create_default_data_source(); end

  def self.get(); end

  def self.set(data_source_or_type, *args); end
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezoneInfo
  def period_for_utc(utc); end

  def periods_for_local(local); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end
end

class TZInfo::DataTimezoneInfo
end

class TZInfo::InfoTimezone
  def info(); end

  def setup(info); end
end

class TZInfo::InfoTimezone
  def self.new(info); end
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezoneInfo
  def initialize(identifier, link_to_identifier); end

  def link_to_identifier(); end
end

class TZInfo::LinkedTimezoneInfo
end

class TZInfo::NoOffsetsDefined
end

class TZInfo::NoOffsetsDefined
end

module TZInfo::OffsetRationals
end

module TZInfo::OffsetRationals
  def self.rational_for_offset(offset); end
end

class TZInfo::PeriodNotFound
end

class TZInfo::PeriodNotFound
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

module TZInfo::RubyCoreSupport
  def self.datetime_new(y=T.unsafe(nil), m=T.unsafe(nil), d=T.unsafe(nil), h=T.unsafe(nil), min=T.unsafe(nil), s=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.datetime_new!(ajd=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.force_encoding(str, encoding); end

  def self.open_file(file_name, mode, opts, &block); end

  def self.rational_new!(numerator, denominator=T.unsafe(nil)); end

  def self.time_nsec(time); end

  def self.time_supports_64bit(); end

  def self.time_supports_negative(); end
end

class TZInfo::RubyCountryInfo
  def initialize(code, name, &block); end
end

class TZInfo::RubyCountryInfo::Zones
  def list(); end

  def timezone(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end
end

class TZInfo::RubyCountryInfo::Zones
end

class TZInfo::RubyCountryInfo
end

class TZInfo::RubyDataSource
end

class TZInfo::RubyDataSource
end

class TZInfo::TimeOrDateTime
  include ::Comparable
  def +(seconds); end

  def -(seconds); end

  def add_with_convert(seconds); end

  def day(); end

  def eql?(todt); end

  def hour(); end

  def initialize(timeOrDateTime); end

  def mday(); end

  def min(); end

  def mon(); end

  def month(); end

  def sec(); end

  def to_datetime(); end

  def to_i(); end

  def to_orig(); end

  def to_time(); end

  def usec(); end

  def year(); end
end

class TZInfo::TimeOrDateTime
  def self.wrap(timeOrDateTime); end
end

class TZInfo::Timezone
  include ::Comparable
  def _dump(limit); end

  def canonical_identifier(); end

  def canonical_zone(); end

  def current_period(); end

  def current_period_and_time(); end

  def current_time_and_period(); end

  def eql?(tz); end

  def friendly_identifier(skip_first_part=T.unsafe(nil)); end

  def identifier(); end

  def local_to_utc(local, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def offsets_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def period_for_local(local, dst=T.unsafe(nil)); end

  def period_for_utc(utc); end

  def periods_for_local(local); end

  def strftime(format, utc=T.unsafe(nil)); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def utc_to_local(utc); end
end

class TZInfo::Timezone
  def self._load(data); end

  def self.all(); end

  def self.all_country_zone_identifiers(); end

  def self.all_country_zones(); end

  def self.all_data_zone_identifiers(); end

  def self.all_data_zones(); end

  def self.all_identifiers(); end

  def self.all_linked_zone_identifiers(); end

  def self.all_linked_zones(); end

  def self.data_source(); end

  def self.default_dst(); end

  def self.default_dst=(value); end

  def self.get(identifier); end

  def self.get_proxies(identifiers); end

  def self.get_proxy(identifier); end

  def self.init_loaded_zones(); end

  def self.new(identifier=T.unsafe(nil)); end

  def self.us_zone_identifiers(); end

  def self.us_zones(); end
end

module TZInfo::TimezoneDefinition
end

module TZInfo::TimezoneDefinition::ClassMethods
  def get(); end

  def linked_timezone(identifier, link_to_identifier); end

  def timezone(identifier); end
end

module TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::TimezoneDefinition
  def self.append_features(base); end
end

module TZInfo::TimezoneIndexDefinition
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
  def data_timezones(); end

  def linked_timezone(identifier); end

  def linked_timezones(); end

  def timezone(identifier); end

  def timezones(); end
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
end

module TZInfo::TimezoneIndexDefinition
  def self.append_features(base); end
end

class TZInfo::TimezoneInfo
  def create_timezone(); end

  def identifier(); end

  def initialize(identifier); end
end

class TZInfo::TimezoneInfo
end

class TZInfo::TimezoneOffset
  def ==(toi); end

  def abbreviation(); end

  def dst?(); end

  def eql?(toi); end

  def initialize(utc_offset, std_offset, abbreviation); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_offset(); end

  def utc_total_offset(); end
end

class TZInfo::TimezoneOffset
end

class TZInfo::TimezonePeriod
  def ==(p); end

  def abbreviation(); end

  def dst?(); end

  def end_transition(); end

  def eql?(p); end

  def initialize(start_transition, end_transition, offset=T.unsafe(nil)); end

  def local_after_start?(local); end

  def local_before_end?(local); end

  def local_end(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_time(); end

  def offset(); end

  def start_transition(); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_after_start?(utc); end

  def utc_before_end?(utc); end

  def utc_end(); end

  def utc_end_time(); end

  def utc_offset(); end

  def utc_start(); end

  def utc_start_time(); end

  def utc_total_offset(); end

  def utc_total_offset_rational(); end

  def valid_for_local?(local); end

  def valid_for_utc?(utc); end

  def zone_identifier(); end
end

class TZInfo::TimezonePeriod
end

class TZInfo::TimezoneProxy
  def transitions_up_to(to, from=T.unsafe(nil)); end
end

class TZInfo::TimezoneProxy
  def self.new(identifier); end
end

class TZInfo::TimezoneTransition
  def ==(tti); end

  def at(); end

  def datetime(); end

  def eql?(tti); end

  def initialize(offset, previous_offset); end

  def local_end(); end

  def local_end_at(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_at(); end

  def local_start_time(); end

  def offset(); end

  def previous_offset(); end

  def time(); end
end

class TZInfo::TimezoneTransition
end

class TZInfo::TimezoneTransitionDefinition
  def denominator(); end

  def initialize(offset, previous_offset, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end

  def numerator_or_time(); end
end

class TZInfo::TimezoneTransitionDefinition
end

class TZInfo::TransitionDataTimezoneInfo
  def offset(id, utc_offset, std_offset, abbreviation); end

  def transition(year, month, offset_id, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end
end

class TZInfo::TransitionDataTimezoneInfo
end

class TZInfo::UnknownTimezone
end

class TZInfo::UnknownTimezone
end

class TZInfo::ZoneinfoCountryInfo
  def initialize(code, name, zones); end
end

class TZInfo::ZoneinfoCountryInfo
end

class TZInfo::ZoneinfoDataSource
  def initialize(zoneinfo_dir=T.unsafe(nil), alternate_iso3166_tab_path=T.unsafe(nil)); end

  def zoneinfo_dir(); end
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoDataSource
  def self.alternate_iso3166_tab_search_path(); end

  def self.alternate_iso3166_tab_search_path=(alternate_iso3166_tab_search_path); end

  def self.process_search_path(path, default); end

  def self.search_path(); end

  def self.search_path=(search_path); end
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoTimezoneInfo
  def initialize(identifier, file_path); end
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
end

module TZInfo
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Terrapin
  OS = ::T.let(nil, ::T.untyped)
end

class Terrapin::CommandLine
  def command(interpolations=T.unsafe(nil)); end

  def command_error_output(); end

  def command_output(); end

  def exit_status(); end

  def initialize(binary, params=T.unsafe(nil), options=T.unsafe(nil)); end

  def output(); end

  def run(interpolations=T.unsafe(nil)); end

  def runner(); end
end

class Terrapin::CommandLine::BackticksRunner
  def call(command, env=T.unsafe(nil), options=T.unsafe(nil)); end

  def supported?(); end
end

class Terrapin::CommandLine::BackticksRunner
  def self.supported?(); end
end

class Terrapin::CommandLine::FakeRunner
  def call(command, env=T.unsafe(nil), options=T.unsafe(nil)); end

  def commands(); end

  def ran?(predicate_command); end

  def supported?(); end
end

class Terrapin::CommandLine::FakeRunner
  def self.supported?(); end
end

class Terrapin::CommandLine::MultiPipe
  def output(); end

  def pipe_options(); end

  def read_and_then(&block); end
end

class Terrapin::CommandLine::MultiPipe
end

class Terrapin::CommandLine::Output
  def error_output(); end

  def initialize(output=T.unsafe(nil), error_output=T.unsafe(nil)); end

  def output(); end
end

class Terrapin::CommandLine::Output
end

class Terrapin::CommandLine::PopenRunner
  def call(command, env=T.unsafe(nil), options=T.unsafe(nil)); end

  def supported?(); end
end

class Terrapin::CommandLine::PopenRunner
  def self.supported?(); end
end

class Terrapin::CommandLine::PosixRunner
  def call(command, env=T.unsafe(nil), options=T.unsafe(nil)); end

  def supported?(); end
end

class Terrapin::CommandLine::PosixRunner
  def self.available?(); end

  def self.supported?(); end
end

class Terrapin::CommandLine::ProcessRunner
  def call(command, env=T.unsafe(nil), options=T.unsafe(nil)); end

  def supported?(); end
end

class Terrapin::CommandLine::ProcessRunner
  def self.available?(); end

  def self.supported?(); end
end

class Terrapin::CommandLine
  def self.environment(); end

  def self.fake!(); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.path(); end

  def self.path=(supplemental_path); end

  def self.runner(); end

  def self.runner=(runner); end

  def self.runner_options(); end

  def self.unfake!(); end
end

class Terrapin::CommandLineError
end

class Terrapin::CommandLineError
end

class Terrapin::CommandNotFoundError
end

class Terrapin::CommandNotFoundError
end

class Terrapin::ExitStatusError
end

class Terrapin::ExitStatusError
end

class Terrapin::InterpolationError
end

class Terrapin::InterpolationError
end

class Terrapin::OSDetector
  def arch(); end

  def java?(); end

  def path_separator(); end

  def unix?(); end

  def windows?(); end
end

class Terrapin::OSDetector
end

module Terrapin
end

class Thor
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Thor::Actions::CreateFile
end

class Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Thor::Actions::EmptyDirectory
end

module Thor::Actions
  def self.included(base); end
end

class Thor::AmbiguousCommandError
end

class Thor::AmbiguousCommandError
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Argument
end

class Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Thor::Command
end

module Thor::CoreExt
end

class Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Thor::CoreExt::HashWithIndifferentAccess
end

module Thor::CoreExt
end

Thor::Correctable = DidYouMean::Correctable

class Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Thor::DynamicCommand
end

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Error
end

class Thor::Error
end

class Thor::Group
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Thor::HiddenCommand
end

class Thor::HiddenCommand
end

Thor::HiddenTask = Thor::HiddenCommand

module Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Thor::Invocation
  def self.included(base); end
end

class Thor::InvocationError
end

class Thor::InvocationError
end

module Thor::LineEditor
end

class Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Thor::LineEditor::Basic
  def self.available?(); end
end

class Thor::LineEditor::Readline
end

class Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Thor::LineEditor::Readline::PathCompletion
end

class Thor::LineEditor::Readline
end

module Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Thor::MalformattedArgumentError
end

class Thor::MalformattedArgumentError
end

class Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Thor::NestedContext
end

class Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Thor::NoKwargSpellChecker
end

class Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Option
  def self.parse(key, value); end
end

class Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  def self.to_switches(options); end
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Thor::RequiredArgumentMissingError
end

class Thor::RequiredArgumentMissingError
end

module Thor::Sandbox
end

module Thor::Sandbox
end

module Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Thor::Shell
end

Thor::Task = Thor::Command

class Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UndefinedCommandError::SpellChecker
end

class Thor::UndefinedCommandError
end

Thor::UndefinedTaskError = Thor::UndefinedCommandError

class Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UnknownArgumentError::SpellChecker
end

class Thor::UnknownArgumentError
end

module Thor::Util
end

module Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Thor
  def self.deprecation_warning(message); end
end

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Cache
  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def values(); end
end

class ThreadSafe::Cache
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::MriCacheBackend
end

class ThreadSafe::NonConcurrentCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end

  def value?(value); end
end

class ThreadSafe::NonConcurrentCacheBackend
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
end

module ThreadSafe::Util
end

module ThreadSafe
end

module Threadsafe
end

module Threadsafe
  def self.const_missing(name); end
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::BuilderTemplate
  def precompiled_postamble(locals); end

  def precompiled_template(locals); end
end

class Tilt::BuilderTemplate
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::Cache
  def clear(); end

  def fetch(*key); end
end

class Tilt::Cache
end

module Tilt::CompiledTemplates
end

module Tilt::CompiledTemplates
end

class Tilt::Dummy
end

class Tilt::Dummy
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::ErubisTemplate
end

class Tilt::ErubisTemplate
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  def [](file); end

  def extensions_for(template_class); end

  def lazy_map(); end

  def new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def register(template_class, *extensions); end

  def register_lazy(class_name, file, *extensions); end

  def registered?(ext); end

  def template_for(file); end

  def template_map(); end

  def templates_for(file); end
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::Mapping
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::RedcarpetTemplate
  def allows_script?(); end

  def generate_renderer(); end
end

class Tilt::RedcarpetTemplate
end

class Tilt::SassTemplate
  def allows_script?(); end
end

Tilt::SassTemplate::Sass = SassC

class Tilt::SassTemplate
end

class Tilt::ScssTemplate
end

class Tilt::ScssTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Tilt::Template
  def basename(suffix=T.unsafe(nil)); end

  def data(); end

  def default_encoding(); end

  def eval_file(); end

  def evaluate(scope, locals, &block); end

  def file(); end

  def initialize(file=T.unsafe(nil), line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def line(); end

  def metadata(); end

  def name(); end

  def options(); end

  def precompiled(local_keys); end

  def precompiled_postamble(local_keys); end

  def precompiled_preamble(local_keys); end

  def precompiled_template(local_keys); end

  def prepare(); end

  def render(scope=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

class Tilt::Template
  def self.default_mime_type(); end

  def self.default_mime_type=(value); end

  def self.metadata(); end
end

module Tilt
  def self.[](file); end

  def self.current_template(); end

  def self.default_mapping(); end

  def self.lazy_map(); end

  def self.new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.prefer(template_class, *extensions); end

  def self.register(template_class, *extensions); end

  def self.register_lazy(class_name, file, *extensions); end

  def self.registered?(ext); end

  def self.template_for(file); end

  def self.templates_for(file); end
end

class Time
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::DateAndTime::Compatibility
  def acts_like_time?(); end

  def ago(seconds); end

  def all_day(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_day(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def end_of_day(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def eql_with_coercion(other); end

  def eql_without_coercion(_); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def in(seconds); end

  def minus_with_coercion(other); end

  def minus_with_duration(other); end

  def minus_without_coercion(other); end

  def minus_without_duration(_); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def sec_fraction(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Time
  def self.===(other); end

  def self.at_with_coercion(*args); end

  def self.at_without_coercion(*_); end

  def self.current(); end

  def self.days_in_month(month, year=T.unsafe(nil)); end

  def self.find_zone(time_zone); end

  def self.find_zone!(time_zone); end

  def self.use_zone(time_zone); end

  def self.zone_default(); end

  def self.zone_default=(zone_default); end

end

class Timing
  include ::Timing::GeneratedAssociationMethods
end

class Timing::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Timing::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Timing::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Timing::GeneratedAssociationMethods
end

module Timing::GeneratedAssociationMethods
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  def to_json(options=T.unsafe(nil)); end
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::GID
  def app(); end

  def model_id(); end

  def model_name(); end

  def params(); end

  def query=(query); end

  def set_params(params); end

  def set_path(path); end

  def set_query(query); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::GID::MissingModelIdError
end

class URI::GID::MissingModelIdError
end

class URI::GID
  def self.create(app, model, params=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.validate_app(app); end
end

class URI::HTTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

  def self.parser(); end

end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module Unicode
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth
  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Unicode
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class Upload
  def _post_process_callbacks(); end

  def _post_process_callbacks?(); end

  def _run_post_process_callbacks(&block); end

  def _run_upload_post_process_callbacks(&block); end

  def _upload_post_process_callbacks(); end

  def _upload_post_process_callbacks?(); end

  def after_add_for_data_associations(); end

  def after_add_for_data_associations=(after_add_for_data_associations); end

  def after_add_for_data_associations?(); end

  def after_remove_for_data_associations(); end

  def after_remove_for_data_associations=(after_remove_for_data_associations); end

  def after_remove_for_data_associations?(); end

  def autosave_associated_records_for_data_associations(*args); end

  def autosave_associated_records_for_job(*args); end

  def autosave_associated_records_for_upload(); end

  def before_add_for_data_associations(); end

  def before_add_for_data_associations=(before_add_for_data_associations); end

  def before_add_for_data_associations?(); end

  def before_remove_for_data_associations(); end

  def before_remove_for_data_associations=(before_remove_for_data_associations); end

  def before_remove_for_data_associations?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def upload=(file); end

  def upload?(); end

  def validate_associated_records_for_data_associations(*args); end
end

class Upload::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Upload::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Upload::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Upload::GeneratedAssociationMethods
  def build_job(*args, &block); end

  def build_upload(*args, &block); end

  def create_job(*args, &block); end

  def create_job!(*args, &block); end

  def create_upload(*args, &block); end

  def create_upload!(*args, &block); end

  def data_association_ids(); end

  def data_association_ids=(ids); end
end

class Upload
  extend ::Paperclip::HasAttachedFile::ClassMethods
  def self._post_process_callbacks(); end

  def self._post_process_callbacks=(val); end

  def self._post_process_callbacks?(); end

  def self._upload_post_process_callbacks(); end

  def self._upload_post_process_callbacks=(val); end

  def self._upload_post_process_callbacks?(); end

  def self.after_add_for_data_associations(); end

  def self.after_add_for_data_associations=(val); end

  def self.after_add_for_data_associations?(); end

  def self.after_remove_for_data_associations(); end

  def self.after_remove_for_data_associations=(val); end

  def self.after_remove_for_data_associations?(); end

  def self.before_add_for_data_associations(); end

  def self.before_add_for_data_associations=(val); end

  def self.before_add_for_data_associations?(); end

  def self.before_remove_for_data_associations(); end

  def self.before_remove_for_data_associations=(val); end

  def self.before_remove_for_data_associations?(); end
end

class UploadIO
  def content_type(); end

  def initialize(filename_or_io, content_type, filename=T.unsafe(nil), opts=T.unsafe(nil)); end

  def io(); end

  def local_path(); end

  def method_missing(*args); end

  def opts(); end

  def original_filename(); end

  def respond_to?(meth, include_all=T.unsafe(nil)); end
end

class UploadIO
  def self.convert!(io, content_type, original_filename, local_path); end
end

class User
  include ::ActiveModel::SecurePassword::InstanceMethodsOnActivation
  def after_add_for_account(); end

  def after_add_for_account=(after_add_for_account); end

  def after_add_for_account?(); end

  def after_add_for_budgets(); end

  def after_add_for_budgets=(after_add_for_budgets); end

  def after_add_for_budgets?(); end

  def after_add_for_codes(); end

  def after_add_for_codes=(after_add_for_codes); end

  def after_add_for_codes?(); end

  def after_add_for_jobs(); end

  def after_add_for_jobs=(after_add_for_jobs); end

  def after_add_for_jobs?(); end

  def after_add_for_memberships(); end

  def after_add_for_memberships=(after_add_for_memberships); end

  def after_add_for_memberships?(); end

  def after_add_for_parameters(); end

  def after_add_for_parameters=(after_add_for_parameters); end

  def after_add_for_parameters?(); end

  def after_add_for_plans(); end

  def after_add_for_plans=(after_add_for_plans); end

  def after_add_for_plans?(); end

  def after_add_for_samples(); end

  def after_add_for_samples=(after_add_for_samples); end

  def after_add_for_samples?(); end

  def after_add_for_user_budget_associations(); end

  def after_add_for_user_budget_associations=(after_add_for_user_budget_associations); end

  def after_add_for_user_budget_associations?(); end

  def after_remove_for_account(); end

  def after_remove_for_account=(after_remove_for_account); end

  def after_remove_for_account?(); end

  def after_remove_for_budgets(); end

  def after_remove_for_budgets=(after_remove_for_budgets); end

  def after_remove_for_budgets?(); end

  def after_remove_for_codes(); end

  def after_remove_for_codes=(after_remove_for_codes); end

  def after_remove_for_codes?(); end

  def after_remove_for_jobs(); end

  def after_remove_for_jobs=(after_remove_for_jobs); end

  def after_remove_for_jobs?(); end

  def after_remove_for_memberships(); end

  def after_remove_for_memberships=(after_remove_for_memberships); end

  def after_remove_for_memberships?(); end

  def after_remove_for_parameters(); end

  def after_remove_for_parameters=(after_remove_for_parameters); end

  def after_remove_for_parameters?(); end

  def after_remove_for_plans(); end

  def after_remove_for_plans=(after_remove_for_plans); end

  def after_remove_for_plans?(); end

  def after_remove_for_samples(); end

  def after_remove_for_samples=(after_remove_for_samples); end

  def after_remove_for_samples?(); end

  def after_remove_for_user_budget_associations(); end

  def after_remove_for_user_budget_associations=(after_remove_for_user_budget_associations); end

  def after_remove_for_user_budget_associations?(); end

  def autosave_associated_records_for_account(*args); end

  def autosave_associated_records_for_budgets(*args); end

  def autosave_associated_records_for_codes(*args); end

  def autosave_associated_records_for_jobs(*args); end

  def autosave_associated_records_for_memberships(*args); end

  def autosave_associated_records_for_parameters(*args); end

  def autosave_associated_records_for_plans(*args); end

  def autosave_associated_records_for_samples(*args); end

  def autosave_associated_records_for_user_budget_associations(*args); end

  def before_add_for_account(); end

  def before_add_for_account=(before_add_for_account); end

  def before_add_for_account?(); end

  def before_add_for_budgets(); end

  def before_add_for_budgets=(before_add_for_budgets); end

  def before_add_for_budgets?(); end

  def before_add_for_codes(); end

  def before_add_for_codes=(before_add_for_codes); end

  def before_add_for_codes?(); end

  def before_add_for_jobs(); end

  def before_add_for_jobs=(before_add_for_jobs); end

  def before_add_for_jobs?(); end

  def before_add_for_memberships(); end

  def before_add_for_memberships=(before_add_for_memberships); end

  def before_add_for_memberships?(); end

  def before_add_for_parameters(); end

  def before_add_for_parameters=(before_add_for_parameters); end

  def before_add_for_parameters?(); end

  def before_add_for_plans(); end

  def before_add_for_plans=(before_add_for_plans); end

  def before_add_for_plans?(); end

  def before_add_for_samples(); end

  def before_add_for_samples=(before_add_for_samples); end

  def before_add_for_samples?(); end

  def before_add_for_user_budget_associations(); end

  def before_add_for_user_budget_associations=(before_add_for_user_budget_associations); end

  def before_add_for_user_budget_associations?(); end

  def before_remove_for_account(); end

  def before_remove_for_account=(before_remove_for_account); end

  def before_remove_for_account?(); end

  def before_remove_for_budgets(); end

  def before_remove_for_budgets=(before_remove_for_budgets); end

  def before_remove_for_budgets?(); end

  def before_remove_for_codes(); end

  def before_remove_for_codes=(before_remove_for_codes); end

  def before_remove_for_codes?(); end

  def before_remove_for_jobs(); end

  def before_remove_for_jobs=(before_remove_for_jobs); end

  def before_remove_for_jobs?(); end

  def before_remove_for_memberships(); end

  def before_remove_for_memberships=(before_remove_for_memberships); end

  def before_remove_for_memberships?(); end

  def before_remove_for_parameters(); end

  def before_remove_for_parameters=(before_remove_for_parameters); end

  def before_remove_for_parameters?(); end

  def before_remove_for_plans(); end

  def before_remove_for_plans=(before_remove_for_plans); end

  def before_remove_for_plans?(); end

  def before_remove_for_samples(); end

  def before_remove_for_samples=(before_remove_for_samples); end

  def before_remove_for_samples?(); end

  def before_remove_for_user_budget_associations(); end

  def before_remove_for_user_budget_associations=(before_remove_for_user_budget_associations); end

  def before_remove_for_user_budget_associations?(); end

  def password_confirmation(); end

  def validate_associated_records_for_account(*args); end

  def validate_associated_records_for_budgets(*args); end

  def validate_associated_records_for_codes(*args); end

  def validate_associated_records_for_jobs(*args); end

  def validate_associated_records_for_memberships(*args); end

  def validate_associated_records_for_parameters(*args); end

  def validate_associated_records_for_plans(*args); end

  def validate_associated_records_for_samples(*args); end

  def validate_associated_records_for_user_budget_associations(*args); end
end

class User::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class User::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class User::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module User::GeneratedAssociationMethods
  def account_ids(); end

  def account_ids=(ids); end

  def budget_ids(); end

  def budget_ids=(ids); end

  def code_ids(); end

  def code_ids=(ids); end

  def job_ids(); end

  def job_ids=(ids); end

  def membership_ids(); end

  def membership_ids=(ids); end

  def parameter_ids(); end

  def parameter_ids=(ids); end

  def plan_ids(); end

  def plan_ids=(ids); end

  def sample_ids(); end

  def sample_ids=(ids); end

  def user_budget_association_ids(); end

  def user_budget_association_ids=(ids); end
end

class User
  def self.after_add_for_account(); end

  def self.after_add_for_account=(val); end

  def self.after_add_for_account?(); end

  def self.after_add_for_budgets(); end

  def self.after_add_for_budgets=(val); end

  def self.after_add_for_budgets?(); end

  def self.after_add_for_codes(); end

  def self.after_add_for_codes=(val); end

  def self.after_add_for_codes?(); end

  def self.after_add_for_jobs(); end

  def self.after_add_for_jobs=(val); end

  def self.after_add_for_jobs?(); end

  def self.after_add_for_memberships(); end

  def self.after_add_for_memberships=(val); end

  def self.after_add_for_memberships?(); end

  def self.after_add_for_parameters(); end

  def self.after_add_for_parameters=(val); end

  def self.after_add_for_parameters?(); end

  def self.after_add_for_plans(); end

  def self.after_add_for_plans=(val); end

  def self.after_add_for_plans?(); end

  def self.after_add_for_samples(); end

  def self.after_add_for_samples=(val); end

  def self.after_add_for_samples?(); end

  def self.after_add_for_user_budget_associations(); end

  def self.after_add_for_user_budget_associations=(val); end

  def self.after_add_for_user_budget_associations?(); end

  def self.after_remove_for_account(); end

  def self.after_remove_for_account=(val); end

  def self.after_remove_for_account?(); end

  def self.after_remove_for_budgets(); end

  def self.after_remove_for_budgets=(val); end

  def self.after_remove_for_budgets?(); end

  def self.after_remove_for_codes(); end

  def self.after_remove_for_codes=(val); end

  def self.after_remove_for_codes?(); end

  def self.after_remove_for_jobs(); end

  def self.after_remove_for_jobs=(val); end

  def self.after_remove_for_jobs?(); end

  def self.after_remove_for_memberships(); end

  def self.after_remove_for_memberships=(val); end

  def self.after_remove_for_memberships?(); end

  def self.after_remove_for_parameters(); end

  def self.after_remove_for_parameters=(val); end

  def self.after_remove_for_parameters?(); end

  def self.after_remove_for_plans(); end

  def self.after_remove_for_plans=(val); end

  def self.after_remove_for_plans?(); end

  def self.after_remove_for_samples(); end

  def self.after_remove_for_samples=(val); end

  def self.after_remove_for_samples?(); end

  def self.after_remove_for_user_budget_associations(); end

  def self.after_remove_for_user_budget_associations=(val); end

  def self.after_remove_for_user_budget_associations?(); end

  def self.before_add_for_account(); end

  def self.before_add_for_account=(val); end

  def self.before_add_for_account?(); end

  def self.before_add_for_budgets(); end

  def self.before_add_for_budgets=(val); end

  def self.before_add_for_budgets?(); end

  def self.before_add_for_codes(); end

  def self.before_add_for_codes=(val); end

  def self.before_add_for_codes?(); end

  def self.before_add_for_jobs(); end

  def self.before_add_for_jobs=(val); end

  def self.before_add_for_jobs?(); end

  def self.before_add_for_memberships(); end

  def self.before_add_for_memberships=(val); end

  def self.before_add_for_memberships?(); end

  def self.before_add_for_parameters(); end

  def self.before_add_for_parameters=(val); end

  def self.before_add_for_parameters?(); end

  def self.before_add_for_plans(); end

  def self.before_add_for_plans=(val); end

  def self.before_add_for_plans?(); end

  def self.before_add_for_samples(); end

  def self.before_add_for_samples=(val); end

  def self.before_add_for_samples?(); end

  def self.before_add_for_user_budget_associations(); end

  def self.before_add_for_user_budget_associations=(val); end

  def self.before_add_for_user_budget_associations?(); end

  def self.before_remove_for_account(); end

  def self.before_remove_for_account=(val); end

  def self.before_remove_for_account?(); end

  def self.before_remove_for_budgets(); end

  def self.before_remove_for_budgets=(val); end

  def self.before_remove_for_budgets?(); end

  def self.before_remove_for_codes(); end

  def self.before_remove_for_codes=(val); end

  def self.before_remove_for_codes?(); end

  def self.before_remove_for_jobs(); end

  def self.before_remove_for_jobs=(val); end

  def self.before_remove_for_jobs?(); end

  def self.before_remove_for_memberships(); end

  def self.before_remove_for_memberships=(val); end

  def self.before_remove_for_memberships?(); end

  def self.before_remove_for_parameters(); end

  def self.before_remove_for_parameters=(val); end

  def self.before_remove_for_parameters?(); end

  def self.before_remove_for_plans(); end

  def self.before_remove_for_plans=(val); end

  def self.before_remove_for_plans?(); end

  def self.before_remove_for_samples(); end

  def self.before_remove_for_samples=(val); end

  def self.before_remove_for_samples?(); end

  def self.before_remove_for_user_budget_associations(); end

  def self.before_remove_for_user_budget_associations=(val); end

  def self.before_remove_for_user_budget_associations?(); end
end

class UserBudgetAssociation
  def autosave_associated_records_for_budget(*args); end

  def autosave_associated_records_for_user(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class UserBudgetAssociation::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class UserBudgetAssociation::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class UserBudgetAssociation::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module UserBudgetAssociation::GeneratedAssociationMethods
  def build_budget(*args, &block); end

  def build_user(*args, &block); end

  def create_budget(*args, &block); end

  def create_budget!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end
end

class VirtualOperation::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class VirtualOperation::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class VirtualOperation::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

Visitor = Psych::Visitors::Visitor

class WEBrick::AccessLog::AccessLogError
end

class WEBrick::AccessLog::AccessLogError
end

module WEBrick::Config
  BasicAuth = ::T.let(nil, ::T.untyped)
  DigestAuth = ::T.let(nil, ::T.untyped)
  FileHandler = ::T.let(nil, ::T.untyped)
  General = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  LIBDIR = ::T.let(nil, ::T.untyped)
end

module WEBrick::Config
end

WEBrick::HTTPAuth::Authenticator::AuthException = WEBrick::HTTPStatus::Unauthorized

WEBrick::HTTPAuth::ProxyAuthenticator::AuthException = WEBrick::HTTPStatus::ProxyAuthenticationRequired

class WEBrick::HTTPRequest
  def body_reader(); end

  def readpartial(size, buf=T.unsafe(nil)); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end

  def xhr?(); end
  MAX_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPResponse
  def _rack_setup_header(); end

  def rack(); end

  def rack=(rack); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
  def <<(*buf); end

  def initialize(socket, resp); end

  def write(buf); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
end

class WEBrick::HTTPResponse::InvalidHeader
end

class WEBrick::HTTPResponse::InvalidHeader
end

class WEBrick::HTTPServer
  def create_request(with_webrick_config); end

  def create_response(with_webrick_config); end
end

class WEBrick::HTTPServerError
end

class WEBrick::HTTPServerError
end

class WEBrick::HTTPServlet::DefaultFileHandler
  def multipart_body(body, parts, boundary, mtype, filesize); end
end

class WEBrick::HTTPServlet::HTTPServletError
end

class WEBrick::HTTPServlet::HTTPServletError
end

class WEBrick::HTTPStatus::EOFError
end

class WEBrick::HTTPStatus::EOFError
end

class WEBrick::ServerError
end

class WEBrick::ServerError
end

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

module WebConsole
  def logger(); end

  def logger=(obj); end
end

class WebConsole::DoubleRenderError
end

class WebConsole::DoubleRenderError
end

class WebConsole::Error
end

class WebConsole::Error
end

class WebConsole::Evaluator
  def cleaner(); end

  def eval(input); end

  def initialize(binding=T.unsafe(nil)); end
end

class WebConsole::Evaluator
  def self.cleaner(); end
end

class WebConsole::ExceptionMapper
  def [](index); end

  def first(); end

  def initialize(exception); end
end

class WebConsole::ExceptionMapper
end

class WebConsole::Middleware
  def call(env); end

  def initialize(app); end

  def mount_point(); end

  def mount_point=(obj); end

  def whiny_requests(); end

  def whiny_requests=(obj); end
  TEMPLATES_PATH = ::T.let(nil, ::T.untyped)
end

class WebConsole::Middleware
  def self.mount_point(); end

  def self.mount_point=(obj); end

  def self.whiny_requests(); end

  def self.whiny_requests=(obj); end
end

class WebConsole::Railtie
end

class WebConsole::Railtie
end

class WebConsole::Request
  def acceptable?(); end

  def from_whitelisted_ip?(); end

  def strict_remote_ip(); end

  def whitelisted_ips(); end

  def whitelisted_ips=(obj); end
end

class WebConsole::Request::GetSecureIp
  def initialize(req, proxies); end
end

class WebConsole::Request::GetSecureIp
end

class WebConsole::Request
  def self.whitelisted_ips(); end

  def self.whitelisted_ips=(obj); end
end

class WebConsole::Response
  def finish(); end

  def write(content); end
end

class WebConsole::Response
end

class WebConsole::Session
  def eval(input); end

  def id(); end

  def initialize(bindings); end

  def inmemory_storage(); end

  def switch_binding_to(index); end
end

class WebConsole::Session
  def self.find(id); end

  def self.from(storage); end

  def self.inmemory_storage(); end
end

class WebConsole::Template
  def initialize(env, session); end

  def render(template); end

  def template_paths(); end

  def template_paths=(obj); end
end

class WebConsole::Template
  def self.template_paths(); end

  def self.template_paths=(obj); end
end

class WebConsole::View
  def only_on_error_page(*args); end

  def render(*_); end

  def render_inlined_string(template); end

  def render_javascript(template); end
end

class WebConsole::View
end

class WebConsole::WhinyRequest
  def from_whitelisted_ip?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class WebConsole::WhinyRequest
end

class WebConsole::Whitelist
  def include?(network); end

  def initialize(networks=T.unsafe(nil)); end
  ALWAYS_WHITELISTED_NETWORKS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Whitelist
end

module WebConsole
  extend ::ActiveSupport::Autoload
  def self.caller_bindings(); end

  def self.logger(); end

  def self.logger=(obj); end
end

module WillPaginate
end

module WillPaginate::ActionView
  include ::WillPaginate::ViewHelpers
  include ::WillPaginate::I18n
  def infer_collection_from_controller(); end

  def page_entries_info(collection=T.unsafe(nil), options=T.unsafe(nil)); end

  def paginated_section(*args, &block); end

  def will_paginate(collection=T.unsafe(nil), options=T.unsafe(nil)); end

  def will_paginate_translate(keys, options=T.unsafe(nil)); end
end

module WillPaginate::ActionView
end

module WillPaginate::ActiveRecord
end

module WillPaginate::ActiveRecord::BaseMethods
  def paginate_by_sql(sql, options); end
end

module WillPaginate::ActiveRecord::BaseMethods
end

module WillPaginate::ActiveRecord::Pagination
  def page(num); end

  def paginate(options); end
end

module WillPaginate::ActiveRecord::Pagination
end

module WillPaginate::ActiveRecord::RelationMethods
  include ::WillPaginate::CollectionMethods
  def clone(); end

  def count(*args); end

  def current_page(); end

  def current_page=(current_page); end

  def empty?(); end

  def find_last(*args); end

  def first(*args); end

  def limit(num); end

  def offset(value=T.unsafe(nil)); end

  def per_page(value=T.unsafe(nil)); end

  def scoped(options=T.unsafe(nil)); end

  def size(); end

  def to_a(); end

  def total_entries(); end

  def total_entries=(total_entries); end
end

module WillPaginate::ActiveRecord::RelationMethods
end

module WillPaginate::ActiveRecord
end

class WillPaginate::Collection
  include ::WillPaginate::CollectionMethods
  def current_page(); end

  def initialize(page, per_page=T.unsafe(nil), total=T.unsafe(nil)); end

  def offset(); end

  def per_page(); end

  def replace(array); end

  def total_entries(); end

  def total_entries=(number); end
end

class WillPaginate::Collection
  def self.create(page, per_page, total=T.unsafe(nil)); end
end

module WillPaginate::CollectionMethods
  def next_page(); end

  def out_of_bounds?(); end

  def previous_page(); end

  def total_pages(); end
end

module WillPaginate::CollectionMethods
end

module WillPaginate::Deprecation
end

class WillPaginate::Deprecation::Hash
  def []=(key, value); end

  def deprecate_key(*keys, &block); end

  def initialize(values=T.unsafe(nil)); end

  def merge(another); end
end

class WillPaginate::Deprecation::Hash
end

module WillPaginate::Deprecation
  def self.warn(message, stack=T.unsafe(nil)); end
end

module WillPaginate::I18n
  def will_paginate_translate(keys, options=T.unsafe(nil), &block); end
end

module WillPaginate::I18n
  def self.load_path(); end

  def self.locale_dir(); end
end

module WillPaginate::InvalidPage
end

module WillPaginate::InvalidPage
end

class WillPaginate::PageNumber
  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def /(*args, &block); end

  def ==(*args, &block); end

  def coerce(*args, &block); end

  def initialize(value, name); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def to_i(); end

  def to_json(*args, &block); end

  def to_offset(per_page); end

  def to_s(*args, &block); end
  BIGINT = ::T.let(nil, ::T.untyped)
end

class WillPaginate::PageNumber
  extend ::Forwardable
end

module WillPaginate::PerPage
  def per_page(); end

  def per_page=(limit); end
end

module WillPaginate::PerPage::Inheritance
  def inherited(subclass); end
end

module WillPaginate::PerPage::Inheritance
end

module WillPaginate::PerPage
  def self.extended(base); end
end

class WillPaginate::Railtie
end

module WillPaginate::Railtie::ControllerRescuePatch
  def rescue_from(*args, **kwargs, &block); end
end

module WillPaginate::Railtie::ControllerRescuePatch
end

module WillPaginate::Railtie::ShowExceptionsPatch
  def status_code_with_paginate(exception=T.unsafe(nil)); end
end

module WillPaginate::Railtie::ShowExceptionsPatch
  extend ::ActiveSupport::Concern
end

class WillPaginate::Railtie
  def self.setup_actioncontroller(); end
end

module WillPaginate::ViewHelpers
  include ::WillPaginate::I18n
  def page_entries_info(collection, options=T.unsafe(nil)); end

  def will_paginate(collection, options=T.unsafe(nil)); end
end

module WillPaginate::ViewHelpers
  def self.pagination_options(); end

  def self.pagination_options=(pagination_options); end
end

module WillPaginate
  extend ::WillPaginate::PerPage
  def self.PageNumber(value, name=T.unsafe(nil)); end
end

class Wire
  def autosave_associated_records_for_from(*args); end

  def autosave_associated_records_for_to(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

class Wire::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Wire::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Wire::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

module Wire::GeneratedAssociationMethods
  def build_from(*args, &block); end

  def build_to(*args, &block); end

  def create_from(*args, &block); end

  def create_from!(*args, &block); end

  def create_to(*args, &block); end

  def create_to!(*args, &block); end
end

class Wizard
  def after_add_for_locators(); end

  def after_add_for_locators=(after_add_for_locators); end

  def after_add_for_locators?(); end

  def after_remove_for_locators(); end

  def after_remove_for_locators=(after_remove_for_locators); end

  def after_remove_for_locators?(); end

  def autosave_associated_records_for_locators(*args); end

  def before_add_for_locators(); end

  def before_add_for_locators=(before_add_for_locators); end

  def before_add_for_locators?(); end

  def before_remove_for_locators(); end

  def before_remove_for_locators=(before_remove_for_locators); end

  def before_remove_for_locators?(); end

  def validate_associated_records_for_locators(*args); end
end

class Wizard::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Wizard::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
end

class Wizard::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  def name(*args, &block); end
end

module Wizard::GeneratedAssociationMethods
  def locator_ids(); end

  def locator_ids=(ids); end
end

class Wizard
  def self.after_add_for_locators(); end

  def self.after_add_for_locators=(val); end

  def self.after_add_for_locators?(); end

  def self.after_remove_for_locators(); end

  def self.after_remove_for_locators=(val); end

  def self.after_remove_for_locators?(); end

  def self.before_add_for_locators(); end

  def self.before_add_for_locators=(val); end

  def self.before_add_for_locators?(); end

  def self.before_remove_for_locators(); end

  def self.before_remove_for_locators=(val); end

  def self.before_remove_for_locators?(); end
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

module YARD
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  TEMPLATE_ROOT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module YARD::CLI
end

class YARD::CLI::Command
  def common_options(opts); end

  def description(); end

  def load_script(file); end

  def parse_options(opts, args); end

  def unrecognized_option(err); end
end

class YARD::CLI::Command
  def self.run(*args); end
end

class YARD::CLI::CommandParser
  def run(*args); end
end

class YARD::CLI::CommandParser
  def self.commands(); end

  def self.commands=(commands); end

  def self.default_command(); end

  def self.default_command=(default_command); end

  def self.run(*args); end
end

class YARD::CLI::Config
  def append(); end

  def append=(append); end

  def as_list(); end

  def as_list=(as_list); end

  def gem_install_cmd(); end

  def gem_install_cmd=(gem_install_cmd); end

  def key(); end

  def key=(key); end

  def reset(); end

  def reset=(reset); end

  def run(*args); end

  def values(); end

  def values=(values); end
end

class YARD::CLI::Config
end

class YARD::CLI::Diff
  def run(*args); end
end

class YARD::CLI::Diff
end

class YARD::CLI::Display
  def format_objects(); end

  def initialize(*args); end

  def wrap_layout(contents); end
end

class YARD::CLI::Display
end

class YARD::CLI::Gems
  def run(*args); end
end

class YARD::CLI::Gems
end

class YARD::CLI::Graph
  def objects(); end

  def options(); end

  def run(*args); end
end

class YARD::CLI::Graph
end

class YARD::CLI::Help
  def run(*args); end
end

class YARD::CLI::Help
end

class YARD::CLI::I18n
end

class YARD::CLI::I18n
end

class YARD::CLI::List
  def run(*args); end
end

class YARD::CLI::List
end

class YARD::CLI::MarkupTypes
  def run(*args); end
end

class YARD::CLI::MarkupTypes
end

class YARD::CLI::Server
  def adapter(); end

  def adapter=(adapter); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def run(*args); end

  def scripts(); end

  def scripts=(scripts); end

  def server_options(); end

  def server_options=(server_options); end

  def template_paths(); end

  def template_paths=(template_paths); end
end

class YARD::CLI::Server
end

class YARD::CLI::Stats
  include ::YARD::Templates::Helpers::BaseHelper
  def initialize(parse=T.unsafe(nil)); end

  def output(name, data, undoc=T.unsafe(nil)); end

  def parse(); end

  def parse=(parse); end

  def print_statistics(); end

  def print_undocumented_objects(); end

  def stats_for_attributes(); end

  def stats_for_classes(); end

  def stats_for_constants(); end

  def stats_for_files(); end

  def stats_for_methods(); end

  def stats_for_modules(); end
  STATS_ORDER = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Stats
end

class YARD::CLI::YRI
  def cache_object(name, path); end

  def find_object(name); end

  def print_object(object); end

  def print_usage(); end

  def run(*args); end
  CACHE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  SEARCH_PATHS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YRI
end

class YARD::CLI::Yardoc
  def all_objects(); end

  def apis(); end

  def apis=(apis); end

  def assets(); end

  def assets=(assets); end

  def excluded(); end

  def excluded=(excluded); end

  def fail_on_warning(); end

  def fail_on_warning=(fail_on_warning); end

  def files(); end

  def files=(files); end

  def generate(); end

  def generate=(generate); end

  def has_markup(); end

  def has_markup=(has_markup); end

  def hidden_apis(); end

  def hidden_apis=(hidden_apis); end

  def hidden_tags(); end

  def hidden_tags=(hidden_tags); end

  def list(); end

  def list=(list); end

  def options(); end

  def run(*args); end

  def save_yardoc(); end

  def save_yardoc=(save_yardoc); end

  def statistics(); end

  def statistics=(statistics); end

  def use_cache(); end

  def use_cache=(use_cache); end

  def visibilities(); end

  def visibilities=(visibilities); end
end

class YARD::CLI::Yardoc
end

class YARD::CLI::YardocOptions
  def file(); end

  def file=(file); end

  def files(); end

  def files=(files); end

  def item(); end

  def item=(item); end

  def locale(); end

  def locale=(locale); end

  def objects(); end

  def objects=(objects); end

  def onefile(); end

  def onefile=(onefile); end

  def readme(); end

  def readme=(readme); end

  def title(); end

  def title=(title); end
end

class YARD::CLI::YardocOptions
end

class YARD::CLI::YardoptsCommand
  def options_file(); end

  def options_file=(options_file); end

  def parse_arguments(*args); end

  def use_document_file(); end

  def use_document_file=(use_document_file); end

  def use_yardopts_file(); end

  def use_yardopts_file=(use_yardopts_file); end

  def yardopts_options(opts); end
  DEFAULT_YARDOPTS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YardoptsCommand
end

module YARD::CLI
end

module YARD::CodeObjects
  BUILTIN_ALL = ::T.let(nil, ::T.untyped)
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS_HASH = ::T.let(nil, ::T.untyped)
  BUILTIN_MODULES = ::T.let(nil, ::T.untyped)
  CONSTANTMATCH = ::T.let(nil, ::T.untyped)
  CONSTANTSTART = ::T.let(nil, ::T.untyped)
  CSEP = ::T.let(nil, ::T.untyped)
  CSEPQ = ::T.let(nil, ::T.untyped)
  ISEP = ::T.let(nil, ::T.untyped)
  ISEPQ = ::T.let(nil, ::T.untyped)
  METHODMATCH = ::T.let(nil, ::T.untyped)
  METHODNAMEMATCH = ::T.let(nil, ::T.untyped)
  NAMESPACEMATCH = ::T.let(nil, ::T.untyped)
  NSEP = ::T.let(nil, ::T.untyped)
  NSEPQ = ::T.let(nil, ::T.untyped)
  PROXY_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::Base
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def add_file(file, line=T.unsafe(nil), has_comments=T.unsafe(nil)); end

  def add_tag(*tags); end

  def base_docstring(); end

  def copy_to(other); end

  def copyable_attributes(); end

  def docstring(locale=T.unsafe(nil)); end

  def docstring=(comments); end

  def dynamic(); end

  def dynamic=(dynamic); end

  def dynamic?(); end

  def eql?(other); end

  def equal?(other); end

  def file(); end

  def files(); end

  def format(options=T.unsafe(nil)); end

  def group(); end

  def group=(group); end

  def has_tag?(name); end

  def initialize(namespace, name, *_); end

  def line(); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def namespace=(obj); end

  def parent(); end

  def parent=(obj); end

  def path(); end

  def relative_path(other); end

  def root?(); end

  def sep(); end

  def signature(); end

  def signature=(signature); end

  def source(); end

  def source=(statement); end

  def source_type(); end

  def source_type=(source_type); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def title(); end

  def to_ary(); end

  def type(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::CodeObjects::Base
  def self.===(other); end

  def self.new(namespace, name, *args, &block); end
end

class YARD::CodeObjects::ClassObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end

  def inherited_constants(); end

  def inherited_meths(opts=T.unsafe(nil)); end

  def is_exception?(); end

  def superclass(); end

  def superclass=(object); end
end

class YARD::CodeObjects::ClassObject
end

class YARD::CodeObjects::ClassVariableObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ClassVariableObject
end

class YARD::CodeObjects::CodeObjectList
  def <<(value); end

  def initialize(owner=T.unsafe(nil)); end

  def push(value); end
end

class YARD::CodeObjects::CodeObjectList
end

class YARD::CodeObjects::ConstantObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ConstantObject
end

class YARD::CodeObjects::ExtendedMethodObject
  def initialize(obj); end

  def method_missing(sym, *args, &block); end

  def scope(); end
end

class YARD::CodeObjects::ExtendedMethodObject
end

class YARD::CodeObjects::ExtraFileObject
  def ==(other); end

  def attributes(); end

  def attributes=(attributes); end

  def contents(); end

  def contents=(contents); end

  def eql?(other); end

  def equal?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(filename, contents=T.unsafe(nil)); end

  def locale(); end

  def locale=(locale); end

  def name(); end

  def name=(name); end

  def path(); end

  def title(); end

  def type(); end
end

class YARD::CodeObjects::ExtraFileObject
end

class YARD::CodeObjects::MacroObject
  def attached?(); end

  def expand(call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def macro_data(); end

  def macro_data=(macro_data); end

  def method_object(); end

  def method_object=(method_object); end
  MACRO_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::MacroObject
  def self.apply(docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil), _method_object=T.unsafe(nil)); end

  def self.apply_macro(macro, docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.create(macro_name, data, method_object=T.unsafe(nil)); end

  def self.create_docstring(macro_name, data, method_object=T.unsafe(nil)); end

  def self.expand(macro_data, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.find(macro_name); end

  def self.find_or_create(macro_name, data, method_object=T.unsafe(nil)); end
end

class YARD::CodeObjects::MethodObject
  def aliases(); end

  def attr_info(); end

  def constructor?(); end

  def explicit(); end

  def explicit=(explicit); end

  def initialize(namespace, name, scope=T.unsafe(nil), &block); end

  def is_alias?(); end

  def is_attribute?(); end

  def is_explicit?(); end

  def module_function?(); end

  def overridden_method(); end

  def parameters(); end

  def parameters=(parameters); end

  def reader?(); end

  def scope(); end

  def scope=(v); end

  def writer?(); end
end

class YARD::CodeObjects::MethodObject
end

class YARD::CodeObjects::ModuleObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end
end

class YARD::CodeObjects::ModuleObject
end

module YARD::CodeObjects::NamespaceMapper
  def clear_separators(); end

  def default_separator(value=T.unsafe(nil)); end

  def register_separator(sep, *valid_types); end

  def separators(); end

  def separators_for_type(type); end

  def separators_match(); end

  def types_for_separator(sep); end
end

module YARD::CodeObjects::NamespaceMapper
  def self.default_separator(); end

  def self.default_separator=(default_separator); end

  def self.invalidate(); end

  def self.map(); end

  def self.map_match(); end

  def self.rev_map(); end
end

class YARD::CodeObjects::NamespaceObject
  def aliases(); end

  def attributes(); end

  def child(opts=T.unsafe(nil)); end

  def children(); end

  def class_attributes(); end

  def class_mixins(); end

  def constants(opts=T.unsafe(nil)); end

  def cvars(); end

  def groups(); end

  def groups=(groups); end

  def included_constants(); end

  def included_meths(opts=T.unsafe(nil)); end

  def initialize(namespace, name, *args, &block); end

  def instance_attributes(); end

  def instance_mixins(); end

  def meths(opts=T.unsafe(nil)); end

  def mixins(*scopes); end
end

class YARD::CodeObjects::NamespaceObject
end

class YARD::CodeObjects::Proxy
  def ==(other); end

  def ===(other); end

  def equal?(other); end

  def initialize(namespace, name, type=T.unsafe(nil)); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def parent(); end

  def path(); end

  def respond_to?(meth, include_private=T.unsafe(nil)); end

  def root?(); end

  def title(); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class YARD::CodeObjects::Proxy
  def self.===(other); end
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::RootObject
end

class YARD::CodeObjects::RootObject
end

module YARD::CodeObjects
  extend ::YARD::CodeObjects::NamespaceMapper
end

class YARD::Config
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  CONFIG_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG_OPTIONS = ::T.let(nil, ::T.untyped)
  IGNORED_PLUGINS = ::T.let(nil, ::T.untyped)
  YARD_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class YARD::Config
  def self.add_ignored_plugins_file(); end

  def self.arguments(); end

  def self.load(); end

  def self.load_autoload_plugins(); end

  def self.load_commandline_plugins(); end

  def self.load_commandline_safemode(); end

  def self.load_gem_plugins(); end

  def self.load_plugin(name); end

  def self.load_plugin_failed(name, exception); end

  def self.load_plugins(); end

  def self.options(); end

  def self.options=(options); end

  def self.read_config_file(); end

  def self.save(); end

  def self.translate_plugin_name(name); end

  def self.translate_plugin_names(); end

  def self.with_yardopts(); end
end

class YARD::Docstring
  def +(other); end

  def add_tag(*tags); end

  def all(); end

  def all=(content, parse=T.unsafe(nil)); end

  def blank?(only_visible_tags=T.unsafe(nil)); end

  def delete_tag_if(&block); end

  def delete_tags(name); end

  def has_tag?(name); end

  def hash_flag(); end

  def hash_flag=(v); end

  def initialize(content=T.unsafe(nil), object=T.unsafe(nil)); end

  def line(); end

  def line_range(); end

  def line_range=(line_range); end

  def object(); end

  def object=(object); end

  def ref_tags(); end

  def replace(content, parse=T.unsafe(nil)); end

  def resolve_reference(); end

  def summary(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def to_raw(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Docstring
  def self.default_parser(); end

  def self.default_parser=(default_parser); end

  def self.new!(text, tags=T.unsafe(nil), object=T.unsafe(nil), raw_data=T.unsafe(nil), ref_object=T.unsafe(nil)); end

  def self.parser(*args); end
end

class YARD::DocstringParser
  def create_directive(tag_name, tag_buf); end

  def create_ref_tag(tag_name, name, object_name); end

  def create_tag(tag_name, tag_buf=T.unsafe(nil)); end

  def directives(); end

  def directives=(directives); end

  def handler(); end

  def handler=(handler); end

  def initialize(library=T.unsafe(nil)); end

  def library(); end

  def library=(library); end

  def object(); end

  def object=(object); end

  def parse(content, object=T.unsafe(nil), handler=T.unsafe(nil)); end

  def parse_content(content); end

  def post_process(); end

  def raw_text(); end

  def raw_text=(raw_text); end

  def reference(); end

  def reference=(reference); end

  def state(); end

  def state=(state); end

  def tag_is_directive?(tag_name); end

  def tags(); end

  def tags=(tags); end

  def text(); end

  def text=(text); end

  def to_docstring(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::DocstringParser
  def self.after_parse(&block); end

  def self.after_parse_callbacks(); end
end

module YARD::GemIndex
end

module YARD::GemIndex
  def self.all(); end

  def self.each(&block); end

  def self.find_all_by_name(*args); end
end

module YARD::Handlers
end

class YARD::Handlers::Base
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def abort!(); end

  def call_params(); end

  def caller_method(); end

  def ensure_loaded!(object, max_retries=T.unsafe(nil)); end

  def extra_state(); end

  def globals(); end

  def initialize(source_parser, stmt); end

  def namespace(); end

  def namespace=(v); end

  def owner(); end

  def owner=(v); end

  def parse_block(*_); end

  def parser(); end

  def process(); end

  def push_state(opts=T.unsafe(nil)); end

  def register(*objects); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end

  def register_dynamic(object); end

  def register_ensure_loaded(object); end

  def register_file_info(object, file=T.unsafe(nil), line=T.unsafe(nil), comments=T.unsafe(nil)); end

  def register_group(object, group=T.unsafe(nil)); end

  def register_module_function(object); end

  def register_source(object, source=T.unsafe(nil), type=T.unsafe(nil)); end

  def register_transitive_tags(object); end

  def register_visibility(object, visibility=T.unsafe(nil)); end

  def scope(); end

  def scope=(v); end

  def statement(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::Handlers::Base
  def self.clear_subclasses(); end

  def self.handlers(); end

  def self.handles(*matches); end

  def self.handles?(statement); end

  def self.in_file(filename); end

  def self.inherited(subclass); end

  def self.matches_file?(filename); end

  def self.namespace_only(); end

  def self.namespace_only?(); end

  def self.process(&block); end
end

module YARD::Handlers::C
end

class YARD::Handlers::C::AliasHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AliasHandler
end

class YARD::Handlers::C::AttributeHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AttributeHandler
end

class YARD::Handlers::C::Base
  include ::YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::Handlers::Common::MethodHandler
  def ensure_variable_defined!(var, max_retries=T.unsafe(nil)); end

  def namespace_for_variable(var); end

  def namespaces(); end

  def override_comments(); end

  def parse_block(opts=T.unsafe(nil)); end

  def process_file(file, object); end

  def processed_files(); end

  def symbols(); end
end

class YARD::Handlers::C::Base
  def self.handles?(statement, processor); end

  def self.statement_class(type=T.unsafe(nil)); end
end

class YARD::Handlers::C::ClassHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ClassHandler
end

class YARD::Handlers::C::ConstantHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ConstantHandler
end

module YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::CodeObjects
  include ::YARD::Handlers::Common::MethodHandler
  def handle_alias(var_name, new_name, old_name); end

  def handle_attribute(var_name, name, read, write); end

  def handle_class(var_name, class_name, parent, in_module=T.unsafe(nil)); end

  def handle_constants(type, var_name, const_name, value); end

  def handle_method(scope, var_name, name, func_name, _source_file=T.unsafe(nil)); end

  def handle_module(var_name, module_name, in_module=T.unsafe(nil)); end
end

module YARD::Handlers::C::HandlerMethods
end

class YARD::Handlers::C::InitHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::InitHandler
end

class YARD::Handlers::C::MethodHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
  MATCH3 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MethodHandler
end

class YARD::Handlers::C::MixinHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MixinHandler
end

class YARD::Handlers::C::ModuleHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ModuleHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::PathHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::PathHandler
end

class YARD::Handlers::C::StructHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::StructHandler
end

class YARD::Handlers::C::SymbolHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::SymbolHandler
end

module YARD::Handlers::C
end

module YARD::Handlers::Common
end

module YARD::Handlers::Common::MethodHandler
  def add_predicate_return_tag(obj); end
end

module YARD::Handlers::Common::MethodHandler
end

module YARD::Handlers::Common
end

class YARD::Handlers::HandlerAborted
end

class YARD::Handlers::HandlerAborted
end

class YARD::Handlers::NamespaceMissingError
  def initialize(object); end

  def object(); end

  def object=(object); end
end

class YARD::Handlers::NamespaceMissingError
end

class YARD::Handlers::Processor
  def extra_state(); end

  def extra_state=(extra_state); end

  def file(); end

  def file=(file); end

  def find_handlers(statement); end

  def globals(); end

  def globals=(globals); end

  def initialize(parser); end

  def namespace(); end

  def namespace=(namespace); end

  def owner(); end

  def owner=(owner); end

  def parse_remaining_files(); end

  def parser_type(); end

  def parser_type=(parser_type); end

  def process(statements); end

  def scope(); end

  def scope=(scope); end

  def visibility(); end

  def visibility=(visibility); end
end

class YARD::Handlers::Processor
  def self.namespace_for_handler(); end

  def self.register_handler_namespace(type, ns); end
end

module YARD::Handlers::Ruby
end

module YARD::Handlers::Ruby::ActiveRecord
end

module YARD::Handlers::Ruby::ActiveRecord::Associations
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::Base
  def group_name(); end
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::Base
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::BelongsToHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::BelongsToHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::HasAndBelongsToManyHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::HasAndBelongsToManyHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::HasManyHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::HasManyHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::HasOneHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::HasOneHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::PluralHandler
  def class_name(); end
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::PluralHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::SingularHandler
  def class_name(); end
end

class YARD::Handlers::Ruby::ActiveRecord::Associations::SingularHandler
end

module YARD::Handlers::Ruby::ActiveRecord::Associations
end

module YARD::Handlers::Ruby::ActiveRecord::Delegations
end

class YARD::Handlers::Ruby::ActiveRecord::Delegations::DelegateHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Delegations::DelegateHandler
end

module YARD::Handlers::Ruby::ActiveRecord::Delegations
end

module YARD::Handlers::Ruby::ActiveRecord::Fields
end

class YARD::Handlers::Ruby::ActiveRecord::Fields::CreateTableHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Fields::CreateTableHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Fields::DefineHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Fields::DefineHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Fields::FieldHandler
  def description(method_name); end

  def get_tag(tag, text, return_classes); end
end

class YARD::Handlers::Ruby::ActiveRecord::Fields::FieldHandler
end

module YARD::Handlers::Ruby::ActiveRecord::Fields
end

module YARD::Handlers::Ruby::ActiveRecord::Scopes
end

class YARD::Handlers::Ruby::ActiveRecord::Scopes::ScopeHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Scopes::ScopeHandler
end

module YARD::Handlers::Ruby::ActiveRecord::Scopes
end

module YARD::Handlers::Ruby::ActiveRecord::Validate
  STANDARD_LINKS = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::ActiveRecord::Validate::ValidatesHandler
end

class YARD::Handlers::Ruby::ActiveRecord::Validate::ValidatesHandler
end

module YARD::Handlers::Ruby::ActiveRecord::Validate
  def self.add_validation_type(type, link); end

  def self.link_for_validation(type); end
end

module YARD::Handlers::Ruby::ActiveRecord
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AttributeHandler
  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::AttributeHandler
end

class YARD::Handlers::Ruby::Base
  include ::YARD::Parser::Ruby
  def parse_block(inner_node, opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Base
  extend ::YARD::Parser::Ruby
  def self.handles?(node); end

  def self.meta_type(type); end

  def self.method_call(name=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
end

class YARD::Handlers::Ruby::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ClassHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ConstantHandler
end

class YARD::Handlers::Ruby::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::DSLHandler
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def handle_comments(); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end
  IGNORE_METHODS = ::T.let(nil, ::T.untyped)
end

module YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::HandlesExtension
  def initialize(name); end

  def matches?(node); end

  def name(); end
end

class YARD::Handlers::Ruby::HandlesExtension
end

module YARD::Handlers::Ruby::Legacy
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  def parse_block(opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Legacy::Base
  def self.handles?(stmt); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

module YARD::Handlers::Ruby::Legacy
end

class YARD::Handlers::Ruby::MethodCallWrapper
end

class YARD::Handlers::Ruby::MethodCallWrapper
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodHandler
  include ::YARD::Handlers::Common::MethodHandler
  def format_args(); end

  def method_signature(); end
end

class YARD::Handlers::Ruby::MethodHandler
end

class YARD::Handlers::Ruby::MixinHandler
  def process_mixin(mixin); end
end

class YARD::Handlers::Ruby::MixinHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
end

module YARD::Handlers::Ruby::StructHandlerMethods
  include ::YARD::CodeObjects
  def add_reader_tags(klass, new_method, member); end

  def add_writer_tags(klass, new_method, member); end

  def create_attributes(klass, members); end

  def create_class(classname, superclass); end

  def create_member_method?(klass, member, type=T.unsafe(nil)); end

  def create_reader(klass, member); end

  def create_writer(klass, member); end

  def member_tag_for_member(klass, member, type=T.unsafe(nil)); end

  def members_from_tags(klass); end

  def return_type_from_tag(member_tag); end
end

module YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::TestNodeWrapper
end

class YARD::Handlers::Ruby::TestNodeWrapper
end

class YARD::Handlers::Ruby::VisibilityHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

module YARD::Handlers::Ruby
end

module YARD::Handlers
end

module YARD::I18n
end

class YARD::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class YARD::I18n::Locale
  def self.default(); end

  def self.default=(locale); end
end

class YARD::I18n::Message
  def ==(other); end

  def add_comment(comment); end

  def add_location(path, line); end

  def comments(); end

  def id(); end

  def initialize(id); end

  def locations(); end
end

class YARD::I18n::Message
end

class YARD::I18n::Messages
  include ::Enumerable
  def ==(other); end

  def [](id); end

  def each(&block); end

  def messages(); end

  def register(id); end
end

class YARD::I18n::Messages
end

class YARD::I18n::PotGenerator
  def generate(); end

  def initialize(relative_base_path); end

  def messages(); end

  def parse_files(files); end

  def parse_objects(objects); end
end

class YARD::I18n::PotGenerator
end

class YARD::I18n::Text
  def extract_messages(); end

  def initialize(input, options=T.unsafe(nil)); end

  def translate(locale); end
end

class YARD::I18n::Text
end

module YARD::I18n
end

class YARD::Logger
  def <<(msg=T.unsafe(nil)); end

  def backtrace(exc, level_meth=T.unsafe(nil)); end

  def capture(msg, nontty_log=T.unsafe(nil)); end

  def clear_progress(); end

  def debug(*args); end

  def enter_level(new_level=T.unsafe(nil)); end

  def initialize(pipe, *args); end

  def io(); end

  def io=(pipe); end

  def print(msg=T.unsafe(nil)); end

  def progress(msg, nontty_log=T.unsafe(nil)); end

  def puts(msg=T.unsafe(nil)); end

  def show_backtraces(); end

  def show_backtraces=(show_backtraces); end

  def show_progress(); end

  def show_progress=(show_progress); end

  def warn(*args); end

  def warn_no_continuations(); end

  def warned(); end

  def warned=(warned); end
  PROGRESS_INDICATORS = ::T.let(nil, ::T.untyped)
end

class YARD::Logger
  def self.instance(pipe=T.unsafe(nil)); end
end

class YARD::Options
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def each(&blk); end

  def merge(opts); end

  def method_missing(meth, *args, &block); end

  def reset_defaults(); end

  def to_hash(); end

  def update(opts); end
end

class YARD::Options
  def self.default_attr(key, default); end
end

module YARD::Parser
end

class YARD::Parser::Base
  def enumerator(); end

  def initialize(source, filename); end

  def parse(); end

  def tokenize(); end
end

class YARD::Parser::Base
  def self.parse(source, filename=T.unsafe(nil)); end
end

module YARD::Parser::C
end

module YARD::Parser::C
end

class YARD::Parser::OrderedParser
  def files(); end

  def files=(files); end

  def initialize(global_state, files); end

  def parse(); end
end

class YARD::Parser::OrderedParser
end

class YARD::Parser::ParserSyntaxError
end

class YARD::Parser::ParserSyntaxError
end

module YARD::Parser::Ruby
  def s(*args); end
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value=T.unsafe(nil)); end

  def set_token_position(line, char); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  NEWLINE_TOKEN = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

module YARD::Parser::Ruby
end

class YARD::Parser::SourceParser
  def contents(); end

  def file(); end

  def file=(file); end

  def globals(); end

  def initialize(parser_type=T.unsafe(nil), globals1=T.unsafe(nil), globals2=T.unsafe(nil)); end

  def parse(content=T.unsafe(nil)); end

  def parser_type(); end

  def tokenize(content); end
  DEFAULT_PATH_GLOB = ::T.let(nil, ::T.untyped)
  ENCODING_BYTE_ORDER_MARKS = ::T.let(nil, ::T.untyped)
  ENCODING_LINE = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LINE = ::T.let(nil, ::T.untyped)
  SHEBANG_LINE = ::T.let(nil, ::T.untyped)
end

class YARD::Parser::SourceParser
  def self.after_parse_file(&block); end

  def self.after_parse_file_callbacks(); end

  def self.after_parse_list(&block); end

  def self.after_parse_list_callbacks(); end

  def self.before_parse_file(&block); end

  def self.before_parse_file_callbacks(); end

  def self.before_parse_list(&block); end

  def self.before_parse_list_callbacks(); end

  def self.parse(paths=T.unsafe(nil), excluded=T.unsafe(nil), level=T.unsafe(nil)); end

  def self.parse_string(content, ptype=T.unsafe(nil)); end

  def self.parser_type(); end

  def self.parser_type=(value); end

  def self.parser_type_extensions(); end

  def self.parser_type_extensions=(value); end

  def self.parser_type_for_extension(extension); end

  def self.parser_types(); end

  def self.parser_types=(value); end

  def self.register_parser_type(type, parser_klass, extensions=T.unsafe(nil)); end

  def self.tokenize(content, ptype=T.unsafe(nil)); end

  def self.validated_parser_type(type); end
end

class YARD::Parser::UndocumentableError
end

class YARD::Parser::UndocumentableError
end

module YARD::Parser
end

module YARD::Rake
end

class YARD::Rake::YardocTask
  def after(); end

  def after=(after); end

  def before(); end

  def before=(before); end

  def define(); end

  def files(); end

  def files=(files); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def stats_options(); end

  def stats_options=(stats_options); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Rake::YardocTask
end

module YARD::Rake
end

module YARD::Registry
  DEFAULT_PO_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_YARDOC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_YARDOC_INDEX = ::T.let(nil, ::T.untyped)
end

module YARD::Registry
  extend ::Enumerable
  def self.[](path); end

  def self.all(*types); end

  def self.at(path); end

  def self.checksum_for(data); end

  def self.checksums(); end

  def self.clear(); end

  def self.delete(object); end

  def self.delete_from_disk(); end

  def self.each(&block); end

  def self.instance(); end

  def self.load(files=T.unsafe(nil), reparse=T.unsafe(nil)); end

  def self.load!(file=T.unsafe(nil)); end

  def self.load_all(); end

  def self.load_yardoc(file=T.unsafe(nil)); end

  def self.locale(name); end

  def self.lock_for_writing(file=T.unsafe(nil), &block); end

  def self.locked_for_writing?(file=T.unsafe(nil)); end

  def self.paths(reload=T.unsafe(nil)); end

  def self.po_dir(); end

  def self.po_dir=(dir); end

  def self.proxy_types(); end

  def self.register(object); end

  def self.resolve(namespace, name, inheritance=T.unsafe(nil), proxy_fallback=T.unsafe(nil), type=T.unsafe(nil)); end

  def self.root(); end

  def self.save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def self.single_object_db(); end

  def self.single_object_db=(v); end

  def self.yardoc_file(); end

  def self.yardoc_file=(v); end

  def self.yardoc_file_for_gem(gem, ver_require=T.unsafe(nil), for_writing=T.unsafe(nil)); end
end

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper
  def initialize(registry=T.unsafe(nil)); end

  def lookup_by_path(path, opts=T.unsafe(nil)); end
end

class YARD::RegistryResolver
end

class YARD::RegistryStore
  def [](key); end

  def []=(key, value); end

  def checksums(); end

  def checksums_path(); end

  def delete(key); end

  def destroy(force=T.unsafe(nil)); end

  def file(); end

  def get(key); end

  def keys(reload=T.unsafe(nil)); end

  def load(file=T.unsafe(nil)); end

  def load!(file=T.unsafe(nil)); end

  def load_all(); end

  def load_yardoc(); end

  def locale(name); end

  def lock_for_writing(file=T.unsafe(nil), &block); end

  def locked_for_writing?(file=T.unsafe(nil)); end

  def object_types_path(); end

  def objects_path(); end

  def paths_for_type(type, reload=T.unsafe(nil)); end

  def proxy_types(); end

  def proxy_types_path(); end

  def put(key, value); end

  def root(); end

  def save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def values(reload=T.unsafe(nil)); end

  def values_for_type(type, reload=T.unsafe(nil)); end
end

class YARD::RegistryStore
end

module YARD::Serializers
end

class YARD::Serializers::Base
  def after_serialize(data); end

  def before_serialize(); end

  def exists?(object); end

  def initialize(opts=T.unsafe(nil)); end

  def options(); end

  def serialize(object, data); end

  def serialized_path(object); end
end

class YARD::Serializers::Base
end

class YARD::Serializers::FileSystemSerializer
  def basepath(); end

  def basepath=(value); end

  def extension(); end

  def extension=(value); end
end

class YARD::Serializers::FileSystemSerializer
end

class YARD::Serializers::ProcessSerializer
  def initialize(cmd); end

  def serialize(_object, data); end
end

class YARD::Serializers::ProcessSerializer
end

class YARD::Serializers::StdoutSerializer
  def initialize(wrap=T.unsafe(nil)); end

  def serialize(_object, data); end
end

class YARD::Serializers::StdoutSerializer
end

class YARD::Serializers::YardocSerializer
  def checksums_path(); end

  def complete?(); end

  def complete_lock_path(); end

  def deserialize(path, is_path=T.unsafe(nil)); end

  def initialize(yfile); end

  def lock_for_writing(); end

  def locked_for_writing?(); end

  def object_types_path(); end

  def objects_path(); end

  def processing_path(); end

  def proxy_types_path(); end

  def serialize(object); end
end

class YARD::Serializers::YardocSerializer
end

module YARD::Serializers
end

module YARD::Server
end

class YARD::Server::Adapter
  def add_library(library); end

  def document_root(); end

  def document_root=(document_root); end

  def initialize(libs, opts=T.unsafe(nil), server_opts=T.unsafe(nil)); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def router(); end

  def router=(router); end

  def server_options(); end

  def server_options=(server_options); end

  def start(); end
end

class YARD::Server::Adapter
  def self.setup(); end

  def self.shutdown(); end
end

module YARD::Server::Commands
end

class YARD::Server::Commands::Base
  def adapter(); end

  def adapter=(adapter); end

  def body(); end

  def body=(body); end

  def cache(data); end

  def caching(); end

  def caching=(caching); end

  def call(request); end

  def command_options(); end

  def command_options=(command_options); end

  def headers(); end

  def headers=(headers); end

  def initialize(opts=T.unsafe(nil)); end

  def not_found(); end

  def path(); end

  def path=(path); end

  def redirect(url); end

  def render(object=T.unsafe(nil)); end

  def request(); end

  def request=(request); end

  def run(); end

  def status(); end

  def status=(status); end
end

class YARD::Server::Commands::Base
end

class YARD::Server::Commands::DisplayFileCommand
  def index(); end

  def index=(index); end
end

class YARD::Server::Commands::DisplayFileCommand
end

class YARD::Server::Commands::DisplayObjectCommand
  include ::YARD::Server::DocServerHelper
  def index(); end
end

class YARD::Server::Commands::DisplayObjectCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::LibraryCommand
  def incremental(); end

  def incremental=(incremental); end

  def library(); end

  def library=(library); end

  def options(); end

  def options=(options); end

  def serializer(); end

  def serializer=(serializer); end

  def single_library(); end

  def single_library=(single_library); end

  def use_fork(); end

  def use_fork=(use_fork); end
  CAN_FORK = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::LibraryCommand
end

class YARD::Server::Commands::LibraryIndexCommand
  def options(); end

  def options=(options); end
end

class YARD::Server::Commands::LibraryIndexCommand
end

class YARD::Server::Commands::ListCommand
  include ::YARD::Templates::Helpers::BaseHelper
end

class YARD::Server::Commands::ListCommand
end

class YARD::Server::Commands::RootRequestCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
end

class YARD::Server::Commands::RootRequestCommand
end

class YARD::Server::Commands::SearchCommand
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper
  def query(); end

  def query=(query); end

  def results(); end

  def results=(results); end

  def visible_results(); end
end

class YARD::Server::Commands::SearchCommand
end

class YARD::Server::Commands::StaticFileCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  STATIC_PATHS = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::StaticFileCommand
end

module YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  def favicon?(); end

  def static_template_file?(); end
end

module YARD::Server::Commands::StaticFileHelpers
  def self.find_file(adapter, url); end
end

module YARD::Server::Commands
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end

  def base_path(path); end

  def mtime(file); end

  def mtime_url(file); end

  def router(); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
end

module YARD::Server::DocServerHelper
end

class YARD::Server::DocServerSerializer
  def initialize(_command=T.unsafe(nil)); end
end

class YARD::Server::DocServerSerializer
end

class YARD::Server::FinishRequest
end

class YARD::Server::FinishRequest
end

class YARD::Server::LibraryVersion
  def ==(other); end

  def eql?(other); end

  def equal?(other); end

  def gemspec(); end

  def initialize(name, version=T.unsafe(nil), yardoc=T.unsafe(nil), source=T.unsafe(nil)); end

  def load_yardoc_from_disk(); end

  def load_yardoc_from_gem(); end

  def name(); end

  def name=(name); end

  def prepare!(); end

  def ready?(); end

  def source(); end

  def source=(source); end

  def source_path(); end

  def source_path=(source_path); end

  def source_path_for_disk(); end

  def source_path_for_gem(); end

  def to_s(url_format=T.unsafe(nil)); end

  def version(); end

  def version=(version); end

  def yardoc_file(); end

  def yardoc_file=(yardoc_file); end

  def yardoc_file_for_gem(); end
end

class YARD::Server::LibraryVersion
end

class YARD::Server::NotFoundError
end

class YARD::Server::NotFoundError
end

class YARD::Server::RackAdapter
  include ::WEBrick::HTTPUtils
  def call(env); end
end

class YARD::Server::RackAdapter
end

class YARD::Server::RackMiddleware
  def call(env); end

  def initialize(app, opts=T.unsafe(nil)); end
end

class YARD::Server::RackMiddleware
end

class YARD::Server::Router
  include ::YARD::Server::StaticCaching
  include ::YARD::Server::Commands
  def adapter(); end

  def adapter=(adapter); end

  def call(request); end

  def docs_prefix(); end

  def final_options(library, paths); end

  def initialize(adapter); end

  def list_prefix(); end

  def parse_library_from_path(paths); end

  def request(); end

  def request=(request); end

  def route(path=T.unsafe(nil)); end

  def route_docs(library, paths); end

  def route_index(); end

  def route_list(library, paths); end

  def route_search(library, paths); end

  def route_static(library, paths); end

  def search_prefix(); end

  def static_prefix(); end
end

class YARD::Server::Router
end

module YARD::Server::StaticCaching
  def check_static_cache(); end
end

module YARD::Server::StaticCaching
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickServlet
  def adapter(); end

  def adapter=(adapter); end

  def do_GET(request, response); end

  def initialize(server, adapter); end
end

class YARD::Server::WebrickServlet
end

module YARD::Server
  def self.register_static_path(path); end
end

class YARD::StubProxy
  def _dump(_depth); end

  def initialize(path, transient=T.unsafe(nil)); end

  def method_missing(meth, *args, &block); end
  FILELEN = ::T.let(nil, ::T.untyped)
end

class YARD::StubProxy
  def self._load(str); end
end

module YARD::Tags
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end

  def parse_tag_with_name(tag_name, text); end

  def parse_tag_with_options(tag_name, text); end

  def parse_tag_with_title_and_text(tag_name, text); end

  def parse_tag_with_types(tag_name, text); end

  def parse_tag_with_types_and_name(tag_name, text); end

  def parse_tag_with_types_and_title(tag_name, text); end

  def parse_tag_with_types_name_and_default(tag_name, text); end
  TYPELIST_CLOSING_CHARS = ::T.let(nil, ::T.untyped)
  TYPELIST_OPENING_CHARS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
end

class YARD::Tags::DefaultTag
  def defaults(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

class YARD::Tags::DefaultTag
end

class YARD::Tags::Directive
  def after_parse(); end

  def call(); end

  def expanded_text(); end

  def expanded_text=(expanded_text); end

  def handler(); end

  def initialize(tag, parser); end

  def object(); end

  def parser(); end

  def parser=(parser); end

  def tag(); end

  def tag=(tag); end
end

class YARD::Tags::Directive
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::Library
  def abstract_tag(text); end

  def api_tag(text); end

  def attr_reader_tag(text); end

  def attr_tag(text); end

  def attr_writer_tag(text); end

  def attribute_directive(tag, parser); end

  def author_tag(text); end

  def deprecated_tag(text); end

  def directive_create(tag_name, tag_buf, parser); end

  def endgroup_directive(tag, parser); end

  def example_tag(text); end

  def factory(); end

  def factory=(factory); end

  def group_directive(tag, parser); end

  def has_directive?(tag_name); end

  def has_tag?(tag_name); end

  def initialize(factory=T.unsafe(nil)); end

  def macro_directive(tag, parser); end

  def method_directive(tag, parser); end

  def note_tag(text); end

  def option_tag(text); end

  def overload_tag(text); end

  def param_tag(text); end

  def parse_directive(tag, parser); end

  def private_tag(text); end

  def raise_tag(text); end

  def return_tag(text); end

  def scope_directive(tag, parser); end

  def see_tag(text); end

  def since_tag(text); end

  def tag_create(tag_name, tag_buf); end

  def todo_tag(text); end

  def validates_tag(text); end

  def version_tag(text); end

  def visibility_directive(tag, parser); end

  def yield_tag(text); end

  def yieldparam_tag(text); end

  def yieldreturn_tag(text); end
end

class YARD::Tags::Library
  def self.default_factory(); end

  def self.default_factory=(factory); end

  def self.define_directive(tag, tag_meth=T.unsafe(nil), directive_class=T.unsafe(nil)); end

  def self.define_tag(label, tag, meth=T.unsafe(nil)); end

  def self.directive_method_name(tag_name); end

  def self.factory_method_for(tag); end

  def self.factory_method_for_directive(directive); end

  def self.instance(); end

  def self.labels(); end

  def self.sorted_labels(); end

  def self.tag_method_name(tag_name); end

  def self.transitive_tags(); end

  def self.transitive_tags=(transitive_tags); end

  def self.visible_tags(); end

  def self.visible_tags=(visible_tags); end
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MethodDirective
  def create_object(); end

  def method_name(); end

  def method_signature(); end

  def sanitized_tag_signature(); end

  def use_indented_text(); end
  SCOPE_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::MethodDirective
end

class YARD::Tags::OptionTag
  def initialize(tag_name, name, pair); end

  def pair(); end

  def pair=(pair); end
end

class YARD::Tags::OptionTag
end

class YARD::Tags::OverloadTag
  def docstring(); end

  def has_tag?(name); end

  def initialize(tag_name, text); end

  def is_a?(other); end

  def kind_of?(other); end

  def method_missing(*args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def object=(value); end

  def parameters(); end

  def signature(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end
end

class YARD::Tags::OverloadTag
end

class YARD::Tags::ParseDirective
end

class YARD::Tags::ParseDirective
end

module YARD::Tags::RefTag
  def owner(); end

  def owner=(owner); end
end

module YARD::Tags::RefTag
end

class YARD::Tags::RefTagList
  def initialize(tag_name, owner, name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def owner(); end

  def owner=(owner); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def tags(); end
end

class YARD::Tags::RefTagList
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::Tag
  def explain_types(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def object(); end

  def object=(object); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def text(); end

  def text=(text); end

  def type(); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::Tag
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TypesExplainer
end

class YARD::Tags::TypesExplainer::CollectionType
  def initialize(name, types); end

  def to_s(_singular=T.unsafe(nil)); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::TypesExplainer::CollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::HashCollectionType
  def initialize(name, key_types, value_types); end

  def key_types(); end

  def key_types=(key_types); end

  def to_s(_singular=T.unsafe(nil)); end

  def value_types(); end

  def value_types=(value_types); end
end

class YARD::Tags::TypesExplainer::HashCollectionType
end

class YARD::Tags::TypesExplainer::Parser
  include ::YARD::CodeObjects
  def initialize(string); end

  def parse(); end
  TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::TypesExplainer::Parser
  def self.parse(string); end
end

class YARD::Tags::TypesExplainer::Type
  def initialize(name); end

  def name(); end

  def name=(name); end

  def to_s(singular=T.unsafe(nil)); end
end

class YARD::Tags::TypesExplainer::Type
end

class YARD::Tags::TypesExplainer
  def self.explain(*types); end

  def self.explain!(*types); end
end

class YARD::Tags::VisibilityDirective
end

class YARD::Tags::VisibilityDirective
end

module YARD::Tags
end

module YARD::Templates
end

module YARD::Templates::Engine
end

module YARD::Templates::Engine
  def self.generate(objects, options=T.unsafe(nil)); end

  def self.register_template_path(path); end

  def self.render(options=T.unsafe(nil)); end

  def self.template(*path); end

  def self.template!(path, full_paths=T.unsafe(nil)); end

  def self.template_paths(); end

  def self.template_paths=(template_paths); end

  def self.with_serializer(object, serializer); end
end

module YARD::Templates::ErbCache
end

module YARD::Templates::ErbCache
  def self.clear!(); end

  def self.method_for(filename); end
end

module YARD::Templates::Helpers
end

module YARD::Templates::Helpers::BaseHelper
  def format_object_title(object); end

  def format_object_type(object); end

  def format_source(value); end

  def format_types(list, brackets=T.unsafe(nil)); end

  def globals(); end

  def h(text); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def linkify(*args); end

  def object(); end

  def object=(object); end

  def owner(); end

  def run_verifier(list); end

  def serializer(); end

  def serializer=(serializer); end
end

module YARD::Templates::Helpers::BaseHelper
end

module YARD::Templates::Helpers::FilterHelper
  def is_class?(object); end

  def is_method?(object); end

  def is_module?(object); end

  def is_namespace?(object); end
end

module YARD::Templates::Helpers::FilterHelper
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def anchor_for(object); end

  def charset(); end

  def format_object_name_list(objects); end

  def format_types(typelist, brackets=T.unsafe(nil)); end

  def h(text); end

  def html_markup_asciidoc(text); end

  def html_markup_html(text); end

  def html_markup_markdown(text); end

  def html_markup_none(text); end

  def html_markup_org(text); end

  def html_markup_pre(text); end

  def html_markup_rdoc(text); end

  def html_markup_ruby(source); end

  def html_markup_text(text); end

  def html_markup_textile(text); end

  def html_markup_textile_strict(text); end

  def html_syntax_highlight(source, type=T.unsafe(nil)); end

  def html_syntax_highlight_plain(source); end

  def htmlify(text, markup=T.unsafe(nil)); end

  def htmlify_line(*args); end

  def insert_include(text, markup=T.unsafe(nil)); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil), anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def mtime(_file); end

  def mtime_url(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def resolve_links(text); end

  def signature(meth, link=T.unsafe(nil), show_extras=T.unsafe(nil), full_attr_name=T.unsafe(nil)); end

  def signature_types(meth, link=T.unsafe(nil)); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
  ASCIIDOC_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  URLMATCH = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::HtmlHelper
  def self.urlencode(text); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def html_syntax_highlight_ruby(source); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
end

module YARD::Templates::Helpers::Markup
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
  def fix_typewriter(html); end
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup
  def from_path(); end

  def from_path=(from_path); end

  def initialize(text); end

  def to_html(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute_manager(); end

  def convert(input, formatter); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrChanger
  def turn_off(); end

  def turn_off=(_); end

  def turn_on(); end

  def turn_on=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrChanger
  def self.[](*_); end

  def self.members(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrSpan
  def [](n); end

  def initialize(length); end

  def set_attrs(start, length, bits); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrSpan
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttributeManager
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute(turn_on, turn_off); end

  def attributes(); end

  def change_attribute(current, new); end

  def changed_attribute_by_name(current_set, new_set); end

  def convert_attrs(str, attrs); end

  def convert_html(str, attrs); end

  def convert_regexp_handlings(str, attrs); end

  def copy_string(start_pos, end_pos); end

  def display_attributes(); end

  def flow(str); end

  def html_tags(); end

  def mask_protected_sequences(); end

  def matching_word_pairs(); end

  def protectable(); end

  def regexp_handlings(); end

  def split_into_flow(); end

  def unmask_protected_sequences(); end

  def word_pair_map(); end
  A_PROTECT = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  PROTECT_ATTR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttributeManager
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Attributes
  def as_string(bitmap); end

  def bitmap_for(name); end

  def each_name_of(bitmap); end

  def regexp_handling(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Attributes
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlankLine
  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlankLine
  def self.new(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlockQuote
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlockQuote
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Document
  include ::Enumerable
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def concat(parts); end

  def each(&block); end

  def empty?(); end

  def file(); end

  def file=(location); end

  def initialize(*parts); end

  def merge(other); end

  def merged?(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def parts(); end

  def push(*parts); end

  def table_of_contents(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Document
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter
  def accept_document(document); end

  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def add_tag(name, start, stop); end

  def annotate(tag); end

  def convert(content); end

  def convert_flow(flow); end

  def convert_regexp_handling(target); end

  def convert_string(string); end

  def ignore(*node); end

  def in_tt?(); end

  def initialize(options, markup=T.unsafe(nil)); end

  def off_tags(res, item); end

  def on_tags(res, item); end

  def parse_url(url); end

  def tt?(tag); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter::InlineTag
  def bit(); end

  def bit=(_); end

  def off(); end

  def off=(_); end

  def on(); end

  def on=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter::InlineTag
  def self.[](*_); end

  def self.members(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter
  def self.gen_relative_url(path, target); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::HardBreak
  def ==(other); end

  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::HardBreak
  def self.new(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Heading
  def accept(visitor); end

  def aref(); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def level=(_); end

  def plain_html(); end

  def text(); end

  def text=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Heading
  def self.[](*_); end

  def self.members(); end

  def self.to_html(); end

  def self.to_label(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Include
  def ==(other); end

  def file(); end

  def include_path(); end

  def initialize(file, include_path); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Include
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::IndentedParagraph
  def indent(); end

  def initialize(indent, *parts); end

  def text(hard_break=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::IndentedParagraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::List
  def <<(item); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(type=T.unsafe(nil), *items); end

  def items(); end

  def last(); end

  def push(*items); end

  def type(); end

  def type=(type); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::List
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ListItem
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(label=T.unsafe(nil), *parts); end

  def label(); end

  def label=(label); end

  def length(); end

  def parts(); end

  def push(*parts); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ListItem
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Paragraph
  def text(hard_break=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Paragraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser
  include ::RDoc::Text
  def build_heading(level); end

  def build_list(margin); end

  def build_paragraph(margin); end

  def build_verbatim(margin); end

  def char_pos(byte_offset); end

  def debug(); end

  def debug=(debug); end

  def get(); end

  def parse(parent, indent=T.unsafe(nil)); end

  def parse_text(parent, indent); end

  def peek_token(); end

  def setup_scanner(input); end

  def skip(token_type, error=T.unsafe(nil)); end

  def token_pos(byte_offset); end

  def tokenize(input); end

  def tokens(); end

  def unget(); end
  LIST_TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::Error
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::Error
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::ParseError
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::ParseError
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser
  def self.parse(str); end

  def self.tokenize(str); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::PreProcess
  def find_include_file(name); end

  def handle(text, code_object=T.unsafe(nil), &block); end

  def handle_directive(prefix, directive, param, code_object=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def include_file(name, indent, encoding); end

  def initialize(input_file_name, include_path); end

  def options(); end

  def options=(options); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::PreProcess
  def self.post_process(&block); end

  def self.post_processors(); end

  def self.register(directive, &block); end

  def self.registered(); end

  def self.reset(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Raw
  def <<(text); end

  def ==(other); end

  def accept(visitor); end

  def initialize(*parts); end

  def merge(other); end

  def parts(); end

  def push(*texts); end

  def text(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Raw
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::RegexpHandling
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Rule
  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Rule
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToAnsi
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToAnsi
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToBs
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToBs
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtml
  include ::RDoc::Text
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def code_object(); end

  def code_object=(code_object); end

  def convert_string(text); end

  def end_accepting(); end

  def from_path(); end

  def from_path=(from_path); end

  def gen_url(url, text); end

  def handle_RDOCLINK(url); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end

  def html_list_name(list_type, open_tag); end

  def in_list_entry(); end

  def init_tags(); end

  def list(); end

  def list_end_for(list_type); end

  def list_item_start(list_item, list_type); end

  def parseable?(text); end

  def res(); end

  def start_accepting(); end

  def to_html(item); end
  LIST_TYPE_TO_HTML = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtml
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlCrossref
  def context(); end

  def context=(context); end

  def cross_reference(name, text=T.unsafe(nil), code=T.unsafe(nil)); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end

  def link(name, text, code=T.unsafe(nil)); end

  def show_hash(); end

  def show_hash=(show_hash); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlCrossref
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlSnippet
  def accept_raw(*node); end

  def accept_rule(*node); end

  def add_paragraph(); end

  def character_limit(); end

  def characters(); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end

  def mask(); end

  def paragraph_limit(); end

  def paragraphs(); end

  def truncate(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlSnippet
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToJoinedParagraph
  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(paragraph); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def start_accepting(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToJoinedParagraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToLabel
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def convert(text); end

  def end_accepting(*node); end

  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end

  def res(); end

  def start_accepting(*node); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToLabel
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToMarkdown
  def gen_url(url, text); end

  def handle_rdoc_link(url); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToRdoc
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_indented_paragraph(paragraph); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def attributes(text); end

  def end_accepting(); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def indent(); end

  def indent=(indent); end

  def init_tags(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_index(); end

  def list_type(); end

  def list_width(); end

  def prefix(); end

  def res(); end

  def start_accepting(); end

  def use_prefix(); end

  def width(); end

  def width=(width); end

  def wrap(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToRdoc
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTableOfContents
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(heading); end

  def accept_list_end(*node); end

  def accept_list_end_bullet(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def res(); end

  def start_accepting(); end

  def suppressed?(heading); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTableOfContents
  def self.to_toc(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTest
  def accept_blank_line(blank_line); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def end_accepting(); end

  def start_accepting(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTest
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTtOnly
  def accept_blank_line(markup_item); end

  def accept_block_quote(block_quote); end

  def accept_heading(markup_item); end

  def accept_list_end(list); end

  def accept_list_item_end(markup_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(markup_item); end

  def accept_rule(markup_item); end

  def accept_verbatim(markup_item); end

  def do_nothing(markup_item); end

  def end_accepting(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_type(); end

  def res(); end

  def start_accepting(); end

  def tt_sections(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTtOnly
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Verbatim
  def format(); end

  def format=(format); end

  def normalize(); end

  def ruby?(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Verbatim
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP
  def self.parse(str); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup
end

module YARD::Templates::Helpers::Markup
end

module YARD::Templates::Helpers::MarkupHelper
  def load_markup_provider(type=T.unsafe(nil)); end

  def markup_class(type=T.unsafe(nil)); end

  def markup_file_contents(contents); end

  def markup_for_file(contents, filename); end

  def markup_provider(type=T.unsafe(nil)); end
  MARKUP_EXTENSIONS = ::T.let(nil, ::T.untyped)
  MARKUP_FILE_SHEBANG = ::T.let(nil, ::T.untyped)
  MARKUP_PROVIDERS = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::MarkupHelper
  def self.clear_markup_cache(); end

  def self.markup_cache(); end

  def self.markup_cache=(markup_cache); end
end

module YARD::Templates::Helpers::MethodHelper
  def format_args(object); end

  def format_block(object); end

  def format_code(object, _show_lines=T.unsafe(nil)); end

  def format_constant(value); end

  def format_lines(object); end

  def format_return_types(object); end
end

module YARD::Templates::Helpers::MethodHelper
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::TextHelper
  def align_right(text, spacer=T.unsafe(nil), col=T.unsafe(nil)); end

  def h(text); end

  def hr(col=T.unsafe(nil), sep=T.unsafe(nil)); end

  def indent(text, len=T.unsafe(nil)); end

  def signature(meth); end

  def title_align_right(text, col=T.unsafe(nil)); end

  def wrap(text, col=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::TextHelper
end

module YARD::Templates::Helpers::UMLHelper
  def format_path(object); end

  def h(text); end

  def tidy(data); end

  def uml_visibility(object); end
end

module YARD::Templates::Helpers::UMLHelper
end

module YARD::Templates::Helpers
end

class YARD::Templates::Section
  def <<(*args); end

  def ==(other); end

  def [](*args); end

  def any(item); end

  def eql?(other); end

  def initialize(name, *args); end

  def name(); end

  def name=(name); end

  def place(*args); end

  def push(*args); end

  def unshift(*args); end
end

class YARD::Templates::Section
end

module YARD::Templates::Template
  include ::YARD::Templates::ErbCache
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::MethodHelper
  def T(*path); end

  def class(); end

  def class=(_); end

  def erb(section, &block); end

  def erb_file_for(section); end

  def erb_with(content, filename=T.unsafe(nil)); end

  def file(basename, allow_inherited=T.unsafe(nil)); end

  def init(); end

  def initialize(opts=T.unsafe(nil)); end

  def inspect(); end

  def options(); end

  def options=(value); end

  def run(opts=T.unsafe(nil), sects=T.unsafe(nil), start_at=T.unsafe(nil), break_first=T.unsafe(nil), &block); end

  def section(); end

  def section=(section); end

  def sections(*args); end

  def superb(sect=T.unsafe(nil), &block); end

  def yieldall(opts=T.unsafe(nil), &block); end
end

module YARD::Templates::Template::ClassMethods
  def S(*args); end

  def T(*path); end

  def find_file(basename); end

  def find_nth_file(basename, index=T.unsafe(nil)); end

  def full_path(); end

  def full_path=(full_path); end

  def full_paths(); end

  def initialize(path, full_paths); end

  def is_a?(klass); end

  def new(*args); end

  def path(); end

  def path=(path); end

  def reset_full_paths(); end

  def run(*args); end
end

module YARD::Templates::Template::ClassMethods
end

module YARD::Templates::Template
  def self.extra_includes(); end

  def self.extra_includes=(extra_includes); end

  def self.include_extra(template, options); end

  def self.included(klass); end
end

class YARD::Templates::TemplateOptions
  def __globals(); end

  def default_return(); end

  def default_return=(default_return); end

  def embed_mixins(); end

  def embed_mixins=(embed_mixins); end

  def embed_mixins_match?(mixin); end

  def format(); end

  def format=(format); end

  def globals(); end

  def globals=(globals); end

  def hide_void_return(); end

  def hide_void_return=(hide_void_return); end

  def highlight(); end

  def highlight=(highlight); end

  def index(); end

  def index=(index); end

  def markup(); end

  def markup=(markup); end

  def markup_provider(); end

  def markup_provider=(markup_provider); end

  def no_highlight(); end

  def no_highlight=(value); end

  def object(); end

  def object=(object); end

  def owner(); end

  def owner=(owner); end

  def page_title(); end

  def page_title=(page_title); end

  def serialize(); end

  def serialize=(serialize); end

  def serializer(); end

  def serializer=(serializer); end

  def template(); end

  def template=(template); end

  def type(); end

  def type=(type); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Templates::TemplateOptions
end

module YARD::Templates
end

class YARD::Verifier
  def add_expressions(*expressions); end

  def call(object); end

  def expressions(); end

  def expressions=(value); end

  def initialize(*expressions); end

  def method_missing(sym, *args, &block); end

  def o(); end

  def object(); end

  def run(list); end
  NILCLASS_METHODS = ::T.let(nil, ::T.untyped)
end

class YARD::Verifier
end

module YARD
  def self.load_plugins(); end

  def self.parse(*args); end

  def self.parse_string(*args); end

  def self.ruby18?(); end

  def self.ruby19?(); end

  def self.ruby2?(); end

  def self.windows?(); end
end

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
  def self.open(*_); end
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
  def self.open(*_); end
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
